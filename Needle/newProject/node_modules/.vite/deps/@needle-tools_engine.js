import {
  $physicsKey,
  ActionBuilder,
  ActionCollection,
  ActionModel,
  Addressables,
  AlignmentConstraint,
  AmbientMode,
  Animation,
  AnimationCurve,
  AnimationExtension,
  AnimationTrackHandler,
  AnimationUtils,
  Animator,
  AnimatorConditionMode,
  AnimatorController,
  AnimatorControllerParameterType,
  AnimatorStateInfo,
  Antialiasing,
  Application,
  ApplicationEvents,
  AssetDatabase,
  AssetReference,
  AudioExtension,
  AudioListener,
  AudioSource,
  AudioTrackHandler,
  Avatar,
  AvatarBlink_Simple,
  AvatarEyeLook_Rotation,
  AvatarMarker,
  Avatar_Brain_LookAt,
  Avatar_MouthShapes,
  Avatar_MustacheShake,
  Avatar_POI,
  Axes,
  AxesHelper,
  BUILD_TIME,
  BaseUIComponent,
  BasicIKConstraint,
  BehaviorExtension,
  BehaviorModel,
  BlobStorage,
  BloomEffect,
  BoxCollider,
  BoxGizmo,
  BoxHelperComponent,
  Button,
  ButtonsFactory,
  CallDirection,
  CallInfo,
  Camera,
  CameraTargetReachedEvent,
  Canvas,
  CanvasGroup,
  CapsuleCollider,
  ChangeMaterialOnClick,
  ChangeTransformOnClick,
  CharacterController,
  CharacterControllerInput,
  ChromaticAberration,
  CircularBuffer,
  ClearFlags,
  ClipExtrapolation,
  Collider,
  Collision,
  CollisionDetectionMode,
  ColorAdjustments,
  ColorBySpeedModule,
  ColorOverLifetimeModule,
  Component,
  ComponentLifecycleEvents,
  Component_exports,
  ConnectionEvents,
  ContactPoint,
  ContactShadows,
  Context,
  ContextArgs,
  ContextEvent,
  ContextRegistry,
  ControlTrackHandler,
  CustomBranding,
  CustomShader,
  DefaultReflectionMode,
  Deletable,
  DeleteBox,
  DepthOfField,
  DeviceFlag,
  DeviceUtilities,
  DragControls,
  DragMode,
  DropListener,
  Duplicatable,
  EffectWrapper,
  EmissionModule,
  EmphasizeOnClick,
  EngineLoadingView,
  EventList,
  EventListEvent,
  EventSystem,
  EventTrigger,
  FieldWithDefault,
  FileReference,
  FileReferenceSerializer,
  FileSpawnModel,
  File_Event,
  FixedJoint,
  Fog,
  FrameEvent,
  GENERATOR,
  GLTFExporter,
  GLTFLoader,
  GLTFMeshGPUInstancingExtension,
  GameObject,
  GizmoWriter,
  Gizmos,
  GltfExport,
  GltfExportBox,
  GltfLoadEvent,
  GltfLoadEventType,
  Gradient,
  Graphic,
  GraphicRaycaster,
  Graphics,
  GridHelper,
  GridLayoutGroup,
  GroundProjectedEnv,
  GroupActionModel,
  HideFlags,
  HideOnStart,
  HingeJoint,
  HorizontalLayoutGroup,
  HostData,
  Image,
  ImageReference,
  ImageReferenceSerializer,
  InheritVelocityModule,
  Input,
  InputEventQueue,
  InputEvents,
  InputField,
  InstanceHandle,
  InstancingHandler,
  InstancingUtil,
  InstantiateEvent,
  InstantiateIdProvider,
  InstantiateOptions,
  Interactable,
  InternalScreenshotUtils,
  JoinedRoomResponse,
  KeyEventArgs,
  Keyframe,
  LODGroup,
  LODModel,
  LeftRoomResponse,
  Light,
  LightData,
  LimitVelocityOverLifetimeModule,
  LoadingElementOptions,
  LogStats,
  LogType,
  LookAt,
  LookAtConstraint,
  MODULES,
  MainModule,
  MarkerType,
  MaskableGraphic,
  Mathf,
  MeshCollider,
  MeshRenderer,
  MinMaxCurve,
  MinMaxGradient,
  NEEDLE_progressive,
  NEKeyboardEvent,
  NEPointerEvent,
  NeedleEngineHTMLElement,
  NeedleLoader,
  NeedleMenu,
  NeedlePatchesKey,
  NeedleXRController,
  NeedleXRSession,
  NeedleXRSync,
  NeedleXRUtils,
  NestedGltf,
  NetworkConnection,
  NetworkedStreamEvents,
  NetworkedStreams,
  Networking,
  NewInstanceModel,
  NoiseModule,
  ObjectRaycaster,
  ObjectUtils,
  OffsetConstraint,
  OneEuroFilter,
  OneEuroFilterXYZ,
  OpenURL,
  OrbitControls,
  OrbitControls2,
  Outline,
  OwnershipEvent,
  OwnershipModel,
  PUBLIC_KEY,
  Padding,
  ParticleBurst,
  ParticleSubEmitter,
  ParticleSystem,
  ParticleSystemBaseBehaviour,
  ParticleSystemRenderer,
  ParticleSystemShapeType,
  PeerHandle,
  PeerNetworking,
  Physics,
  PhysicsExtension,
  PhysicsMaterialCombine,
  PixelationEffect,
  PlayAnimationOnClick,
  PlayAudioOnClick,
  PlayableDirector,
  PlayerColor,
  PlayerState,
  PlayerStateEvent,
  PlayerSync,
  PlayerView,
  PlayerViewManager,
  PointerEventData,
  PointerType,
  PostProcessingEffect,
  PostProcessingHandler,
  PreliminaryAction,
  PreliminaryTrigger,
  PreviewHelper,
  PrimitiveType,
  Progress,
  PromiseAllWithErrors,
  PromiseErrorResult,
  RGBAColor,
  RawImage,
  RaycastOptions,
  Rect,
  RectTransform,
  ReflectionProbe,
  RegisteredAnimationInfo,
  RemoteSkybox,
  RenderTexture,
  RenderTextureSerializer,
  RenderTextureWriter,
  Renderer,
  RendererData,
  RendererLightmap,
  Rigidbody,
  RigidbodyConstraints,
  RoomEvents,
  RotationBySpeedModule,
  RotationOverLifetimeModule,
  SceneLightSettings,
  SceneSwitcher,
  ScreenCapture,
  ScreenSpaceAmbientOcclusion,
  ScreenSpaceAmbientOcclusionN8,
  SendQueue,
  SerializationContext,
  SetActiveOnClick,
  ShadowCatcher,
  ShapeModule,
  SharpeningEffect,
  SignalAsset,
  SignalReceiver,
  SignalReceiverEvent,
  SignalTrackHandler,
  Size,
  SizeBySpeedModule,
  SizeOverLifetimeModule,
  SkinnedMeshRenderer,
  SmoothFollow,
  SpatialGrabRaycaster,
  SpatialHtml,
  SpatialTrigger,
  SpatialTriggerReceiver,
  SpectatorCamera,
  SphereCollider,
  SphereIntersection,
  SphereOverlapResult,
  Sprite,
  SpriteData,
  SpriteRenderer,
  SpriteSheet,
  StateMachineBehaviour,
  StreamEndedEvent,
  StreamReceivedEvent,
  SubEmitterSystem,
  SyncedCamera,
  SyncedRoom,
  SyncedTransform,
  TapGestureTrigger,
  TeleportTarget,
  TestRunner,
  TestSimulateUserData,
  Text,
  TextBuilder,
  TextExtension,
  TextureSheetAnimationModule,
  TiltShiftEffect,
  Time,
  ToneMappingEffect,
  TrackHandler,
  TrackType,
  TrailModule,
  TransformData,
  TransformGizmo,
  TriggerBuilder,
  TriggerModel,
  TypeStore,
  UIRaycastUtils,
  UIRootComponent,
  USDDocument,
  USDObject,
  USDWriter,
  USDZExporter,
  USDZExporter2,
  USDZText,
  USDZUIExtension,
  UriSerializer,
  UsageMarker,
  UserJoinedOrLeftRoomModel,
  VERSION,
  VariantAction,
  VelocityOverLifetimeModule,
  VerticalLayoutGroup,
  VideoPlayer,
  ViewDevice,
  Vignette,
  VisibilityAction,
  Voip,
  Volume,
  VolumeParameter,
  VolumeProfile,
  WaitForFrames,
  WaitForPromise,
  WaitForSeconds,
  Watch,
  WebARCameraBackground,
  WebARSessionRoot,
  WebXR,
  WebXRButtonFactory,
  WebXRImageTracking,
  WebXRImageTrackingModel,
  WebXRPlaneTracking,
  WebXRTrackedImage,
  XRControllerFollow,
  XRControllerModel,
  XRControllerMovement,
  XRFlag,
  XRRig,
  XRState,
  XRStateFlag,
  __internalNotifyObjectDestroyed,
  activeInHierarchyFieldName,
  addAttributeChangeCallback,
  addComponent,
  addCustomExtensionPlugin,
  addDracoAndKTX2Loaders,
  addGltfLoadEventListener,
  addLog,
  addNewComponent,
  addPatch,
  addScriptToArrays,
  apply,
  applyPrototypeExtensions,
  beginListenDestroy,
  beginListenInstantiate,
  binaryIdentifierCasts,
  build_scene_functions,
  builtinComponentKeyName,
  calculateProgress01,
  clearMessages,
  colorSerializer,
  compareAssociation,
  componentSerializer,
  copyTexture,
  createLoader,
  createMotion,
  debugNet,
  debugOwner,
  decompressGpuTexture,
  deepClone,
  delay,
  delayForFrames,
  deserializeObject,
  destroy,
  destroyComponentInstance,
  disposeObjectResources,
  disposeStream,
  editorGuidKeyName,
  enableSpatialConsole,
  euler,
  eventListSerializer,
  findByGuid,
  findObjectOfType,
  findObjectsOfType,
  findResourceUsers,
  fitObjectIntoVolume,
  foreachComponent,
  foreachComponentEnumerator,
  forward,
  generateQRCode,
  generateSeed,
  getBoundingBox,
  getCameraController,
  getComponent,
  getComponentInChildren,
  getComponentInParent,
  getComponents,
  getComponentsInChildren,
  getComponentsInParent,
  getFormattedDate,
  getIconElement,
  getIconTexture,
  getIp,
  getIpAndLocation,
  getIpCloudflare,
  getLoader,
  getOrAddComponent,
  getParam,
  getParentHierarchyPath,
  getPath,
  getPeerOptions,
  getPeerjsInstance,
  getResourceUserCount,
  getTempColor,
  getTempQuaternion,
  getTempVector,
  getUrlParams,
  getVisibleInCustomShadowRendering,
  getWorldDirection,
  getWorldEuler,
  getWorldPosition,
  getWorldQuaternion,
  getWorldRotation,
  getWorldScale,
  hasCommercialLicense,
  hasIndieLicense,
  hasPointerEventComponent,
  hasProLicense,
  hideDebugConsole,
  iconFontUrl,
  imageToCanvas,
  instantiate,
  invokeAfterImportPluginHooks,
  invokeXRSessionEnd,
  invokeXRSessionStart,
  isActiveInHierarchy,
  isActiveSelf,
  isAndroidDevice,
  isAnimationAction,
  isComponent,
  isDebugMode,
  isDesktop,
  isDestroyed,
  isDevEnvironment,
  isDisposed,
  isHostedOnGlitch,
  isIPad,
  isIconElement,
  isLocalNetwork,
  isMacOS,
  isMobileDevice,
  isMozillaXR,
  isQuest,
  isResourceTrackingEnabled,
  isSafari,
  isUsingInstancing,
  isiOS,
  isiPad,
  loadFont,
  loadSync,
  logHierarchy,
  lookAtInverse,
  lookAtObject,
  lookAtScreenPoint,
  makeId,
  makeIdFromRandomWords,
  makeNameSafe,
  markAsInstancedRendered,
  mergeVertices,
  microphonePermissionsGranted,
  nameof,
  nameofFactory,
  objectSerializer,
  offXRSessionEnd,
  offXRSessionStart,
  onAfterRender,
  onBeforeRender,
  onClear,
  onDestroy,
  onInitialized,
  onStart,
  onUpdate,
  onXRSessionEnd,
  onXRSessionStart,
  parseSync,
  placeOnSurface,
  postprocessFBXMaterials,
  prefix,
  pushState,
  randomNumber,
  registerBinaryType,
  registerComponent,
  registerComponentExtension,
  registerCustomEffectType,
  registerExportExtensions,
  registerExtensions,
  registerLoader,
  registerPrefabProvider,
  registerPrototypeExtensions,
  registerType,
  relativePathPrefix,
  removeAttributeChangeCallback,
  removeComponent,
  removeCustomImportExtensionType,
  removeGltfLoadEventListener,
  removePatch,
  removeScriptFromContext,
  resolveUrl,
  sanitizeString,
  saveImage,
  screenshot,
  screenshot2,
  sendDestroyed,
  serializable,
  serializeObject,
  serializeable,
  setActive,
  setAllowBalloonMessages,
  setAllowOverlayMessages,
  setAutoFitEnabled,
  setCameraController,
  setDestroyed,
  setDevEnvironment,
  setDisposable,
  setDontDestroy,
  setOrAddParamsToUrl,
  setParam,
  setParamWithoutReload,
  setPeerOptions,
  setResourceTrackingEnabled,
  setState,
  setVisibleInCustomShadowRendering,
  setWorldEuler,
  setWorldPosition,
  setWorldPositionXYZ,
  setWorldQuaternion,
  setWorldQuaternionXYZW,
  setWorldRotation,
  setWorldRotationXYZ,
  setWorldScale,
  shouldExport_HideFlags,
  showBalloonError,
  showBalloonMessage,
  showBalloonWarning,
  showDebugConsole,
  slerp,
  syncDestroy,
  syncField,
  syncInstantiate,
  textureToCanvas,
  tryCastBinary,
  tryDetermineFileTypeFromBinary,
  tryDetermineFileTypeFromURL,
  tryFindObject,
  tryGetGuid,
  unwatchWrite,
  useForAutoFit,
  validate,
  watchWrite
} from "./chunk-MZTUBDKM.js";
import "./chunk-GTWKTLO2.js";
import "./chunk-44U3T43X.js";
import "./chunk-PUUJIG6R.js";
import {
  AudioContext,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Color,
  EquirectangularReflectionMapping,
  InterleavedBufferAttribute,
  LineBasicMaterial,
  LineSegments,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshStandardMaterial,
  Object3D,
  PMREMGenerator$1,
  PerspectiveCamera,
  PointLight,
  Quaternion,
  Scene,
  Vector3,
  three_module_exports
} from "./chunk-4G6G5IWY.js";
import {
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-4RACSZOF.js";

// node_modules/@needle-tools/engine/lib/engine/engine_audio.js
function ensureAudioContextIsResumed() {
  Application.registerWaitForInteraction(() => {
    const ctx = AudioContext.getContext();
    ctx.addEventListener("statechange", () => {
      setTimeout(() => {
        const state = ctx.state;
        if (state === "suspended" || state === "interrupted") {
          ctx.resume().then(() => {
            console.log("AudioContext resumed successfully");
          }).catch((e) => {
            console.log("Failed to resume AudioContext: " + e);
          });
        }
      }, 500);
    });
  });
}
setTimeout(ensureAudioContextIsResumed, 1e3);

// node_modules/@needle-tools/engine/lib/engine/engine_hot_reload.js
var debug = getParam("debughotreload");
if (import.meta.hot) {
  import.meta.hot.on("vite:beforeUpdate", (cb) => {
    if (debug)
      console.log(cb);
    for (const update of cb.updates) {
      console.log("[Needle Engine] Hot reloading " + update.path);
    }
  });
}
var isApplyingChanges = false;
var instances = /* @__PURE__ */ new Map();
function isHotReloading() {
  return isApplyingChanges;
}
function registerHotReloadType(instance) {
  var _a2;
  if (isApplyingChanges)
    return;
  const type = instance.constructor;
  const name = type.name;
  if (!instances.has(name)) {
    instances.set(name, [instance]);
  } else {
    (_a2 = instances.get(name)) == null ? void 0 : _a2.push(instance);
  }
}
function unregisterHotReloadType(instance) {
  if (isApplyingChanges)
    return;
  const type = instance.constructor;
  const name = type.name;
  const instancesOfType = instances.get(name);
  if (!instancesOfType)
    return;
  const idx = instancesOfType.indexOf(instance);
  if (idx === -1)
    return;
  instancesOfType.splice(idx, 1);
}
var didRegisterUnhandledExceptionListener = false;
function reloadPageOnHotReloadError() {
  if (debug)
    return;
  if (didRegisterUnhandledExceptionListener)
    return;
  didRegisterUnhandledExceptionListener = true;
  const error = console.error;
  console.error = (...args) => {
    if (args.length) {
      const arg = args[0];
      if (typeof arg === "string" && arg.includes("[hmr] Failed to reload ")) {
        console.log("[Needle Engine] Hot reloading failed");
        window.location.reload();
        return;
      }
    }
    error.apply(console, args);
  };
}
function applyHMRChanges(newModule) {
  if (debug)
    console.log("[HMR] Apply changes", newModule, Object.keys(newModule));
  reloadPageOnHotReloadError();
  for (const key of Object.keys(newModule)) {
    try {
      isApplyingChanges = true;
      const typeToUpdate = TypeStore.get(key);
      if (!typeToUpdate) {
        if (debug)
          console.log("[HMR] Type not found: " + key);
        continue;
      }
      const newType = newModule[key];
      const instancesOfType = instances.get(newType.name);
      let hotReloadMessage = "[Needle Engine] Updating type: " + key;
      const typesCount = (instancesOfType == null ? void 0 : instancesOfType.length) ?? -1;
      if (typesCount > 0)
        hotReloadMessage += " x" + typesCount;
      else
        hotReloadMessage += " - no instances";
      console.log(hotReloadMessage);
      const previousMethods = Object.getOwnPropertyNames(typeToUpdate.prototype);
      const methodsAndProperties = Object.getOwnPropertyDescriptors(newType.prototype);
      for (const typeKey in methodsAndProperties) {
        const desc = methodsAndProperties[typeKey];
        if (!desc.writable)
          continue;
        typeToUpdate.prototype[typeKey] = newModule[key].prototype[typeKey];
      }
      for (const typeKey of previousMethods) {
        if (!methodsAndProperties[typeKey]) {
          delete typeToUpdate.prototype[typeKey];
        }
      }
      if (instancesOfType) {
        const newTypeInstance = new newType();
        const keys = Object.getOwnPropertyDescriptors(newTypeInstance);
        for (const inst of instancesOfType) {
          const componentInstance = inst;
          const isComponent2 = componentInstance.isComponent === true;
          const active = isComponent2 ? componentInstance.activeAndEnabled : true;
          const context = isComponent2 ? componentInstance.context : void 0;
          try {
            if (isComponent2 && context) {
              removeScriptFromContext(componentInstance, context);
            }
            if (isComponent2 && active) {
              componentInstance.enabled = false;
            }
            if (inst["onBeforeHotReloadFields"]) {
              const res = inst["onBeforeHotReloadFields"]();
              if (res === false)
                continue;
            }
            for (const key2 in keys) {
              const desc = keys[key2];
              if (!desc.writable)
                continue;
              if (inst[key2] === void 0) {
                inst[key2] = newTypeInstance[key2];
              } else if (typeof inst[key2] === "function" && !inst[key2].prototype) {
                const boundMethod = inst[key2];
                const targetMethodName = boundMethod.name;
                const prefix2 = "bound ";
                if (targetMethodName === prefix2)
                  continue;
                const name = boundMethod.name.substring(prefix2.length);
                const newTarget = newType.prototype[name];
                if (newTarget)
                  inst[key2] = newTarget.bind(inst);
              }
            }
            if (inst["onAfterHotReloadFields"])
              inst["onAfterHotReloadFields"]();
          } finally {
            if (isComponent2 && context) {
              addScriptToArrays(componentInstance, context);
            }
            if (isComponent2 && active) {
              componentInstance.enabled = true;
            }
          }
        }
      }
    } catch (err) {
      if (debug)
        console.error(err);
      else
        return false;
    } finally {
      isApplyingChanges = false;
      addLog(LogType.Log, "Script changes applied (HMR)");
    }
  }
  return true;
}

// node_modules/@needle-tools/engine/lib/engine/engine_physics_rapier.js
var debugPhysics = getParam("debugphysics");
var debugColliderPlacement = getParam("debugcolliderplacement");
var debugCollisions = getParam("debugcollisions");
var showColliders = getParam("showcolliders");
var showPhysicsRaycasts = getParam("debugraycasts");
var $componentKey = Symbol("needle component");
var $bodyKey = Symbol("physics body");
var $colliderRigidbody = Symbol("rigidbody");
globalThis["NEEDLE_USE_RAPIER"] = globalThis["NEEDLE_USE_RAPIER"] !== void 0 ? globalThis["NEEDLE_USE_RAPIER"] : true;
if (debugPhysics)
  console.log("Use Rapier", NEEDLE_USE_RAPIER, globalThis["NEEDLE_USE_RAPIER"]);
if (NEEDLE_USE_RAPIER) {
  ContextRegistry.registerCallback(ContextEvent.ContextCreationStart, (evt) => {
    if (debugPhysics)
      console.log("Register rapier physics backend");
    evt.context.physics.engine = new RapierPhysics(evt.context);
  });
}
var _RapierPhysics = class {
  constructor(ctx) {
    __publicField(this, "debugRenderColliders", false);
    __publicField(this, "debugRenderRaycasts", false);
    __publicField(this, "context");
    __publicField(this, "_initializePromise");
    __publicField(this, "_isInitialized", false);
    __publicField(this, "rapierRay");
    __publicField(this, "raycastVectorsBuffer", new CircularBuffer(() => new Vector3(), 10));
    __publicField(this, "rapierSphere", null);
    __publicField(this, "rapierColliderArray", []);
    __publicField(this, "rapierIdentityRotation", { x: 0, y: 0, z: 0, w: 1 });
    __publicField(this, "rapierForwardVector", { x: 0, y: 0, z: 1 });
    // physics simulation
    __publicField(this, "enabled", false);
    __publicField(this, "_tempPosition", new Vector3());
    __publicField(this, "_tempQuaternion", new Quaternion());
    __publicField(this, "_tempScale", new Vector3());
    __publicField(this, "_tempMatrix", new Matrix4());
    __publicField(this, "_isUpdatingPhysicsWorld", false);
    __publicField(this, "_world");
    __publicField(this, "_hasCreatedWorld", false);
    __publicField(this, "eventQueue");
    __publicField(this, "collisionHandler");
    __publicField(this, "objects", []);
    __publicField(this, "bodies", []);
    __publicField(this, "_meshCache", /* @__PURE__ */ new Map());
    __publicField(this, "_gravity", { x: 0, y: -9.81, z: 0 });
    // private _lastStepTime: number | undefined = 0;
    __publicField(this, "lines");
    __publicField(this, "_tempCenterPos", new Vector3());
    __publicField(this, "_tempCenterVec", new Vector3());
    __publicField(this, "_tempCenterQuaternion", new Quaternion());
    this.context = ctx;
  }
  removeBody(obj) {
    var _a2, _b, _c;
    if (!obj)
      return;
    this.validate();
    const body = obj[$bodyKey];
    obj[$bodyKey] = null;
    if (body && this.world) {
      const index = this.objects.findIndex((o) => o === obj);
      if (index >= 0) {
        const rapierBody = this.bodies[index];
        this.bodies.splice(index, 1);
        this.objects.splice(index, 1);
        if (rapierBody instanceof MODULES.RAPIER_PHYSICS.MODULE.Collider) {
          const rapierCollider = rapierBody;
          (_a2 = this.world) == null ? void 0 : _a2.removeCollider(rapierCollider, true);
          const rapierRigidbody = rapierCollider.parent();
          if (rapierRigidbody && rapierRigidbody.numColliders() <= 0) {
            const rigidbody = rapierRigidbody[$componentKey];
            if (rigidbody) {
            } else {
              (_b = this.world) == null ? void 0 : _b.removeRigidBody(rapierRigidbody);
            }
          }
        } else if (rapierBody instanceof MODULES.RAPIER_PHYSICS.MODULE.RigidBody) {
          if (rapierBody.numColliders() <= 0) {
            (_c = this.world) == null ? void 0 : _c.removeRigidBody(rapierBody);
          } else {
            if (isDevEnvironment()) {
              if (!rapierBody["did_log_removing"]) {
                setTimeout(() => {
                  if (rapierBody.numColliders() > 0) {
                    rapierBody["did_log_removing"] = true;
                    console.warn("RapierPhysics: removing rigidbody with colliders from the physics world is not possible right now, please remove the colliders first");
                  }
                }, 1);
              }
            }
          }
        }
      }
    }
  }
  updateBody(comp, translation, rotation) {
    this.validate();
    if (!this.enabled)
      return;
    if (comp.destroyed || !comp.gameObject)
      return;
    if (!translation && !rotation)
      return;
    if (comp.isCollider === true) {
      console.warn("TODO: implement updating collider position");
    } else {
      const rigidbody = comp;
      const body = rigidbody[$bodyKey];
      if (body) {
        this.syncPhysicsBody(rigidbody.gameObject, body, translation, rotation);
      }
    }
  }
  updateProperties(obj) {
    this.validate();
    if (obj.isCollider) {
      const col = obj;
      const body = col[$bodyKey];
      if (body) {
        this.internalUpdateColliderProperties(col, body);
        if (col.sharedMaterial)
          this.updatePhysicsMaterial(col);
      }
    } else {
      const rb = obj;
      const physicsBody = this.internal_getRigidbody(rb);
      if (physicsBody) {
        this.internalUpdateRigidbodyProperties(rb, physicsBody);
      }
    }
  }
  addForce(rigidbody, force, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rigidbody);
    if (body)
      body.addForce(force, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not apply force (does your object with the Rigidbody have a collider?)");
  }
  addImpulse(rigidbody, force, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rigidbody);
    if (body)
      body.applyImpulse(force, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  getLinearVelocity(comp) {
    this.validate();
    const body = this.internal_getRigidbody(comp);
    if (body) {
      const vel = body.linvel();
      return vel;
    }
    return null;
  }
  getAngularVelocity(rb) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body) {
      const vel = body.angvel();
      return vel;
    }
    return null;
  }
  resetForces(rb, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    body == null ? void 0 : body.resetForces(wakeup);
  }
  resetTorques(rb, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    body == null ? void 0 : body.resetTorques(wakeup);
  }
  applyImpulse(rb, vec, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body)
      body.applyImpulse(vec, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  wakeup(rb) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body)
      body.wakeUp();
    else
      console.warn("Rigidbody doesn't exist: can not wake up (does your object with the Rigidbody have a collider?)");
  }
  isSleeping(rb) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    return body == null ? void 0 : body.isSleeping();
  }
  setAngularVelocity(rb, vec, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body)
      body.setAngvel(vec, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not set angular velocity (does your object with the Rigidbody have a collider?)");
  }
  setLinearVelocity(rb, vec, wakeup) {
    this.validate();
    const body = this.internal_getRigidbody(rb);
    if (body)
      body.setLinvel(vec, wakeup);
    else
      console.warn("Rigidbody doesn't exist: can not set linear velocity (does your object with the Rigidbody have a collider?)");
  }
  get isInitialized() {
    return this._isInitialized;
  }
  async initialize() {
    if (!this._initializePromise)
      this._initializePromise = this.internalInitialization();
    return this._initializePromise;
  }
  async internalInitialization() {
    if (getParam("__nophysics")) {
      console.warn("Physics are disabled");
      return false;
    }
    if (debugPhysics)
      console.log("Initialize rapier physics engine");
    if ("env" in import.meta && import.meta.env.VITE_NEEDLE_USE_RAPIER === "false") {
      if (debugPhysics)
        console.log("Rapier disabled");
      return false;
    }
    if (!NEEDLE_USE_RAPIER)
      return false;
    if (this._hasCreatedWorld) {
      console.error("Invalid call to create physics world: world is already created");
      return true;
    }
    this._hasCreatedWorld = true;
    if (MODULES.RAPIER_PHYSICS.MAYBEMODULE == void 0) {
      if (debugPhysics)
        console.trace("Loading rapier physics engine");
      const module = await MODULES.RAPIER_PHYSICS.load();
      await module.init();
    }
    if (debugPhysics)
      console.log("Physics engine initialized, creating world...");
    this._world = new MODULES.RAPIER_PHYSICS.MODULE.World(this._gravity);
    this.rapierRay = new MODULES.RAPIER_PHYSICS.MODULE.Ray({ x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 });
    this.enabled = true;
    this._isInitialized = true;
    if (debugPhysics)
      console.log("Physics world created");
    return true;
  }
  /** Check is the physics engine has been initialized and the call can be made */
  validate() {
    if (!this._isInitialized) {
      if (debugPhysics) {
        this["_lastWarnTime"] = this["_lastWarnTime"] ?? 0;
        if (Date.now() - this["_lastWarnTime"] > 1e3) {
          this["_lastWarnTime"] = Date.now();
          console.warn("Physics engine is not initialized");
        }
      }
    }
  }
  raycast(origin, direction, options) {
    var _a2;
    if (!this._isInitialized) {
      console.log("Physics engine is not initialized");
      return null;
    }
    let maxDistance = options == null ? void 0 : options.maxDistance;
    let solid = options == null ? void 0 : options.solid;
    if (maxDistance === void 0)
      maxDistance = Infinity;
    if (solid === void 0)
      solid = true;
    const ray = this.getPhysicsRay(this.rapierRay, origin, direction);
    if (!ray)
      return null;
    if (this.debugRenderRaycasts || showPhysicsRaycasts)
      Gizmos.DrawRay(ray.origin, ray.dir, 255, 1);
    const hit = (_a2 = this.world) == null ? void 0 : _a2.castRay(ray, maxDistance, solid, options == null ? void 0 : options.queryFilterFlags, options == null ? void 0 : options.filterGroups, void 0, void 0, (c) => {
      const component = c[$componentKey];
      if (options == null ? void 0 : options.filterPredicate)
        return options.filterPredicate(component);
      if ((options == null ? void 0 : options.useIgnoreRaycastLayer) !== false) {
        return !(component == null ? void 0 : component.gameObject.layers.isEnabled(2));
      }
      return true;
    });
    if (hit) {
      const point = ray.pointAt(hit.timeOfImpact);
      const vec = this.raycastVectorsBuffer.get();
      vec.set(point.x, point.y, point.z);
      return { point: vec, collider: hit.collider[$componentKey] };
    }
    return null;
  }
  raycastAndGetNormal(origin, direction, options) {
    var _a2;
    if (!this._isInitialized) {
      return null;
    }
    let maxDistance = options == null ? void 0 : options.maxDistance;
    let solid = options == null ? void 0 : options.solid;
    if (maxDistance === void 0)
      maxDistance = Infinity;
    if (solid === void 0)
      solid = true;
    const ray = this.getPhysicsRay(this.rapierRay, origin, direction);
    if (!ray)
      return null;
    if (this.debugRenderRaycasts || showPhysicsRaycasts)
      Gizmos.DrawRay(ray.origin, ray.dir, 255, 1);
    const hit = (_a2 = this.world) == null ? void 0 : _a2.castRayAndGetNormal(ray, maxDistance, solid, options == null ? void 0 : options.queryFilterFlags, options == null ? void 0 : options.filterGroups, void 0, void 0, (c) => {
      const component = c[$componentKey];
      if (options == null ? void 0 : options.filterPredicate)
        return options.filterPredicate(component);
      if ((options == null ? void 0 : options.useIgnoreRaycastLayer) !== false) {
        return !(component == null ? void 0 : component.gameObject.layers.isEnabled(2));
      }
      return true;
    });
    if (hit) {
      const point = ray.pointAt(hit.timeOfImpact);
      const normal = hit.normal;
      const vec = this.raycastVectorsBuffer.get();
      const nor = this.raycastVectorsBuffer.get();
      vec.set(point.x, point.y, point.z);
      nor.set(normal.x, normal.y, normal.z);
      return { point: vec, normal: nor, collider: hit.collider[$componentKey] };
    }
    return null;
  }
  getPhysicsRay(ray, origin, direction) {
    var _a2, _b, _c;
    const cam = (_a2 = this.context) == null ? void 0 : _a2.mainCamera;
    if (origin === void 0) {
      const pos = (_b = this.context) == null ? void 0 : _b.input.getPointerPosition(0);
      if (pos)
        origin = pos;
      else
        return null;
    }
    if (origin["z"] === void 0) {
      if (!cam) {
        console.error("Can not perform raycast from 2d point - no main camera found");
        return null;
      }
      const vec3 = this.raycastVectorsBuffer.get();
      vec3.x = origin.x;
      vec3.y = origin.y;
      vec3.z = 0;
      if (vec3.x > 1 || vec3.y > 1 || vec3.y < -1 || vec3.x < -1) {
        if (debugPhysics)
          console.warn("Converting screenspace to raycast space", vec3);
        (_c = this.context) == null ? void 0 : _c.input.convertScreenspaceToRaycastSpace(vec3);
      }
      vec3.unproject(cam);
      origin = vec3;
    }
    const o = origin;
    ray.origin.x = o.x;
    ray.origin.y = o.y;
    ray.origin.z = o.z;
    const vec = this.raycastVectorsBuffer.get();
    if (direction)
      vec.set(direction.x, direction.y, direction.z);
    else {
      if (!cam) {
        console.error("Can not perform raycast - no camera found");
        return null;
      }
      vec.set(ray.origin.x, ray.origin.y, ray.origin.z);
      const camPosition = getWorldPosition(cam);
      vec.sub(camPosition);
    }
    vec.normalize();
    ray.dir.x = vec.x;
    ray.dir.y = vec.y;
    ray.dir.z = vec.z;
    return ray;
  }
  /** Precice sphere overlap detection using rapier against colliders
   * @param point center of the sphere in worldspace
   * @param radius radius of the sphere
   * @returns array of colliders that overlap with the sphere. Note: they currently only contain the collider and the gameobject
   */
  sphereOverlap(point, radius) {
    this.rapierColliderArray.length = 0;
    if (!this._isInitialized) {
      return this.rapierColliderArray;
    }
    if (!this.world)
      return this.rapierColliderArray;
    this.rapierSphere ?? (this.rapierSphere = new MODULES.RAPIER_PHYSICS.MODULE.Ball(radius));
    this.rapierSphere.radius = radius;
    if (this.debugRenderRaycasts || showPhysicsRaycasts)
      Gizmos.DrawWireSphere(point, radius, 3359999, 1);
    this.world.intersectionsWithShape(
      point,
      this.rapierIdentityRotation,
      this.rapierSphere,
      (col) => {
        const collider = col[$componentKey];
        const intersection = new SphereOverlapResult(collider.gameObject, collider);
        this.rapierColliderArray.push(intersection);
        return true;
      },
      // TODO: it seems as QueryFilterFlags.EXCLUDE_SENSORS also excludes DYNAMIC Rigidbodies (only if they're set to kinematic)
      void 0,
      // QueryFilterFlags.EXCLUDE_SENSORS, 
      void 0,
      void 0,
      void 0,
      (col) => {
        if (col.isSensor())
          return false;
        const collider = col[$componentKey];
        return collider.gameObject.layers.isEnabled(2) == false;
      }
    );
    return this.rapierColliderArray;
  }
  /** Get access to the rapier world */
  get world() {
    return this._world;
  }
  get isUpdating() {
    return this._isUpdatingPhysicsWorld;
  }
  get gravity() {
    var _a2;
    return ((_a2 = this.world) == null ? void 0 : _a2.gravity) ?? this._gravity;
  }
  set gravity(value) {
    if (this.world) {
      this.world.gravity = value;
    } else {
      this._gravity = value;
    }
  }
  clearCaches() {
    var _a2, _b, _c, _d;
    this._meshCache.clear();
    if ((_a2 = this.eventQueue) == null ? void 0 : _a2.raw)
      (_b = this.eventQueue) == null ? void 0 : _b.free();
    if ((_c = this.world) == null ? void 0 : _c.bodies)
      (_d = this.world) == null ? void 0 : _d.free();
  }
  async addBoxCollider(collider, size) {
    if (!this._isInitialized)
      await this.initialize();
    if (!collider.activeAndEnabled)
      return;
    if (!this.enabled) {
      if (debugPhysics)
        console.warn("Physics are disabled");
      return;
    }
    const obj = collider.gameObject;
    const scale = getWorldScale(obj, this._tempPosition).multiply(size);
    scale.multiplyScalar(0.5);
    if (scale.x < 0)
      scale.x = Math.abs(scale.x);
    if (scale.y < 0)
      scale.y = Math.abs(scale.y);
    if (scale.z < 0)
      scale.z = Math.abs(scale.z);
    if (scale.x == 0)
      scale.x = 1e-7;
    if (scale.y == 0)
      scale.y = 1e-7;
    if (scale.z == 0)
      scale.z = 1e-7;
    const desc = MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.cuboid(scale.x, scale.y, scale.z);
    this.createCollider(collider, desc);
  }
  async addSphereCollider(collider) {
    if (!this._isInitialized)
      await this.initialize();
    if (!collider.activeAndEnabled)
      return;
    if (!this.enabled) {
      if (debugPhysics)
        console.warn("Physics are disabled");
      return;
    }
    const desc = MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.ball(0.5);
    this.createCollider(collider, desc);
    this.updateProperties(collider);
  }
  async addCapsuleCollider(collider, height, radius) {
    if (!this._isInitialized)
      await this.initialize();
    if (!collider.activeAndEnabled)
      return;
    if (!this.enabled) {
      if (debugPhysics)
        console.warn("Physics are disabled");
      return;
    }
    const obj = collider.gameObject;
    const scale = getWorldScale(obj, this._tempPosition);
    scale.x = Math.abs(scale.x);
    scale.y = Math.abs(scale.y);
    const finalRadius = radius * scale.x;
    height = Math.max(height, finalRadius * 2);
    const hh = Mathf.clamp(height * 0.5 * scale.y - radius * scale.x, 0, Number.MAX_SAFE_INTEGER);
    const desc = MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.capsule(hh, finalRadius);
    this.createCollider(collider, desc);
  }
  async addMeshCollider(collider, mesh, convex, extraScale) {
    var _a2, _b, _c;
    let geo = mesh.geometry;
    if (!geo) {
      if (debugPhysics)
        console.warn("Missing mesh geometry", mesh.name);
      return;
    }
    if (!((_b = (_a2 = geo.index) == null ? void 0 : _a2.array) == null ? void 0 : _b.length)) {
      console.warn(`Your MeshCollider is missing vertices or indices in the assined mesh "${mesh.name}". Consider providing an indexed geometry.`);
      geo = mergeVertices(geo);
    }
    let positions = null;
    const positionAttribute = geo.getAttribute("position");
    if (positionAttribute instanceof InterleavedBufferAttribute) {
      const count = positionAttribute.count;
      positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        const x = positionAttribute.getX(i);
        const y = positionAttribute.getY(i);
        const z = positionAttribute.getZ(i);
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
      }
    } else {
      positions = positionAttribute.array;
    }
    await this.initialize();
    if (!this.enabled) {
      if (debugPhysics)
        console.warn("Physics are disabled");
      return;
    }
    if (!collider.activeAndEnabled)
      return;
    const indices = (_c = geo.index) == null ? void 0 : _c.array;
    const scale = collider.gameObject.worldScale.clone();
    if (extraScale)
      scale.multiply(extraScale);
    if (Math.abs(scale.x - 1) > 1e-4 || Math.abs(scale.y - 1) > 1e-4 || Math.abs(scale.z - 1) > 1e-4) {
      const key = `${geo.uuid}_${scale.x}_${scale.y}_${scale.z}_${convex}`;
      if (this._meshCache.has(key)) {
        if (debugPhysics)
          console.warn("Use cached mesh collider");
        positions = this._meshCache.get(key);
      } else {
        if (debugPhysics || isDevEnvironment())
          console.debug(`[Performance] Your MeshCollider "${collider.name}" is scaled: consider applying the scale to the collider mesh instead (${scale.x}, ${scale.y}, ${scale.z})`);
        const scaledPositions = new Float32Array(positions.length);
        for (let i = 0; i < positions.length; i += 3) {
          scaledPositions[i] = positions[i] * scale.x;
          scaledPositions[i + 1] = positions[i + 1] * scale.y;
          scaledPositions[i + 2] = positions[i + 2] * scale.z;
        }
        positions = scaledPositions;
        this._meshCache.set(key, scaledPositions);
      }
    }
    const desc = convex ? MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.convexHull(positions) : MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.trimesh(positions, indices);
    if (desc) {
      this.createCollider(collider, desc);
    }
  }
  updatePhysicsMaterial(col) {
    if (!col)
      return;
    const physicsMaterial = col.sharedMaterial;
    const rapier_collider = col[$bodyKey];
    if (!rapier_collider)
      return;
    if (physicsMaterial) {
      if (physicsMaterial.bounciness !== void 0)
        rapier_collider.setRestitution(physicsMaterial.bounciness);
      if (physicsMaterial.bounceCombine !== void 0) {
        switch (physicsMaterial.bounceCombine) {
          case PhysicsMaterialCombine.Average:
            rapier_collider.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case PhysicsMaterialCombine.Maximum:
            rapier_collider.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case PhysicsMaterialCombine.Minimum:
            rapier_collider.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case PhysicsMaterialCombine.Multiply:
            rapier_collider.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      }
      if (physicsMaterial.dynamicFriction !== void 0)
        rapier_collider.setFriction(physicsMaterial.dynamicFriction);
      if (physicsMaterial.frictionCombine !== void 0) {
        switch (physicsMaterial.frictionCombine) {
          case PhysicsMaterialCombine.Average:
            rapier_collider.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case PhysicsMaterialCombine.Maximum:
            rapier_collider.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case PhysicsMaterialCombine.Minimum:
            rapier_collider.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case PhysicsMaterialCombine.Multiply:
            rapier_collider.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      }
    }
  }
  /** Get the rapier body for a Needle component */
  getBody(obj) {
    if (!obj)
      return null;
    const body = obj[$bodyKey];
    return body;
  }
  /** Get the Needle Engine component for a rapier object */
  getComponent(rapierObject) {
    if (!rapierObject)
      return null;
    const component = rapierObject[$componentKey];
    return component;
  }
  createCollider(collider, desc) {
    var _a2;
    if (!this.world)
      throw new Error("Physics world not initialized");
    const matrix = this._tempMatrix;
    let rigidBody = void 0;
    if (!collider.attachedRigidbody) {
      if (debugPhysics)
        console.log("Create collider without rigidbody", collider.name);
      matrix.makeRotationFromQuaternion(getWorldQuaternion(collider.gameObject));
      matrix.setPosition(getWorldPosition(collider.gameObject));
    } else {
      rigidBody = this.getRigidbody(collider, this._tempMatrix);
    }
    matrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    this.tryApplyCenter(collider, this._tempPosition);
    desc.setTranslation(this._tempPosition.x, this._tempPosition.y, this._tempPosition.z);
    desc.setRotation(this._tempQuaternion);
    desc.setSensor(collider.isTrigger);
    const physicsMaterial = collider.sharedMaterial;
    if (physicsMaterial) {
      if (physicsMaterial.bounciness !== void 0)
        desc.setRestitution(physicsMaterial.bounciness);
      if (physicsMaterial.bounceCombine !== void 0) {
        switch (physicsMaterial.bounceCombine) {
          case PhysicsMaterialCombine.Average:
            desc.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case PhysicsMaterialCombine.Maximum:
            desc.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case PhysicsMaterialCombine.Minimum:
            desc.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case PhysicsMaterialCombine.Multiply:
            desc.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      }
      if (physicsMaterial.dynamicFriction !== void 0)
        desc.setFriction(physicsMaterial.dynamicFriction);
      if (physicsMaterial.frictionCombine !== void 0) {
        switch (physicsMaterial.frictionCombine) {
          case PhysicsMaterialCombine.Average:
            desc.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case PhysicsMaterialCombine.Maximum:
            desc.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case PhysicsMaterialCombine.Minimum:
            desc.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case PhysicsMaterialCombine.Multiply:
            desc.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      }
    }
    if (((_a2 = collider.attachedRigidbody) == null ? void 0 : _a2.autoMass) === false) {
      desc.setDensity(1e-6);
      desc.setMass(1e-6);
    }
    try {
      const col = this.world.createCollider(desc, rigidBody);
      col[$componentKey] = collider;
      collider[$bodyKey] = col;
      col.setActiveEvents(MODULES.RAPIER_PHYSICS.MODULE.ActiveEvents.COLLISION_EVENTS);
      col.setActiveCollisionTypes(MODULES.RAPIER_PHYSICS.MODULE.ActiveCollisionTypes.ALL);
      this.objects.push(collider);
      this.bodies.push(col);
      this.updateColliderCollisionGroups(collider);
      return col;
    } catch (e) {
      console.error('Error creating collider "' + collider.name + '"\nError:', e);
      return null;
    }
  }
  /**
   * Updates the collision groups of a collider.
   *
   * @param collider - The collider to update.
   */
  updateColliderCollisionGroups(collider) {
    const body = collider[$bodyKey];
    const members = collider.membership;
    let memberMask = 0;
    if (members == void 0) {
      memberMask = 65535;
    } else {
      for (let i = 0; i < members.length; i++) {
        const member = members[i];
        if (member > 31)
          console.error(`Rapier only supports 32 layers, layer ${member} is not supported`);
        else
          memberMask |= 1 << Math.floor(member);
      }
    }
    const mask = collider.filter;
    let filterMask = 0;
    if (mask == void 0) {
      filterMask = 65535;
    } else {
      for (let i = 0; i < mask.length; i++) {
        const member = mask[i];
        if (member > 31)
          console.error(`Rapier only supports 32 layers, layer ${member} is not supported`);
        else
          filterMask |= 1 << Math.floor(member);
      }
    }
    body.setCollisionGroups(memberMask << 16 | filterMask);
  }
  getRigidbody(collider, _matrix) {
    if (!this.world)
      throw new Error("Physics world not initialized");
    let rigidBody = null;
    if (collider.attachedRigidbody) {
      const rb = collider.attachedRigidbody;
      rigidBody = rb[$bodyKey];
      if (!rigidBody) {
        const kinematic = rb.isKinematic && !debugColliderPlacement;
        if (debugPhysics)
          console.log("Create rigidbody", kinematic);
        const rigidBodyDesc = kinematic ? MODULES.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased() : MODULES.RAPIER_PHYSICS.MODULE.RigidBodyDesc.dynamic();
        const pos = getWorldPosition(collider.attachedRigidbody.gameObject);
        rigidBodyDesc.setTranslation(pos.x, pos.y, pos.z);
        rigidBodyDesc.setRotation(getWorldQuaternion(collider.attachedRigidbody.gameObject));
        rigidBodyDesc.centerOfMass = new MODULES.RAPIER_PHYSICS.MODULE.Vector3(rb.centerOfMass.x, rb.centerOfMass.y, rb.centerOfMass.z);
        rigidBody = this.world.createRigidBody(rigidBodyDesc);
        this.bodies.push(rigidBody);
        this.objects.push(rb);
      }
      rigidBody[$componentKey] = rb;
      rb[$bodyKey] = rigidBody;
      this.internalUpdateRigidbodyProperties(rb, rigidBody);
      this.getRigidbodyRelativeMatrix(collider.gameObject, rb.gameObject, _matrix);
      collider[$colliderRigidbody] = rigidBody;
    } else {
      const rigidBodyDesc = MODULES.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased();
      const pos = getWorldPosition(collider.gameObject);
      rigidBodyDesc.setTranslation(pos.x, pos.y, pos.z);
      rigidBodyDesc.setRotation(getWorldQuaternion(collider.gameObject));
      rigidBody = this.world.createRigidBody(rigidBodyDesc);
      _matrix.identity();
      rigidBody[$componentKey] = null;
    }
    return rigidBody;
  }
  internal_getRigidbody(rb) {
    if (rb.isCollider === true)
      return rb[$colliderRigidbody];
    return rb[$bodyKey];
  }
  internalUpdateColliderProperties(col, collider) {
    const shape = collider.shape;
    let sizeHasChanged = false;
    switch (shape.type) {
      case MODULES.RAPIER_PHYSICS.MODULE.ShapeType.Ball: {
        const ball = shape;
        const sc2 = col;
        const obj2 = col.gameObject;
        const scale2 = getWorldScale(obj2, this._tempPosition);
        const radius = Math.abs(sc2.radius * scale2.x);
        sizeHasChanged = ball.radius !== radius;
        ball.radius = radius;
        if (sizeHasChanged) {
          collider.setShape(ball);
        }
        break;
      }
      case MODULES.RAPIER_PHYSICS.MODULE.ShapeType.Cuboid:
        const cuboid = shape;
        const sc = col;
        const obj = col.gameObject;
        const scale = getWorldScale(obj, this._tempPosition);
        const newX = sc.size.x * 0.5 * scale.x;
        const newY = sc.size.y * 0.5 * scale.y;
        const newZ = sc.size.z * 0.5 * scale.z;
        sizeHasChanged = cuboid.halfExtents.x !== newX || cuboid.halfExtents.y !== newY || cuboid.halfExtents.z !== newZ;
        cuboid.halfExtents.x = newX;
        cuboid.halfExtents.y = newY;
        cuboid.halfExtents.z = newZ;
        if (sizeHasChanged) {
          collider.setShape(cuboid);
        }
        break;
    }
    if (sizeHasChanged) {
      const rb = col.attachedRigidbody;
      if (rb == null ? void 0 : rb.autoMass) {
        const ph = this.getBody(rb);
        ph == null ? void 0 : ph.recomputeMassPropertiesFromColliders();
      }
    }
    this.updateColliderCollisionGroups(col);
    if (col.isTrigger !== collider.isSensor())
      collider.setSensor(col.isTrigger);
  }
  internalUpdateRigidbodyProperties(rb, rigidbody) {
    rigidbody.enableCcd(rb.collisionDetectionMode !== CollisionDetectionMode.Discrete);
    rigidbody.setLinearDamping(rb.drag);
    rigidbody.setAngularDamping(rb.angularDrag);
    rigidbody.setGravityScale(rb.useGravity ? rb.gravityScale : 0, true);
    if (rb.dominanceGroup <= 127 && rb.dominanceGroup >= -127)
      rigidbody.setDominanceGroup(Math.floor(rb.dominanceGroup));
    else
      rigidbody.setDominanceGroup(0);
    if (rb.autoMass) {
      rigidbody.setAdditionalMass(0, false);
      for (let i = 0; i < rigidbody.numColliders(); i++) {
        const col = rigidbody.collider(i);
        col.setDensity(1);
      }
      rigidbody.recomputeMassPropertiesFromColliders();
    } else {
      rigidbody.setAdditionalMass(rb.mass, false);
      for (let i = 0; i < rigidbody.numColliders(); i++) {
        const col = rigidbody.collider(i);
        col.setDensity(1e-7);
      }
      rigidbody.recomputeMassPropertiesFromColliders();
    }
    rigidbody.setEnabledRotations(!rb.lockRotationX, !rb.lockRotationY, !rb.lockRotationZ, false);
    rigidbody.setEnabledTranslations(!rb.lockPositionX, !rb.lockPositionY, !rb.lockPositionZ, false);
    if (rb.isKinematic) {
      rigidbody.setBodyType(MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased, false);
    } else {
      rigidbody.setBodyType(MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.Dynamic, false);
    }
  }
  step(dt) {
    if (!this.world)
      return;
    if (!this.enabled)
      return;
    this._isUpdatingPhysicsWorld = true;
    if (!this.eventQueue) {
      this.eventQueue = new MODULES.RAPIER_PHYSICS.MODULE.EventQueue(false);
    }
    if (dt === void 0 || dt <= 0) {
      this._isUpdatingPhysicsWorld = false;
      return;
    } else if (dt !== void 0) {
      this.world.timestep = Mathf.lerp(this.world.timestep, dt, 0.8);
    }
    try {
      this.world.step(this.eventQueue);
    } catch (e) {
      console.warn("Error running physics step", e);
    }
    this._isUpdatingPhysicsWorld = false;
  }
  postStep() {
    if (!this.world)
      return;
    if (!this.enabled)
      return;
    this._isUpdatingPhysicsWorld = true;
    this.syncObjects();
    this._isUpdatingPhysicsWorld = false;
    if (this.eventQueue && !this.collisionHandler) {
      this.collisionHandler = new PhysicsCollisionHandler(this.world, this.eventQueue);
    }
    if (this.collisionHandler) {
      this.collisionHandler.handleCollisionEvents();
      this.collisionHandler.update();
    }
    this.updateDebugRendering(this.world);
  }
  updateDebugRendering(world) {
    var _a2, _b, _c, _d;
    if (debugPhysics || debugColliderPlacement || showColliders || this.debugRenderColliders === true) {
      if (!this.lines) {
        const material = new LineBasicMaterial({
          color: 7855479,
          fog: false
          // vertexColors: VertexColors
        });
        const geometry = new BufferGeometry();
        this.lines = new LineSegments(geometry, material);
        this.lines.layers.disableAll();
        this.lines.layers.enable(2);
      }
      if (this.lines.parent !== ((_a2 = this.context) == null ? void 0 : _a2.scene))
        (_b = this.context) == null ? void 0 : _b.scene.add(this.lines);
      const buffers = world.debugRender();
      this.lines.geometry.setAttribute("position", new BufferAttribute(buffers.vertices, 3));
      this.lines.geometry.setAttribute("color", new BufferAttribute(buffers.colors, 4));
      if (this.context.time.frame % 30 === 0 || ((_c = this.lines.geometry.boundingSphere) == null ? void 0 : _c.radius) === 0) {
        this.lines.geometry.computeBoundingSphere();
      }
    } else {
      if (this.lines) {
        (_d = this.context) == null ? void 0 : _d.scene.remove(this.lines);
      }
    }
  }
  /** sync rendered objects with physics world (except for colliders without rigidbody) */
  syncObjects() {
    if (debugColliderPlacement)
      return;
    for (let i = 0; i < this.bodies.length; i++) {
      const obj = this.objects[i];
      const body = this.bodies[i];
      const col = obj;
      if ((col == null ? void 0 : col.isCollider) === true && !col.attachedRigidbody) {
        const rigidbody = body.parent();
        if (rigidbody)
          this.syncPhysicsBody(obj.gameObject, rigidbody, true, true);
        else
          this.syncPhysicsBody(obj.gameObject, body, true, true);
        continue;
      }
      const pos = body.translation();
      const rot = body.rotation();
      if (Number.isNaN(pos.x) || Number.isNaN(rot.x)) {
        if (!col["__COLLIDER_NAN"] && isDevEnvironment()) {
          console.warn("Collider has NaN values", col.name, col.gameObject, body);
          col["__COLLIDER_NAN"] = true;
        }
        continue;
      }
      const center = obj["center"];
      if (center && center.isVector3) {
        this._tempQuaternion.set(rot.x, rot.y, rot.z, rot.w);
        const offset = this._tempPosition.copy(center).applyQuaternion(this._tempQuaternion);
        const scale = getWorldScale(obj.gameObject);
        offset.multiply(scale);
        pos.x -= offset.x;
        pos.y -= offset.y;
        pos.z -= offset.z;
      }
      setWorldPositionXYZ(obj.gameObject, pos.x, pos.y, pos.z);
      setWorldQuaternionXYZW(obj.gameObject, rot.x, rot.y, rot.z, rot.w);
    }
  }
  syncPhysicsBody(obj, body, translation, rotation) {
    if (body instanceof MODULES.RAPIER_PHYSICS.MODULE.RigidBody) {
      const worldPosition = getWorldPosition(obj, this._tempPosition);
      const worldQuaternion = getWorldQuaternion(obj, this._tempQuaternion);
      const type = body.bodyType();
      switch (type) {
        case MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.Fixed:
        case MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased:
        case MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicVelocityBased:
          if (translation)
            body.setNextKinematicTranslation(worldPosition);
          if (rotation)
            body.setNextKinematicRotation(worldQuaternion);
          break;
        default:
          if (translation)
            body.setTranslation(worldPosition, false);
          if (rotation)
            body.setRotation(worldQuaternion, false);
          break;
      }
    } else if (body instanceof MODULES.RAPIER_PHYSICS.MODULE.Collider) {
      if (obj.matrixWorldNeedsUpdate) {
        obj.updateWorldMatrix(true, false);
      }
      obj.matrixWorld.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
      const wp = this._tempPosition;
      const wq = this._tempQuaternion;
      const collider = body[$componentKey];
      this.tryApplyCenter(collider, wp);
      if (translation) {
        const ct = body.translation();
        if (ct.x !== wp.x || ct.y !== wp.y || ct.z !== wp.z)
          body.setTranslation(wp);
      }
      if (rotation) {
        const cr = body.rotation();
        if (cr.x !== wq.x || cr.y !== wq.y || cr.z !== wq.z || cr.w !== wq.w)
          body.setRotation(wq);
      }
    }
  }
  tryApplyCenter(collider, targetVector) {
    const center = collider.center;
    if (center && collider.gameObject) {
      if (center.x !== 0 || center.y !== 0 || center.z !== 0) {
        this._tempCenterPos.x = center.x;
        this._tempCenterPos.y = center.y;
        this._tempCenterPos.z = center.z;
        getWorldScale(collider.gameObject, this._tempCenterVec);
        this._tempCenterPos.multiply(this._tempCenterVec);
        if (!collider.attachedRigidbody) {
          getWorldQuaternion(collider.gameObject, this._tempCenterQuaternion);
          this._tempCenterPos.applyQuaternion(this._tempCenterQuaternion);
        } else {
          this._tempCenterPos.applyQuaternion(collider.gameObject.quaternion);
        }
        targetVector.x += this._tempCenterPos.x;
        targetVector.y += this._tempCenterPos.y;
        targetVector.z += this._tempCenterPos.z;
      }
    }
  }
  getRigidbodyRelativeMatrix(comp, rigidbody, mat, matrices) {
    if (matrices === void 0) {
      matrices = _RapierPhysics._matricesBuffer;
      matrices.length = 0;
    }
    if (comp === rigidbody) {
      const scale = getWorldScale(comp, this._tempPosition);
      mat.makeScale(scale.x, scale.y, scale.z);
      for (let i = matrices.length - 1; i >= 0; i--) {
        mat.multiply(matrices[i]);
      }
      return mat;
    }
    matrices.push(comp.matrix);
    if (comp.parent) {
      this.getRigidbodyRelativeMatrix(comp.parent, rigidbody, mat, matrices);
    }
    return mat;
  }
  addFixedJoint(body1, body2) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const b1 = body1[$bodyKey];
    const b2 = body2[$bodyKey];
    this.calculateJointRelativeMatrices(body1.gameObject, body2.gameObject, this._tempMatrix);
    this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const params = MODULES.RAPIER_PHYSICS.MODULE.JointData.fixed(_RapierPhysics.centerConnectionPos, _RapierPhysics.centerConnectionRot, this._tempPosition, this._tempQuaternion);
    const joint = this.world.createImpulseJoint(params, b1, b2, true);
    if (debugPhysics)
      console.log("ADD FIXED JOINT", joint);
  }
  /** The joint prevents any relative movement between two rigid-bodies, except for relative rotations along one axis. This is typically used to simulate wheels, fans, etc. They are characterized by one local anchor as well as one local axis on each rigid-body. */
  addHingeJoint(body1, body2, anchor, axis) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const b1 = body1[$bodyKey];
    const b2 = body2[$bodyKey];
    this.calculateJointRelativeMatrices(body1.gameObject, body2.gameObject, this._tempMatrix);
    this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const params = MODULES.RAPIER_PHYSICS.MODULE.JointData.revolute(anchor, this._tempPosition, axis);
    const joint = this.world.createImpulseJoint(params, b1, b2, true);
    if (debugPhysics)
      console.log("ADD HINGE JOINT", joint);
  }
  calculateJointRelativeMatrices(body1, body2, mat) {
    body1.updateWorldMatrix(true, false);
    body2.updateWorldMatrix(true, false);
    const world1 = body1.matrixWorld;
    const world2 = body2.matrixWorld;
    world1.elements[0] = 1;
    world1.elements[5] = 1;
    world1.elements[10] = 1;
    world2.elements[0] = 1;
    world2.elements[5] = 1;
    world2.elements[10] = 1;
    mat.copy(world2).premultiply(world1.invert()).invert();
  }
};
var RapierPhysics = _RapierPhysics;
__publicField(RapierPhysics, "_didLoadPhysicsEngine", false);
__publicField(RapierPhysics, "_matricesBuffer", []);
__publicField(RapierPhysics, "centerConnectionPos", { x: 0, y: 0, z: 0 });
__publicField(RapierPhysics, "centerConnectionRot", { x: 0, y: 0, z: 0, w: 1 });
var PhysicsCollisionHandler = class {
  constructor(world, eventQueue) {
    __publicField(this, "world");
    __publicField(this, "eventQueue");
    __publicField(this, "activeCollisions", []);
    __publicField(this, "activeCollisionsStay", []);
    __publicField(this, "activeTriggers", []);
    this.world = world;
    this.eventQueue = eventQueue;
  }
  handleCollisionEvents() {
    if (!this.eventQueue)
      return;
    if (!this.world)
      return;
    this.eventQueue.drainCollisionEvents((handle1, handle2, started) => {
      const col1 = this.world.getCollider(handle1);
      const col2 = this.world.getCollider(handle2);
      if (!col1 || !col2)
        return;
      const colliderComponent1 = col1[$componentKey];
      const colliderComponent2 = col2[$componentKey];
      if (debugCollisions)
        console.log("EVT", colliderComponent1.name, colliderComponent2.name, started, col1, col2);
      if (colliderComponent1 && colliderComponent2) {
        if (started) {
          this.onCollisionStarted(colliderComponent1, col1, colliderComponent2, col2);
          this.onCollisionStarted(colliderComponent2, col2, colliderComponent1, col1);
        } else {
          this.onCollisionEnded(colliderComponent1, colliderComponent2);
          this.onCollisionEnded(colliderComponent2, colliderComponent1);
        }
      }
    });
  }
  update() {
    this.onHandleCollisionStay();
  }
  onCollisionStarted(self, selfBody, other, otherBody) {
    let collision = null;
    if (self.isTrigger || other.isTrigger) {
      foreachComponent(self.gameObject, (c) => {
        if (c.onTriggerEnter && !c.destroyed) {
          c.onTriggerEnter(other);
        }
        this.activeTriggers.push({ collider: self, component: c, otherCollider: other });
      });
    } else {
      const object = self.gameObject;
      this.world.contactPair(selfBody, otherBody, (manifold, _flipped) => {
        foreachComponent(object, (c) => {
          var _a2;
          if (c.destroyed)
            return;
          const hasDeclaredEventMethod = c.onCollisionEnter || c.onCollisionStay || c.onCollisionExit;
          if (hasDeclaredEventMethod || debugCollisions) {
            if (!collision) {
              const contacts = [];
              const normal = manifold.normal();
              if (other instanceof MeshCollider && other.convex) {
                normal.x = -normal.x;
                normal.y = -normal.y;
                normal.z = -normal.z;
              }
              for (let i = 0; i < manifold.numSolverContacts(); i++) {
                const pt = manifold.solverContactPoint(i);
                const impulse = manifold.contactImpulse(i);
                if (pt) {
                  const dist = manifold.contactDist(i);
                  const friction = manifold.solverContactFriction(i);
                  const tangentVelocity = manifold.solverContactTangentVelocity(i);
                  const contact = new ContactPoint(pt, dist, normal, impulse, friction, tangentVelocity);
                  contacts.push(contact);
                  if (debugCollisions) {
                    Gizmos.DrawDirection(pt, normal, 16711680, 3, true);
                  }
                }
              }
              collision = new Collision(object, other, contacts);
            }
            if (hasDeclaredEventMethod) {
              const info = { collider: self, component: c, collision };
              this.activeCollisions.push(info);
              if (c.onCollisionStay) {
                this.activeCollisionsStay.push(info);
              }
              (_a2 = c.onCollisionEnter) == null ? void 0 : _a2.call(c, collision);
            }
          }
        });
      });
    }
  }
  onHandleCollisionStay() {
    for (const active of this.activeCollisionsStay) {
      const c = active.component;
      if (c.destroyed)
        continue;
      if (c.activeAndEnabled && c.onCollisionStay) {
        if (active.collision.collider.destroyed)
          continue;
        const arg = active.collision;
        c.onCollisionStay(arg);
      }
    }
    for (const active of this.activeTriggers) {
      const c = active.component;
      if (c.destroyed)
        continue;
      if (c.activeAndEnabled && c.onTriggerStay) {
        const arg = active.otherCollider;
        if (arg.destroyed)
          continue;
        c.onTriggerStay(arg);
      }
    }
  }
  onCollisionEnded(self, other) {
    if (self.destroyed || other.destroyed)
      return;
    for (let i = 0; i < this.activeCollisions.length; i++) {
      const active = this.activeCollisions[i];
      const collider = active.collider;
      if (collider.destroyed || active.collision.collider.destroyed) {
        this.activeCollisions.splice(i, 1);
        i--;
        continue;
      }
      if (collider === self && active.collision.collider === other) {
        const c = active.component;
        this.activeCollisions.splice(i, 1);
        i--;
        if (c.activeAndEnabled && c.onCollisionExit) {
          const collision = active.collision;
          c.onCollisionExit(collision);
        }
      }
    }
    for (let i = 0; i < this.activeCollisionsStay.length; i++) {
      const active = this.activeCollisionsStay[i];
      const collider = active.collider;
      if (collider.destroyed || active.collision.collider.destroyed) {
        this.activeCollisionsStay.splice(i, 1);
        i--;
        continue;
      }
      if (collider === self && active.collision.collider === other) {
        const c = active.component;
        this.activeCollisionsStay.splice(i, 1);
        i--;
        if (c.activeAndEnabled && c.onCollisionExit) {
          const collision = active.collision;
          c.onCollisionExit(collision);
        }
      }
    }
    for (let i = 0; i < this.activeTriggers.length; i++) {
      const active = this.activeTriggers[i];
      const collider = active.collider;
      if (collider.destroyed || active.otherCollider.destroyed) {
        this.activeTriggers.splice(i, 1);
        i--;
        continue;
      }
      if (collider === self && active.otherCollider === other) {
        const c = active.component;
        this.activeTriggers.splice(i, 1);
        i--;
        if (c.activeAndEnabled && c.onTriggerExit) {
          const collision = active.otherCollider;
          c.onTriggerExit(collision);
        }
      }
    }
  }
};

// node_modules/@needle-tools/engine/lib/engine/engine_test_utils.js
var TestSceneUtils = class {
  /**
   * Use this method to quickly setup a scene to compare multiple models.
   * @example
   * ```ts
   * const files = [
   *    "https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb",
   *   "https://threejs.org/examples/models/gltf/Lantern/glTF-Binary/Lantern.glb",
   * ];
   * const { scene, camera } = await TestUtils.createComparisonScene({ files });
   * // this could now be assigned to the Needle Engine Context
   * context.scene = scene;
   * context.mainCamera = camera;
   * ```
   */
  static async createComparisonScene(opts) {
    const { files } = opts;
    const promises = Promise.all(files.map((file) => new AssetReference(file).loadAssetAsync()));
    const results = await promises;
    const scene = new Scene();
    let offset = 0;
    for (const result of results) {
      if (result instanceof Object3D) {
        result.position.y = offset;
        scene.add(result);
        const box2 = getBoundingBox([result]);
        offset += box2.getSize(new Vector3()).y;
        offset += 0.1;
      }
    }
    const camera = new PerspectiveCamera(20);
    scene.add(camera);
    const environmentUrl = opts.environment || "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/studio_small_09_1k.exr";
    if (environmentUrl) {
      let loader = null;
      if (environmentUrl.endsWith(".hdr")) {
        const RGBELoader = (await import("./RGBELoader-DJWU3WUR.js")).RGBELoader;
        loader = new RGBELoader();
      } else if (environmentUrl.endsWith(".exr")) {
        const EXRLoader = (await import("./EXRLoader-W2KTV3QX.js")).EXRLoader;
        loader = new EXRLoader();
      }
      if (loader) {
        const envmap = await loader.loadAsync(environmentUrl).catch((e) => {
          console.error(e);
          return null;
        });
        if (envmap) {
          envmap.mapping = EquirectangularReflectionMapping;
          envmap.needsUpdate = true;
          scene.background = envmap;
          scene.environment = envmap;
          scene.backgroundBlurriness = 0.75;
        }
      } else
        console.warn("Unsupported environment map format", environmentUrl);
    }
    const box = getBoundingBox(scene.children);
    const center = box.getCenter(new Vector3());
    const size = box.getSize(new Vector3());
    const max = Math.max(size.x, size.y, size.z);
    const distance = max / (2 * Math.tan(Math.PI * camera.fov / 360));
    camera.position.set(center.x, center.y, distance);
    camera.lookAt(center);
    const orbit = new OrbitControls(camera, opts.domElement || document.body);
    orbit.target = center;
    orbit.update();
    const element = (opts.domElement || document.body).getBoundingClientRect();
    camera.aspect = element.width / element.height;
    camera.updateProjectionMatrix();
    return {
      scene,
      camera
    };
  }
};

// node_modules/@needle-tools/engine/lib/engine/export/state.js
var exportingStack = 0;
function __isExporting(state) {
  if (state) {
    exportingStack++;
  } else {
    exportingStack--;
  }
}
function isExporting() {
  return exportingStack > 0;
}

// node_modules/@needle-tools/engine/lib/engine/export/gltf/index.js
var DEFAULT_OPTIONS = {
  binary: true,
  animations: true
};
async function exportAsGLTF(_opts) {
  if (!_opts.context) {
    throw new Error("No context provided to exportAsGLTF");
  }
  if (!_opts.scene) {
    _opts.scene = _opts.context.scene;
  }
  const opts = {
    ...DEFAULT_OPTIONS,
    ..._opts
  };
  const { context } = opts;
  const exporter = new GLTFExporter();
  exporter.register((writer) => new GLTFMeshGPUInstancingExtension(writer));
  exporter.register((writer) => new GizmoWriter(writer));
  exporter.register((writer) => new RenderTextureWriter(writer));
  registerExportExtensions(exporter, opts.context);
  const exporterOptions = {
    binary: opts.binary,
    animations: collectAnimations(context, opts.scene, [])
  };
  const state = new ExporterState();
  console.debug("Exporting GLTF", exporterOptions);
  state.onBeforeExport(opts);
  __isExporting(true);
  const res = await exporter.parseAsync(opts.scene, exporterOptions).catch((e) => {
    console.error(e);
    return null;
  });
  __isExporting(false);
  state.onAfterExport(opts);
  if (!res) {
    throw new Error("Failed to export GLTF");
  }
  if (opts.downloadAs != void 0) {
    let blob = null;
    if (res instanceof ArrayBuffer) {
      blob = new Blob([res], { type: "application/octet-stream" });
    } else {
      console.error("Can not download GLTF as a blob", res);
    }
    if (blob) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      let name = opts.downloadAs;
      if (!name.endsWith(".glb") && !name.endsWith(".gltf")) {
        name += opts.binary ? ".glb" : ".gltf";
      }
      a.download = name;
      a.click();
    }
  }
  return res;
}
var ACTIONS_WEIGHT_KEY = Symbol("needle:weight");
var ExporterState = class {
  constructor() {
    __publicField(this, "_undo", []);
  }
  onBeforeExport(opts) {
    opts.context.animations.mixers.forEach((mixer) => {
      const actions = AnimationUtils.tryGetActionsFromMixer(mixer);
      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const action = actions[i];
          action[ACTIONS_WEIGHT_KEY] = action.weight;
          action.weight = 0;
          this._undo.push(() => {
            action.weight = action[ACTIONS_WEIGHT_KEY];
          });
        }
      }
      mixer.update(0);
    });
    opts.context.scene.traverse((obj) => {
      if (!shouldExport_HideFlags(obj)) {
        const parent = obj.parent;
        if (parent) {
          obj.removeFromParent();
          this._undo.push(() => parent.add(obj));
        }
      }
    });
  }
  onAfterExport(_opts) {
    this._undo.forEach((fn) => fn());
    this._undo.length = 0;
  }
};
function collectAnimations(context, scene, clips) {
  context.animations.mixers.forEach((mixer) => {
    const actions = AnimationUtils.tryGetActionsFromMixer(mixer);
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const action = actions[i];
        const clip = action.getClip();
        clips.push(clip);
      }
    }
  });
  if (!Array.isArray(scene))
    scene = [scene];
  for (const obj of scene) {
    AnimationUtils.tryGetAnimationClipsFromObjectHierarchy(obj, clips);
  }
  const uniqueClips = new Set(clips);
  return Array.from(uniqueClips);
}

// node_modules/@needle-tools/engine/lib/engine/webcomponents/needle-button.js
var htmlTagName = "needle-button";
var isDev = isDevEnvironment();
var _root, _slot, _styles, _button, _webxrfactory, _observer, _update, update_fn, _updateVisibility, updateVisibility_fn, _onclick;
var NeedleButtonElement = class extends HTMLElement {
  constructor() {
    super();
    __privateAdd(this, _update);
    __privateAdd(this, _updateVisibility);
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _slot, void 0);
    /** These are the default styles that can be overridden by the user from the outside by styling <needle-button> */
    __privateAdd(this, _styles, void 0);
    /** This is the button that was generated using one of the factories */
    __privateAdd(this, _button, void 0);
    /** If AR or VR is requested we create and use the webxr button factory to create a button with default behaviour */
    __privateAdd(this, _webxrfactory, void 0);
    __privateAdd(this, _observer, void 0);
    __privateAdd(this, _onclick, (_ev) => {
      if (isDev) {
        console.log("Needle Button clicked");
      }
      if (_ev.defaultPrevented)
        return;
      if (__privateGet(this, _button)) {
        __privateGet(this, _button).click();
      }
    });
    this.removeEventListener("click", __privateGet(this, _onclick));
    this.addEventListener("click", __privateGet(this, _onclick));
  }
  attributeChangedCallback(_name, _oldValue, _newValue) {
    __privateMethod(this, _update, update_fn).call(this);
  }
};
_root = new WeakMap();
_slot = new WeakMap();
_styles = new WeakMap();
_button = new WeakMap();
_webxrfactory = new WeakMap();
_observer = new WeakMap();
_update = new WeakSet();
update_fn = function() {
  var _a2, _b;
  (_a2 = __privateGet(this, _button)) == null ? void 0 : _a2.remove();
  if (this.getAttribute("ar") != null) {
    __privateGet(this, _webxrfactory) ?? __privateSet(this, _webxrfactory, new WebXRButtonFactory());
    __privateSet(this, _button, __privateGet(this, _webxrfactory).createARButton());
  } else if (this.getAttribute("vr") != null) {
    __privateGet(this, _webxrfactory) ?? __privateSet(this, _webxrfactory, new WebXRButtonFactory());
    __privateSet(this, _button, __privateGet(this, _webxrfactory).createVRButton());
  } else if (this.getAttribute("quicklook") != null) {
    __privateGet(this, _webxrfactory) ?? __privateSet(this, _webxrfactory, new WebXRButtonFactory());
    __privateSet(this, _button, __privateGet(this, _webxrfactory).createQuicklookButton());
  } else {
    if (isDev) {
      console.warn("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.");
    } else {
      console.debug("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.");
    }
    return;
  }
  __privateGet(this, _root) ?? __privateSet(this, _root, this.attachShadow({ mode: "open" }));
  __privateGet(this, _slot) ?? __privateSet(this, _slot, document.createElement("slot"));
  __privateGet(this, _styles) ?? __privateSet(this, _styles, document.createElement("style"));
  __privateGet(this, _styles).innerHTML = `
            button {
                all: initial;
                cursor: inherit;
                color: inherit;
                font-family: inherit;
                gap: inherit;
                white-space: nowrap;
            }
        `;
  const hasUnstyledAttribute = this.getAttribute("unstyled") != void 0;
  if (!hasUnstyledAttribute) {
    __privateGet(this, _styles).innerHTML += `
            :host {
                display: inline-block;
                background: rgba(255, 255, 255, .8);
                backdrop-filter: blur(10px);
                width: fit-content;
                transition: background .2s;

                cursor: pointer;
                padding: 0.4rem .5rem;
                border-radius: 0.8rem;
                color: black;
                background: rgba(245, 245, 245, .8);
                outline: rgba(0,0,0,.05) 1px solid;
            }
            :host(:hover) {
                background: rgba(255, 255, 255, 1);
                transition: background .2s;
            }
            slot {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: .5rem;
            }
`;
  }
  __privateGet(this, _slot).innerHTML = __privateGet(this, _button).innerHTML;
  __privateGet(this, _slot).style.cssText = `display: flex; align-items: center; justify-content: center;`;
  __privateGet(this, _button).innerHTML = __privateGet(this, _slot).outerHTML;
  __privateGet(this, _root).innerHTML = __privateGet(this, _button).outerHTML;
  __privateGet(this, _root).prepend(__privateGet(this, _styles));
  loadFont(iconFontUrl, { element: __privateGet(this, _root) });
  (_b = __privateGet(this, _observer)) == null ? void 0 : _b.disconnect();
  __privateGet(this, _observer) ?? __privateSet(this, _observer, new MutationObserver(() => __privateMethod(this, _updateVisibility, updateVisibility_fn).call(this)));
  __privateGet(this, _observer).observe(__privateGet(this, _button), { attributes: true });
  if (isDev) {
    console.log("Needle Button updated");
  }
};
_updateVisibility = new WeakSet();
updateVisibility_fn = function() {
  if (__privateGet(this, _button)) {
    if (__privateGet(this, _button).style.display === "none") {
      this.style.display = "none";
    } else if (this.style.display === "none") {
      this.style.display = "";
    }
  }
};
_onclick = new WeakMap();
__publicField(NeedleButtonElement, "observedAttributes", ["ar", "vr", "quicklook"]);
if (typeof window !== "undefined" && !window.customElements.get(htmlTagName))
  window.customElements.define(htmlTagName, NeedleButtonElement);

// node_modules/@needle-tools/engine/lib/engine-components/codegen/components.js
var components_exports = {};
__export(components_exports, {
  ActionBuilder: () => ActionBuilder,
  ActionCollection: () => ActionCollection,
  ActionModel: () => ActionModel,
  AlignmentConstraint: () => AlignmentConstraint,
  Animation: () => Animation,
  AnimationCurve: () => AnimationCurve,
  AnimationExtension: () => AnimationExtension,
  AnimationTrackHandler: () => AnimationTrackHandler,
  Animator: () => Animator,
  AnimatorController: () => AnimatorController,
  Antialiasing: () => Antialiasing,
  AudioExtension: () => AudioExtension,
  AudioListener: () => AudioListener,
  AudioSource: () => AudioSource,
  AudioTrackHandler: () => AudioTrackHandler,
  Avatar: () => Avatar,
  AvatarBlink_Simple: () => AvatarBlink_Simple,
  AvatarEyeLook_Rotation: () => AvatarEyeLook_Rotation,
  AvatarLoader: () => AvatarLoader,
  AvatarMarker: () => AvatarMarker,
  AvatarModel: () => AvatarModel,
  Avatar_Brain_LookAt: () => Avatar_Brain_LookAt,
  Avatar_MouthShapes: () => Avatar_MouthShapes,
  Avatar_MustacheShake: () => Avatar_MustacheShake,
  Avatar_POI: () => Avatar_POI,
  AxesHelper: () => AxesHelper,
  BaseUIComponent: () => BaseUIComponent,
  BasicIKConstraint: () => BasicIKConstraint,
  BehaviorExtension: () => BehaviorExtension,
  BehaviorModel: () => BehaviorModel,
  BloomEffect: () => BloomEffect,
  BoxCollider: () => BoxCollider,
  BoxGizmo: () => BoxGizmo,
  BoxHelperComponent: () => BoxHelperComponent,
  Button: () => Button,
  CallInfo: () => CallInfo,
  Camera: () => Camera,
  CameraTargetReachedEvent: () => CameraTargetReachedEvent,
  Canvas: () => Canvas,
  CanvasGroup: () => CanvasGroup,
  CapsuleCollider: () => CapsuleCollider,
  ChangeMaterialOnClick: () => ChangeMaterialOnClick,
  ChangeTransformOnClick: () => ChangeTransformOnClick,
  CharacterController: () => CharacterController,
  CharacterControllerInput: () => CharacterControllerInput,
  ChromaticAberration: () => ChromaticAberration,
  Collider: () => Collider,
  ColorAdjustments: () => ColorAdjustments,
  ColorBySpeedModule: () => ColorBySpeedModule,
  ColorOverLifetimeModule: () => ColorOverLifetimeModule,
  ContactShadows: () => ContactShadows,
  ControlTrackHandler: () => ControlTrackHandler,
  CustomBranding: () => CustomBranding,
  Deletable: () => Deletable,
  DeleteBox: () => DeleteBox,
  DepthOfField: () => DepthOfField,
  DeviceFlag: () => DeviceFlag,
  DocumentExtension: () => DocumentExtension,
  DragControls: () => DragControls,
  DropListener: () => DropListener,
  Duplicatable: () => Duplicatable,
  EffectWrapper: () => EffectWrapper,
  EmissionModule: () => EmissionModule,
  EmphasizeOnClick: () => EmphasizeOnClick,
  EventList: () => EventList,
  EventListEvent: () => EventListEvent,
  EventSystem: () => EventSystem,
  EventTrigger: () => EventTrigger,
  FieldWithDefault: () => FieldWithDefault,
  FixedJoint: () => FixedJoint,
  Fog: () => Fog,
  GltfExport: () => GltfExport,
  GltfExportBox: () => GltfExportBox,
  Gradient: () => Gradient,
  Graphic: () => Graphic,
  GraphicRaycaster: () => GraphicRaycaster,
  GridHelper: () => GridHelper,
  GridLayoutGroup: () => GridLayoutGroup,
  GroundProjectedEnv: () => GroundProjectedEnv,
  GroupActionModel: () => GroupActionModel,
  HideOnStart: () => HideOnStart,
  HingeJoint: () => HingeJoint,
  HorizontalLayoutGroup: () => HorizontalLayoutGroup,
  Image: () => Image,
  InheritVelocityModule: () => InheritVelocityModule,
  InputField: () => InputField,
  InstanceHandle: () => InstanceHandle,
  InstancingHandler: () => InstancingHandler,
  Interactable: () => Interactable,
  Keyframe: () => Keyframe,
  LODGroup: () => LODGroup,
  LODModel: () => LODModel,
  Light: () => Light,
  LimitVelocityOverLifetimeModule: () => LimitVelocityOverLifetimeModule,
  LogStats: () => LogStats,
  LookAt: () => LookAt,
  LookAtConstraint: () => LookAtConstraint,
  MainModule: () => MainModule,
  MaskableGraphic: () => MaskableGraphic,
  MeshCollider: () => MeshCollider,
  MeshRenderer: () => MeshRenderer,
  MinMaxCurve: () => MinMaxCurve,
  MinMaxGradient: () => MinMaxGradient,
  NeedleMenu: () => NeedleMenu,
  NestedGltf: () => NestedGltf,
  Networking: () => Networking,
  NoiseModule: () => NoiseModule,
  ObjectRaycaster: () => ObjectRaycaster,
  OffsetConstraint: () => OffsetConstraint,
  OpenURL: () => OpenURL,
  OrbitControls: () => OrbitControls2,
  Outline: () => Outline,
  Padding: () => Padding,
  ParticleBurst: () => ParticleBurst,
  ParticleSubEmitter: () => ParticleSubEmitter,
  ParticleSystem: () => ParticleSystem,
  ParticleSystemRenderer: () => ParticleSystemRenderer,
  PhysicsExtension: () => PhysicsExtension,
  PixelationEffect: () => PixelationEffect,
  PlayAnimationOnClick: () => PlayAnimationOnClick,
  PlayAudioOnClick: () => PlayAudioOnClick,
  PlayableDirector: () => PlayableDirector,
  PlayerColor: () => PlayerColor,
  PointerEventData: () => PointerEventData,
  PostProcessingHandler: () => PostProcessingHandler,
  PreliminaryAction: () => PreliminaryAction,
  PreliminaryTrigger: () => PreliminaryTrigger,
  RawImage: () => RawImage,
  Rect: () => Rect,
  RectTransform: () => RectTransform,
  ReflectionProbe: () => ReflectionProbe,
  RegisteredAnimationInfo: () => RegisteredAnimationInfo,
  RemoteSkybox: () => RemoteSkybox,
  Renderer: () => Renderer,
  RendererLightmap: () => RendererLightmap,
  Rigidbody: () => Rigidbody,
  RotationBySpeedModule: () => RotationBySpeedModule,
  RotationOverLifetimeModule: () => RotationOverLifetimeModule,
  SceneSwitcher: () => SceneSwitcher,
  ScreenCapture: () => ScreenCapture,
  ScreenSpaceAmbientOcclusion: () => ScreenSpaceAmbientOcclusion,
  ScreenSpaceAmbientOcclusionN8: () => ScreenSpaceAmbientOcclusionN8,
  SetActiveOnClick: () => SetActiveOnClick,
  ShadowCatcher: () => ShadowCatcher,
  ShapeModule: () => ShapeModule,
  SharpeningEffect: () => SharpeningEffect,
  SignalAsset: () => SignalAsset,
  SignalReceiver: () => SignalReceiver,
  SignalReceiverEvent: () => SignalReceiverEvent,
  SignalTrackHandler: () => SignalTrackHandler,
  Size: () => Size,
  SizeBySpeedModule: () => SizeBySpeedModule,
  SizeOverLifetimeModule: () => SizeOverLifetimeModule,
  SkinnedMeshRenderer: () => SkinnedMeshRenderer,
  SmoothFollow: () => SmoothFollow,
  SpatialGrabRaycaster: () => SpatialGrabRaycaster,
  SpatialHtml: () => SpatialHtml,
  SpatialTrigger: () => SpatialTrigger,
  SpatialTriggerReceiver: () => SpatialTriggerReceiver,
  SpectatorCamera: () => SpectatorCamera,
  SphereCollider: () => SphereCollider,
  Sprite: () => Sprite,
  SpriteData: () => SpriteData,
  SpriteRenderer: () => SpriteRenderer,
  SpriteSheet: () => SpriteSheet,
  SubEmitterSystem: () => SubEmitterSystem,
  SyncedCamera: () => SyncedCamera,
  SyncedRoom: () => SyncedRoom,
  SyncedTransform: () => SyncedTransform,
  TapGestureTrigger: () => TapGestureTrigger,
  TeleportTarget: () => TeleportTarget,
  TestRunner: () => TestRunner,
  TestSimulateUserData: () => TestSimulateUserData,
  Text: () => Text,
  TextBuilder: () => TextBuilder,
  TextExtension: () => TextExtension,
  TextureSheetAnimationModule: () => TextureSheetAnimationModule,
  TiltShiftEffect: () => TiltShiftEffect,
  ToneMappingEffect: () => ToneMappingEffect,
  TrailModule: () => TrailModule,
  TransformData: () => TransformData,
  TransformGizmo: () => TransformGizmo,
  TriggerBuilder: () => TriggerBuilder,
  TriggerModel: () => TriggerModel,
  UIRaycastUtils: () => UIRaycastUtils,
  UIRootComponent: () => UIRootComponent,
  USDZExporter: () => USDZExporter2,
  USDZText: () => USDZText,
  USDZUIExtension: () => USDZUIExtension,
  UsageMarker: () => UsageMarker,
  VariantAction: () => VariantAction,
  VelocityOverLifetimeModule: () => VelocityOverLifetimeModule,
  VerticalLayoutGroup: () => VerticalLayoutGroup,
  VideoPlayer: () => VideoPlayer,
  Vignette: () => Vignette,
  VisibilityAction: () => VisibilityAction,
  Voip: () => Voip,
  Volume: () => Volume,
  VolumeParameter: () => VolumeParameter,
  VolumeProfile: () => VolumeProfile,
  WebARCameraBackground: () => WebARCameraBackground,
  WebARSessionRoot: () => WebARSessionRoot,
  WebXR: () => WebXR,
  WebXRImageTracking: () => WebXRImageTracking,
  WebXRImageTrackingModel: () => WebXRImageTrackingModel,
  WebXRPlaneTracking: () => WebXRPlaneTracking,
  WebXRTrackedImage: () => WebXRTrackedImage,
  XRControllerFollow: () => XRControllerFollow,
  XRControllerModel: () => XRControllerModel,
  XRControllerMovement: () => XRControllerMovement,
  XRFlag: () => XRFlag,
  XRRig: () => XRRig,
  XRState: () => XRState,
  __Ignore: () => __Ignore
});

// node_modules/@needle-tools/engine/lib/engine-components/AvatarLoader.js
var debug2 = getParam("debugavatar");
var AvatarModel = class {
  /**
   * Creates a new avatar model.
   * @param root The root object of the avatar
   * @param head The head object of the avatar
   * @param leftHand The left hand object of the avatar
   * @param rigthHand The right hand object of the avatar
   */
  constructor(root, head, leftHand, rigthHand) {
    /** The root object of the avatar model */
    __publicField(this, "root");
    /** The head object of the avatar model */
    __publicField(this, "head");
    /** The left hand object of the avatar model, if available */
    __publicField(this, "leftHand");
    /** The right hand object of the avatar model, if available */
    __publicField(this, "rigthHand");
    var _a2;
    this.root = root;
    this.head = head;
    this.leftHand = leftHand;
    this.rigthHand = rigthHand;
    (_a2 = this.root) == null ? void 0 : _a2.traverse((h) => h.layers.set(2));
  }
  /**
   * Checks if the avatar model has a valid configuration.
   * An avatar is considered valid if it has a head.
   * @returns Whether the avatar has a valid setup
   */
  get isValid() {
    return this.head !== null && this.head !== void 0;
  }
};
var AvatarLoader = class {
  constructor() {
    __publicField(this, "avatarRegistryUrl", null);
  }
  // private loader: GLTFLoader | null;
  // private avatarModelCache: Map<string, AvatarModel | null> = new Map<string, AvatarModel | null>();
  /**
   * Retrieves or creates a new avatar instance from an ID or existing Object3D.
   * @param context The application context
   * @param avatarId Either a string ID to load an avatar or an existing Object3D to use as avatar
   * @returns Promise resolving to an AvatarModel if successful, or null if failed
   */
  async getOrCreateNewAvatarInstance(context, avatarId) {
    if (!avatarId) {
      console.error("Can not create avatar: failed to provide id or root object");
      return null;
    }
    let root = null;
    if (typeof avatarId === "string") {
      root = await this.loadAvatar(context, avatarId);
      if (!root) {
        const opts = new InstantiateOptions();
        root = GameObject.instantiate(tryFindObject(avatarId, context.scene), opts);
      }
    } else
      root = avatarId;
    if (!root) {
      return null;
    }
    const model = this.findAvatar(root);
    if (model.isValid) {
      if (debug2)
        console.log("[Custom Avatar] valid config", avatarId, debug2 ? model : "");
      return model;
    } else {
      console.warn("[Custom Avatar] config isn't valid", avatarId, debug2 ? model : "");
      return null;
    }
  }
  /**
   * Loads an avatar model from a file or registry using the provided ID.
   * @param context The engine context
   * @param avatarId The ID of the avatar to load
   * @returns Promise resolving to the loaded avatar's Object3D, or null if failed
   */
  async loadAvatar(context, avatarId) {
    console.assert(avatarId !== void 0 && avatarId !== null && typeof avatarId === "string", "Avatar id must not be null");
    if (avatarId.length <= 0)
      return null;
    if (!avatarId)
      return null;
    if (debug2)
      console.log("[Custom Avatar] " + avatarId + ", loading...");
    if (!avatarId.endsWith(".glb"))
      avatarId += ".glb";
    if (this.avatarRegistryUrl === null) {
      const download_res = await fetch("./" + avatarId);
      let bin = null;
      if (download_res.ok) {
        const blob = await download_res.blob();
        if (blob)
          bin = await blob.arrayBuffer();
      }
      if (!bin) {
        return null;
      }
      const gltf = await getLoader().parseSync(context, bin, null, 0);
      return (gltf == null ? void 0 : gltf.scene) ?? null;
    }
    const loader = new GLTFLoader();
    addDracoAndKTX2Loaders(loader, context);
    return new Promise((resolve, _reject) => {
      const url = this.avatarRegistryUrl + "/" + avatarId;
      loader.load(url, async (gltf) => {
        await getLoader().createBuiltinComponents(context, url, gltf, null, void 0);
        resolve(gltf.scene);
      }, (progress) => {
        if (debug2)
          console.log("[Custom Avatar] " + progress.loaded / progress.total * 100 + "% loaded of " + progress.total / 1024 + "kB");
      }, (error) => {
        console.error("[Custom Avatar] Error when loading: " + error);
        resolve(null);
      });
    });
  }
  /**
   * Caches an avatar model for reuse.
   * @param _id The ID to associate with the model
   * @param _model The avatar model to cache
   */
  cacheModel(_id, _model) {
  }
  /**
   * Analyzes an Object3D to find avatar parts (head, hands) based on naming conventions.
   * @param obj The Object3D to search for avatar parts
   * @returns A structured AvatarModel with references to found parts
   */
  findAvatar(obj) {
    const root = obj;
    let searchIn = root;
    if (searchIn.children.length == 1)
      searchIn = obj.children[0];
    let head = this.findAvatarPart(searchIn, ["head"]);
    const leftHand = this.findAvatarPart(searchIn, ["left", "hand"]);
    const rightHand = this.findAvatarPart(searchIn, ["right", "hand"]);
    if (!head) {
      head = root;
      const boundsSize = new Vector3();
      new Box3().setFromObject(head).getSize(boundsSize);
      const maxAxis = Math.max(boundsSize.x, boundsSize.y, boundsSize.z);
      console.warn("[Custom Avatar] Normalizing head scale, it's too big: " + maxAxis + " meters! Should be < 0.3m");
      if (maxAxis > 0.3) {
        head.scale.multiplyScalar(1 / maxAxis * 0.3);
      }
    }
    const model = new AvatarModel(root, head, leftHand, rightHand);
    return model;
  }
  /**
   * Recursively searches for an avatar part by name within an Object3D hierarchy.
   * @param obj The Object3D to search within
   * @param searchString Array of strings that should all be present in the object name
   * @returns The found Object3D part or null if not found
   */
  findAvatarPart(obj, searchString) {
    const name = obj.name.toLowerCase();
    let matchesAll = true;
    for (const str of searchString) {
      if (!matchesAll)
        break;
      if (name.indexOf(str) === -1)
        matchesAll = false;
    }
    if (matchesAll)
      return obj;
    if (obj.children) {
      for (const child of obj.children) {
        const found = this.findAvatarPart(child, searchString);
        if (found)
          return found;
      }
    }
    return null;
  }
  /**
   * Handles HTTP response errors from avatar loading operations.
   * @param response The fetch API response to check
   * @returns The response if it was ok
   * @throws Error with status text if response was not ok
   */
  handleCustomAvatarErrors(response) {
    if (!response.ok) {
      throw Error(response.statusText);
    }
    return response;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/export/usdz/extensions/DocumentExtension.js
var DocumentExtension = class {
  get extensionName() {
    return "DocumentExtension";
  }
  onAfterBuildDocument(_context) {
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/codegen/components.js
var __Ignore = class {
};

// node_modules/@needle-tools/engine/lib/engine-components/utils/EnvironmentScene.js
var legacy = {
  topLight: {
    intensity: 500,
    position: [0.418, 16.199, 0.3]
  },
  room: {
    position: [-0.757, 13.219, 0.717],
    scale: [31.713, 28.305, 28.591]
  },
  boxes: [
    {
      position: [-10.906, 2.009, 1.846],
      rotation: -0.195,
      scale: [2.328, 7.905, 4.651]
    },
    {
      position: [-5.607, -0.754, -0.758],
      rotation: 0.994,
      scale: [1.97, 1.534, 3.955]
    },
    {
      position: [6.167, 0.857, 7.803],
      rotation: 0.561,
      scale: [3.927, 6.285, 3.687]
    },
    {
      position: [-2.017, 0.018, 6.124],
      rotation: 0.333,
      scale: [2.002, 4.566, 2.064]
    },
    {
      position: [2.291, -0.756, -2.621],
      rotation: -0.286,
      scale: [1.546, 1.552, 1.496]
    },
    {
      position: [-2.193, -0.369, -5.547],
      rotation: 0.516,
      scale: [3.875, 3.487, 2.986]
    }
  ],
  lights: [
    {
      intensity: 50,
      position: [-16.116, 14.37, 8.208],
      scale: [0.1, 2.428, 2.739]
    },
    {
      intensity: 50,
      position: [-16.109, 18.021, -8.207],
      scale: [0.1, 2.425, 2.751]
    },
    {
      intensity: 17,
      position: [14.904, 12.198, -1.832],
      scale: [0.15, 4.265, 6.331]
    },
    {
      intensity: 43,
      position: [-0.462, 8.89, 14.52],
      scale: [4.38, 5.441, 0.088]
    },
    {
      intensity: 20,
      position: [3.235, 11.486, -12.541],
      scale: [2.5, 2, 0.1]
    },
    {
      intensity: 100,
      position: [0, 20, 0],
      scale: [1, 0.1, 1]
    }
  ]
};
var neutral = {
  topLight: {
    intensity: 400,
    position: [0.5, 14, 0.5]
  },
  room: {
    position: [0, 13.2, 0],
    scale: [31.5, 28.5, 31.5]
  },
  boxes: [
    {
      position: [-10.906, -1, 1.846],
      rotation: -0.195,
      scale: [2.328, 7.905, 4.651]
    },
    {
      position: [-5.607, -0.754, -0.758],
      rotation: 0.994,
      scale: [1.97, 1.534, 3.955]
    },
    {
      position: [6.167, -0.16, 7.803],
      rotation: 0.561,
      scale: [3.927, 6.285, 3.687]
    },
    {
      position: [-2.017, 0.018, 6.124],
      rotation: 0.333,
      scale: [2.002, 4.566, 2.064]
    },
    {
      position: [2.291, -0.756, -2.621],
      rotation: -0.286,
      scale: [1.546, 1.552, 1.496]
    },
    {
      position: [-2.193, -0.369, -5.547],
      rotation: 0.516,
      scale: [3.875, 3.487, 2.986]
    }
  ],
  lights: [
    {
      intensity: 80,
      position: [-14, 10, 8],
      scale: [0.1, 2.5, 2.5]
    },
    {
      intensity: 80,
      position: [-14, 14, -4],
      scale: [0.1, 2.5, 2.5]
    },
    {
      intensity: 23,
      position: [14, 12, 0],
      scale: [0.1, 5, 5]
    },
    {
      intensity: 16,
      position: [0, 9, 14],
      scale: [5, 5, 0.1]
    },
    {
      intensity: 80,
      position: [7, 8, -14],
      scale: [2.5, 2.5, 0.1]
    },
    {
      intensity: 80,
      position: [-7, 16, -14],
      scale: [2.5, 2.5, 0.1]
    },
    {
      intensity: 1,
      position: [0, 20, 0],
      scale: [0.1, 0.1, 0.1]
    }
  ]
};
var EnvironmentScene = class extends Scene {
  constructor(name) {
    super();
    this.position.y = -3.5;
    const geometry = new BoxGeometry();
    geometry.deleteAttribute("uv");
    const roomMaterial = new MeshStandardMaterial({ metalness: 0, side: BackSide });
    const boxMaterial = new MeshStandardMaterial({ metalness: 0 });
    const data = name == "legacy" ? legacy : neutral;
    const mainLight = new PointLight(16777215, data.topLight.intensity, 28, 2);
    mainLight.position.set(...data.topLight.position);
    this.add(mainLight);
    const room = new Mesh(geometry, roomMaterial);
    room.position.set(...data.room.position);
    room.scale.set(...data.room.scale);
    this.add(room);
    for (const box of data.boxes) {
      const box1 = new Mesh(geometry, boxMaterial);
      box1.position.set(...box.position);
      box1.rotation.set(0, box.rotation, 0);
      box1.scale.set(...box.scale);
      this.add(box1);
    }
    for (const light of data.lights) {
      const light1 = new Mesh(geometry, this.createAreaLightMaterial(light.intensity));
      light1.position.set(...light.position);
      light1.scale.set(...light.scale);
      this.add(light1);
    }
  }
  createAreaLightMaterial(intensity) {
    const material = new MeshBasicMaterial();
    material.color.setScalar(intensity);
    return material;
  }
};

// node_modules/@needle-tools/engine/lib/engine-components/CameraUtils.js
var debug3 = getParam("debugmissingcamera");
ContextRegistry.registerCallback(ContextEvent.MissingCamera, (evt) => {
  var _a2, _b, _c, _d;
  if (debug3)
    console.warn("Creating missing camera");
  const scene = evt.context.scene;
  const cameraObject = new PerspectiveCamera();
  cameraObject.name = "Default Fallback Camera";
  scene.add(cameraObject);
  const camInstance = new Camera();
  camInstance.sourceId = ((_b = (_a2 = evt.files) == null ? void 0 : _a2[0]) == null ? void 0 : _b.src) ?? "unknown";
  camInstance.fieldOfView = 35;
  const transparentAttribute = evt.context.domElement.getAttribute("transparent");
  if (transparentAttribute != void 0) {
    camInstance.clearFlags = ClearFlags.Uninitialized;
  } else if (((_c = evt.context.domElement.getAttribute("skybox-image")) == null ? void 0 : _c.length) || ((_d = evt.context.domElement.getAttribute("background-image")) == null ? void 0 : _d.length) || evt.context.lightmaps.tryGetSkybox(camInstance.sourceId)) {
    camInstance.clearFlags = ClearFlags.Skybox;
    camInstance.backgroundBlurriness = 0.2;
  } else {
    camInstance.clearFlags = ClearFlags.SolidColor;
    let backgroundColor = "#efefef";
    if (typeof window !== void 0 && window.matchMedia("(prefers-color-scheme: dark)").matches) {
      backgroundColor = "#1f1f1f";
    }
    scene.background = new Color(backgroundColor);
    if (!scene.environment) {
      const pmremGenerator = new PMREMGenerator$1(evt.context.renderer);
      const env = new EnvironmentScene("neutral");
      scene.environment = pmremGenerator.fromScene(env, 0.025).texture;
    }
  }
  const cam = addNewComponent(cameraObject, camInstance, true);
  cameraObject.position.x = 0;
  cameraObject.position.y = 1;
  cameraObject.position.z = 2;
  const engineElement = evt.context.domElement;
  if ((engineElement == null ? void 0 : engineElement.cameraControls) != false) {
    createDefaultCameraControls(evt.context, cam);
  }
  return cam;
});
ContextRegistry.registerCallback(ContextEvent.ContextCreated, (evt) => {
  if (!evt.context.mainCamera) {
    if (debug3)
      console.log("Will not auto-fit because a default camera exists");
    return;
  }
  const engineElement = evt.context.domElement;
  if ((engineElement == null ? void 0 : engineElement.cameraControls) == true) {
    const existing = getCameraController(evt.context.mainCamera);
    if ((existing == null ? void 0 : existing.isCameraController) == true) {
      if (debug3)
        console.log("Will not auto-fit because a camera controller exists");
      return;
    }
    createDefaultCameraControls(evt.context);
  }
});
function createDefaultCameraControls(context, cam) {
  cam = cam ?? context.mainCameraComponent;
  const cameraObject = cam == null ? void 0 : cam.gameObject;
  if (debug3)
    console.log("Creating default camera controls", cam == null ? void 0 : cam.name);
  if (cameraObject) {
    const orbit = getOrAddComponent(cameraObject, OrbitControls2);
    orbit.sourceId = (cam == null ? void 0 : cam.sourceId) ?? "unknown";
    const autoRotate = context.domElement.getAttribute("auto-rotate");
    orbit.autoRotate = autoRotate !== void 0 && autoRotate !== null && (autoRotate != "0" && (autoRotate == null ? void 0 : autoRotate.toLowerCase()) != "false");
    orbit.autoRotateSpeed = 0.5;
    orbit.autoFit = true;
    if (orbit.autoRotate && autoRotate) {
      const autoRotateValue = parseFloat(autoRotate);
      if (!isNaN(autoRotateValue)) {
        orbit.autoRotateSpeed = autoRotateValue;
      }
    }
  } else {
    console.warn("Missing camera object, can not add orbit controls");
  }
}

// node_modules/@needle-tools/engine/lib/engine-components/AnimationUtilsAutoplay.js
ContextRegistry.registerCallback(ContextEvent.ContextCreated, (args) => {
  const autoplay = args.context.domElement.getAttribute("autoplay");
  if (autoplay !== void 0 && (autoplay === "" || autoplay === "true" || autoplay === "1")) {
    if (args.files) {
      for (const file of args.files) {
        const hasAnimation = GameObject.foreachComponent(file.file.scene, (comp) => {
          if (comp.enabled === false)
            return void 0;
          if (comp instanceof Animation && comp.playAutomatically || comp instanceof Animator || comp instanceof PlayableDirector && comp.playOnAwake === true) {
            return true;
          } else if (comp instanceof Animation) {
            comp.playAutomatically = true;
            return true;
          } else if (comp instanceof PlayableDirector) {
            comp.playOnAwake = true;
            return true;
          }
          return void 0;
        }, true);
        if (hasAnimation !== true) {
          AnimationUtils.assignAnimationsFromFile(file.file, {
            createAnimationComponent: (obj, _clip) => {
              return addComponent(obj, Animation);
            }
          });
        }
      }
    }
  }
});

// node_modules/@needle-tools/engine/lib/needle-engine.js
var Needle = {
  VERSION,
  Context,
  NeedleXRSession,
  gltf: {
    loadFromURL: loadSync
  },
  onStart,
  onUpdate,
  onBeforeRender,
  onAfterRender,
  onInitializedContext: onInitialized,
  onDestroyContext: onDestroy,
  onClearContext: onClear
};
var _a;
if (((_a = globalThis["Needle"]) == null ? void 0 : _a.VERSION) !== void 0) {
  console.warn(`Needle Engine is already imported: ${globalThis["Needle"].VERSION}`);
}
function registerGlobal(obj) {
  for (const key in obj) {
    Needle[key] = obj[key];
  }
}
registerGlobal(Component_exports);
registerGlobal(components_exports);
for (const method of Object.getOwnPropertyNames(GameObject)) {
  switch (method) {
    case "prototype":
    case "constructor":
    case "length":
    case "name":
      continue;
    default:
      Needle[method] = GameObject[method];
      break;
  }
}
if (!globalThis["Needle"]) {
  globalThis["Needle"] = Needle;
} else {
  for (const key in Needle) {
    globalThis["Needle"][key] = Needle[key];
  }
}
if (!globalThis["THREE"]) {
  globalThis["THREE"] = three_module_exports;
} else
  console.warn("Three.js is already imported");
export {
  $physicsKey,
  ActionBuilder,
  ActionCollection,
  ActionModel,
  Addressables,
  AlignmentConstraint,
  AmbientMode,
  Animation,
  AnimationCurve,
  AnimationExtension,
  AnimationTrackHandler,
  AnimationUtils,
  Animator,
  AnimatorConditionMode,
  AnimatorController,
  AnimatorControllerParameterType,
  AnimatorStateInfo,
  Antialiasing,
  Application,
  ApplicationEvents,
  AssetDatabase,
  AssetReference,
  AudioExtension,
  AudioListener,
  AudioSource,
  AudioTrackHandler,
  Avatar,
  AvatarBlink_Simple,
  AvatarEyeLook_Rotation,
  AvatarLoader,
  AvatarMarker,
  AvatarModel,
  Avatar_Brain_LookAt,
  Avatar_MouthShapes,
  Avatar_MustacheShake,
  Avatar_POI,
  Axes,
  AxesHelper,
  BUILD_TIME,
  BaseUIComponent,
  BasicIKConstraint,
  BehaviorExtension,
  BehaviorModel,
  Component as Behaviour,
  BlobStorage,
  BloomEffect,
  BoxCollider,
  BoxGizmo,
  BoxHelperComponent,
  Button,
  ButtonsFactory,
  CallDirection,
  CallInfo,
  Camera,
  CameraTargetReachedEvent,
  Canvas,
  CanvasGroup,
  CapsuleCollider,
  ChangeMaterialOnClick,
  ChangeTransformOnClick,
  CharacterController,
  CharacterControllerInput,
  ChromaticAberration,
  CircularBuffer,
  ClearFlags,
  ClipExtrapolation,
  Collider,
  Collision,
  CollisionDetectionMode,
  ColorAdjustments,
  ColorBySpeedModule,
  ColorOverLifetimeModule,
  Component,
  ComponentLifecycleEvents,
  ConnectionEvents,
  ContactPoint,
  ContactShadows,
  Context,
  ContextArgs,
  ContextEvent,
  ContextRegistry,
  ControlTrackHandler,
  CustomBranding,
  CustomShader,
  DefaultReflectionMode,
  Deletable,
  DeleteBox,
  DepthOfField,
  DeviceFlag,
  DeviceUtilities,
  DocumentExtension,
  DragControls,
  DragMode,
  DropListener,
  Duplicatable,
  EffectWrapper,
  EmissionModule,
  EmphasizeOnClick,
  EngineLoadingView,
  EventList,
  EventListEvent,
  EventSystem,
  EventTrigger,
  FieldWithDefault,
  FileReference,
  FileReferenceSerializer,
  FileSpawnModel,
  File_Event,
  FixedJoint,
  Fog,
  FrameEvent,
  GENERATOR,
  GameObject,
  Gizmos,
  GltfExport,
  GltfExportBox,
  GltfLoadEvent,
  GltfLoadEventType,
  Gradient,
  Graphic,
  GraphicRaycaster,
  Graphics,
  GridHelper,
  GridLayoutGroup,
  GroundProjectedEnv,
  GroupActionModel,
  HideFlags,
  HideOnStart,
  HingeJoint,
  HorizontalLayoutGroup,
  HostData,
  Image,
  ImageReference,
  ImageReferenceSerializer,
  InheritVelocityModule,
  Input,
  InputEventQueue,
  InputEvents,
  InputField,
  InstanceHandle,
  InstancingHandler,
  InstancingUtil,
  InstantiateEvent,
  InstantiateIdProvider,
  InstantiateOptions,
  Interactable,
  InternalScreenshotUtils,
  JoinedRoomResponse,
  KeyEventArgs,
  Keyframe,
  LODGroup,
  LODModel,
  LeftRoomResponse,
  Light,
  LightData,
  LimitVelocityOverLifetimeModule,
  LoadingElementOptions,
  LogStats,
  LogType,
  LookAt,
  LookAtConstraint,
  MainModule,
  MarkerType,
  MaskableGraphic,
  Mathf,
  MeshCollider,
  MeshRenderer,
  MinMaxCurve,
  MinMaxGradient,
  MODULES as NEEDLE_ENGINE_MODULES,
  NEEDLE_progressive,
  NEKeyboardEvent,
  NEPointerEvent,
  NeedleButtonElement,
  ContextRegistry as NeedleEngine,
  NeedleEngineHTMLElement,
  NeedleLoader,
  NeedleMenu,
  NeedlePatchesKey,
  USDZExporter as NeedleUSDZExporter,
  NeedleXRController,
  NeedleXRSession,
  NeedleXRSync,
  NeedleXRUtils,
  NestedGltf,
  NetworkConnection,
  NetworkedStreamEvents,
  NetworkedStreams,
  Networking,
  NewInstanceModel,
  NoiseModule,
  ObjectRaycaster,
  ObjectUtils,
  OffsetConstraint,
  OneEuroFilter,
  OneEuroFilterXYZ,
  OpenURL,
  OrbitControls2 as OrbitControls,
  Outline,
  OwnershipEvent,
  OwnershipModel,
  PUBLIC_KEY,
  Padding,
  ParticleBurst,
  ParticleSubEmitter,
  ParticleSystem,
  ParticleSystemBaseBehaviour,
  ParticleSystemRenderer,
  ParticleSystemShapeType,
  PeerHandle,
  PeerNetworking,
  Physics,
  PhysicsExtension,
  PhysicsMaterialCombine,
  PixelationEffect,
  PlayAnimationOnClick,
  PlayAudioOnClick,
  PlayableDirector,
  PlayerColor,
  PlayerState,
  PlayerStateEvent,
  PlayerSync,
  PlayerView,
  PlayerViewManager,
  PointerEventData,
  PointerType,
  PostProcessingEffect,
  PostProcessingHandler,
  Volume as PostProcessingManager,
  PreliminaryAction,
  PreliminaryTrigger,
  PreviewHelper,
  PrimitiveType,
  Progress,
  PromiseAllWithErrors,
  PromiseErrorResult,
  RGBAColor,
  RapierPhysics,
  RawImage,
  RaycastOptions,
  Rect,
  RectTransform,
  ReflectionProbe,
  RegisteredAnimationInfo,
  RemoteSkybox,
  RenderTexture,
  RenderTextureSerializer,
  Renderer,
  RendererData,
  RendererLightmap,
  Rigidbody,
  RigidbodyConstraints,
  RoomEvents,
  RotationBySpeedModule,
  RotationOverLifetimeModule,
  SceneLightSettings,
  SceneSwitcher,
  ScreenCapture,
  ScreenSpaceAmbientOcclusion,
  ScreenSpaceAmbientOcclusionN8,
  SendQueue,
  SerializationContext,
  SetActiveOnClick,
  ShadowCatcher,
  ShapeModule,
  SharpeningEffect,
  SignalAsset,
  SignalReceiver,
  SignalReceiverEvent,
  SignalTrackHandler,
  Size,
  SizeBySpeedModule,
  SizeOverLifetimeModule,
  SkinnedMeshRenderer,
  SmoothFollow,
  SpatialGrabRaycaster,
  SpatialHtml,
  SpatialTrigger,
  SpatialTriggerReceiver,
  SpectatorCamera,
  SphereCollider,
  SphereIntersection,
  SphereOverlapResult,
  Sprite,
  SpriteData,
  SpriteRenderer,
  SpriteSheet,
  StateMachineBehaviour,
  StreamEndedEvent,
  StreamReceivedEvent,
  SubEmitterSystem,
  SyncedCamera,
  SyncedRoom,
  SyncedTransform,
  TapGestureTrigger,
  TeleportTarget,
  TestRunner,
  TestSceneUtils,
  TestSimulateUserData,
  Text,
  TextBuilder,
  TextExtension,
  TextureSheetAnimationModule,
  TiltShiftEffect,
  Time,
  ToneMappingEffect,
  TrackHandler,
  TrackType,
  TrailModule,
  TransformData,
  TransformGizmo,
  TriggerBuilder,
  TriggerModel,
  TypeStore,
  UIRaycastUtils,
  UIRootComponent,
  USDDocument,
  USDObject,
  USDWriter,
  USDZExporter2 as USDZExporter,
  USDZText,
  USDZUIExtension,
  UriSerializer,
  UsageMarker,
  UserJoinedOrLeftRoomModel,
  VERSION,
  VariantAction,
  VelocityOverLifetimeModule,
  VerticalLayoutGroup,
  VideoPlayer,
  ViewDevice,
  Vignette,
  VisibilityAction,
  Voip,
  Volume,
  VolumeParameter,
  VolumeProfile,
  WaitForFrames,
  WaitForPromise,
  WaitForSeconds,
  Watch,
  WebARCameraBackground,
  WebARSessionRoot,
  WebXR,
  WebXRButtonFactory,
  WebXRImageTracking,
  WebXRImageTrackingModel,
  WebXRPlaneTracking,
  WebXRTrackedImage,
  XRControllerFollow,
  XRControllerModel,
  XRControllerMovement,
  XRFlag,
  XRRig,
  XRState,
  XRStateFlag,
  __Ignore,
  __internalNotifyObjectDestroyed,
  activeInHierarchyFieldName,
  addAttributeChangeCallback,
  addComponent,
  addCustomExtensionPlugin,
  addGltfLoadEventListener,
  addNewComponent,
  addPatch,
  apply,
  applyHMRChanges,
  applyPrototypeExtensions,
  beginListenDestroy,
  beginListenInstantiate,
  binaryIdentifierCasts,
  build_scene_functions,
  builtinComponentKeyName,
  calculateProgress01,
  clearMessages as clearBalloonMessages,
  clearMessages as clearOverlayMessages,
  colorSerializer,
  compareAssociation,
  componentSerializer,
  copyTexture,
  createLoader,
  createMotion,
  debugNet,
  debugOwner,
  decompressGpuTexture,
  deepClone,
  delay,
  delayForFrames,
  deserializeObject,
  destroy,
  destroyComponentInstance,
  disposeObjectResources,
  disposeStream,
  editorGuidKeyName,
  enableSpatialConsole,
  euler,
  eventListSerializer,
  exportAsGLTF,
  findByGuid,
  findObjectOfType,
  findObjectsOfType,
  findResourceUsers,
  fitObjectIntoVolume,
  foreachComponent,
  foreachComponentEnumerator,
  forward,
  generateQRCode,
  generateSeed,
  getBoundingBox,
  getCameraController,
  getComponent,
  getComponentInChildren,
  getComponentInParent,
  getComponents,
  getComponentsInChildren,
  getComponentsInParent,
  getFormattedDate,
  getIconElement,
  getIconTexture,
  getIp,
  getIpAndLocation,
  getIpCloudflare,
  getLoader,
  getOrAddComponent,
  getParam,
  getParentHierarchyPath,
  getPath,
  getPeerOptions,
  getPeerjsInstance,
  getResourceUserCount,
  getTempColor,
  getTempQuaternion,
  getTempVector,
  getUrlParams,
  getVisibleInCustomShadowRendering,
  getWorldDirection,
  getWorldEuler,
  getWorldPosition,
  getWorldQuaternion,
  getWorldRotation,
  getWorldScale,
  hasCommercialLicense,
  hasIndieLicense,
  hasPointerEventComponent,
  hasProLicense,
  hideDebugConsole,
  imageToCanvas,
  instantiate,
  invokeAfterImportPluginHooks,
  invokeXRSessionEnd,
  invokeXRSessionStart,
  isActiveInHierarchy,
  isActiveSelf,
  isAndroidDevice,
  isAnimationAction,
  isComponent,
  isDebugMode,
  isDesktop,
  isDestroyed,
  isDevEnvironment,
  isDisposed,
  isExporting,
  isHostedOnGlitch,
  isHotReloading,
  isIPad,
  isIconElement,
  isLocalNetwork,
  isMacOS,
  isMobileDevice,
  isMozillaXR,
  isQuest,
  isResourceTrackingEnabled,
  isSafari,
  isUsingInstancing,
  isiOS,
  isiPad,
  loadSync,
  logHierarchy,
  lookAtInverse,
  lookAtObject,
  lookAtScreenPoint,
  makeId,
  makeIdFromRandomWords,
  makeNameSafe as makeNameSafeForUSD,
  markAsInstancedRendered,
  microphonePermissionsGranted,
  nameof,
  nameofFactory,
  objectSerializer,
  offXRSessionEnd,
  offXRSessionStart,
  onAfterRender,
  onBeforeRender,
  onClear,
  onDestroy,
  onInitialized,
  onStart,
  onUpdate,
  onXRSessionEnd,
  onXRSessionStart,
  parseSync,
  placeOnSurface,
  postprocessFBXMaterials,
  prefix,
  pushState,
  randomNumber,
  registerBinaryType,
  registerComponent,
  registerComponentExtension,
  registerCustomEffectType,
  registerExportExtensions,
  registerExtensions,
  registerHotReloadType,
  registerLoader,
  registerPrefabProvider,
  registerPrototypeExtensions,
  registerType,
  relativePathPrefix,
  removeAttributeChangeCallback,
  removeComponent,
  removeCustomImportExtensionType,
  removeGltfLoadEventListener,
  removePatch,
  resolveUrl,
  sanitizeString,
  saveImage,
  screenshot,
  screenshot2,
  sendDestroyed,
  serializable,
  serializeObject,
  serializeable,
  setActive,
  setAllowBalloonMessages,
  setAllowOverlayMessages,
  setAutoFitEnabled,
  setCameraController,
  setDestroyed,
  setDevEnvironment,
  setDisposable,
  setDontDestroy,
  setOrAddParamsToUrl,
  setParam,
  setParamWithoutReload,
  setPeerOptions,
  setResourceTrackingEnabled,
  setState,
  setVisibleInCustomShadowRendering,
  setWorldEuler,
  setWorldPosition,
  setWorldPositionXYZ,
  setWorldQuaternion,
  setWorldQuaternionXYZW,
  setWorldRotation,
  setWorldRotationXYZ,
  setWorldScale,
  showBalloonError,
  showBalloonMessage,
  showBalloonWarning,
  showDebugConsole,
  slerp,
  syncDestroy,
  syncField,
  syncInstantiate,
  textureToCanvas,
  tryCastBinary,
  tryDetermineFileTypeFromBinary,
  tryDetermineFileTypeFromURL,
  tryFindObject,
  tryGetGuid,
  unregisterHotReloadType,
  unwatchWrite,
  useForAutoFit,
  validate,
  watchWrite
};
/*! Bundled license information:

@needle-tools/engine/lib/engine-components/utils/EnvironmentScene.js:
  (* @license
   * Copyright 2021 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the 'License');
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an 'AS IS' BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=@needle-tools_engine.js.map
