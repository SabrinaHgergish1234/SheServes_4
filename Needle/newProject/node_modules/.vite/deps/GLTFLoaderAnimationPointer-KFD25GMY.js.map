{
  "version": 3,
  "sources": ["../../three/examples/jsm/loaders/GLTFLoaderAnimationPointer.js"],
  "sourcesContent": ["import {\n\tAnimationClip,\n\tColorKeyframeTrack,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNumberKeyframeTrack,\n\tPropertyBinding,\n\tQuaternionKeyframeTrack,\n\tVectorKeyframeTrack,\n\tSkinnedMesh\n} from 'three';\n\n// DUPLICATED from GLTFLoader.js\nconst ANIMATION_TARGET_TYPE = {\n\tnode: 'node',\n\tmaterial: 'material',\n\tcamera: 'camera',\n\tlight: 'light',\n};\n\nconst KHR_ANIMATION_POINTER = 'KHR_animation_pointer';\n\n// DUPLICATED from GLTFLoader.js\nconst INTERPOLATION = {\n\t// We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t// keyframe track will be initialized with a default interpolation type, then modified.\n\tCUBICSPLINE: undefined,\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\n// HACK monkey patching findNode to ensure we can map to other types required by KHR_animation_pointer.\nconst find = PropertyBinding.findNode;\nconst _animationPointerDebug = false;\nlet _havePatchedPropertyBindings = false;\n\n/**\n * Animation Pointer Extension\n *\n * Draft Specification: https://github.com/ux3d/glTF/tree/extensions/KHR_animation_pointer/extensions/2.0/Khronos/KHR_animation_pointer\n */\nclass GLTFAnimationPointerExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = KHR_ANIMATION_POINTER;\n\t\tthis.animationPointerResolver = null;\n\n\t}\n\n\tsetAnimationPointerResolver( animationPointerResolver ) {\n\n\t\tthis.animationPointerResolver = animationPointerResolver;\n\t\treturn this;\n\n\t}\n\n\t_patchPropertyBindingFindNode() {\n\n\t\tif ( _havePatchedPropertyBindings ) return;\n\t\t_havePatchedPropertyBindings = true;\n\n\t\t// \"node\" is the Animator component in our case\n\t\t// \"path\" is the animated property path, just with translated material names.\n\t\tPropertyBinding.findNode = function ( node, path ) {\n\n\t\t\tif ( path.startsWith( '.materials.' ) ) {\n\n\t\t\t\tif ( _animationPointerDebug ) console.log( 'FIND', path );\n\n\t\t\t\tconst remainingPath = path.substring( '.materials.'.length ).substring( path.indexOf( '.' ) );\n\t\t\t\tconst nextIndex = remainingPath.indexOf( '.' );\n\t\t\t\tconst uuid = nextIndex < 0 ? remainingPath : remainingPath.substring( 0, nextIndex );\n\t\t\t\tlet res = null;\n\t\t\t\tnode.traverse( x => {\n\n\t\t\t\t\tif ( res !== null || ( x.type !== 'Mesh' && x.type !== 'SkinnedMesh' ) ) return;\n\t\t\t\t\tif ( x[ 'material' ] && ( x[ 'material' ].uuid === uuid || x[ 'material' ].name === uuid ) ) {\n\n\t\t\t\t\t\tres = x[ 'material' ];\n\t\t\t\t\t\tif ( _animationPointerDebug ) console.log( res, remainingPath );\n\t\t\t\t\t\tif ( res !== null ) {\n\n\t\t\t\t\t\t\tif ( remainingPath.endsWith( '.map' ) )\n\t\t\t\t\t\t\t\tres = res[ 'map' ];\n\t\t\t\t\t\t\telse if ( remainingPath.endsWith( '.emissiveMap' ) )\n\t\t\t\t\t\t\t\tres = res[ 'emissiveMap' ];\n\n\t\t\t\t\t\t\t// TODO other texture slots only make sense if three.js actually supports them\n\t\t\t\t\t\t\t// (currently only .map can have repeat/offset)\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else if ( path.startsWith( '.nodes.' ) || path.startsWith( '.lights.' ) || path.startsWith( '.cameras.' ) ) {\n\n\t\t\t\tconst sections = path.split( '.' );\n\t\t\t\tlet currentTarget = undefined;\n\t\t\t\tfor ( let i = 1; i < sections.length; i ++ ) {\n\n\t\t\t\t\tconst val = sections[ i ];\n\t\t\t\t\tconst isUUID = val.length == 36;\n\t\t\t\t\tif ( isUUID ) {\n\n\t\t\t\t\t\t// access by UUID\n\t\t\t\t\t\tcurrentTarget = node.getObjectByProperty( 'uuid', val );\n\n\t\t\t\t\t} else if ( currentTarget && currentTarget[ val ] ) {\n\n\t\t\t\t\t\t// access by index\n\t\t\t\t\t\tconst index = Number.parseInt( val );\n\t\t\t\t\t\tlet key = val;\n\t\t\t\t\t\tif ( index >= 0 ) key = index;\n\t\t\t\t\t\tcurrentTarget = currentTarget[ key ];\n\t\t\t\t\t\tif ( _animationPointerDebug )\n\t\t\t\t\t\t\tconsole.log( currentTarget );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// access by node name\n\t\t\t\t\t\tconst foundNode = node.getObjectByName( val );\n\n\t\t\t\t\t\tif ( foundNode )\n\t\t\t\t\t\t\tcurrentTarget = foundNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! currentTarget ) {\n\n\t\t\t\t\tconst originalFindResult = find( node, sections[ 2 ] );\n\n\t\t\t\t\tif ( ! originalFindResult )\n\t\t\t\t\t\tconsole.warn( KHR_ANIMATION_POINTER + ': Property binding not found', path, node, node.name, sections );\n\n\t\t\t\t\treturn originalFindResult;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _animationPointerDebug )\n\t\t\t\t\tconsole.log( 'NODE', path, currentTarget );\n\n\t\t\t\treturn currentTarget;\n\n\t\t\t}\n\n\t\t\treturn find( node, path );\n\n\t\t};\n\n\t}\n\n\t/* DUPLICATE of functionality in GLTFLoader */\n\tloadAnimationTargetFromChannel( animationChannel ) {\n\n\t\tconst target = animationChannel.target;\n\t\tconst name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\treturn this.parser.getDependency( 'node', name );\n\n\t}\n\n\tloadAnimationTargetFromChannelWithAnimationPointer( animationChannel ) {\n\n\t\tif ( ! this._havePatchedPropertyBindings )\n\t\t\tthis._patchPropertyBindingFindNode();\n\n\t\tconst target = animationChannel.target;\n\t\tconst useExtension = target.extensions && target.extensions[ KHR_ANIMATION_POINTER ] && target.path && target.path === 'pointer';\n\t\tif ( ! useExtension ) return null;\n\n\t\tlet targetProperty = undefined;\n\n\t\t// check if this is a extension animation\n\t\tlet type = ANIMATION_TARGET_TYPE.node;\n\t\tlet targetId = undefined;\n\n\t\tif ( useExtension ) {\n\n\t\t\tconst ext = target.extensions[ KHR_ANIMATION_POINTER ];\n\t\t\tlet path = ext.pointer;\n\t\t\tif ( _animationPointerDebug )\n\t\t\t\tconsole.log( 'Original path: ' + path, target );\n\n\t\t\tif ( ! path ) {\n\n\t\t\t\tconsole.warn( 'Invalid path', ext, target );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( path.startsWith( '/materials/' ) )\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.material;\n\t\t\telse if ( path.startsWith( '/extensions/KHR_lights_punctual/lights/' ) )\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.light;\n\t\t\telse if ( path.startsWith( '/cameras/' ) )\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.camera;\n\n\t\t\ttargetId = this._tryResolveTargetId( path, type );\n\t\t\tif ( targetId === null || isNaN( targetId ) ) {\n\n\t\t\t\tconsole.warn( 'Failed resolving animation node id: ' + targetId, path );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\tif ( _animationPointerDebug ) console.log( 'Resolved node ID for ' + type, targetId );\n\n\t\t\t}\n\n\t\t\t// TODO could be parsed better\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase ANIMATION_TARGET_TYPE.material:\n\t\t\t\t\tconst pathIndex = ( '/materials/' + targetId.toString() + '/' ).length;\n\t\t\t\t\tconst pathStart = path.substring( 0, pathIndex );\n\t\t\t\t\ttargetProperty = path.substring( pathIndex );\n\n\t\t\t\t\tswitch ( targetProperty ) {\n\n\t\t\t\t\t\t// Core Spec PBR Properties\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorFactor':\n\t\t\t\t\t\t\ttargetProperty = 'color';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/roughnessFactor':\n\t\t\t\t\t\t\ttargetProperty = 'roughness';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/metallicFactor':\n\t\t\t\t\t\t\ttargetProperty = 'metalness';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'emissiveFactor':\n\t\t\t\t\t\t\ttargetProperty = 'emissive';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'alphaCutoff':\n\t\t\t\t\t\t\ttargetProperty = 'alphaTest';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'occlusionTexture/strength':\n\t\t\t\t\t\t\ttargetProperty = 'aoMapIntensity';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'normalTexture/scale':\n\t\t\t\t\t\t\ttargetProperty = 'normalScale';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// Core Spec + KHR_texture_transform\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale':\n\t\t\t\t\t\t\ttargetProperty = 'map/repeat';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset':\n\t\t\t\t\t\t\ttargetProperty = 'map/offset';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// UV transforms for anything but map doesn't seem to currently be supported in three.js\n\t\t\t\t\t\tcase 'emissiveTexture/extensions/KHR_texture_transform/scale':\n\t\t\t\t\t\t\ttargetProperty = 'emissiveMap/repeat';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'emissiveTexture/extensions/KHR_texture_transform/offset':\n\t\t\t\t\t\t\ttargetProperty = 'emissiveMap/offset';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_emissive_strength\n\t\t\t\t\t\tcase 'extensions/KHR_materials_emissive_strength/emissiveStrength':\n\t\t\t\t\t\t\ttargetProperty = 'emissiveIntensity';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_transmission\n\t\t\t\t\t\tcase 'extensions/KHR_materials_transmission/transmissionFactor':\n\t\t\t\t\t\t\ttargetProperty = 'transmission';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_ior\n\t\t\t\t\t\tcase 'extensions/KHR_materials_ior/ior':\n\t\t\t\t\t\t\ttargetProperty = 'ior';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_volume\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/thicknessFactor':\n\t\t\t\t\t\t\ttargetProperty = 'thickness';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/attenuationColor':\n\t\t\t\t\t\t\ttargetProperty = 'attenuationColor';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/attenuationDistance':\n\t\t\t\t\t\t\ttargetProperty = 'attenuationDistance';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_iridescence\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceFactor':\n\t\t\t\t\t\t\ttargetProperty = 'iridescence';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceIor':\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceIOR';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceThicknessMinimum':\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceThicknessRange[0]';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceThicknessMaximum':\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceThicknessRange[1]';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_clearcoat\n\t\t\t\t\t\tcase 'extensions/KHR_materials_clearcoat/clearcoatFactor':\n\t\t\t\t\t\t\ttargetProperty = 'clearcoat';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor':\n\t\t\t\t\t\t\ttargetProperty = 'clearcoatRoughness';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_sheen\n\t\t\t\t\t\tcase 'extensions/KHR_materials_sheen/sheenColorFactor':\n\t\t\t\t\t\t\ttargetProperty = 'sheenColor';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_sheen/sheenRoughnessFactor':\n\t\t\t\t\t\t\ttargetProperty = 'sheenRoughness';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_specular\n\t\t\t\t\t\tcase 'extensions/KHR_materials_specular/specularFactor':\n\t\t\t\t\t\t\ttargetProperty = 'specularIntensity';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_specular/specularColorFactor':\n\t\t\t\t\t\t\ttargetProperty = 'specularColor';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = pathStart + targetProperty;\n\t\t\t\t\tif ( _animationPointerDebug ) console.log( 'PROPERTY PATH', pathStart, targetProperty, path );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIMATION_TARGET_TYPE.node:\n\t\t\t\t\tconst pathIndexNode = ( '/nodes/' + targetId.toString() + '/' ).length;\n\t\t\t\t\tconst pathStartNode = path.substring( 0, pathIndexNode );\n\t\t\t\t\ttargetProperty = path.substring( pathIndexNode );\n\n\t\t\t\t\tswitch ( targetProperty ) {\n\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\ttargetProperty = 'position';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\ttargetProperty = 'quaternion';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\ttargetProperty = 'scale';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'weights':\n\t\t\t\t\t\t\ttargetProperty = 'morphTargetInfluences';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = pathStartNode + targetProperty;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIMATION_TARGET_TYPE.light:\n\t\t\t\t\tconst pathIndexLight = ( '/extensions/KHR_lights_punctual/lights/' + targetId.toString() + '/' ).length;\n\t\t\t\t\ttargetProperty = path.substring( pathIndexLight );\n\n\t\t\t\t\tswitch ( targetProperty ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'intensity':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'spot/innerConeAngle':\n\t\t\t\t\t\t\t// TODO would need to set .penumbra, but requires calculations on every animation change (?)\n\t\t\t\t\t\t\ttargetProperty = 'penumbra';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'spot/outerConeAngle':\n\t\t\t\t\t\t\ttargetProperty = 'angle';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'range':\n\t\t\t\t\t\t\ttargetProperty = 'distance';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = '/lights/' + targetId.toString() + '/' + targetProperty;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIMATION_TARGET_TYPE.camera:\n\t\t\t\t\tconst pathIndexCamera = ( '/cameras/' + targetId.toString() + '/' ).length;\n\t\t\t\t\tconst pathStartCamera = path.substring( 0, pathIndexCamera );\n\t\t\t\t\ttargetProperty = path.substring( pathIndexCamera );\n\n\t\t\t\t\tswitch ( targetProperty ) {\n\n\t\t\t\t\t\tcase 'perspective/yfov':\n\t\t\t\t\t\t\ttargetProperty = 'fov';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'perspective/znear':\n\t\t\t\t\t\tcase 'orthographic/znear':\n\t\t\t\t\t\t\ttargetProperty = 'near';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'perspective/zfar':\n\t\t\t\t\t\tcase 'orthographic/zfar':\n\t\t\t\t\t\t\ttargetProperty = 'far';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'perspective/aspect':\n\t\t\t\t\t\t\ttargetProperty = 'aspect';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// these two write to the same target property since three.js orthographic camera only supports 'zoom'.\n\t\t\t\t\t\t// TODO should there be a warning for either of them? E.g. a warning for \"xmag\" so that \"yfov\" + \"ymag\" work by default?\n\t\t\t\t\t\tcase 'orthographic/xmag':\n\t\t\t\t\t\t\ttargetProperty = 'zoom';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'orthographic/ymag':\n\t\t\t\t\t\t\ttargetProperty = 'zoom';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = pathStartCamera + targetProperty;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst pointerResolver = this.animationPointerResolver;\n\t\t\tif ( pointerResolver && pointerResolver.resolvePath ) {\n\n\t\t\t\tpath = pointerResolver.resolvePath( path );\n\n\t\t\t}\n\n\t\t\ttarget.extensions[ KHR_ANIMATION_POINTER ].pointer = path;\n\n\t\t}\n\n\t\tif ( targetId === null || isNaN( targetId ) ) {\n\n\t\t\tconsole.warn( 'Failed resolving animation node id: ' + targetId, target );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet depPromise;\n\n\t\tif ( type === ANIMATION_TARGET_TYPE.node )\n\t\t\tdepPromise = this.parser.getDependency( 'node', targetId );\n\t\telse if ( type === ANIMATION_TARGET_TYPE.material )\n\t\t\tdepPromise = this.parser.getDependency( 'material', targetId );\n\t\telse if ( type === ANIMATION_TARGET_TYPE.light )\n\t\t\tdepPromise = this.parser.getDependency( 'light', targetId );\n\t\telse if ( type === ANIMATION_TARGET_TYPE.camera )\n\t\t\tdepPromise = this.parser.getDependency( 'camera', targetId );\n\t\telse\n\t\t\tconsole.error( 'Unhandled type', type );\n\n\t\treturn depPromise;\n\n\t}\n\n\tcreateAnimationTracksWithAnimationPointer( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst useExtension = target.extensions && target.extensions[ KHR_ANIMATION_POINTER ] && target.path && target.path === 'pointer';\n\t\tif ( ! useExtension ) return null;\n\n\t\tlet animationPointerPropertyPath = target.extensions[ KHR_ANIMATION_POINTER ].pointer;\n\t\tif ( ! animationPointerPropertyPath ) return null;\n\n\t\tconst tracks = [];\n\n\t\tanimationPointerPropertyPath = animationPointerPropertyPath.replaceAll( '/', '.' );\n\t\t// replace node/material/camera/light ID by UUID\n\t\tconst parts = animationPointerPropertyPath.split( '.' );\n\t\tconst hasName = node.name !== undefined && node.name !== null;\n\t\tvar nodeTargetName = hasName ? node.name : node.uuid;\n\t\tparts[ 2 ] = nodeTargetName;\n\n\t\t// specially handle the morphTargetInfluences property for multi-material meshes\n\t\t// in which case the target object is a Group and the children are the actual targets\n\t\t// see NE-3311\n\t\tif ( parts[ 3 ] === 'morphTargetInfluences' ) {\n\n\t\t\tif ( node.type === 'Group' ) {\n\n\t\t\t\tif ( _animationPointerDebug )\n\t\t\t\t\tconsole.log( 'Detected multi-material skinnedMesh export', animationPointerPropertyPath, node );\n\n\t\t\t\t// We assume the children are skinned meshes\n\t\t\t\tfor ( const ch of node.children ) {\n\n\t\t\t\t\tif ( ch instanceof SkinnedMesh && ch.morphTargetInfluences ) {\n\n\t\t\t\t\t\tparts[ 3 ] = ch.name;\n\t\t\t\t\t\tparts[ 4 ] = 'morphTargetInfluences';\n\t\t\t\t\t\t__createTrack( this.parser );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn tracks;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// default\n\t\t__createTrack( this.parser );\n\n\t\t/** Create a new track using the current parts array */\n\t\tfunction __createTrack( parser ) {\n\n\t\t\tanimationPointerPropertyPath = parts.join( '.' );\n\n\t\t\tif ( _animationPointerDebug )\n\t\t\t\tconsole.log( node, inputAccessor, outputAccessor, target, animationPointerPropertyPath );\n\n\t\t\tlet TypedKeyframeTrack;\n\n\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\tcase 1:\n\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\n\t\t\t\t\tif ( animationPointerPropertyPath.endsWith( '.quaternion' ) )\n\t\t\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\t\telse\n\t\t\t\t\t\tTypedKeyframeTrack = ColorKeyframeTrack;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\t\t\tlet outputArray = parser._getArrayFromAccessor( outputAccessor );\n\n\t\t\t// convert fov values from radians to degrees\n\t\t\tif ( animationPointerPropertyPath.endsWith( '.fov' ) ) {\n\n\t\t\t\toutputArray = outputArray.map( value => value / Math.PI * 180 );\n\n\t\t\t}\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\tanimationPointerPropertyPath,\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tparser._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t\t// glTF has opacity animation as last component of baseColorFactor,\n\t\t\t// so we need to split that up here and create a separate opacity track if that is animated.\n\t\t\tif ( animationPointerPropertyPath && outputAccessor.itemSize === 4 &&\n\t\t\t\tanimationPointerPropertyPath.startsWith( '.materials.' ) && animationPointerPropertyPath.endsWith( '.color' ) ) {\n\n\t\t\t\tconst opacityArray = new Float32Array( outputArray.length / 4 );\n\n\t\t\t\tfor ( let j = 0, jl = outputArray.length / 4; j < jl; j += 1 ) {\n\n\t\t\t\t\topacityArray[ j ] = outputArray[ j * 4 + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst opacityTrack = new TypedKeyframeTrack(\n\t\t\t\t\tanimationPointerPropertyPath.replace( '.color', '.opacity' ),\n\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\topacityArray,\n\t\t\t\t\tinterpolation\n\t\t\t\t);\n\n\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\tif ( interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\tparser._createCubicSplineTrackInterpolant( track );\n\n\t\t\t\t}\n\n\t\t\t\ttracks.push( opacityTrack );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_tryResolveTargetId( path, type ) {\n\n\t\tlet name = '';\n\t\tif ( type === 'node' ) {\n\n\t\t\tname = path.substring( '/nodes/'.length );\n\n\t\t} else if ( type === 'material' ) {\n\n\t\t\tname = path.substring( '/materials/'.length );\n\n\t\t} else if ( type === 'light' ) {\n\n\t\t\tname = path.substring( '/extensions/KHR_lights_punctual/lights/'.length );\n\n\t\t} else if ( type === 'camera' ) {\n\n\t\t\tname = path.substring( '/cameras/'.length );\n\n\t\t}\n\n\t\tname = name.substring( 0, name.indexOf( '/' ) );\n\t\tconst index = Number.parseInt( name );\n\t\treturn index;\n\n\t}\n\n\t/* MOSTLY DUPLICATE of GLTFLoader.loadAnimation, but also tries to resolve KHR_animation_pointer. */\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst me = this;\n\t\tconst json = this.parser.json;\n\t\tconst parser = this.parser;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tlet nodeDependency = me.loadAnimationTargetFromChannelWithAnimationPointer( channel );\n\t\t\tif ( ! nodeDependency )\n\t\t\t\tnodeDependency = me.loadAnimationTargetFromChannel( channel );\n\n\t\t\tpendingNodes.push( nodeDependency );\n\t\t\tpendingInputAccessors.push( parser.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( parser.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tlet createdTracks = me.createAnimationTracksWithAnimationPointer( node, inputAccessor, outputAccessor, sampler, target );\n\t\t\t\tif ( ! createdTracks )\n\t\t\t\t\tcreatedTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n}\n\nexport { GLTFAnimationPointerExtension };\n"],
  "mappings": "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",
  "names": []
}
