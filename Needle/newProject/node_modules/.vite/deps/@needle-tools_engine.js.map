{
  "version": 3,
  "sources": ["../../@needle-tools/engine/src/engine/engine_audio.ts", "../../@needle-tools/engine/src/engine/engine_hot_reload.ts", "../../@needle-tools/engine/src/engine/engine_physics_rapier.ts", "../../@needle-tools/engine/src/engine/engine_test_utils.ts", "../../@needle-tools/engine/src/engine/export/state.ts", "../../@needle-tools/engine/src/engine/export/gltf/index.ts", "../../@needle-tools/engine/src/engine/webcomponents/needle-button.ts", "../../@needle-tools/engine/src/engine-components/codegen/components.ts", "../../@needle-tools/engine/src/engine-components/AvatarLoader.ts", "../../@needle-tools/engine/src/engine-components/export/usdz/extensions/DocumentExtension.ts", "../../@needle-tools/engine/src/engine-components/utils/EnvironmentScene.ts", "../../@needle-tools/engine/src/engine-components/CameraUtils.ts", "../../@needle-tools/engine/src/engine-components/AnimationUtilsAutoplay.ts", "../../@needle-tools/engine/src/needle-engine.ts"],
  "sourcesContent": ["import { AudioContext } from \"three\";\r\n\r\nimport { Application } from \"./engine_application.js\";\r\n\r\n/** \r\n * @internal \r\n * Ensure the audio context is resumed if it gets suspended or interrupted */\r\nexport function ensureAudioContextIsResumed() {\r\n    Application.registerWaitForInteraction(() => {\r\n        // this is a fix for https://github.com/mrdoob/three.js/issues/27779 & https://linear.app/needle/issue/NE-4257\r\n        const ctx = AudioContext.getContext();\r\n        ctx.addEventListener(\"statechange\", () => {\r\n            setTimeout(() => {\r\n                // on iOS the audiocontext can be interrupted: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/state#resuming_interrupted_play_states_in_ios_safari\r\n                const state = ctx.state as AudioContextState | \"interrupted\";\r\n                if (state === \"suspended\" || state === \"interrupted\") {\r\n                    ctx.resume()\r\n                        .then(() => { console.log(\"AudioContext resumed successfully\"); })\r\n                        .catch((e) => { console.log(\"Failed to resume AudioContext: \" + e); });\r\n                }\r\n            }, 500);\r\n        });\r\n    });\r\n}\r\nsetTimeout(ensureAudioContextIsResumed, 1000);", "import { addLog, LogType } from \"./debug/debug_overlay.js\";\r\nimport { addScriptToArrays, removeScriptFromContext } from \"./engine_mainloop_utils.js\"\r\nimport type { IComponent } from \"./engine_types.js\";\r\nimport { TypeStore } from \"./engine_typestore.js\";\r\nimport { getParam } from \"./engine_utils.js\";\r\n\r\nconst debug = getParam(\"debughotreload\");\r\n\r\ndeclare type BeforeUpdateArgs = {\r\n    type: string,\r\n    updates: Array<{ path: string, timestamp: number, acceptedPath: string, explicitImportRequired: boolean, type: string }>,\r\n}\r\n\r\n//@ts-ignore\r\nif (import.meta.hot) {\r\n    //@ts-ignore\r\n    import.meta.hot.on('vite:beforeUpdate', (cb: BeforeUpdateArgs) => {\r\n        if (debug) console.log(cb);\r\n        for (const update of cb.updates) {\r\n            console.log(\"[Needle Engine] Hot reloading \" + update.path);\r\n        }\r\n    });\r\n}\r\n\r\n\r\nlet isApplyingChanges = false;\r\n\r\nconst instances: Map<string, object[]> = new Map();\r\n\r\n/** @internal true during hot reload, can be used to modify behaviour in onEnable and onDisable */\r\nexport function isHotReloading() {\r\n    return isApplyingChanges;\r\n}\r\n\r\n/** @internal */\r\nexport function registerHotReloadType(instance: object) {\r\n    if (isApplyingChanges) return;\r\n    const type = instance.constructor;\r\n    const name = type.name;\r\n    if (!instances.has(name)) {\r\n        instances.set(name, [instance]);\r\n    }\r\n    else {\r\n        instances.get(name)?.push(instance);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function unregisterHotReloadType(instance: object) {\r\n    if (isApplyingChanges) return;\r\n    const type = instance.constructor;\r\n    const name = type.name;\r\n    const instancesOfType = instances.get(name);\r\n    if (!instancesOfType) return;\r\n    const idx = instancesOfType.indexOf(instance);\r\n    if (idx === -1) return;\r\n    instancesOfType.splice(idx, 1);\r\n}\r\n\r\n\r\nlet didRegisterUnhandledExceptionListener = false;\r\nfunction reloadPageOnHotReloadError() {\r\n    if (debug) return;\r\n    if (didRegisterUnhandledExceptionListener) return;\r\n    didRegisterUnhandledExceptionListener = true;\r\n\r\n    const error = console.error;\r\n    console.error = (...args: any[]) => {\r\n        if (args.length) {\r\n            const arg: string = args[0];\r\n            // When making changes in e.g. the engine package and then making changes in project scripts again that import the engine package: hot reload fails and reports redefinitions of types, we just reload the page in those cases for now\r\n            // editing a script in one package seems to work for now so it should be good enough for a start\r\n            if (typeof arg === \"string\" && arg.includes(\"[hmr] Failed to reload \")) {\r\n                console.log(\"[Needle Engine] Hot reloading failed\")\r\n                window.location.reload();\r\n                return;\r\n            }\r\n\r\n        }\r\n        error.apply(console, args);\r\n    };\r\n}\r\n\r\n\r\nexport function applyHMRChanges(newModule): boolean {\r\n\r\n    if (debug)\r\n        console.log(\"[HMR] Apply changes\", newModule, Object.keys(newModule));\r\n\r\n    reloadPageOnHotReloadError();\r\n\r\n    // console.dir(newModule);\r\n\r\n    for (const key of Object.keys(newModule)) {\r\n        try {\r\n            isApplyingChanges = true;\r\n\r\n            const typeToUpdate = TypeStore.get(key);\r\n            if (!typeToUpdate) {\r\n                if(debug) console.log(\"[HMR] Type not found: \" + key)\r\n                continue;\r\n            }\r\n            const newType = newModule[key];\r\n            const instancesOfType = instances.get(newType.name);\r\n\r\n            let hotReloadMessage = \"[Needle Engine] Updating type: \" + key;\r\n            const typesCount = instancesOfType?.length ?? -1;\r\n            if (typesCount > 0) hotReloadMessage += \" x\" + typesCount;\r\n            else hotReloadMessage += \" - no instances\";\r\n            console.log(hotReloadMessage);\r\n\r\n            // Update prototype (methods and properties)\r\n            const previousMethods = Object.getOwnPropertyNames(typeToUpdate.prototype);\r\n            const methodsAndProperties = Object.getOwnPropertyDescriptors(newType.prototype);\r\n            for (const typeKey in methodsAndProperties) {\r\n                const desc = methodsAndProperties[typeKey];\r\n                if (!desc.writable) continue;\r\n                typeToUpdate.prototype[typeKey] = newModule[key].prototype[typeKey];\r\n            }\r\n            // Remove methods that are no longer present\r\n            for (const typeKey of previousMethods) {\r\n                if (!methodsAndProperties[typeKey]) {\r\n                    delete typeToUpdate.prototype[typeKey];\r\n                }\r\n            }\r\n\r\n            // Update fields (we only add new fields if they are undefined)\r\n            // we create a instance to get access to the fields\r\n            if (instancesOfType) {\r\n                const newTypeInstance = new newType();\r\n                const keys = Object.getOwnPropertyDescriptors(newTypeInstance);\r\n                for (const inst of instancesOfType) {\r\n                    const componentInstance = inst as unknown as IComponent;\r\n                    const isComponent = componentInstance.isComponent === true;\r\n                    const active = isComponent ? componentInstance.activeAndEnabled : true;\r\n                    const context = isComponent ? componentInstance.context : undefined;\r\n                    try {\r\n                        if (isComponent && context) {\r\n                            removeScriptFromContext(componentInstance, context);\r\n                        }\r\n                        if (isComponent && active) {\r\n                            componentInstance.enabled = false;\r\n                        }\r\n\r\n                        if (inst[\"onBeforeHotReloadFields\"]) {\r\n                            const res = inst[\"onBeforeHotReloadFields\"]();\r\n                            if (res === false) continue;\r\n                        }\r\n                        for (const key in keys) {\r\n                            const desc = keys[key];\r\n                            if (!desc.writable) continue;\r\n                            if (inst[key] === undefined) {\r\n                                inst[key] = newTypeInstance[key];\r\n                            }\r\n                            // if its a function but not on the prototype\r\n                            // then its a bound method that needs to be rebound\r\n                            else if (typeof inst[key] === \"function\" && !inst[key].prototype) {\r\n                                const boundMethod = inst[key];\r\n                                // try to get the target method name\r\n                                const targetMethodName = boundMethod.name;\r\n                                const prefix = \"bound \"; // < magic prefix\r\n                                if (targetMethodName === prefix) continue;\r\n                                const name = boundMethod.name.substring(prefix.length);\r\n                                // if the target method name still exists on the new prototype\r\n                                // we want to rebind it and assign it to the field\r\n                                // Beware that this will not work if the method is added to some event listener etc\r\n                                const newTarget = newType.prototype[name];\r\n                                if (newTarget)\r\n                                    inst[key] = newTarget.bind(inst);\r\n                            }\r\n                        }\r\n                        if (inst[\"onAfterHotReloadFields\"]) inst[\"onAfterHotReloadFields\"]();\r\n                    }\r\n                    finally {\r\n                        if (isComponent && context) {\r\n                            addScriptToArrays(componentInstance, context);\r\n                        }\r\n                        if (isComponent && active) {\r\n                            componentInstance.enabled = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (debug) console.error(err);\r\n            // we only want to invalidate changes if we debug hot reload\r\n            else return false;\r\n        }\r\n        finally {\r\n            isApplyingChanges = false;\r\n            addLog(LogType.Log, \"Script changes applied (HMR)\")\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n", "import type { Ball, Collider, ColliderDesc, Cuboid, EventQueue, QueryFilterFlags, Ray, RigidBody, RigidBodyDesc, World } from '@dimforge/rapier3d-compat';\r\nimport { BufferAttribute, BufferGeometry, InterleavedBufferAttribute, LineBasicMaterial, LineSegments, Matrix4, Mesh, Object3D, Quaternion, Vector3 } from 'three'\r\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js'\r\n\r\nimport { CollisionDetectionMode, PhysicsMaterialCombine } from '../engine/engine_physics.types.js';\r\nimport { MeshCollider } from '../engine-components/Collider.js';\r\nimport { isDevEnvironment } from './debug/debug.js';\r\nimport { ContextEvent, ContextRegistry } from './engine_context_registry.js';\r\nimport { foreachComponent } from './engine_gameobject.js';\r\nimport { Gizmos } from './engine_gizmos.js';\r\nimport { Mathf } from './engine_math.js';\r\nimport { MODULES } from './engine_modules.js';\r\nimport { getWorldPosition, getWorldQuaternion, getWorldScale, setWorldPositionXYZ, setWorldQuaternionXYZW } from \"./engine_three_utils.js\"\r\nimport type {\r\n    IBoxCollider,\r\n    ICollider,\r\n    IComponent,\r\n    IContext,\r\n    IGameObject,\r\n    IPhysicsEngine,\r\n    IRigidbody,\r\n    ISphereCollider,\r\n    Vec2,\r\n    Vec3,\r\n} from './engine_types.js';\r\nimport { Collision, ContactPoint } from './engine_types.js';\r\nimport { SphereOverlapResult } from './engine_types.js';\r\nimport { CircularBuffer, getParam } from \"./engine_utils.js\"\r\n\r\nconst debugPhysics = getParam(\"debugphysics\");\r\nconst debugColliderPlacement = getParam(\"debugcolliderplacement\");\r\nconst debugCollisions = getParam(\"debugcollisions\");\r\nconst showColliders = getParam(\"showcolliders\");\r\nconst showPhysicsRaycasts = getParam(\"debugraycasts\");\r\n\r\n\r\n/** on physics body and references the needle component */\r\nconst $componentKey = Symbol(\"needle component\");\r\n/** on needle component and references physics body */\r\nconst $bodyKey = Symbol(\"physics body\");\r\nconst $colliderRigidbody = Symbol(\"rigidbody\");\r\n\r\n\r\ndeclare const NEEDLE_USE_RAPIER: boolean;\r\nglobalThis[\"NEEDLE_USE_RAPIER\"] = globalThis[\"NEEDLE_USE_RAPIER\"] !== undefined ? globalThis[\"NEEDLE_USE_RAPIER\"] : true;\r\nif (debugPhysics)\r\n    console.log(\"Use Rapier\", NEEDLE_USE_RAPIER, globalThis[\"NEEDLE_USE_RAPIER\"])\r\n\r\nif (NEEDLE_USE_RAPIER) {\r\n    ContextRegistry.registerCallback(ContextEvent.ContextCreationStart, evt => {\r\n        if (debugPhysics)\r\n            console.log(\"Register rapier physics backend\")\r\n        evt.context.physics.engine = new RapierPhysics(evt.context);\r\n        // We do not initialize physics immediately to avoid loading the physics engine if it is not needed\r\n    });\r\n}\r\n\r\n\r\ndeclare type PhysicsBody = {\r\n    translation(): { x: number, y: number, z: number }\r\n    rotation(): { x: number, y: number, z: number, w: number }\r\n}\r\n\r\nexport class RapierPhysics implements IPhysicsEngine {\r\n\r\n    debugRenderColliders: boolean = false;\r\n    debugRenderRaycasts: boolean = false;\r\n\r\n    removeBody(obj: IComponent) {\r\n        if (!obj) return;\r\n        this.validate();\r\n        const body = obj[$bodyKey];\r\n        obj[$bodyKey] = null;\r\n        if (body && this.world) {\r\n            const index = this.objects.findIndex(o => o === obj);\r\n            if (index >= 0) {\r\n                const rapierBody = this.bodies[index];\r\n                // Remove references\r\n                this.bodies.splice(index, 1);\r\n                this.objects.splice(index, 1);\r\n\r\n\r\n                // Remove the collider from the physics world\r\n                if (rapierBody instanceof MODULES.RAPIER_PHYSICS.MODULE.Collider) {\r\n                    const rapierCollider = rapierBody as Collider;\r\n                    this.world?.removeCollider(rapierCollider, true);\r\n\r\n                    // also remove the rigidbody if it doesnt have colliders anymore\r\n                    const rapierRigidbody: RigidBody | null = rapierCollider.parent();\r\n                    if (rapierRigidbody && rapierRigidbody.numColliders() <= 0) {\r\n                        const rigidbody = rapierRigidbody[$componentKey] as IRigidbody;\r\n                        if (rigidbody) {\r\n                            // If the collider was attached to a rigidbody and this rigidbody now has no colliders anymore we should ignore it - because the Rigidbody component will delete itself\r\n                        }\r\n                        else {\r\n                            // But if there is no explicit rigidbody needle component then the colliders did create it implictly and thus we need to remove it here:\r\n                            this.world?.removeRigidBody(rapierRigidbody);\r\n                        }\r\n                    }\r\n                }\r\n                // Remove the rigidbody from the physics world\r\n                else if (rapierBody instanceof MODULES.RAPIER_PHYSICS.MODULE.RigidBody) {\r\n                    if (rapierBody.numColliders() <= 0) {\r\n                        this.world?.removeRigidBody(rapierBody);\r\n                    }\r\n                    else {\r\n                        if (isDevEnvironment()) {\r\n                            if (!rapierBody[\"did_log_removing\"]) {\r\n                                setTimeout(() => {\r\n                                    if (rapierBody.numColliders() > 0) {\r\n                                        rapierBody[\"did_log_removing\"] = true;\r\n                                        console.warn(\"RapierPhysics: removing rigidbody with colliders from the physics world is not possible right now, please remove the colliders first\");\r\n                                    }\r\n                                }, 1);\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateBody(comp: ICollider | IRigidbody, translation: boolean, rotation: boolean) {\r\n        this.validate();\r\n        if (!this.enabled) return;\r\n        if (comp.destroyed || !comp.gameObject) return;\r\n        if (!translation && !rotation) return;\r\n\r\n        if ((comp as ICollider).isCollider === true) {\r\n            // const collider = comp as ICollider;\r\n            console.warn(\"TODO: implement updating collider position\");\r\n        }\r\n        else {\r\n            const rigidbody = comp as IRigidbody;\r\n            const body = rigidbody[$bodyKey];\r\n            if (body) {\r\n                this.syncPhysicsBody(rigidbody.gameObject, body, translation, rotation);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateProperties(obj: IRigidbody | ICollider) {\r\n        this.validate();\r\n\r\n        if ((obj as ICollider).isCollider) {\r\n            const col = obj as ICollider;\r\n            const body = col[$bodyKey];\r\n            if (body) {\r\n                this.internalUpdateColliderProperties(col, body);\r\n                if (col.sharedMaterial)\r\n                    this.updatePhysicsMaterial(col);\r\n            }\r\n        }\r\n        else {\r\n            const rb = obj as IRigidbody;\r\n            const physicsBody = this.internal_getRigidbody(rb);\r\n            if (physicsBody) {\r\n                this.internalUpdateRigidbodyProperties(rb, physicsBody);\r\n            }\r\n        }\r\n    }\r\n    addForce(rigidbody: IRigidbody, force: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rigidbody);\r\n        if (body) body.addForce(force, wakeup)\r\n        else console.warn(\"Rigidbody doesn't exist: can not apply force (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n    addImpulse(rigidbody: IRigidbody, force: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rigidbody);\r\n        if (body) body.applyImpulse(force, wakeup);\r\n        else console.warn(\"Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n    getLinearVelocity(comp: IRigidbody | ICollider): Vec3 | null {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(comp);\r\n        if (body) {\r\n            const vel = body.linvel();\r\n            return vel;\r\n        }\r\n        // else console.warn(\"Rigidbody doesn't exist: can not get linear velocity (does your object with the Rigidbody have a collider?)\");\r\n        return null;\r\n    }\r\n    getAngularVelocity(rb: IRigidbody): Vec3 | null {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) {\r\n            const vel = body.angvel();\r\n            return vel;\r\n        }\r\n        // else console.warn(\"Rigidbody doesn't exist: can not get angular velocity (does your object with the Rigidbody have a collider?)\");\r\n        return null;\r\n    }\r\n    resetForces(rb: IRigidbody, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        body?.resetForces(wakeup);\r\n    }\r\n    resetTorques(rb: IRigidbody, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        body?.resetTorques(wakeup);\r\n    }\r\n    applyImpulse(rb: IRigidbody, vec: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) body.applyImpulse(vec, wakeup);\r\n        else console.warn(\"Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n\r\n    wakeup(rb: IRigidbody) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) body.wakeUp();\r\n        else console.warn(\"Rigidbody doesn't exist: can not wake up (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n    isSleeping(rb: IRigidbody) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        return body?.isSleeping();\r\n    }\r\n    setAngularVelocity(rb: IRigidbody, vec: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) body.setAngvel(vec, wakeup);\r\n        else console.warn(\"Rigidbody doesn't exist: can not set angular velocity (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n    setLinearVelocity(rb: IRigidbody, vec: Vec3, wakeup: boolean) {\r\n        this.validate();\r\n        const body = this.internal_getRigidbody(rb);\r\n        if (body) body.setLinvel(vec, wakeup);\r\n        else console.warn(\"Rigidbody doesn't exist: can not set linear velocity (does your object with the Rigidbody have a collider?)\");\r\n    }\r\n\r\n    private readonly context?: IContext;\r\n    private _initializePromise?: Promise<boolean>;\r\n    private _isInitialized: boolean = false;\r\n\r\n    constructor(ctx: IContext) {\r\n        this.context = ctx;\r\n    }\r\n\r\n    get isInitialized() { return this._isInitialized; }\r\n\r\n    async initialize() {\r\n        if (!this._initializePromise)\r\n            this._initializePromise = this.internalInitialization();\r\n        return this._initializePromise;\r\n    }\r\n\r\n    private async internalInitialization() {\r\n        if (getParam(\"__nophysics\")) {\r\n            console.warn(\"Physics are disabled\");\r\n            return false;\r\n        }\r\n        if (debugPhysics) console.log(\"Initialize rapier physics engine\");\r\n        // NEEDLE_PHYSICS_INIT_START\r\n        // use .env file with VITE_NEEDLE_USE_RAPIER=false to treeshake rapier\r\n        // @ts-ignore\r\n        if (\"env\" in import.meta && import.meta.env.VITE_NEEDLE_USE_RAPIER === \"false\") {\r\n            if (debugPhysics) console.log(\"Rapier disabled\");\r\n            return false;\r\n        }\r\n        // Can be transformed during build time to disable rapier\r\n        if (!NEEDLE_USE_RAPIER) return false;\r\n        if (this._hasCreatedWorld) {\r\n            console.error(\"Invalid call to create physics world: world is already created\");\r\n            return true;\r\n        }\r\n        this._hasCreatedWorld = true;\r\n        if (MODULES.RAPIER_PHYSICS.MAYBEMODULE == undefined) {\r\n            if (debugPhysics) console.trace(\"Loading rapier physics engine\");\r\n            const module = await MODULES.RAPIER_PHYSICS.load();\r\n            await module.init();\r\n        }\r\n        if (debugPhysics) console.log(\"Physics engine initialized, creating world...\");\r\n        this._world = new MODULES.RAPIER_PHYSICS.MODULE.World(this._gravity);\r\n        this.rapierRay = new MODULES.RAPIER_PHYSICS.MODULE.Ray({ x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 });\r\n        this.enabled = true;\r\n        this._isInitialized = true;\r\n        if (debugPhysics) console.log(\"Physics world created\");\r\n        return true;\r\n        // NEEDLE_PHYSICS_INIT_END\r\n    }\r\n\r\n    /** Check is the physics engine has been initialized and the call can be made */\r\n    private validate() {\r\n        if (!this._isInitialized) {\r\n            if (debugPhysics) {\r\n                this[\"_lastWarnTime\"] = this[\"_lastWarnTime\"] ?? 0;\r\n                if (Date.now() - this[\"_lastWarnTime\"] > 1000) {\r\n                    this[\"_lastWarnTime\"] = Date.now();\r\n                    console.warn(\"Physics engine is not initialized\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private rapierRay!: Ray;\r\n    private raycastVectorsBuffer = new CircularBuffer(() => new Vector3(), 10);\r\n\r\n    public raycast(origin?: Vec2 | Vec3, direction?: Vec3, options?: {\r\n        maxDistance?: number,\r\n        /** True if you want to also hit objects when the raycast starts from inside a collider */\r\n        solid?: boolean,\r\n        queryFilterFlags?: QueryFilterFlags,\r\n        filterGroups?: number,\r\n        /** Return false to ignore this collider */\r\n        filterPredicate?: (c: ICollider) => boolean,\r\n        /** When enabled the hit object's layer will be tested. If layer 2 is enabled the object will be ignored (Layer 2 == IgnoreRaycast) \r\n         * If not set the raycast will ignore objects in the IgnoreRaycast layer (default: true)\r\n         * @default undefined \r\n        */\r\n        useIgnoreRaycastLayer?: boolean\r\n    })\r\n        : null | { point: Vector3, collider: ICollider } {\r\n\r\n        if (!this._isInitialized) {\r\n            console.log(\"Physics engine is not initialized\");\r\n            return null;\r\n        }\r\n\r\n        let maxDistance = options?.maxDistance;\r\n        let solid = options?.solid;\r\n\r\n        if (maxDistance === undefined) maxDistance = Infinity;\r\n        if (solid === undefined) solid = true;\r\n\r\n        const ray = this.getPhysicsRay(this.rapierRay, origin, direction);\r\n        if (!ray) return null;\r\n\r\n        if (this.debugRenderRaycasts || showPhysicsRaycasts) Gizmos.DrawRay(ray.origin, ray.dir, 0x0000ff, 1);\r\n\r\n        const hit = this.world?.castRay(ray, maxDistance, solid, options?.queryFilterFlags, options?.filterGroups, undefined, undefined, (c) => {\r\n            const component = c[$componentKey];\r\n            if (options?.filterPredicate) return options.filterPredicate(component);\r\n            if (options?.useIgnoreRaycastLayer !== false) {\r\n                // ignore objects in the IgnoreRaycast=2 layer\r\n                return !component?.gameObject.layers.isEnabled(2);\r\n            }\r\n            return true;\r\n        });\r\n        if (hit) {\r\n            const point = ray.pointAt(hit.timeOfImpact);\r\n            const vec = this.raycastVectorsBuffer.get();\r\n            vec.set(point.x, point.y, point.z);\r\n            return { point: vec, collider: hit.collider[$componentKey] };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public raycastAndGetNormal(origin?: Vec2 | Vec3, direction?: Vec3, options?: {\r\n        maxDistance?: number,\r\n        /** True if you want to also hit objects when the raycast starts from inside a collider */\r\n        solid?: boolean,\r\n        queryFilterFlags?: QueryFilterFlags,\r\n        filterGroups?: number,\r\n        /** Return false to ignore this collider */\r\n        filterPredicate?: (c: ICollider) => boolean,\r\n        /** When enabled the hit object's layer will be tested. If layer 2 is enabled the object will be ignored (Layer 2 == IgnoreRaycast) \r\n         * If not set the raycast will ignore objects in the IgnoreRaycast layer (default: true)\r\n         * @default undefined \r\n        */\r\n        useIgnoreRaycastLayer?: boolean\r\n    })\r\n        : null | { point: Vector3, normal: Vector3, collider: ICollider } {\r\n\r\n        if (!this._isInitialized) {\r\n            return null;\r\n        }\r\n\r\n        let maxDistance = options?.maxDistance;\r\n        let solid = options?.solid;\r\n\r\n        if (maxDistance === undefined) maxDistance = Infinity;\r\n        if (solid === undefined) solid = true;\r\n\r\n        const ray = this.getPhysicsRay(this.rapierRay, origin, direction);\r\n        if (!ray) return null;\r\n\r\n        if (this.debugRenderRaycasts || showPhysicsRaycasts) Gizmos.DrawRay(ray.origin, ray.dir, 0x0000ff, 1);\r\n\r\n        const hit = this.world?.castRayAndGetNormal(ray, maxDistance, solid, options?.queryFilterFlags, options?.filterGroups, undefined, undefined, (c) => {\r\n            const component = c[$componentKey];\r\n            if (options?.filterPredicate) return options.filterPredicate(component);\r\n            if (options?.useIgnoreRaycastLayer !== false) {\r\n                // ignore objects in the IgnoreRaycast=2 layer\r\n                return !component?.gameObject.layers.isEnabled(2);\r\n            }\r\n            return true;\r\n        });\r\n        if (hit) {\r\n            const point = ray.pointAt(hit.timeOfImpact);\r\n            const normal = hit.normal;\r\n            const vec = this.raycastVectorsBuffer.get();\r\n            const nor = this.raycastVectorsBuffer.get();\r\n            vec.set(point.x, point.y, point.z);\r\n            nor.set(normal.x, normal.y, normal.z);\r\n            return { point: vec, normal: nor, collider: hit.collider[$componentKey] };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private getPhysicsRay(ray: Ray, origin?: Vec2 | Vec3, direction?: Vec3): Ray | null {\r\n        const cam = this.context?.mainCamera;\r\n        if (origin === undefined) {\r\n            const pos = this.context?.input.getPointerPosition(0);\r\n            if (pos) origin = pos;\r\n            else return null;\r\n        }\r\n        // if we get origin in 2d space we need to project it to 3d space\r\n        if (origin[\"z\"] === undefined) {\r\n            if (!cam) {\r\n                console.error(\"Can not perform raycast from 2d point - no main camera found\");\r\n                return null;\r\n            }\r\n            const vec3 = this.raycastVectorsBuffer.get();\r\n            vec3.x = origin.x;\r\n            vec3.y = origin.y;\r\n            vec3.z = 0;\r\n            // if the origin is in screen space we need to convert it to raycaster space\r\n            if (vec3.x > 1 || vec3.y > 1 || vec3.y < -1 || vec3.x < -1) {\r\n                if (debugPhysics) console.warn(\"Converting screenspace to raycast space\", vec3)\r\n                this.context?.input.convertScreenspaceToRaycastSpace(vec3);\r\n            }\r\n            vec3.unproject(cam);\r\n            origin = vec3;\r\n        }\r\n\r\n        const o = origin as Vec3;\r\n\r\n        ray.origin.x = o.x;\r\n        ray.origin.y = o.y;\r\n        ray.origin.z = o.z;\r\n        const vec = this.raycastVectorsBuffer.get();\r\n        if (direction)\r\n            vec.set(direction.x, direction.y, direction.z);\r\n        else {\r\n            if (!cam) {\r\n                console.error(\"Can not perform raycast - no camera found\");\r\n                return null;\r\n            }\r\n            vec.set(ray.origin.x, ray.origin.y, ray.origin.z);\r\n            const camPosition = getWorldPosition(cam);\r\n            vec.sub(camPosition);\r\n        }\r\n        // we need to normalize the ray because our input is a max travel length and the direction may be not normalized\r\n        vec.normalize();\r\n        ray.dir.x = vec.x;\r\n        ray.dir.y = vec.y;\r\n        ray.dir.z = vec.z;\r\n        // Gizmos.DrawRay(ray.origin, ray.dir, 0xff0000, Infinity);\r\n        return ray;\r\n    }\r\n\r\n\r\n    private rapierSphere: Ball | null = null;\r\n    private readonly rapierColliderArray: Array<SphereOverlapResult> = [];\r\n    private readonly rapierIdentityRotation = { x: 0, y: 0, z: 0, w: 1 };\r\n    private readonly rapierForwardVector = { x: 0, y: 0, z: 1 };\r\n    /** Precice sphere overlap detection using rapier against colliders\r\n     * @param point center of the sphere in worldspace\r\n     * @param radius radius of the sphere\r\n     * @returns array of colliders that overlap with the sphere. Note: they currently only contain the collider and the gameobject\r\n     */\r\n    public sphereOverlap(point: Vector3, radius: number): Array<SphereOverlapResult> {\r\n        this.rapierColliderArray.length = 0;\r\n        if (!this._isInitialized) {\r\n            return this.rapierColliderArray;\r\n        }\r\n        if (!this.world) return this.rapierColliderArray;\r\n        this.rapierSphere ??= new MODULES.RAPIER_PHYSICS.MODULE.Ball(radius);\r\n        this.rapierSphere.radius = radius;\r\n\r\n        if (this.debugRenderRaycasts || showPhysicsRaycasts) Gizmos.DrawWireSphere(point, radius, 0x3344ff, 1);\r\n        this.world.intersectionsWithShape(point,\r\n            this.rapierIdentityRotation,\r\n            this.rapierSphere,\r\n            col => {\r\n                const collider = col[$componentKey] as ICollider\r\n                // if (collider.gameObject.layers.isEnabled(2)) return true;\r\n                const intersection = new SphereOverlapResult(collider.gameObject, collider);\r\n                this.rapierColliderArray.push(intersection);\r\n                return true; // Return `false` instead if we want to stop searching for other colliders that contain this point.\r\n            },\r\n            // TODO: it seems as QueryFilterFlags.EXCLUDE_SENSORS also excludes DYNAMIC Rigidbodies (only if they're set to kinematic)\r\n            undefined, // QueryFilterFlags.EXCLUDE_SENSORS, \r\n            undefined, undefined, undefined,\r\n            col => {\r\n                // we don't want to raycast against triggers (see comment about Exclude Sensors above)\r\n                if (col.isSensor()) return false;\r\n                const collider = col[$componentKey] as ICollider\r\n                return collider.gameObject.layers.isEnabled(2) == false\r\n            }\r\n        );\r\n        return this.rapierColliderArray;\r\n\r\n\r\n        // TODO: this only returns one hit\r\n        // let filterGroups = 0xffffffff;\r\n        // filterGroups &= ~(1 << 2);\r\n        // const hit: ShapeColliderTOI | null = this.world.castShape(point,\r\n        //     this.rapierIdentityRotation,\r\n        //     this.rapierForwardVector,\r\n        //     this.rapierSphere,\r\n        //     0,\r\n        //     QueryFilterFlags.EXCLUDE_SENSORS,\r\n        //     // filterGroups,\r\n        // );\r\n        // // console.log(hit);\r\n        // if (hit) {\r\n        //     const collider = hit.collider[$componentKey] as ICollider\r\n        //     const intersection = new SphereOverlapResult(collider.gameObject);\r\n        //     this.rapierColliderArray.push(intersection);\r\n        //     // const localpt = hit.witness2;\r\n        //     // // const normal = hit.normal2;\r\n        //     // const hitPoint = new Vector3(localpt.x, localpt.y, localpt.z);\r\n        //     // // collider.gameObject.localToWorld(hitPoint);\r\n        //     // // const normalPt = new Vector3(normal.x, normal.y, normal.z);\r\n        //     // // const mat = new Matrix4().setPosition(point).scale(new Vector3(radius, radius, radius));\r\n        //     // // hitPoint.applyMatrix4(mat);\r\n        //     // console.log(hit.witness2)\r\n        //     // // hitPoint.add(point);\r\n        //     // const dist = hitPoint.distanceTo(point);\r\n        // }\r\n\r\n        // return this.rapierColliderArray;\r\n    }\r\n\r\n\r\n\r\n\r\n    // physics simulation\r\n\r\n    enabled: boolean = false;\r\n    /** Get access to the rapier world */\r\n    public get world(): World | undefined { return this._world };\r\n\r\n    private _tempPosition: Vector3 = new Vector3();\r\n    private _tempQuaternion: Quaternion = new Quaternion();\r\n    private _tempScale: Vector3 = new Vector3();\r\n    private _tempMatrix: Matrix4 = new Matrix4();\r\n\r\n    private static _didLoadPhysicsEngine: boolean = false;\r\n\r\n    private _isUpdatingPhysicsWorld: boolean = false;\r\n    get isUpdating(): boolean { return this._isUpdatingPhysicsWorld; }\r\n\r\n\r\n    private _world?: World;\r\n    private _hasCreatedWorld: boolean = false;\r\n    private eventQueue?: EventQueue;\r\n    private collisionHandler?: PhysicsCollisionHandler;\r\n\r\n\r\n    private objects: IComponent[] = [];\r\n    private bodies: PhysicsBody[] = [];\r\n\r\n    private _meshCache: Map<string, Float32Array> = new Map<string, Float32Array>();\r\n\r\n    private _gravity = { x: 0.0, y: -9.81, z: 0.0 };\r\n\r\n    get gravity() {\r\n        return this.world?.gravity ?? this._gravity;\r\n    }\r\n\r\n    set gravity(value: Vec3) {\r\n        if (this.world) {\r\n            this.world.gravity = value;\r\n        }\r\n        else {\r\n            this._gravity = value;\r\n        }\r\n    }\r\n\r\n    clearCaches() {\r\n        this._meshCache.clear();\r\n        if (this.eventQueue?.raw)\r\n            this.eventQueue?.free();\r\n        if (this.world?.bodies)\r\n            this.world?.free();\r\n    }\r\n\r\n    async addBoxCollider(collider: ICollider, size: Vector3) {\r\n        if (!this._isInitialized)\r\n            await this.initialize();\r\n        if (!collider.activeAndEnabled) return;\r\n\r\n        if (!this.enabled) {\r\n            if (debugPhysics) console.warn(\"Physics are disabled\");\r\n            return;\r\n        }\r\n        const obj = collider.gameObject;\r\n        const scale = getWorldScale(obj, this._tempPosition).multiply(size);\r\n        scale.multiplyScalar(0.5);\r\n\r\n        // prevent negative scale\r\n        if (scale.x < 0)\r\n            scale.x = Math.abs(scale.x);\r\n        if (scale.y < 0)\r\n            scale.y = Math.abs(scale.y);\r\n        if (scale.z < 0)\r\n            scale.z = Math.abs(scale.z);\r\n\r\n        // prevent zero scale - seems normals are flipped otherwise\r\n        if (scale.x == 0) scale.x = 0.0000001;\r\n        if (scale.y == 0) scale.y = 0.0000001;\r\n        if (scale.z == 0) scale.z = 0.0000001;\r\n\r\n        const desc = MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.cuboid(scale.x, scale.y, scale.z);\r\n        // const objectLayerMask = collider.gameObject.layers.mask;\r\n        // const mask = objectLayerMask & ~2;\r\n        // TODO: https://rapier.rs/docs/user_guides/javascript/colliders/#collision-groups-and-solver-groups\r\n        // desc.setCollisionGroups(objectLayerMask);\r\n        this.createCollider(collider, desc);\r\n    }\r\n\r\n    async addSphereCollider(collider: ICollider) {\r\n        if (!this._isInitialized)\r\n            await this.initialize();\r\n        if (!collider.activeAndEnabled) return;\r\n        if (!this.enabled) {\r\n            if (debugPhysics) console.warn(\"Physics are disabled\");\r\n            return;\r\n        }\r\n        const desc = MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.ball(.5);\r\n        this.createCollider(collider, desc);\r\n        this.updateProperties(collider);\r\n    }\r\n\r\n    async addCapsuleCollider(collider: ICollider, height: number, radius: number) {\r\n        if (!this._isInitialized)\r\n            await this.initialize();\r\n        if (!collider.activeAndEnabled) return;\r\n        if (!this.enabled) {\r\n            if (debugPhysics) console.warn(\"Physics are disabled\");\r\n            return;\r\n        }\r\n        const obj = collider.gameObject;\r\n        const scale = getWorldScale(obj, this._tempPosition);\r\n        // Prevent negative scales\r\n        scale.x = Math.abs(scale.x);\r\n        scale.y = Math.abs(scale.y);\r\n        const finalRadius = radius * scale.x;\r\n        // half height = distance between capsule origin and top sphere origin (not the top end of the capsule)\r\n        height = Math.max(height, finalRadius * 2);\r\n        const hh = Mathf.clamp((height * .5 * scale.y) - (radius * scale.x), 0, Number.MAX_SAFE_INTEGER);\r\n        const desc = MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.capsule(hh, finalRadius);\r\n        this.createCollider(collider, desc);\r\n    }\r\n\r\n    async addMeshCollider(collider: ICollider, mesh: Mesh, convex: boolean, extraScale?: Vector3) {\r\n        \r\n        // capture the geometry before waiting for phyiscs engine\r\n        let geo = mesh.geometry;\r\n        if (!geo) {\r\n            if (debugPhysics) console.warn(\"Missing mesh geometry\", mesh.name);\r\n            return;\r\n        }\r\n\r\n        // check if mesh is indexed, if not generate indices\r\n        if (!geo.index?.array?.length) {\r\n            console.warn(`Your MeshCollider is missing vertices or indices in the assined mesh \\\"${mesh.name}\\\". Consider providing an indexed geometry.`);\r\n            geo = BufferGeometryUtils.mergeVertices(geo);\r\n        }\r\n\r\n        let positions: Float32Array | null = null;\r\n\r\n        const positionAttribute = geo.getAttribute(\"position\") as BufferAttribute | InterleavedBufferAttribute;\r\n        if (positionAttribute instanceof InterleavedBufferAttribute) {\r\n            const count = positionAttribute.count;\r\n            positions = new Float32Array(count * 3);\r\n            for (let i = 0; i < count; i++) {\r\n                const x = positionAttribute.getX(i);\r\n                const y = positionAttribute.getY(i);\r\n                const z = positionAttribute.getZ(i);\r\n                positions[i * 3] = x;\r\n                positions[i * 3 + 1] = y;\r\n                positions[i * 3 + 2] = z;\r\n            }\r\n        }\r\n        else {\r\n            positions = positionAttribute.array as Float32Array;\r\n        }\r\n\r\n        await this.initialize();\r\n\r\n        if (!this.enabled) {\r\n            if (debugPhysics) console.warn(\"Physics are disabled\");\r\n            return;\r\n        }\r\n\r\n        if (!collider.activeAndEnabled) return;\r\n        \r\n\r\n        // let positions = geo.getAttribute(\"position\").array as Float32Array;\r\n        const indices = geo.index?.array as Uint32Array;\r\n        \r\n        const scale = collider.gameObject.worldScale.clone();\r\n        if(extraScale) scale.multiply(extraScale);\r\n\r\n        // scaling seems not supported yet https://github.com/dimforge/rapier/issues/243\r\n        if (Math.abs(scale.x - 1) > 0.0001 || Math.abs(scale.y - 1) > 0.0001 || Math.abs(scale.z - 1) > 0.0001) {\r\n            const key = `${geo.uuid}_${scale.x}_${scale.y}_${scale.z}_${convex}`;\r\n            if (this._meshCache.has(key)) {\r\n                if (debugPhysics) console.warn(\"Use cached mesh collider\")\r\n                positions = this._meshCache.get(key)!;\r\n            }\r\n            else {\r\n                if (debugPhysics || isDevEnvironment()) console.debug(`[Performance] Your MeshCollider \\\"${collider.name}\\\" is scaled: consider applying the scale to the collider mesh instead (${scale.x}, ${scale.y}, ${scale.z})`);\r\n                const scaledPositions = new Float32Array(positions.length);\r\n                for (let i = 0; i < positions.length; i += 3) {\r\n                    scaledPositions[i] = positions[i] * scale.x;\r\n                    scaledPositions[i + 1] = positions[i + 1] * scale.y;\r\n                    scaledPositions[i + 2] = positions[i + 2] * scale.z;\r\n                }\r\n                positions = scaledPositions;\r\n                this._meshCache.set(key, scaledPositions);\r\n            }\r\n        }\r\n        const desc = convex\r\n            ? MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.convexHull(positions)\r\n            : MODULES.RAPIER_PHYSICS.MODULE.ColliderDesc.trimesh(positions, indices);\r\n        if (desc) {\r\n            this.createCollider(collider, desc);\r\n            // col.setMassProperties(1, { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 0, w: 1 });\r\n            // rb?.setTranslation({ x: 0, y: 2, z: 0 });\r\n            // col.setTranslationWrtParent(new Vector3(0,2,0));\r\n\r\n        }\r\n    }\r\n\r\n    updatePhysicsMaterial(col: ICollider) {\r\n        if (!col) return;\r\n        const physicsMaterial = col.sharedMaterial;\r\n        const rapier_collider = col[$bodyKey] as Collider;\r\n        if (!rapier_collider) return;\r\n\r\n        if (physicsMaterial) {\r\n            if (physicsMaterial.bounciness !== undefined)\r\n                rapier_collider.setRestitution(physicsMaterial.bounciness);\r\n\r\n            if (physicsMaterial.bounceCombine !== undefined) {\r\n                switch (physicsMaterial.bounceCombine) {\r\n                    case PhysicsMaterialCombine.Average:\r\n                        rapier_collider.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Maximum:\r\n                        rapier_collider.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Minimum:\r\n                        rapier_collider.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Multiply:\r\n                        rapier_collider.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (physicsMaterial.dynamicFriction !== undefined)\r\n                rapier_collider.setFriction(physicsMaterial.dynamicFriction);\r\n\r\n            if (physicsMaterial.frictionCombine !== undefined) {\r\n                switch (physicsMaterial.frictionCombine) {\r\n                    case PhysicsMaterialCombine.Average:\r\n                        rapier_collider.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Maximum:\r\n                        rapier_collider.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Minimum:\r\n                        rapier_collider.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Multiply:\r\n                        rapier_collider.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Get the rapier body for a Needle component */\r\n    getBody(obj: ICollider | IRigidbody): null | any {\r\n        if (!obj) return null;\r\n        const body = obj[$bodyKey];\r\n        return body;\r\n    }\r\n\r\n    /** Get the Needle Engine component for a rapier object */\r\n    getComponent(rapierObject: object): IComponent | null {\r\n        if (!rapierObject) return null;\r\n        const component = rapierObject[$componentKey];\r\n        return component;\r\n    }\r\n\r\n    private createCollider(collider: ICollider, desc: ColliderDesc) {\r\n        if (!this.world) throw new Error(\"Physics world not initialized\");\r\n        const matrix = this._tempMatrix;\r\n        let rigidBody: RigidBody | undefined = undefined;\r\n        if (!collider.attachedRigidbody) {\r\n            if (debugPhysics) console.log(\"Create collider without rigidbody\", collider.name);\r\n            matrix.makeRotationFromQuaternion(getWorldQuaternion(collider.gameObject));\r\n            matrix.setPosition(getWorldPosition(collider.gameObject));\r\n        }\r\n        else {\r\n            rigidBody = this.getRigidbody(collider, this._tempMatrix);\r\n        }\r\n\r\n        matrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);\r\n        this.tryApplyCenter(collider, this._tempPosition);\r\n        desc.setTranslation(this._tempPosition.x, this._tempPosition.y, this._tempPosition.z);\r\n        desc.setRotation(this._tempQuaternion);\r\n        desc.setSensor(collider.isTrigger);\r\n\r\n        // TODO: we might want to update this if the material changes\r\n        const physicsMaterial = collider.sharedMaterial;\r\n        if (physicsMaterial) {\r\n\r\n            if (physicsMaterial.bounciness !== undefined)\r\n                desc.setRestitution(physicsMaterial.bounciness);\r\n\r\n            if (physicsMaterial.bounceCombine !== undefined) {\r\n                switch (physicsMaterial.bounceCombine) {\r\n                    case PhysicsMaterialCombine.Average:\r\n                        desc.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Maximum:\r\n                        desc.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Minimum:\r\n                        desc.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Multiply:\r\n                        desc.setRestitutionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (physicsMaterial.dynamicFriction !== undefined)\r\n                desc.setFriction(physicsMaterial.dynamicFriction);\r\n\r\n            if (physicsMaterial.frictionCombine !== undefined) {\r\n                switch (physicsMaterial.frictionCombine) {\r\n                    case PhysicsMaterialCombine.Average:\r\n                        desc.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Maximum:\r\n                        desc.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Minimum:\r\n                        desc.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);\r\n                        break;\r\n                    case PhysicsMaterialCombine.Multiply:\r\n                        desc.setFrictionCombineRule(MODULES.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // if we want to use explicit mass properties, we need to set the collider density to 0\r\n        // otherwise rapier will compute the mass properties based on the collider shape and density\r\n        // https://rapier.rs/docs/user_guides/javascript/rigid_bodies#mass-properties\r\n        if (collider.attachedRigidbody?.autoMass === false) {\r\n            desc.setDensity(.000001);\r\n            desc.setMass(.000001);\r\n        }\r\n\r\n        try {\r\n            const col = this.world.createCollider(desc, rigidBody);\r\n            col[$componentKey] = collider;\r\n            collider[$bodyKey] = col;\r\n            col.setActiveEvents(MODULES.RAPIER_PHYSICS.MODULE.ActiveEvents.COLLISION_EVENTS);\r\n            // We want to receive collisitons between two triggers too\r\n            col.setActiveCollisionTypes(MODULES.RAPIER_PHYSICS.MODULE.ActiveCollisionTypes.ALL);\r\n            this.objects.push(collider);\r\n            this.bodies.push(col);\r\n\r\n            // set the collider layers\r\n            this.updateColliderCollisionGroups(collider);\r\n\r\n            return col;\r\n        }\r\n        catch (e) {\r\n            console.error(\"Error creating collider \\\"\" + collider.name + \"\\\"\\nError:\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the collision groups of a collider.\r\n     * \r\n     * @param collider - The collider to update.\r\n     */\r\n    private updateColliderCollisionGroups(collider: ICollider) {\r\n        const body = collider[$bodyKey] as Collider;\r\n        const members = collider.membership;\r\n        let memberMask = 0;\r\n        if (members == undefined) {\r\n            memberMask = 0xffff;\r\n        }\r\n        else {\r\n            for (let i = 0; i < members.length; i++) {\r\n                const member = members[i];\r\n                if (member > 31) console.error(`Rapier only supports 32 layers, layer ${member} is not supported`);\r\n                else memberMask |= 1 << Math.floor(member);\r\n            }\r\n        }\r\n\r\n        const mask = collider.filter;\r\n        let filterMask = 0;\r\n        if (mask == undefined) {\r\n            filterMask = 0xffff;\r\n        }\r\n        else {\r\n            for (let i = 0; i < mask.length; i++) {\r\n                const member = mask[i];\r\n                if (member > 31) console.error(`Rapier only supports 32 layers, layer ${member} is not supported`);\r\n                else filterMask |= 1 << Math.floor(member);\r\n            }\r\n        }\r\n        body.setCollisionGroups((memberMask << 16) | filterMask);\r\n    }\r\n\r\n    private getRigidbody(collider: ICollider, _matrix: Matrix4): RigidBody {\r\n\r\n        if (!this.world) throw new Error(\"Physics world not initialized\");\r\n        let rigidBody: RigidBody | null = null;\r\n\r\n        if (collider.attachedRigidbody) {\r\n            const rb = collider.attachedRigidbody;\r\n            rigidBody = rb[$bodyKey];\r\n            if (!rigidBody) {\r\n                const kinematic = rb.isKinematic && !debugColliderPlacement;\r\n                if (debugPhysics)\r\n                    console.log(\"Create rigidbody\", kinematic);\r\n                const rigidBodyDesc = (kinematic ? MODULES.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased() : MODULES.RAPIER_PHYSICS.MODULE.RigidBodyDesc.dynamic()) as RigidBodyDesc;\r\n                const pos = getWorldPosition(collider.attachedRigidbody.gameObject);\r\n                rigidBodyDesc.setTranslation(pos.x, pos.y, pos.z);\r\n                rigidBodyDesc.setRotation(getWorldQuaternion(collider.attachedRigidbody.gameObject));\r\n                rigidBodyDesc.centerOfMass = new MODULES.RAPIER_PHYSICS.MODULE.Vector3(rb.centerOfMass.x, rb.centerOfMass.y, rb.centerOfMass.z);\r\n                rigidBody = this.world.createRigidBody(rigidBodyDesc);\r\n                this.bodies.push(rigidBody);\r\n                this.objects.push(rb);\r\n            }\r\n            rigidBody[$componentKey] = rb;\r\n            rb[$bodyKey] = rigidBody;\r\n            this.internalUpdateRigidbodyProperties(rb, rigidBody);\r\n            this.getRigidbodyRelativeMatrix(collider.gameObject, rb.gameObject, _matrix);\r\n            collider[$colliderRigidbody] = rigidBody;\r\n        }\r\n        else {\r\n            const rigidBodyDesc = MODULES.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased();\r\n            const pos = getWorldPosition(collider.gameObject);\r\n            rigidBodyDesc.setTranslation(pos.x, pos.y, pos.z);\r\n            rigidBodyDesc.setRotation(getWorldQuaternion(collider.gameObject));\r\n            rigidBody = this.world.createRigidBody(rigidBodyDesc);\r\n            _matrix.identity();\r\n            rigidBody[$componentKey] = null;\r\n        }\r\n\r\n\r\n        return rigidBody;\r\n    }\r\n\r\n    private internal_getRigidbody(rb: IRigidbody | ICollider): RigidBody | null {\r\n        if ((rb as ICollider).isCollider === true) return rb[$colliderRigidbody] as RigidBody;\r\n        return rb[$bodyKey] as RigidBody;\r\n    }\r\n\r\n    private internalUpdateColliderProperties(col: ICollider, collider: Collider) {\r\n        const shape = collider.shape;\r\n        let sizeHasChanged = false;\r\n        switch (shape.type) {\r\n            // Sphere Collider\r\n            case MODULES.RAPIER_PHYSICS.MODULE.ShapeType.Ball:\r\n                {\r\n                    const ball = shape as Ball;\r\n                    const sc = col as ISphereCollider;\r\n                    const obj = col.gameObject;\r\n                    const scale = getWorldScale(obj, this._tempPosition);\r\n                    const radius = Math.abs(sc.radius * scale.x);\r\n                    sizeHasChanged = ball.radius !== radius;\r\n                    ball.radius = radius;\r\n                    if (sizeHasChanged) {\r\n                        collider.setShape(ball);\r\n                    }\r\n                    break;\r\n                }\r\n            case MODULES.RAPIER_PHYSICS.MODULE.ShapeType.Cuboid:\r\n                const cuboid = shape as Cuboid;\r\n                const sc = col as IBoxCollider;\r\n                const obj = col.gameObject;\r\n                const scale = getWorldScale(obj, this._tempPosition);\r\n                const newX = sc.size.x * 0.5 * scale.x;\r\n                const newY = sc.size.y * 0.5 * scale.y;\r\n                const newZ = sc.size.z * 0.5 * scale.z;\r\n                sizeHasChanged = cuboid.halfExtents.x !== newX || cuboid.halfExtents.y !== newY || cuboid.halfExtents.z !== newZ;\r\n                cuboid.halfExtents.x = newX;\r\n                cuboid.halfExtents.y = newY;\r\n                cuboid.halfExtents.z = newZ;\r\n                if (sizeHasChanged) {\r\n                    collider.setShape(cuboid);\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (sizeHasChanged) {\r\n            const rb = col.attachedRigidbody;\r\n            if (rb?.autoMass) {\r\n                const ph = this.getBody(rb) as RigidBody\r\n                ph?.recomputeMassPropertiesFromColliders();\r\n            }\r\n        }\r\n\r\n        this.updateColliderCollisionGroups(col);\r\n\r\n        if (col.isTrigger !== collider.isSensor())\r\n            collider.setSensor(col.isTrigger);\r\n    }\r\n\r\n    private internalUpdateRigidbodyProperties(rb: IRigidbody, rigidbody: RigidBody) {\r\n        // continuous collision detection \r\n        // https://rapier.rs/docs/user_guides/javascript/rigid_bodies#continuous-collision-detection\r\n        rigidbody.enableCcd(rb.collisionDetectionMode !== CollisionDetectionMode.Discrete);\r\n        rigidbody.setLinearDamping(rb.drag);\r\n        rigidbody.setAngularDamping(rb.angularDrag);\r\n        rigidbody.setGravityScale(rb.useGravity ? rb.gravityScale : 0, true);\r\n\r\n        // https://rapier.rs/docs/user_guides/javascript/rigid_bodies#dominance\r\n        if (rb.dominanceGroup <= 127 && rb.dominanceGroup >= -127)\r\n            rigidbody.setDominanceGroup(Math.floor(rb.dominanceGroup))\r\n        else rigidbody.setDominanceGroup(0);\r\n\r\n        if (rb.autoMass) {\r\n            rigidbody.setAdditionalMass(0, false);\r\n            for (let i = 0; i < rigidbody.numColliders(); i++) {\r\n                const col = rigidbody.collider(i);\r\n                col.setDensity(1);\r\n            }\r\n            rigidbody.recomputeMassPropertiesFromColliders();\r\n        }\r\n        else {\r\n            rigidbody.setAdditionalMass(rb.mass, false);\r\n            for (let i = 0; i < rigidbody.numColliders(); i++) {\r\n                const col = rigidbody.collider(i);\r\n                col.setDensity(0.0000001);\r\n            }\r\n            rigidbody.recomputeMassPropertiesFromColliders();\r\n        }\r\n\r\n        // https://rapier.rs/docs/user_guides/javascript/rigid_bodies#mass-properties\r\n        // rigidbody.setAdditionalMass(rb.mass, true);\r\n        // for (let i = 0; i < rigidbody.numColliders(); i++) {\r\n        //     const collider = rigidbody.collider(i);\r\n        //     if (collider) {\r\n        //         collider.setMass(rb.mass);\r\n        //         // const density = rb.mass / collider.shape.computeMassProperties().mass;\r\n        //     }\r\n        // }\r\n\r\n        // lock rotations\r\n        rigidbody.setEnabledRotations(!rb.lockRotationX, !rb.lockRotationY, !rb.lockRotationZ, false);\r\n        rigidbody.setEnabledTranslations(!rb.lockPositionX, !rb.lockPositionY, !rb.lockPositionZ, false);\r\n\r\n        if (rb.isKinematic) {\r\n            rigidbody.setBodyType(MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased, false);\r\n        }\r\n        else {\r\n            rigidbody.setBodyType(MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.Dynamic, false);\r\n        }\r\n    }\r\n\r\n    // private _lastStepTime: number | undefined = 0;\r\n    private lines?: LineSegments;\r\n\r\n    public step(dt?: number) {\r\n        if (!this.world) return;\r\n        if (!this.enabled) return;\r\n        this._isUpdatingPhysicsWorld = true;\r\n        if (!this.eventQueue) {\r\n            this.eventQueue = new MODULES.RAPIER_PHYSICS.MODULE.EventQueue(false);\r\n        }\r\n        if (dt === undefined || dt <= 0) {\r\n            this._isUpdatingPhysicsWorld = false;\r\n            return;\r\n        }\r\n        else if (dt !== undefined) {\r\n            // if we make to sudden changes to the timestep the physics can get unstable\r\n            // https://rapier.rs/docs/user_guides/javascript/integration_parameters/#dt\r\n            this.world.timestep = Mathf.lerp(this.world.timestep, dt, 0.8);\r\n        }\r\n        try {\r\n            this.world.step(this.eventQueue);\r\n        }\r\n        catch (e) {\r\n            console.warn(\"Error running physics step\", e);\r\n        }\r\n        this._isUpdatingPhysicsWorld = false;\r\n    }\r\n\r\n    public postStep() {\r\n        if (!this.world) return;\r\n        if (!this.enabled) return;\r\n        this._isUpdatingPhysicsWorld = true;\r\n        this.syncObjects();\r\n        this._isUpdatingPhysicsWorld = false;\r\n\r\n        if (this.eventQueue && !this.collisionHandler) {\r\n            this.collisionHandler = new PhysicsCollisionHandler(this.world, this.eventQueue);\r\n        }\r\n        if (this.collisionHandler) {\r\n            this.collisionHandler.handleCollisionEvents();\r\n            this.collisionHandler.update();\r\n        }\r\n        this.updateDebugRendering(this.world);\r\n    }\r\n\r\n    private updateDebugRendering(world: World) {\r\n        if (debugPhysics || debugColliderPlacement || showColliders || this.debugRenderColliders === true) {\r\n            if (!this.lines) {\r\n                const material = new LineBasicMaterial({\r\n                    color: 0x77dd77,\r\n                    fog: false,\r\n                    // vertexColors: VertexColors\r\n                });\r\n                const geometry = new BufferGeometry();\r\n                this.lines = new LineSegments(geometry, material);\r\n                this.lines.layers.disableAll();\r\n                this.lines.layers.enable(2);\r\n            }\r\n            if (this.lines.parent !== this.context?.scene)\r\n                this.context?.scene.add(this.lines);\r\n            const buffers = world.debugRender();\r\n            this.lines.geometry.setAttribute('position', new BufferAttribute(buffers.vertices, 3));\r\n            this.lines.geometry.setAttribute('color', new BufferAttribute(buffers.colors, 4));\r\n            // If a scene has no colliders at all at the start of the scene\r\n            // the bounding sphere radius will be 0 and the lines will not be rendered\r\n            // so we need to update the bounding sphere (perhaps it's enough to do this once...)\r\n            if (this.context!.time.frame % 30 === 0 || this.lines.geometry.boundingSphere?.radius === 0) {\r\n                this.lines.geometry.computeBoundingSphere();\r\n            }\r\n        }\r\n        else {\r\n            if (this.lines) {\r\n                this.context?.scene.remove(this.lines);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** sync rendered objects with physics world (except for colliders without rigidbody) */\r\n    private syncObjects() {\r\n        if (debugColliderPlacement) return;\r\n        for (let i = 0; i < this.bodies.length; i++) {\r\n            const obj = this.objects[i];\r\n            const body = this.bodies[i] as Collider;\r\n\r\n            // if the collider is not attached to a rigidbody\r\n            // it means that its kinematic so we need to update its position\r\n            const col = (obj as ICollider);\r\n            if (col?.isCollider === true && !col.attachedRigidbody) {\r\n                const rigidbody = body.parent();\r\n                if (rigidbody)\r\n                    this.syncPhysicsBody(obj.gameObject, rigidbody, true, true);\r\n                else\r\n                    this.syncPhysicsBody(obj.gameObject, body, true, true);\r\n                continue;\r\n            }\r\n\r\n\r\n            // sync\r\n            const pos = body.translation();\r\n            const rot = body.rotation();\r\n            if (Number.isNaN(pos.x) || Number.isNaN(rot.x)) {\r\n                if (!col[\"__COLLIDER_NAN\"] && isDevEnvironment()) {\r\n                    console.warn(\"Collider has NaN values\", col.name, col.gameObject, body);\r\n                    col[\"__COLLIDER_NAN\"] = true;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            // make sure to keep the collider offset\r\n            const center = obj[\"center\"] as Vector3;\r\n            if (center && center.isVector3) {\r\n                this._tempQuaternion.set(rot.x, rot.y, rot.z, rot.w);\r\n                const offset = this._tempPosition.copy(center).applyQuaternion(this._tempQuaternion);\r\n                const scale = getWorldScale(obj.gameObject);\r\n                offset.multiply(scale);\r\n                pos.x -= offset.x;\r\n                pos.y -= offset.y;\r\n                pos.z -= offset.z;\r\n            }\r\n            setWorldPositionXYZ(obj.gameObject, pos.x, pos.y, pos.z);\r\n            setWorldQuaternionXYZW(obj.gameObject, rot.x, rot.y, rot.z, rot.w);\r\n        }\r\n    }\r\n\r\n    private syncPhysicsBody(obj: Object3D, body: RigidBody | Collider, translation: boolean, rotation: boolean) {\r\n\r\n        // const bodyType = body.bodyType();\r\n        // const previous = physicsBody.translation();\r\n        // const vel = physicsBody.linvel();\r\n\r\n        if (body instanceof MODULES.RAPIER_PHYSICS.MODULE.RigidBody) {\r\n            const worldPosition = getWorldPosition(obj, this._tempPosition);\r\n            const worldQuaternion = getWorldQuaternion(obj, this._tempQuaternion);\r\n            const type = body.bodyType();\r\n            switch (type) {\r\n                case MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.Fixed:\r\n                case MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased:\r\n                case MODULES.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicVelocityBased:\r\n                    if (translation)\r\n                        body.setNextKinematicTranslation(worldPosition);\r\n                    if (rotation)\r\n                        body.setNextKinematicRotation(worldQuaternion);\r\n                    break;\r\n                default:\r\n                    if (translation)\r\n                        body.setTranslation(worldPosition, false);\r\n                    if (rotation)\r\n                        body.setRotation(worldQuaternion, false);\r\n                    break;\r\n\r\n            }\r\n        }\r\n        else if (body instanceof MODULES.RAPIER_PHYSICS.MODULE.Collider) {\r\n            if (obj.matrixWorldNeedsUpdate) {\r\n                obj.updateWorldMatrix(true, false);\r\n            }\r\n            obj.matrixWorld.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);\r\n            const wp = this._tempPosition;\r\n            const wq = this._tempQuaternion;\r\n            // const wp = getWorldPosition(obj, this._tempPosition);\r\n            // const wq = getWorldQuaternion(obj, this._tempQuaternion);\r\n            const collider = body[$componentKey] as ICollider;\r\n            this.tryApplyCenter(collider, wp);\r\n\r\n            // we need to check if translation or rotation have changed, otherwise the physics engine will wakeup rigidbody that are in contact with this collider\r\n            if (translation) {\r\n                const ct = body.translation();\r\n                if (ct.x !== wp.x || ct.y !== wp.y || ct.z !== wp.z)\r\n                    body.setTranslation(wp);\r\n            }\r\n            if (rotation) {\r\n                const cr = body.rotation();\r\n                if (cr.x !== wq.x || cr.y !== wq.y || cr.z !== wq.z || cr.w !== wq.w)\r\n                    body.setRotation(wq);\r\n            }\r\n        }\r\n\r\n        // physicsBody.setBodyType(RAPIER.RigidBodyType.Fixed);\r\n        // physicsBody.setLinvel(vel, false);\r\n\r\n        // update velocity\r\n        // const pos = physicsBody.translation();\r\n        // pos.x -= previous.x;\r\n        // pos.y -= previous.y;\r\n        // pos.z -= previous.z;\r\n        // // threhold\r\n        // const t = 1;\r\n        // const canUpdateVelocity = Math.abs(pos.x) < t && Math.abs(pos.y) < t && Math.abs(pos.z) < t;\r\n        // if (canUpdateVelocity) {\r\n        //     const damping = 1 + this.context.time.deltaTime;\r\n        //     vel.x *= damping;\r\n        //     vel.y *= damping;\r\n        //     vel.z *= damping;\r\n        //     vel.x += pos.x;\r\n        //     vel.y += pos.y;\r\n        //     vel.z += pos.z;\r\n        //     console.log(vel);\r\n        //     physicsBody.setLinvel(vel, true);\r\n        // }\r\n        // else if(debugPhysics) console.warn(\"Movement exceeded threshold, not updating velocity\", pos);\r\n\r\n        // body.setBodyType(bodyType);\r\n    }\r\n\r\n    private readonly _tempCenterPos: Vector3 = new Vector3();\r\n    private readonly _tempCenterVec: Vector3 = new Vector3();\r\n    private readonly _tempCenterQuaternion: Quaternion = new Quaternion();\r\n    private tryApplyCenter(collider: ICollider, targetVector: Vector3) {\r\n        const center = collider.center;\r\n        if (center && collider.gameObject) {\r\n            if (center.x !== 0 || center.y !== 0 || center.z !== 0) {\r\n                // TODO: fix export of center in editor integrations so we dont have to flip here\r\n                this._tempCenterPos.x = center.x;\r\n                this._tempCenterPos.y = center.y;\r\n                this._tempCenterPos.z = center.z;\r\n                getWorldScale(collider.gameObject, this._tempCenterVec);\r\n                this._tempCenterPos.multiply(this._tempCenterVec);\r\n                if (!collider.attachedRigidbody) {\r\n                    getWorldQuaternion(collider.gameObject, this._tempCenterQuaternion);\r\n                    this._tempCenterPos.applyQuaternion(this._tempCenterQuaternion);\r\n                }\r\n                else {\r\n                    this._tempCenterPos.applyQuaternion(collider.gameObject.quaternion);\r\n                }\r\n                targetVector.x += this._tempCenterPos.x;\r\n                targetVector.y += this._tempCenterPos.y;\r\n                targetVector.z += this._tempCenterPos.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _matricesBuffer: Matrix4[] = [];\r\n    private getRigidbodyRelativeMatrix(comp: Object3D, rigidbody: Object3D, mat: Matrix4, matrices?: Matrix4[]): Matrix4 {\r\n        // collect all matrices to the rigidbody and then build the rigidbody relative matrix\r\n        if (matrices === undefined) {\r\n            matrices = RapierPhysics._matricesBuffer;\r\n            matrices.length = 0;\r\n        }\r\n        if (comp === rigidbody) {\r\n            const scale = getWorldScale(comp, this._tempPosition);\r\n            mat.makeScale(scale.x, scale.y, scale.z);\r\n            for (let i = matrices.length - 1; i >= 0; i--) {\r\n                mat.multiply(matrices[i]);\r\n            }\r\n            return mat;\r\n        }\r\n        matrices.push(comp.matrix);\r\n        if (comp.parent) {\r\n            this.getRigidbodyRelativeMatrix(comp.parent, rigidbody, mat, matrices);\r\n        }\r\n        return mat;\r\n    }\r\n\r\n    private static centerConnectionPos = { x: 0, y: 0, z: 0 };\r\n    private static centerConnectionRot = { x: 0, y: 0, z: 0, w: 1 };\r\n\r\n\r\n\r\n    addFixedJoint(body1: IRigidbody, body2: IRigidbody) {\r\n        if (!this.world) {\r\n            console.error(\"Physics world not initialized\");\r\n            return;\r\n        }\r\n        const b1 = body1[$bodyKey] as RigidBody;\r\n        const b2 = body2[$bodyKey] as RigidBody;\r\n\r\n        this.calculateJointRelativeMatrices(body1.gameObject, body2.gameObject, this._tempMatrix);\r\n        this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);\r\n\r\n        const params = MODULES.RAPIER_PHYSICS.MODULE.JointData.fixed(\r\n            RapierPhysics.centerConnectionPos, RapierPhysics.centerConnectionRot,\r\n            this._tempPosition, this._tempQuaternion,\r\n        );\r\n        const joint = this.world.createImpulseJoint(params, b1, b2, true);\r\n        if (debugPhysics)\r\n            console.log(\"ADD FIXED JOINT\", joint)\r\n    }\r\n\r\n\r\n    /** The joint prevents any relative movement between two rigid-bodies, except for relative rotations along one axis. This is typically used to simulate wheels, fans, etc. They are characterized by one local anchor as well as one local axis on each rigid-body. */\r\n    addHingeJoint(body1: IRigidbody, body2: IRigidbody, anchor: { x: number, y: number, z: number }, axis: { x: number, y: number, z: number }) {\r\n        if (!this.world) {\r\n            console.error(\"Physics world not initialized\");\r\n            return;\r\n        }\r\n        const b1 = body1[$bodyKey] as RigidBody;\r\n        const b2 = body2[$bodyKey] as RigidBody;\r\n\r\n        this.calculateJointRelativeMatrices(body1.gameObject, body2.gameObject, this._tempMatrix);\r\n        this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);\r\n\r\n        const params = MODULES.RAPIER_PHYSICS.MODULE.JointData.revolute(anchor, this._tempPosition, axis);\r\n        const joint = this.world.createImpulseJoint(params, b1, b2, true);\r\n        if (debugPhysics)\r\n            console.log(\"ADD HINGE JOINT\", joint)\r\n    }\r\n\r\n\r\n    private calculateJointRelativeMatrices(body1: IGameObject, body2: IGameObject, mat: Matrix4) {\r\n        body1.updateWorldMatrix(true, false);\r\n        body2.updateWorldMatrix(true, false);\r\n        const world1 = body1.matrixWorld;\r\n        const world2 = body2.matrixWorld;\r\n        // set scale to 1\r\n        world1.elements[0] = 1;\r\n        world1.elements[5] = 1;\r\n        world1.elements[10] = 1;\r\n        world2.elements[0] = 1;\r\n        world2.elements[5] = 1;\r\n        world2.elements[10] = 1;\r\n        mat.copy(world2).premultiply(world1.invert()).invert();\r\n    }\r\n}\r\n\r\n\r\n\r\n/** responsible of processing collision events for the component system */\r\nclass PhysicsCollisionHandler {\r\n\r\n    readonly world: World;\r\n    readonly eventQueue: EventQueue;\r\n\r\n    constructor(world: World, eventQueue: EventQueue) {\r\n        this.world = world;\r\n        this.eventQueue = eventQueue;\r\n    }\r\n\r\n    private activeCollisions: Array<{ collider: ICollider, component: IComponent, collision: Collision }> = [];\r\n    private activeCollisionsStay: Array<{ collider: ICollider, component: IComponent, collision: Collision }> = [];\r\n    private activeTriggers: Array<{ collider: ICollider, component: IComponent, otherCollider: ICollider }> = [];\r\n\r\n    handleCollisionEvents() {\r\n        if (!this.eventQueue) return;\r\n        if (!this.world) return;\r\n        this.eventQueue.drainCollisionEvents((handle1, handle2, started) => {\r\n            const col1 = this.world!.getCollider(handle1);\r\n            const col2 = this.world!.getCollider(handle2);\r\n            if (!col1 || !col2) return;\r\n            const colliderComponent1 = col1[$componentKey];\r\n            const colliderComponent2 = col2[$componentKey];\r\n            if (debugCollisions)\r\n                console.log(\"EVT\", colliderComponent1.name, colliderComponent2.name, started, col1, col2);\r\n            if (colliderComponent1 && colliderComponent2) {\r\n                if (started) {\r\n                    this.onCollisionStarted(colliderComponent1, col1, colliderComponent2, col2);\r\n                    this.onCollisionStarted(colliderComponent2, col2, colliderComponent1, col1);\r\n                }\r\n                else {\r\n                    this.onCollisionEnded(colliderComponent1, colliderComponent2);\r\n                    this.onCollisionEnded(colliderComponent2, colliderComponent1);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    update() {\r\n        this.onHandleCollisionStay();\r\n    }\r\n\r\n    private onCollisionStarted(self: ICollider, selfBody: Collider, other: ICollider, otherBody: Collider) {\r\n        let collision: Collision | null = null;\r\n\r\n        // if one is a trigger we dont get collisions but want to raise the trigger events\r\n        if (self.isTrigger || other.isTrigger) {\r\n            foreachComponent(self.gameObject, (c: IComponent) => {\r\n                if (c.onTriggerEnter && !c.destroyed) {\r\n                    c.onTriggerEnter(other);\r\n                }\r\n                this.activeTriggers.push({ collider: self, component: c, otherCollider: other });\r\n            });\r\n        }\r\n        else {\r\n            const object = self.gameObject;\r\n            // TODO: we dont respect the flip value here!\r\n            this.world.contactPair(selfBody, otherBody, (manifold, _flipped) => {\r\n                foreachComponent(object, (c: IComponent) => {\r\n                    if (c.destroyed) return;\r\n                    const hasDeclaredEventMethod = c.onCollisionEnter || c.onCollisionStay || c.onCollisionExit;\r\n                    if (hasDeclaredEventMethod || debugCollisions) {\r\n                        if (!collision) {\r\n                            const contacts: Array<ContactPoint> = [];\r\n                            const normal = manifold.normal();\r\n                            // invert the normal for convex MeshColliders, NE-2680\r\n                            if (other instanceof MeshCollider && other.convex) {\r\n                                normal.x = -normal.x;\r\n                                normal.y = -normal.y;\r\n                                normal.z = -normal.z;\r\n                            }\r\n                            for (let i = 0; i < manifold.numSolverContacts(); i++) {\r\n                                // solver points are in world space\r\n                                // https://rapier.rs/docs/user_guides/javascript/advanced_collision_detection_js#the-contact-graph\r\n                                const pt = manifold.solverContactPoint(i);\r\n                                const impulse = manifold.contactImpulse(i);\r\n                                if (pt) {\r\n                                    const dist = manifold.contactDist(i);\r\n                                    const friction = manifold.solverContactFriction(i);\r\n                                    const tangentVelocity = manifold.solverContactTangentVelocity(i);\r\n                                    const contact = new ContactPoint(pt, dist, normal, impulse, friction, tangentVelocity);\r\n                                    contacts.push(contact);\r\n                                    if (debugCollisions) {\r\n                                        Gizmos.DrawDirection(pt, normal, 0xff0000, 3, true);\r\n                                    }\r\n                                }\r\n                            }\r\n                            collision = new Collision(object, other, contacts);\r\n                        }\r\n\r\n                        // we only need to keep track if any event exists\r\n                        if (hasDeclaredEventMethod) {\r\n                            const info = { collider: self, component: c, collision };\r\n\r\n                            this.activeCollisions.push(info);\r\n                            if (c.onCollisionStay) {\r\n                                this.activeCollisionsStay.push(info);\r\n                            }\r\n\r\n                            c.onCollisionEnter?.call(c, collision);\r\n                        }\r\n\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    private onHandleCollisionStay() {\r\n        for (const active of this.activeCollisionsStay) {\r\n            const c = active.component;\r\n            if (c.destroyed) continue;\r\n            if (c.activeAndEnabled && c.onCollisionStay) {\r\n                if (active.collision.collider.destroyed) continue;\r\n                const arg = active.collision;\r\n                c.onCollisionStay(arg);\r\n            }\r\n        }\r\n        for (const active of this.activeTriggers) {\r\n            const c = active.component;\r\n            if (c.destroyed) continue;\r\n            if (c.activeAndEnabled && c.onTriggerStay) {\r\n                const arg = active.otherCollider;\r\n                if (arg.destroyed) continue;\r\n                c.onTriggerStay(arg);\r\n            }\r\n        }\r\n    }\r\n\r\n    private onCollisionEnded(self: ICollider, other: ICollider) {\r\n        if (self.destroyed || other.destroyed) return;\r\n        for (let i = 0; i < this.activeCollisions.length; i++) {\r\n            const active = this.activeCollisions[i];\r\n            const collider = active.collider;\r\n            if (collider.destroyed || active.collision.collider.destroyed) {\r\n                this.activeCollisions.splice(i, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n            if (collider === self && active.collision.collider === other) {\r\n                const c = active.component;\r\n                this.activeCollisions.splice(i, 1);\r\n                i--;\r\n                if (c.activeAndEnabled && c.onCollisionExit) {\r\n                    const collision = active.collision;\r\n                    c.onCollisionExit(collision);\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < this.activeCollisionsStay.length; i++) {\r\n            const active = this.activeCollisionsStay[i];\r\n            const collider = active.collider;\r\n            if (collider.destroyed || active.collision.collider.destroyed) {\r\n                this.activeCollisionsStay.splice(i, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n            if (collider === self && active.collision.collider === other) {\r\n                const c = active.component;\r\n                this.activeCollisionsStay.splice(i, 1);\r\n                i--;\r\n                if (c.activeAndEnabled && c.onCollisionExit) {\r\n                    const collision = active.collision;\r\n                    c.onCollisionExit(collision);\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < this.activeTriggers.length; i++) {\r\n            const active = this.activeTriggers[i];\r\n            const collider = active.collider;\r\n            if (collider.destroyed || active.otherCollider.destroyed) {\r\n                this.activeTriggers.splice(i, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n            if (collider === self && active.otherCollider === other) {\r\n                const c = active.component;\r\n                this.activeTriggers.splice(i, 1);\r\n                i--;\r\n                if (c.activeAndEnabled && c.onTriggerExit) {\r\n                    const collision = active.otherCollider;\r\n                    c.onTriggerExit(collision);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { DataTextureLoader,EquirectangularReflectionMapping, Object3D, PerspectiveCamera, Scene, Vector3 } from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\";\r\n\r\nimport { AssetReference } from \"./engine_addressables.js\";\r\nimport { getBoundingBox } from \"./engine_three_utils.js\";\r\n\r\ndeclare type ComparisonSceneOptions = {\r\n    /**\r\n     * An array of model urls to load\r\n     */\r\n    files: string[];\r\n    /**\r\n     * Optional dom element to attach the orbit controls to. By default this should be the WebGLRenderer.domElement\r\n     */\r\n    domElement?: HTMLElement;\r\n    /**\r\n     * Can be a .hdr or .exr file url\r\n     */\r\n    environment?: string;\r\n}\r\n\r\n/**\r\n * A collection of utility methods for quickly spinning up test environments\r\n */\r\nexport class TestSceneUtils {\r\n\r\n    /**\r\n     * Use this method to quickly setup a scene to compare multiple models.  \r\n     * @example\r\n     * ```ts\r\n     * const files = [\r\n     *    \"https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb\",\r\n     *   \"https://threejs.org/examples/models/gltf/Lantern/glTF-Binary/Lantern.glb\",\r\n     * ];\r\n     * const { scene, camera } = await TestUtils.createComparisonScene({ files });\r\n     * // this could now be assigned to the Needle Engine Context\r\n     * context.scene = scene;\r\n     * context.mainCamera = camera;\r\n     * ```\r\n     */\r\n    static async createComparisonScene(opts: ComparisonSceneOptions) {\r\n\r\n        const { files } = opts;\r\n\r\n        const promises = Promise.all(files.map(file => new AssetReference(file).loadAssetAsync()));\r\n        const results = await promises;\r\n        const scene = new Scene();\r\n\r\n        let offset = 0;\r\n        for (const result of results) {\r\n            if (result instanceof Object3D) {\r\n                result.position.y = offset;\r\n                scene.add(result);\r\n                const box = getBoundingBox([result]);\r\n                offset += box.getSize(new Vector3()).y;\r\n                offset += .1;\r\n            }\r\n        }\r\n        const camera = new PerspectiveCamera(20);\r\n        scene.add(camera);\r\n\r\n        // Load an environment map\r\n        const environmentUrl = opts.environment || \"https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/studio_small_09_1k.exr\";\r\n        if (environmentUrl) {\r\n            let loader: DataTextureLoader | null = null;\r\n            if (environmentUrl.endsWith(\".hdr\")) {\r\n                const RGBELoader = (await import(\"three/examples/jsm/loaders/RGBELoader.js\")).RGBELoader;\r\n                loader = new RGBELoader();\r\n            }\r\n            else if (environmentUrl.endsWith(\".exr\")) {\r\n                const EXRLoader = (await import(\"three/examples/jsm/loaders/EXRLoader.js\")).EXRLoader;\r\n                loader = new EXRLoader();\r\n            }\r\n            if (loader) {\r\n                const envmap = await loader.loadAsync(environmentUrl).catch((e) => { console.error(e); return null; });\r\n                if (envmap) {\r\n                    envmap.mapping = EquirectangularReflectionMapping;\r\n                    envmap.needsUpdate = true;\r\n                    scene.background = envmap;\r\n                    scene.environment = envmap;\r\n                    scene.backgroundBlurriness = .75;\r\n                }\r\n            }\r\n            else console.warn(\"Unsupported environment map format\", environmentUrl);\r\n        }\r\n\r\n        const box = getBoundingBox(scene.children);\r\n        const center = box.getCenter(new Vector3());\r\n        const size = box.getSize(new Vector3());\r\n        const max = Math.max(size.x, size.y, size.z);\r\n        const distance = max / (2 * Math.tan(Math.PI * camera.fov / 360));\r\n        camera.position.set(center.x, center.y, distance);\r\n        camera.lookAt(center);\r\n\r\n        const orbit = new OrbitControls(camera, opts.domElement || document.body);\r\n        orbit.target = center;\r\n        orbit.update();\r\n\r\n\r\n        const element = (opts.domElement || document.body).getBoundingClientRect();\r\n        camera.aspect = element.width / element.height;\r\n        camera.updateProjectionMatrix();\r\n\r\n        return {\r\n            scene,\r\n            camera\r\n        }\r\n    }\r\n}\r\n", "\r\n\r\nlet exportingStack: number = 0;\r\n\r\n/** @internal */\r\nexport function __isExporting(state: boolean) {\r\n    if (state) {\r\n        exportingStack++;\r\n    } else {\r\n        exportingStack--;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns whether an export process is currently running.\r\n * @returns True if an export process is currently running, false otherwise.\r\n */\r\nexport function isExporting() {\r\n    return exportingStack > 0;\r\n}", "import { AnimationClip, Object3D } from \"three\";\r\nimport { GLTFExporter, GLTFExporterOptions } from \"three/examples/jsm/exporters/GLTFExporter.js\";\r\n\r\nimport GLTFMeshGPUInstancingExtension from \"../../../include/three/EXT_mesh_gpu_instancing_exporter.js\";\r\nimport { AnimationUtils } from \"../../engine_animation.js\";\r\nimport type { Context } from \"../../engine_setup.js\";\r\nimport { registerExportExtensions } from \"../../extensions/index.js\";\r\nimport { __isExporting } from \"../state.js\";\r\nimport { shouldExport_HideFlags } from \"../utils.js\";\r\nimport { GizmoWriter as GLTFGizmoWriter, RenderTextureWriter as GLTFRenderTextureWriter } from \"./Writers.js\";\r\n\r\ndeclare type ExportOptions = {\r\n    context: Context,\r\n    scene?: Object3D | Array<Object3D>,\r\n    binary?: boolean,\r\n    animations?: boolean,\r\n    downloadAs?: string,\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Omit<ExportOptions, \"context\" | \"scene\"> = {\r\n    binary: true,\r\n    animations: true,\r\n}\r\n\r\nexport async function exportAsGLTF(_opts: ExportOptions): Promise<ArrayBuffer | Record<string, any>> {\r\n\r\n    if (!_opts.context) {\r\n        throw new Error(\"No context provided to exportAsGLTF\");\r\n    }\r\n\r\n    if (!_opts.scene) {\r\n        _opts.scene = _opts.context.scene;\r\n    }\r\n\r\n    const opts = {\r\n        ...DEFAULT_OPTIONS,\r\n        ..._opts\r\n    } as Required<ExportOptions>;\r\n\r\n    const { context } = opts;\r\n\r\n    const exporter = new GLTFExporter();\r\n    exporter.register(writer => new GLTFMeshGPUInstancingExtension(writer));\r\n    exporter.register(writer => new GLTFGizmoWriter(writer));\r\n    exporter.register(writer => new GLTFRenderTextureWriter(writer));\r\n    registerExportExtensions(exporter, opts.context);\r\n\r\n    const exporterOptions: GLTFExporterOptions = {\r\n        binary: opts.binary,\r\n        animations: collectAnimations(context, opts.scene, []),\r\n    }\r\n    const state = new ExporterState();\r\n    console.debug(\"Exporting GLTF\", exporterOptions);\r\n    state.onBeforeExport(opts);\r\n    __isExporting(true);\r\n    const res = await exporter.parseAsync(opts.scene, exporterOptions).catch((e) => {\r\n        console.error(e);\r\n        return null;\r\n    });\r\n    __isExporting(false);\r\n    state.onAfterExport(opts);\r\n\r\n    if (!res) {\r\n        throw new Error(\"Failed to export GLTF\");\r\n    }\r\n\r\n    if (opts.downloadAs != undefined) {\r\n        let blob: Blob | null = null;\r\n        if (res instanceof ArrayBuffer) {\r\n            blob = new Blob([res], { type: \"application/octet-stream\" });\r\n        }\r\n        else {\r\n            console.error(\"Can not download GLTF as a blob\", res);\r\n        }\r\n\r\n        if (blob) {\r\n            const url = URL.createObjectURL(blob);\r\n            const a = document.createElement(\"a\");\r\n            a.href = url;\r\n            let name = opts.downloadAs;\r\n            if (!name.endsWith(\".glb\") && !name.endsWith(\".gltf\")) {\r\n                name += opts.binary ? \".glb\" : \".gltf\";\r\n            }\r\n            a.download = name;\r\n            a.click();\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\n\r\nconst ACTIONS_WEIGHT_KEY = Symbol(\"needle:weight\");\r\n\r\nclass ExporterState {\r\n\r\n    private readonly _undo: Array<() => void> = [];\r\n\r\n    onBeforeExport(opts: Required<ExportOptions>) {\r\n        opts.context.animations.mixers.forEach(mixer => {\r\n            const actions = AnimationUtils.tryGetActionsFromMixer(mixer);\r\n            if (actions) {\r\n                for (let i = 0; i < actions.length; i++) {\r\n                    const action = actions[i];\r\n                    action[ACTIONS_WEIGHT_KEY] = action.weight;\r\n                    action.weight = 0;\r\n                    this._undo.push(() => { action.weight = action[ACTIONS_WEIGHT_KEY]; });\r\n                }\r\n            }\r\n            mixer.update(0);\r\n        });\r\n\r\n        opts.context.scene.traverse(obj => {\r\n            if(!shouldExport_HideFlags(obj)) {\r\n                const parent = obj.parent;\r\n                if(parent) {\r\n                    obj.removeFromParent();\r\n                    this._undo.push(() => parent.add(obj));\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    onAfterExport(_opts: Required<ExportOptions>) {\r\n        this._undo.forEach(fn => fn());\r\n        this._undo.length = 0;\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction collectAnimations(context: Context, scene: Object3D | Array<Object3D>, clips: Array<AnimationClip>): Array<AnimationClip> {\r\n\r\n    // Get all animations that are used by any mixer in the scene\r\n    // technically we might also collect animations here that aren't used by any object in the scene because they're part of another scene\r\n    // But that's a problem for later...\r\n    context.animations.mixers.forEach(mixer => {\r\n        const actions = AnimationUtils.tryGetActionsFromMixer(mixer);\r\n        if (actions) {\r\n            for (let i = 0; i < actions.length; i++) {\r\n                const action = actions[i];\r\n                const clip = action.getClip();\r\n                // TODO: might need to check if the clip is part of the scene that we want to export\r\n                clips.push(clip);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Get all animations that are directly assigned to objects in the scene\r\n    if (!Array.isArray(scene)) scene = [scene];\r\n    for (const obj of scene) {\r\n        AnimationUtils.tryGetAnimationClipsFromObjectHierarchy(obj, clips);\r\n    }\r\n\r\n    // ensure we only have unique clips\r\n    const uniqueClips = new Set(clips);\r\n    return Array.from(uniqueClips);\r\n\r\n}", "import { isDevEnvironment } from \"../debug/index.js\";\r\nimport { iconFontUrl, loadFont } from \"./fonts.js\";\r\nimport { WebXRButtonFactory } from \"./WebXRButtons.js\";\r\n\r\nconst htmlTagName = \"needle-button\";\r\nconst isDev = isDevEnvironment();\r\n\r\n/**\r\n * A <needle-button> can be used to simply add VR, AR or Quicklook buttons to your website without having to write any code.  \r\n * @example\r\n * ```html\r\n * <needle-button ar></needle-button>\r\n * <needle-button vr></needle-button>\r\n * <needle-button quicklook></needle-button>\r\n * ```\r\n * \r\n * @example custom label\r\n * ```html\r\n * <needle-button ar>Start AR</needle-button>\r\n * <needle-button vr>Start VR</needle-button>\r\n * <needle-button quicklook>View in AR</needle-button>\r\n * ```\r\n * \r\n * @example custom styling\r\n * ```html\r\n * <!-- You can either style the element directly or use a CSS stylesheet -->\r\n * <style>\r\n * needle-button {\r\n *    background-color: red;\r\n *   color: white;\r\n * }\r\n * </style>\r\n * <needle-button ar>Start AR</needle-button>\r\n * ```\r\n */\r\nexport class NeedleButtonElement extends HTMLElement {\r\n\r\n    static observedAttributes = [\"ar\", \"vr\", \"quicklook\"];\r\n\r\n    constructor() {\r\n        super();\r\n        this.removeEventListener(\"click\", this.#onclick);\r\n        this.addEventListener(\"click\", this.#onclick);\r\n    }\r\n\r\n    attributeChangedCallback(_name: string, _oldValue: string, _newValue: string) {\r\n        this.#update()\r\n    }\r\n\r\n    #root!: ShadowRoot;\r\n    #slot!: HTMLSlotElement;\r\n    /** These are the default styles that can be overridden by the user from the outside by styling <needle-button> */\r\n    #styles!: HTMLStyleElement;\r\n\r\n    /** This is the button that was generated using one of the factories */\r\n    #button: HTMLButtonElement | undefined;\r\n    /** If AR or VR is requested we create and use the webxr button factory to create a button with default behaviour */\r\n    #webxrfactory: WebXRButtonFactory | undefined;\r\n\r\n    #observer: MutationObserver | undefined;\r\n\r\n    #update() {\r\n        this.#button?.remove();\r\n\r\n\r\n        if (this.getAttribute(\"ar\") != null) {\r\n            this.#webxrfactory ??= new WebXRButtonFactory()\r\n            this.#button = this.#webxrfactory.createARButton();\r\n        }\r\n        else if (this.getAttribute(\"vr\") != null) {\r\n            this.#webxrfactory ??= new WebXRButtonFactory()\r\n            this.#button = this.#webxrfactory.createVRButton();\r\n        }\r\n        else if (this.getAttribute(\"quicklook\") != null) {\r\n            this.#webxrfactory ??= new WebXRButtonFactory()\r\n            this.#button = this.#webxrfactory.createQuicklookButton();\r\n        }\r\n        else {\r\n            if (isDev) {\r\n                console.warn(\"No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.\")\r\n            }\r\n            else{\r\n                console.debug(\"No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.\")\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.#root ??= this.attachShadow({ mode: \"open\" });\r\n        this.#slot ??= document.createElement(\"slot\");\r\n        this.#styles ??= document.createElement(\"style\");\r\n        this.#styles.innerHTML = `\r\n            button {\r\n                all: initial;\r\n                cursor: inherit;\r\n                color: inherit;\r\n                font-family: inherit;\r\n                gap: inherit;\r\n                white-space: nowrap;\r\n            }\r\n        `;\r\n        const hasUnstyledAttribute = this.getAttribute(\"unstyled\") != undefined;\r\n        if (!hasUnstyledAttribute) {\r\n            this.#styles.innerHTML += `\r\n            :host {\r\n                display: inline-block;\r\n                background: rgba(255, 255, 255, .8);\r\n                backdrop-filter: blur(10px);\r\n                width: fit-content;\r\n                transition: background .2s;\r\n\r\n                cursor: pointer;\r\n                padding: 0.4rem .5rem;\r\n                border-radius: 0.8rem;\r\n                color: black;\r\n                background: rgba(245, 245, 245, .8);\r\n                outline: rgba(0,0,0,.05) 1px solid;\r\n            }\r\n            :host(:hover) {\r\n                background: rgba(255, 255, 255, 1);\r\n                transition: background .2s;\r\n            }\r\n            slot {\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: center;\r\n                gap: .5rem;\r\n            }\r\n`\r\n        }\r\n\r\n        /**\r\n         * We now structure the results as follows:\r\n         * <button>\r\n         *  <slot>\r\n         *      <original_button_content>\r\n         *  </slot>\r\n         * </button> \r\n         */\r\n        this.#slot.innerHTML = this.#button.innerHTML;\r\n        this.#slot.style.cssText = `display: flex; align-items: center; justify-content: center;`\r\n        this.#button.innerHTML = this.#slot.outerHTML;\r\n        this.#root.innerHTML = this.#button.outerHTML;\r\n        this.#root.prepend(this.#styles);\r\n        loadFont(iconFontUrl, { element: this.#root });\r\n\r\n        this.#observer?.disconnect();\r\n        this.#observer ??= new MutationObserver(() => this.#updateVisibility());\r\n        this.#observer.observe(this.#button, { attributes: true });\r\n        if(isDev) {\r\n            console.log(\"Needle Button updated\")\r\n        }\r\n    }\r\n\r\n    #updateVisibility() {\r\n        if (this.#button) {\r\n            if (this.#button.style.display === \"none\") {\r\n                this.style.display = \"none\";\r\n            }\r\n            else if (this.style.display === \"none\") {\r\n                this.style.display = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    #onclick = (_ev: MouseEvent) => {\r\n        if (isDev) {\r\n            console.log(\"Needle Button clicked\")\r\n        }\r\n        if (_ev.defaultPrevented) return;\r\n\r\n        if (this.#button) {\r\n            this.#button.click()\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nif (typeof window !== \"undefined\" && !window.customElements.get(htmlTagName))\r\n    window.customElements.define(htmlTagName, NeedleButtonElement);", "/* eslint-disable */\r\n// Export types\r\nexport class __Ignore {}\r\nexport { AlignmentConstraint } from \"../AlignmentConstraint.js\";\r\nexport { Animation } from \"../Animation.js\";\r\nexport { Keyframe } from \"../AnimationCurve.js\";\r\nexport { AnimationCurve } from \"../AnimationCurve.js\";\r\nexport { Animator } from \"../Animator.js\";\r\nexport { AnimatorController } from \"../AnimatorController.js\";\r\nexport { AudioListener } from \"../AudioListener.js\";\r\nexport { AudioSource } from \"../AudioSource.js\";\r\nexport { Avatar_POI } from \"../avatar/Avatar_Brain_LookAt.js\";\r\nexport { Avatar_Brain_LookAt } from \"../avatar/Avatar_Brain_LookAt.js\";\r\nexport { Avatar_MouthShapes } from \"../avatar/Avatar_MouthShapes.js\";\r\nexport { Avatar_MustacheShake } from \"../avatar/Avatar_MustacheShake.js\";\r\nexport { AvatarBlink_Simple } from \"../avatar/AvatarBlink_Simple.js\";\r\nexport { AvatarEyeLook_Rotation } from \"../avatar/AvatarEyeLook_Rotation.js\";\r\nexport { AvatarModel } from \"../AvatarLoader.js\";\r\nexport { AvatarLoader } from \"../AvatarLoader.js\";\r\nexport { AxesHelper } from \"../AxesHelper.js\";\r\nexport { BasicIKConstraint } from \"../BasicIKConstraint.js\";\r\nexport { BoxHelperComponent } from \"../BoxHelperComponent.js\";\r\nexport { Camera } from \"../Camera.js\";\r\nexport { CharacterController } from \"../CharacterController.js\";\r\nexport { CharacterControllerInput } from \"../CharacterController.js\";\r\nexport { Collider } from \"../Collider.js\";\r\nexport { SphereCollider } from \"../Collider.js\";\r\nexport { BoxCollider } from \"../Collider.js\";\r\nexport { MeshCollider } from \"../Collider.js\";\r\nexport { CapsuleCollider } from \"../Collider.js\";\r\nexport { ContactShadows } from \"../ContactShadows.js\";\r\nexport { LogStats } from \"../debug/LogStats.js\";\r\nexport { DeleteBox } from \"../DeleteBox.js\";\r\nexport { Deletable } from \"../DeleteBox.js\";\r\nexport { DeviceFlag } from \"../DeviceFlag.js\";\r\nexport { DragControls } from \"../DragControls.js\";\r\nexport { DropListener } from \"../DropListener.js\";\r\nexport { Duplicatable } from \"../Duplicatable.js\";\r\nexport { CallInfo } from \"../EventList.js\";\r\nexport { EventListEvent } from \"../EventList.js\";\r\nexport { EventList } from \"../EventList.js\";\r\nexport { EventTrigger } from \"../EventTrigger.js\";\r\nexport { GltfExportBox } from \"../export/gltf/GltfExport.js\";\r\nexport { GltfExport } from \"../export/gltf/GltfExport.js\";\r\nexport { RegisteredAnimationInfo } from \"../export/usdz/extensions/Animation.js\";\r\nexport { TransformData } from \"../export/usdz/extensions/Animation.js\";\r\nexport { AnimationExtension } from \"../export/usdz/extensions/Animation.js\";\r\nexport { VariantAction } from \"../export/usdz/extensions/behavior/Actions.js\";\r\nexport { ActionCollection } from \"../export/usdz/extensions/behavior/Actions.js\";\r\nexport { AudioExtension } from \"../export/usdz/extensions/behavior/AudioExtension.js\";\r\nexport { BehaviorExtension } from \"../export/usdz/extensions/behavior/Behaviour.js\";\r\nexport { ChangeTransformOnClick } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { ChangeMaterialOnClick } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { SetActiveOnClick } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { HideOnStart } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { EmphasizeOnClick } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { PlayAudioOnClick } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { PlayAnimationOnClick } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { PreliminaryAction } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { PreliminaryTrigger } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { VisibilityAction } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { TapGestureTrigger } from \"../export/usdz/extensions/behavior/BehaviourComponents.js\";\r\nexport { BehaviorModel } from \"../export/usdz/extensions/behavior/BehavioursBuilder.js\";\r\nexport { TriggerModel } from \"../export/usdz/extensions/behavior/BehavioursBuilder.js\";\r\nexport { TriggerBuilder } from \"../export/usdz/extensions/behavior/BehavioursBuilder.js\";\r\nexport { GroupActionModel } from \"../export/usdz/extensions/behavior/BehavioursBuilder.js\";\r\nexport { ActionModel } from \"../export/usdz/extensions/behavior/BehavioursBuilder.js\";\r\nexport { ActionBuilder } from \"../export/usdz/extensions/behavior/BehavioursBuilder.js\";\r\nexport { PhysicsExtension } from \"../export/usdz/extensions/behavior/PhysicsExtension.js\";\r\nexport { DocumentExtension } from \"../export/usdz/extensions/DocumentExtension.js\";\r\nexport { USDZText } from \"../export/usdz/extensions/USDZText.js\";\r\nexport { TextBuilder } from \"../export/usdz/extensions/USDZText.js\";\r\nexport { TextExtension } from \"../export/usdz/extensions/USDZText.js\";\r\nexport { USDZUIExtension } from \"../export/usdz/extensions/USDZUI.js\";\r\nexport { CustomBranding } from \"../export/usdz/USDZExporter.js\";\r\nexport { USDZExporter } from \"../export/usdz/USDZExporter.js\";\r\nexport { Fog } from \"../Fog.js\";\r\nexport { BoxGizmo } from \"../Gizmos.js\";\r\nexport { GridHelper } from \"../GridHelper.js\";\r\nexport { GroundProjectedEnv } from \"../GroundProjection.js\";\r\nexport { UsageMarker } from \"../Interactable.js\";\r\nexport { Interactable } from \"../Interactable.js\";\r\nexport { FixedJoint } from \"../Joints.js\";\r\nexport { HingeJoint } from \"../Joints.js\";\r\nexport { Light } from \"../Light.js\";\r\nexport { LODModel } from \"../LODGroup.js\";\r\nexport { LODGroup } from \"../LODGroup.js\";\r\nexport { LookAtConstraint } from \"../LookAtConstraint.js\";\r\nexport { NeedleMenu } from \"../NeedleMenu.js\";\r\nexport { NestedGltf } from \"../NestedGltf.js\";\r\nexport { Networking } from \"../Networking.js\";\r\nexport { OffsetConstraint } from \"../OffsetConstraint.js\";\r\nexport { CameraTargetReachedEvent } from \"../OrbitControls.js\";\r\nexport { OrbitControls } from \"../OrbitControls.js\";\r\nexport { ParticleSystemRenderer } from \"../particlesystem/ParticleSystem.js\";\r\nexport { ParticleSystem } from \"../particlesystem/ParticleSystem.js\";\r\nexport { SubEmitterSystem } from \"../particlesystem/ParticleSystem.js\";\r\nexport { Gradient } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { MinMaxCurve } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { MinMaxGradient } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { MainModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { ParticleBurst } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { EmissionModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { ColorOverLifetimeModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { SizeOverLifetimeModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { ShapeModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { NoiseModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { TrailModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { VelocityOverLifetimeModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { TextureSheetAnimationModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { RotationOverLifetimeModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { RotationBySpeedModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { LimitVelocityOverLifetimeModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { InheritVelocityModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { SizeBySpeedModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { ColorBySpeedModule } from \"../particlesystem/ParticleSystemModules.js\";\r\nexport { ParticleSubEmitter } from \"../particlesystem/ParticleSystemSubEmitter.js\";\r\nexport { PlayerColor } from \"../PlayerColor.js\";\r\nexport { Antialiasing } from \"../postprocessing/Effects/Antialiasing.js\";\r\nexport { BloomEffect } from \"../postprocessing/Effects/BloomEffect.js\";\r\nexport { ChromaticAberration } from \"../postprocessing/Effects/ChromaticAberration.js\";\r\nexport { ColorAdjustments } from \"../postprocessing/Effects/ColorAdjustments.js\";\r\nexport { DepthOfField } from \"../postprocessing/Effects/DepthOfField.js\";\r\nexport { EffectWrapper } from \"../postprocessing/Effects/EffectWrapper.js\";\r\nexport { PixelationEffect } from \"../postprocessing/Effects/Pixelation.js\";\r\nexport { ScreenSpaceAmbientOcclusion } from \"../postprocessing/Effects/ScreenspaceAmbientOcclusion.js\";\r\nexport { ScreenSpaceAmbientOcclusionN8 } from \"../postprocessing/Effects/ScreenspaceAmbientOcclusionN8.js\";\r\nexport { SharpeningEffect } from \"../postprocessing/Effects/Sharpening.js\";\r\nexport { TiltShiftEffect } from \"../postprocessing/Effects/TiltShiftEffect.js\";\r\nexport { ToneMappingEffect } from \"../postprocessing/Effects/Tonemapping.js\";\r\nexport { Vignette } from \"../postprocessing/Effects/Vignette.js\";\r\nexport { PostProcessingHandler } from \"../postprocessing/PostProcessingHandler.js\";\r\nexport { Volume } from \"../postprocessing/Volume.js\";\r\nexport { VolumeParameter } from \"../postprocessing/VolumeParameter.js\";\r\nexport { VolumeProfile } from \"../postprocessing/VolumeProfile.js\";\r\nexport { ReflectionProbe } from \"../ReflectionProbe.js\";\r\nexport { FieldWithDefault } from \"../Renderer.js\";\r\nexport { Renderer } from \"../Renderer.js\";\r\nexport { MeshRenderer } from \"../Renderer.js\";\r\nexport { SkinnedMeshRenderer } from \"../Renderer.js\";\r\nexport { InstancingHandler } from \"../RendererInstancing.js\";\r\nexport { InstanceHandle } from \"../RendererInstancing.js\";\r\nexport { RendererLightmap } from \"../RendererLightmap.js\";\r\nexport { Rigidbody } from \"../RigidBody.js\";\r\nexport { SceneSwitcher } from \"../SceneSwitcher.js\";\r\nexport { ScreenCapture } from \"../ScreenCapture.js\";\r\nexport { ShadowCatcher } from \"../ShadowCatcher.js\";\r\nexport { RemoteSkybox } from \"../Skybox.js\";\r\nexport { SmoothFollow } from \"../SmoothFollow.js\";\r\nexport { SpatialTriggerReceiver } from \"../SpatialTrigger.js\";\r\nexport { SpatialTrigger } from \"../SpatialTrigger.js\";\r\nexport { SpectatorCamera } from \"../SpectatorCamera.js\";\r\nexport { Sprite } from \"../SpriteRenderer.js\";\r\nexport { SpriteSheet } from \"../SpriteRenderer.js\";\r\nexport { SpriteData } from \"../SpriteRenderer.js\";\r\nexport { SpriteRenderer } from \"../SpriteRenderer.js\";\r\nexport { SyncedCamera } from \"../SyncedCamera.js\";\r\nexport { SyncedRoom } from \"../SyncedRoom.js\";\r\nexport { SyncedTransform } from \"../SyncedTransform.js\";\r\nexport { TestRunner } from \"../TestRunner.js\";\r\nexport { TestSimulateUserData } from \"../TestRunner.js\";\r\nexport { PlayableDirector } from \"../timeline/PlayableDirector.js\";\r\nexport { SignalAsset } from \"../timeline/SignalAsset.js\";\r\nexport { SignalReceiverEvent } from \"../timeline/SignalAsset.js\";\r\nexport { SignalReceiver } from \"../timeline/SignalAsset.js\";\r\nexport { AnimationTrackHandler } from \"../timeline/TimelineTracks.js\";\r\nexport { AudioTrackHandler } from \"../timeline/TimelineTracks.js\";\r\nexport { SignalTrackHandler } from \"../timeline/TimelineTracks.js\";\r\nexport { ControlTrackHandler } from \"../timeline/TimelineTracks.js\";\r\nexport { TransformGizmo } from \"../TransformGizmo.js\";\r\nexport { BaseUIComponent } from \"../ui/BaseUIComponent.js\";\r\nexport { UIRootComponent } from \"../ui/BaseUIComponent.js\";\r\nexport { Button } from \"../ui/Button.js\";\r\nexport { Canvas } from \"../ui/Canvas.js\";\r\nexport { CanvasGroup } from \"../ui/CanvasGroup.js\";\r\nexport { EventSystem } from \"../ui/EventSystem.js\";\r\nexport { Graphic } from \"../ui/Graphic.js\";\r\nexport { MaskableGraphic } from \"../ui/Graphic.js\";\r\nexport { Image } from \"../ui/Image.js\";\r\nexport { RawImage } from \"../ui/Image.js\";\r\nexport { InputField } from \"../ui/InputField.js\";\r\nexport { Padding } from \"../ui/Layout.js\";\r\nexport { VerticalLayoutGroup } from \"../ui/Layout.js\";\r\nexport { HorizontalLayoutGroup } from \"../ui/Layout.js\";\r\nexport { GridLayoutGroup } from \"../ui/Layout.js\";\r\nexport { Outline } from \"../ui/Outline.js\";\r\nexport { PointerEventData } from \"../ui/PointerEvents.js\";\r\nexport { ObjectRaycaster } from \"../ui/Raycaster.js\";\r\nexport { GraphicRaycaster } from \"../ui/Raycaster.js\";\r\nexport { SpatialGrabRaycaster } from \"../ui/Raycaster.js\";\r\nexport { UIRaycastUtils } from \"../ui/RaycastUtils.js\";\r\nexport { Size } from \"../ui/RectTransform.js\";\r\nexport { Rect } from \"../ui/RectTransform.js\";\r\nexport { RectTransform } from \"../ui/RectTransform.js\";\r\nexport { SpatialHtml } from \"../ui/SpatialHtml.js\";\r\nexport { Text } from \"../ui/Text.js\";\r\nexport { LookAt } from \"../utils/LookAt.js\";\r\nexport { OpenURL } from \"../utils/OpenURL.js\";\r\nexport { VideoPlayer } from \"../VideoPlayer.js\";\r\nexport { Voip } from \"../Voip.js\";\r\nexport { Avatar } from \"../webxr/Avatar.js\";\r\nexport { XRControllerFollow } from \"../webxr/controllers/XRControllerFollow.js\";\r\nexport { XRControllerModel } from \"../webxr/controllers/XRControllerModel.js\";\r\nexport { XRControllerMovement } from \"../webxr/controllers/XRControllerMovement.js\";\r\nexport { TeleportTarget } from \"../webxr/TeleportTarget.js\";\r\nexport { WebARCameraBackground } from \"../webxr/WebARCameraBackground.js\";\r\nexport { WebARSessionRoot } from \"../webxr/WebARSessionRoot.js\";\r\nexport { WebXR } from \"../webxr/WebXR.js\";\r\nexport { AvatarMarker } from \"../webxr/WebXRAvatar.js\";\r\nexport { WebXRTrackedImage } from \"../webxr/WebXRImageTracking.js\";\r\nexport { WebXRImageTrackingModel } from \"../webxr/WebXRImageTracking.js\";\r\nexport { WebXRImageTracking } from \"../webxr/WebXRImageTracking.js\";\r\nexport { WebXRPlaneTracking } from \"../webxr/WebXRPlaneTracking.js\";\r\nexport { XRRig } from \"../webxr/WebXRRig.js\";\r\nexport { XRState } from \"../webxr/XRFlag.js\";\r\nexport { XRFlag } from \"../webxr/XRFlag.js\";\r\n", "import { Box3, Object3D, Vector3 } from \"three\";\r\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader.js\";\r\n\r\nimport { InstantiateOptions } from \"../engine/engine_gameobject.js\";\r\nimport { getLoader } from \"../engine/engine_gltf.js\";\r\nimport * as loaders from \"../engine/engine_loaders.js\"\r\nimport { Context } from \"../engine/engine_setup.js\";\r\nimport * as utils from \"../engine/engine_utils.js\"\r\nimport { GameObject } from \"./Component.js\";\r\n\r\nconst debug = utils.getParam(\"debugavatar\");\r\n\r\n/**\r\n * Represents an avatar model with head and hands references.\r\n * Used for representing characters in 3D space.\r\n */\r\nexport class AvatarModel {\r\n    /** The root object of the avatar model */\r\n    root: Object3D;\r\n    /** The head object of the avatar model */\r\n    head: Object3D;\r\n    /** The left hand object of the avatar model, if available */\r\n    leftHand: Object3D | null;\r\n    /** The right hand object of the avatar model, if available */\r\n    rigthHand: Object3D | null;\r\n\r\n\r\n    /**\r\n     * Checks if the avatar model has a valid configuration.\r\n     * An avatar is considered valid if it has a head.\r\n     * @returns Whether the avatar has a valid setup\r\n     */\r\n    get isValid(): boolean {\r\n        return this.head !== null && this.head !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Creates a new avatar model.\r\n     * @param root The root object of the avatar\r\n     * @param head The head object of the avatar\r\n     * @param leftHand The left hand object of the avatar\r\n     * @param rigthHand The right hand object of the avatar\r\n     */\r\n    constructor(root: Object3D, head: Object3D, leftHand: Object3D | null, rigthHand: Object3D | null) {\r\n        this.root = root;\r\n        this.head = head;\r\n        this.leftHand = leftHand;\r\n        this.rigthHand = rigthHand;\r\n        this.root?.traverse(h => h.layers.set(2));\r\n        // this.head?.traverse(h => h.layers.set(2));\r\n        // this.leftHand?.traverse(h => h.layers.set(2));\r\n        // this.rigthHand?.traverse(h => h.layers.set(2));\r\n    }\r\n}\r\n\r\n/**\r\n * Handles loading and instantiating avatar models from various sources.\r\n * Provides functionality to find and extract important parts of an avatar (head, hands).\r\n * \r\n * Debug mode can be enabled with the URL parameter `?debugavatar`,\r\n * which will log detailed information about avatar loading and configuration.\r\n */\r\nexport class AvatarLoader {\r\n\r\n    private readonly avatarRegistryUrl: string | null = null;\r\n    // private loader: GLTFLoader | null;\r\n    // private avatarModelCache: Map<string, AvatarModel | null> = new Map<string, AvatarModel | null>();\r\n\r\n    /**\r\n     * Retrieves or creates a new avatar instance from an ID or existing Object3D.\r\n     * @param context The application context\r\n     * @param avatarId Either a string ID to load an avatar or an existing Object3D to use as avatar\r\n     * @returns Promise resolving to an AvatarModel if successful, or null if failed\r\n     */\r\n    public async getOrCreateNewAvatarInstance(context: Context, avatarId: string | Object3D): Promise<AvatarModel | null> {\r\n\r\n        if (!avatarId) {\r\n            console.error(\"Can not create avatar: failed to provide id or root object\");\r\n            return null;\r\n        }\r\n\r\n        let root: Object3D | null = null;\r\n        if (typeof avatarId === \"string\") {\r\n            root = await this.loadAvatar(context, avatarId);\r\n            if (!root) {\r\n                const opts = new InstantiateOptions();\r\n                // opts.parent = context.scene.uuid;\r\n                root = GameObject.instantiate(utils.tryFindObject(avatarId, context.scene) as Object3D, opts);\r\n            }\r\n        }\r\n        else root = avatarId;\r\n\r\n        if (!root) {\r\n            return null;\r\n        }\r\n        const model = this.findAvatar(root);\r\n        // model.assignRandomColors();\r\n        // this.cacheModel(avatarId, model);\r\n\r\n        if (model.isValid) {\r\n            if (debug)\r\n                console.log(\"[Custom Avatar] valid config\", avatarId, debug ? model : \"\");\r\n            return model;\r\n        }\r\n        else {\r\n            console.warn(\"[Custom Avatar] config isn't valid\", avatarId, debug ? model : \"\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Loads an avatar model from a file or registry using the provided ID.\r\n     * @param context The engine context\r\n     * @param avatarId The ID of the avatar to load\r\n     * @returns Promise resolving to the loaded avatar's Object3D, or null if failed\r\n     */\r\n    private async loadAvatar(context: Context, avatarId: string): Promise<Object3D | null> {\r\n\r\n        console.assert(avatarId !== undefined && avatarId !== null && typeof avatarId === \"string\", \"Avatar id must not be null\");\r\n        if (avatarId.length <= 0) return null;\r\n        if (!avatarId) return null;\r\n\r\n        if (debug)\r\n            console.log(\"[Custom Avatar] \" + avatarId + \", loading...\");\r\n        // should probably be done by the server?!\r\n        if (!avatarId.endsWith(\".glb\"))\r\n            avatarId += \".glb\";\r\n\r\n\r\n        // for the demo we use the storage backend we uploaded the avatar to (by file drop)\r\n        if (this.avatarRegistryUrl === null) {\r\n            // try loading avatar from local file\r\n            const download_res = await fetch(\"./\" + avatarId);\r\n            let bin: ArrayBuffer | null = null;\r\n            if (download_res.ok) {\r\n                const blob = await download_res.blob();\r\n                if (blob) bin = await blob.arrayBuffer();\r\n            }\r\n            if (!bin) {\r\n                // bin = await BlobStorage.download(avatarId, avatarId, 0, \"no url here go away\", true);\r\n                return null;\r\n            }\r\n\r\n            const gltf = await getLoader().parseSync(context, bin, null!, 0);\r\n            return gltf?.scene ?? null;\r\n        }\r\n\r\n\r\n        // if (this.avatarModelCache.has(avatarId)) {\r\n        //     console.log(\"[Custom Avatar] \" + avatarId + \", found in cache\");\r\n        //     return new Promise((res, _) => {\r\n        //         var model = this.avatarModelCache.get(avatarId)?.createNewInstance();\r\n        //         res(model);\r\n        //     });\r\n        // }\r\n        // return null;\r\n\r\n        const loader = new GLTFLoader();\r\n        loaders.addDracoAndKTX2Loaders(loader, context);\r\n\r\n        // TODO: cache binary (fetch finary from model gallery and use binary method)\r\n        return new Promise((resolve, _reject) => {\r\n            const url = this.avatarRegistryUrl + \"/\" + avatarId;\r\n            loader.load(url,\r\n                async gltf => {\r\n                    await getLoader().createBuiltinComponents(context, url, gltf, null, undefined);\r\n                    resolve(gltf.scene);\r\n                },\r\n                progress => {\r\n                    if (debug)\r\n                        console.log(\"[Custom Avatar] \" + (progress.loaded / progress.total * 100) + '% loaded of ' + (progress.total / 1024) + \"kB\");\r\n                },\r\n                error => {\r\n                    console.error(\"[Custom Avatar] \" + \"Error when loading: \" + error);\r\n                    resolve(null);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Caches an avatar model for reuse.\r\n     * @param _id The ID to associate with the model\r\n     * @param _model The avatar model to cache\r\n     */\r\n    private cacheModel(_id: string, _model: AvatarModel) {\r\n        // this.avatarModelCache.set(id, model);\r\n    }\r\n\r\n    /**\r\n     * Analyzes an Object3D to find avatar parts (head, hands) based on naming conventions.\r\n     * @param obj The Object3D to search for avatar parts\r\n     * @returns A structured AvatarModel with references to found parts\r\n     */\r\n    private findAvatar(obj: Object3D): AvatarModel {\r\n\r\n        const root: Object3D = obj;\r\n        let searchIn = root;\r\n        // some GLTFs have a \"scene\" root it seems, others don't, we skip the root here if there's only one child\r\n        if (searchIn.children.length == 1)\r\n            searchIn = obj.children[0];\r\n        let head = this.findAvatarPart(searchIn, [\"head\"]);\r\n\r\n        const leftHand = this.findAvatarPart(searchIn, [\"left\", \"hand\"]);\r\n        const rightHand = this.findAvatarPart(searchIn, [\"right\", \"hand\"]);\r\n\r\n        if (!head) {\r\n            // very last fallback, entire root is used as head\r\n            head = root;\r\n\r\n            // normalize size, if the object isn't properly setup the scale might be totally off\r\n            const boundsSize = new Vector3();\r\n            new Box3().setFromObject(head).getSize(boundsSize);\r\n            const maxAxis = Math.max(boundsSize.x, boundsSize.y, boundsSize.z);\r\n            console.warn(\"[Custom Avatar] \" + \"Normalizing head scale, it's too big: \" + maxAxis + \" meters! Should be < 0.3m\");\r\n            if (maxAxis > 0.3) {\r\n                head.scale.multiplyScalar(1.0 / maxAxis * 0.3);\r\n            }\r\n        }\r\n\r\n        const model = new AvatarModel(root, head, leftHand, rightHand);\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Recursively searches for an avatar part by name within an Object3D hierarchy.\r\n     * @param obj The Object3D to search within\r\n     * @param searchString Array of strings that should all be present in the object name\r\n     * @returns The found Object3D part or null if not found\r\n     */\r\n    private findAvatarPart(obj: Object3D, searchString: string[]): Object3D | null {\r\n\r\n        const name = obj.name.toLowerCase();\r\n        let matchesAll = true;\r\n        for (const str of searchString) {\r\n            if (!matchesAll) break;\r\n            if (name.indexOf(str) === -1)\r\n                matchesAll = false;\r\n        }\r\n        if (matchesAll) return obj;\r\n\r\n        if (obj.children) {\r\n            for (const child of obj.children) {\r\n                const found = this.findAvatarPart(child, searchString);\r\n                if (found) return found;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Handles HTTP response errors from avatar loading operations.\r\n     * @param response The fetch API response to check\r\n     * @returns The response if it was ok\r\n     * @throws Error with status text if response was not ok\r\n     */\r\n    private handleCustomAvatarErrors(response) {\r\n        if (!response.ok) {\r\n            throw Error(response.statusText);\r\n        }\r\n        return response;\r\n    }\r\n}", "import type { IUSDExporterExtension } from \"../Extension.js\";\r\n\r\nexport class DocumentExtension implements IUSDExporterExtension {\r\n\r\n    get extensionName(): string {\r\n        return \"DocumentExtension\";\r\n    }\r\n\r\n    onAfterBuildDocument(_context: any) { }\r\n}", "// https://github.com/google/model-viewer/blob/c61dd1459b59cd74f539eb31658f943fd13c702e/packages/model-viewer/src/three-components/EnvironmentScene.ts#L198\r\n\r\n/* @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the 'License');\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an 'AS IS' BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BackSide, BoxGeometry, Mesh, MeshBasicMaterial, MeshStandardMaterial, PointLight, Scene} from 'three';\r\n\r\ninterface Box {\r\n  position: [number, number, number];\r\n  rotation: number;\r\n  scale: [number, number, number];\r\n}\r\n\r\ninterface Light {\r\n  intensity: number;\r\n  position: [number, number, number];\r\n  scale: [number, number, number];\r\n}\r\n\r\ninterface Env {\r\n  topLight: {\r\n    intensity: number,\r\n    position: [number, number, number],\r\n  };\r\n  room: {\r\n    position: [number, number, number],\r\n    scale: [number, number, number],\r\n  };\r\n  boxes: Box[];\r\n  lights: Light[];\r\n}\r\n\r\nconst legacy = {\r\n  topLight: {\r\n    intensity: 500,\r\n    position: [0.418, 16.199, 0.300],\r\n  },\r\n  room: {\r\n    position: [-0.757, 13.219, 0.717],\r\n    scale: [31.713, 28.305, 28.591],\r\n  },\r\n  boxes: [\r\n    {\r\n      position: [-10.906, 2.009, 1.846],\r\n      rotation: -0.195,\r\n      scale: [2.328, 7.905, 4.651],\r\n    },\r\n    {\r\n      position: [-5.607, -0.754, -0.758],\r\n      rotation: 0.994,\r\n      scale: [1.970, 1.534, 3.955],\r\n    },\r\n    {\r\n      position: [6.167, 0.857, 7.803],\r\n      rotation: 0.561,\r\n      scale: [3.927, 6.285, 3.687],\r\n    },\r\n    {\r\n      position: [-2.017, 0.018, 6.124],\r\n      rotation: 0.333,\r\n      scale: [2.002, 4.566, 2.064],\r\n    },\r\n    {\r\n      position: [2.291, -0.756, -2.621],\r\n      rotation: -0.286,\r\n      scale: [1.546, 1.552, 1.496],\r\n    },\r\n    {\r\n      position: [-2.193, -0.369, -5.547],\r\n      rotation: 0.516,\r\n      scale: [3.875, 3.487, 2.986],\r\n    },\r\n  ],\r\n  lights: [\r\n    {\r\n      intensity: 50,\r\n      position: [-16.116, 14.37, 8.208],\r\n      scale: [0.1, 2.428, 2.739],\r\n    },\r\n    {\r\n      intensity: 50,\r\n      position: [-16.109, 18.021, -8.207],\r\n      scale: [0.1, 2.425, 2.751],\r\n    },\r\n    {\r\n      intensity: 17,\r\n      position: [14.904, 12.198, -1.832],\r\n      scale: [0.15, 4.265, 6.331],\r\n    },\r\n    {\r\n      intensity: 43,\r\n      position: [-0.462, 8.89, 14.520],\r\n      scale: [4.38, 5.441, 0.088],\r\n    },\r\n    {\r\n      intensity: 20,\r\n      position: [3.235, 11.486, -12.541],\r\n      scale: [2.5, 2.0, 0.1],\r\n    },\r\n    {\r\n      intensity: 100,\r\n      position: [0.0, 20.0, 0.0],\r\n      scale: [1.0, 0.1, 1.0],\r\n    },\r\n  ]\r\n} as Env;\r\n\r\nconst neutral = {\r\n  topLight: {\r\n    intensity: 400,\r\n    position: [0.5, 14.0, 0.5],\r\n  },\r\n  room: {\r\n    position: [0.0, 13.2, 0.0],\r\n    scale: [31.5, 28.5, 31.5],\r\n  },\r\n  boxes: [\r\n    {\r\n      position: [-10.906, -1.0, 1.846],\r\n      rotation: -0.195,\r\n      scale: [2.328, 7.905, 4.651],\r\n    },\r\n    {\r\n      position: [-5.607, -0.754, -0.758],\r\n      rotation: 0.994,\r\n      scale: [1.970, 1.534, 3.955],\r\n    },\r\n    {\r\n      position: [6.167, -0.16, 7.803],\r\n      rotation: 0.561,\r\n      scale: [3.927, 6.285, 3.687],\r\n    },\r\n    {\r\n      position: [-2.017, 0.018, 6.124],\r\n      rotation: 0.333,\r\n      scale: [2.002, 4.566, 2.064],\r\n    },\r\n    {\r\n      position: [2.291, -0.756, -2.621],\r\n      rotation: -0.286,\r\n      scale: [1.546, 1.552, 1.496],\r\n    },\r\n    {\r\n      position: [-2.193, -0.369, -5.547],\r\n      rotation: 0.516,\r\n      scale: [3.875, 3.487, 2.986],\r\n    },\r\n  ],\r\n  lights: [\r\n    {\r\n      intensity: 80,\r\n      position: [-14.0, 10.0, 8.0],\r\n      scale: [0.1, 2.5, 2.5],\r\n    },\r\n    {\r\n      intensity: 80,\r\n      position: [-14.0, 14.0, -4.0],\r\n      scale: [0.1, 2.5, 2.5],\r\n    },\r\n    {\r\n      intensity: 23,\r\n      position: [14.0, 12.0, 0.0],\r\n      scale: [0.1, 5.0, 5.0],\r\n    },\r\n    {\r\n      intensity: 16,\r\n      position: [0.0, 9.0, 14.0],\r\n      scale: [5.0, 5.0, 0.1],\r\n    },\r\n    {\r\n      intensity: 80,\r\n      position: [7.0, 8.0, -14.0],\r\n      scale: [2.5, 2.5, 0.1],\r\n    },\r\n    {\r\n      intensity: 80,\r\n      position: [-7.0, 16.0, -14.0],\r\n      scale: [2.5, 2.5, 0.1],\r\n    },\r\n    {\r\n      intensity: 1,\r\n      position: [0.0, 20.0, 0.0],\r\n      scale: [0.1, 0.1, 0.1],\r\n    },\r\n  ]\r\n} as Env;\r\n\r\nexport default class EnvironmentScene extends Scene {\r\n  constructor(name: 'legacy'|'neutral') {\r\n    super();\r\n\r\n    this.position.y = -3.5;\r\n\r\n    const geometry = new BoxGeometry();\r\n    geometry.deleteAttribute('uv');\r\n\r\n    const roomMaterial =\r\n        new MeshStandardMaterial({metalness: 0, side: BackSide});\r\n    const boxMaterial = new MeshStandardMaterial({metalness: 0});\r\n\r\n    const data = name == 'legacy' ? legacy : neutral;\r\n\r\n    const mainLight = new PointLight(0xffffff, data.topLight.intensity, 28, 2);\r\n    mainLight.position.set(...data.topLight.position);\r\n    this.add(mainLight);\r\n\r\n    const room = new Mesh(geometry, roomMaterial);\r\n    room.position.set(...data.room.position);\r\n    room.scale.set(...data.room.scale);\r\n    this.add(room);\r\n\r\n    for (const box of data.boxes) {\r\n      const box1 = new Mesh(geometry, boxMaterial);\r\n      box1.position.set(...box.position);\r\n      box1.rotation.set(0, box.rotation, 0);\r\n      box1.scale.set(...box.scale);\r\n      this.add(box1);\r\n    }\r\n\r\n    for (const light of data.lights) {\r\n      const light1 =\r\n          new Mesh(geometry, this.createAreaLightMaterial(light.intensity));\r\n      light1.position.set(...light.position);\r\n      light1.scale.set(...light.scale);\r\n      this.add(light1);\r\n    }\r\n  }\r\n\r\n  createAreaLightMaterial(intensity: number): MeshBasicMaterial {\r\n    const material = new MeshBasicMaterial();\r\n    material.color.setScalar(intensity);\r\n    return material;\r\n  }\r\n}", "import { Color, PerspectiveCamera, PMREMGenerator } from \"three\";\r\n\r\nimport { getCameraController } from \"../engine/engine_camera.js\";\r\nimport { addNewComponent, getOrAddComponent } from \"../engine/engine_components.js\";\r\nimport { Context } from \"../engine/engine_context.js\";\r\nimport { ContextEvent, ContextRegistry } from \"../engine/engine_context_registry.js\";\r\nimport { NeedleEngineHTMLElement } from \"../engine/engine_element.js\";\r\nimport { createFlatTexture, createTrilightTexture } from \"../engine/engine_shaders.js\";\r\nimport type { ICamera, IContext } from \"../engine/engine_types.js\";\r\nimport { getParam } from \"../engine/engine_utils.js\";\r\nimport { RGBAColor } from \"../engine/js-extensions/index.js\";\r\nimport { Camera, ClearFlags } from \"./Camera.js\";\r\nimport { OrbitControls } from \"./OrbitControls.js\";\r\nimport EnvironmentScene from \"./utils/EnvironmentScene.js\";\r\n\r\nconst debug = getParam(\"debugmissingcamera\");\r\n\r\n/**\r\n * Handler for missing camera events. Creates a default fallback camera when no camera is found in the scene.\r\n * Sets up camera properties based on the context and HTML element attributes.\r\n * \r\n * @param evt The context event containing scene and configuration information\r\n * @returns The created camera component\r\n */\r\nContextRegistry.registerCallback(ContextEvent.MissingCamera, (evt) => {\r\n    if (debug) console.warn(\"Creating missing camera\")\r\n    const scene = evt.context.scene;\r\n\r\n    const cameraObject = new PerspectiveCamera();\r\n    cameraObject.name = \"Default Fallback Camera\"\r\n    scene.add(cameraObject);\r\n\r\n    const camInstance = new Camera();\r\n    camInstance.sourceId = evt.files?.[0]?.src ?? \"unknown\"\r\n    camInstance.fieldOfView = 35;\r\n\r\n    const transparentAttribute = evt.context.domElement.getAttribute(\"transparent\");\r\n    if (transparentAttribute != undefined) {\r\n        camInstance.clearFlags = ClearFlags.Uninitialized;\r\n    }\r\n    // Set the clearFlags to a skybox if we have one OR if the user set a skybox image attribute\r\n    else if (evt.context.domElement.getAttribute(\"skybox-image\")?.length || evt.context.domElement.getAttribute(\"background-image\")?.length || (evt.context as Context).lightmaps.tryGetSkybox(camInstance.sourceId)) {\r\n        camInstance.clearFlags = ClearFlags.Skybox;\r\n        // TODO: can we store the backgroundBlurriness in the gltf file somewhere except inside the camera?\r\n        // e.g. when we export a scene from blender without a camera in the scene\r\n        camInstance.backgroundBlurriness = .2; // same as in blender 0.5\r\n    }\r\n    else {\r\n        camInstance.clearFlags = ClearFlags.SolidColor;\r\n\r\n        let backgroundColor = \"#efefef\";\r\n        if(typeof window !== undefined && (window.matchMedia('(prefers-color-scheme: dark)').matches)) {\r\n            backgroundColor = \"#1f1f1f\";\r\n        }\r\n        scene.background = new Color(backgroundColor); // dont set it on the camera because this might be controlled from \"background-color\" attribute which is set on the scene directly. If the camera has a background color, it will override the scene's background color\r\n\r\n        // Generate a default environment map if none is set\r\n        if (!scene.environment) {\r\n            // const backgroundColorAttribute = evt.context.domElement.getAttribute(\"background-color\") ?? \"#fff\";\r\n            // const backgroundColor = new Color(backgroundColorAttribute);\r\n            const pmremGenerator = new PMREMGenerator(evt.context.renderer);\r\n            const env = new EnvironmentScene(\"neutral\");\r\n            // const background = scene.background;\r\n            // const col0 = new Color(.1, .1, .1);\r\n            // const col1 = new Color(.3, .3, .3);\r\n            // const col2 = new Color(1, 1, 1);\r\n            // const envmap = createTrilightTexture(col0, col1, col2, 32, 32);\r\n            // scene.background = envmap;\r\n            scene.environment = pmremGenerator.fromScene(env, .025).texture;\r\n            // scene.background = background;\r\n        }\r\n    }\r\n\r\n\r\n    const cam = addNewComponent(cameraObject, camInstance, true) as ICamera;\r\n    cameraObject.position.x = 0;\r\n    cameraObject.position.y = 1;\r\n    cameraObject.position.z = 2;\r\n\r\n    const engineElement = evt.context.domElement as NeedleEngineHTMLElement\r\n    // If the camera is missing and the <needle-engine controls> is not set to false, create default camera controls\r\n    // That way we still create controls if the attribute is not added to <needle-engine> at all\r\n    if (engineElement?.cameraControls != false) {\r\n        createDefaultCameraControls(evt.context, cam);\r\n    }\r\n\r\n    return cam;\r\n});\r\n\r\n/**\r\n * Handler for context creation events. Checks if camera controls should be added\r\n * to the main camera when the context is created.\r\n * \r\n * @param evt The context creation event containing the context information\r\n */\r\nContextRegistry.registerCallback(ContextEvent.ContextCreated, (evt) => {\r\n    if (!evt.context.mainCamera) {\r\n        if (debug) console.log(\"Will not auto-fit because a default camera exists\");\r\n        return;\r\n    }\r\n\r\n    // check if <needle-engine camera-controls> attribute is present or enabled\r\n    const engineElement = evt.context.domElement as NeedleEngineHTMLElement\r\n    if (engineElement?.cameraControls == true) {\r\n\r\n        // Check if something else already acts as a camera controller\r\n        const existing = getCameraController(evt.context.mainCamera);\r\n        if (existing?.isCameraController == true) {\r\n            if (debug) console.log(\"Will not auto-fit because a camera controller exists\");\r\n            return;\r\n        }\r\n        createDefaultCameraControls(evt.context);\r\n    }\r\n})\r\n\r\n/**\r\n * Creates default orbit camera controls for the specified camera.\r\n * Configures auto-rotation and auto-fit settings based on HTML attributes.\r\n * \r\n * @param context The rendering context\r\n * @param cam Optional camera component to attach controls to (uses main camera if not specified)\r\n */\r\nfunction createDefaultCameraControls(context: IContext, cam?: ICamera) {\r\n\r\n    cam = cam ?? context.mainCameraComponent;\r\n    const cameraObject = cam?.gameObject;\r\n    if (debug) console.log(\"Creating default camera controls\", cam?.name)\r\n    if (cameraObject) {\r\n        const orbit = getOrAddComponent(cameraObject, OrbitControls) as OrbitControls;\r\n        orbit.sourceId = cam?.sourceId ?? \"unknown\";\r\n        const autoRotate = context.domElement.getAttribute(\"auto-rotate\");\r\n        orbit.autoRotate = autoRotate !== undefined && autoRotate !== null && (autoRotate != \"0\" && autoRotate?.toLowerCase() != \"false\");\r\n        orbit.autoRotateSpeed = 0.5;\r\n        orbit.autoFit = true;\r\n        if (orbit.autoRotate && autoRotate) {\r\n            const autoRotateValue = parseFloat(autoRotate);\r\n            if (!isNaN(autoRotateValue)) {\r\n                orbit.autoRotateSpeed = autoRotateValue;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        console.warn(\"Missing camera object, can not add orbit controls\")\r\n    }\r\n}", "import type { GLTF } from \"three/examples/jsm/loaders/GLTFLoader.js\";\r\n\r\nimport { AnimationUtils } from \"../engine/engine_animation.js\";\r\nimport { addComponent } from \"../engine/engine_components.js\";\r\nimport { ContextEvent, ContextRegistry } from \"../engine/engine_context_registry.js\";\r\nimport { Animation } from \"./Animation.js\";\r\nimport { Animator } from \"./Animator.js\";\r\nimport { GameObject } from \"./Component.js\";\r\nimport { PlayableDirector } from \"./timeline/PlayableDirector.js\";\r\n\r\nContextRegistry.registerCallback(ContextEvent.ContextCreated, args => {\r\n    const autoplay = args.context.domElement.getAttribute(\"autoplay\");\r\n    if (autoplay !== undefined && (autoplay === \"\" || autoplay === \"true\" || autoplay === \"1\")) {\r\n        if (args.files) {\r\n            for (const file of args.files) {\r\n                const hasAnimation = GameObject.foreachComponent(file.file.scene, comp => {\r\n                    if (comp.enabled === false) return undefined;\r\n                    if (comp instanceof Animation && comp.playAutomatically || comp instanceof Animator || comp instanceof PlayableDirector && comp.playOnAwake === true) {\r\n                        return true;\r\n                    }\r\n                    else if (comp instanceof Animation) {\r\n                        comp.playAutomatically = true;\r\n                        return true;\r\n                    }\r\n                    else if (comp instanceof PlayableDirector) {\r\n                        comp.playOnAwake = true;\r\n                        return true;\r\n                    }\r\n                    return undefined;\r\n                }, true);\r\n                if (hasAnimation !== true) {\r\n                    AnimationUtils.assignAnimationsFromFile(file.file as GLTF, {\r\n                        createAnimationComponent: (obj, _clip) => {\r\n                            return addComponent(obj, Animation);\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\n\r\n", "import \"./engine/engine_element.js\";\r\nimport \"./engine/engine_setup.js\";\r\nimport \"./engine/engine_audio.js\";\r\nexport * from \"./engine/api.js\";\r\nexport * from \"./engine-components/api.js\";\r\nexport * from \"./engine-components-experimental/api.js\";\r\nexport * from \"./engine-schemes/api.js\";\r\n\r\n// make accessible for external javascript\r\nimport { Context, loadSync, NeedleXRSession, onAfterRender, onBeforeRender, onClear, onDestroy, onInitialized, onStart, onUpdate, VERSION } from \"./engine/api.js\";\r\nconst Needle = {\r\n    VERSION: VERSION,\r\n    Context: Context,\r\n    NeedleXRSession: NeedleXRSession,\r\n    gltf: {\r\n        loadFromURL: loadSync,\r\n    },\r\n    onStart: onStart,\r\n    onUpdate: onUpdate,\r\n    onBeforeRender: onBeforeRender,\r\n    onAfterRender: onAfterRender,\r\n    onInitializedContext: onInitialized,\r\n    onDestroyContext: onDestroy,\r\n    onClearContext: onClear,\r\n};\r\nif (globalThis[\"Needle\"]?.VERSION !== undefined) {\r\n    console.warn(`Needle Engine is already imported: ${globalThis[\"Needle\"].VERSION}`);\r\n}\r\nfunction registerGlobal(obj: object) {\r\n    for (const key in obj) {\r\n        Needle[key] = obj[key];\r\n    }\r\n}\r\nimport * as Component from \"./engine-components/Component.js\";\r\nregisterGlobal(Component);\r\n\r\nimport * as Components from \"./engine-components/codegen/components.js\";\r\nregisterGlobal(Components);\r\n\r\nimport { GameObject } from \"./engine-components/Component.js\";\r\nfor (const method of Object.getOwnPropertyNames(GameObject)) {\r\n    switch (method) {\r\n        case \"prototype\":\r\n        case \"constructor\":\r\n        case \"length\":\r\n        case \"name\":\r\n            continue;\r\n        default:\r\n            Needle[method] = GameObject[method];\r\n            break;\r\n    }\r\n}\r\n\r\nif (!globalThis[\"Needle\"]) {\r\n    globalThis[\"Needle\"] = Needle;\r\n}\r\nelse {\r\n    for (const key in Needle) {\r\n        globalThis[\"Needle\"][key] = Needle[key];\r\n    }\r\n}\r\n\r\n\r\n// make three accessible\r\nimport * as THREE from \"three\";\r\nif (!globalThis[\"THREE\"]) {\r\n    globalThis[\"THREE\"] = THREE;\r\n}\r\nelse console.warn(\"Three.js is already imported\");\r\n\r\n"],
  "mappings": "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",
  "names": ["_a", "isComponent", "key", "prefix", "_a", "sc", "obj", "scale", "box", "_a", "OrbitControls", "USDZExporter", "debug", "_a", "debug", "_a", "OrbitControls"]
}
