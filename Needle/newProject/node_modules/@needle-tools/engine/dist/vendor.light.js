import { PlaneGeometry as Or, ShaderChunk as fc, Triangle as wt, Vector3 as M, Layers as _s, MeshBasicMaterial as En, DoubleSide as jn, AdditiveBlending as _r, Object3D as Lo, InstancedBufferAttribute as Me, DynamicDrawUsage as ft, InstancedBufferGeometry as Vc, Uniform$1 as Qt, ShaderMaterial as On, BufferGeometry as oi, BufferAttribute as Gt, Mesh as mn, MeshStandardMaterial as Rc, MeshPhysicalMaterial as xc, Vector2 as qt, Plane as Dr, Line3 as he, Sphere as Ar, Matrix4 as kt, Box3 as Ct, REVISION as qr, BackSide as Lc, FrontSide as Jo, Group as Sc, LineBasicMaterial as Wc, BatchedMesh as Cc, Ray as gc, DataTexture as _n, NearestFilter as ii, UnsignedIntType as Ni, IntType as Ds, FloatType as Ii, UnsignedByteType as Uo, UnsignedShortType as zc, ByteType as Po, ShortType as vc, RGBAFormat as nn, RGBAIntegerFormat as Dn, RGFormat as Kc, RedFormat as Tc, RGIntegerFormat as $r, RedIntegerFormat as Mc, Matrix3 as Yc, Vector4 as So } from "./three.light.js";
const rt = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function tl(s) {
  const t = await fetch(s);
  if (t.ok)
    return t.json();
  throw new Error(t.statusText);
}
async function kc(s) {
  if (!s)
    throw new Error("No basePath supplied");
  return await tl(`${s}/profilesList.json`);
}
async function Yu(s, t, e = null, i = !0) {
  if (!s)
    throw new Error("No xrInputSource supplied");
  if (!t)
    throw new Error("No basePath supplied");
  const n = await kc(t);
  let o;
  if (s.profiles.some((l) => {
    const a = n[l];
    return a && (o = {
      profileId: l,
      profilePath: `${t}/${a.path}`,
      deprecated: !!a.deprecated
    }), !!o;
  }), !o) {
    if (!e)
      throw new Error("No matching profile name found");
    const l = n[e];
    if (!l)
      throw new Error(`No matching profile name found and default profile "${e}" missing.`);
    o = {
      profileId: e,
      profilePath: `${t}/${l.path}`,
      deprecated: !!l.deprecated
    };
  }
  const r = await tl(o.profilePath);
  let c;
  if (i) {
    let l;
    if (s.handedness === "any" ? l = r.layouts[Object.keys(r.layouts)[0]] : l = r.layouts[s.handedness], !l)
      throw new Error(
        `No matching handedness, ${s.handedness}, in profile ${o.profileId}`
      );
    l.assetPath && (c = o.profilePath.replace("profile.json", l.assetPath));
  }
  return { profile: r, assetPath: c };
}
const Hc = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: rt.ComponentState.DEFAULT
};
function Nc(s = 0, t = 0) {
  let e = s, i = t;
  if (Math.sqrt(s * s + t * t) > 1) {
    const r = Math.atan2(t, s);
    e = Math.cos(r), i = Math.sin(r);
  }
  return {
    normalizedXAxis: e * 0.5 + 0.5,
    normalizedYAxis: i * 0.5 + 0.5
  };
}
class Ic {
  constructor(t) {
    this.componentProperty = t.componentProperty, this.states = t.states, this.valueNodeName = t.valueNodeName, this.valueNodeProperty = t.valueNodeProperty, this.valueNodeProperty === rt.VisualResponseProperty.TRANSFORM && (this.minNodeName = t.minNodeName, this.maxNodeName = t.maxNodeName), this.value = 0, this.updateFromComponent(Hc);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: t,
    yAxis: e,
    button: i,
    state: n
  }) {
    const { normalizedXAxis: o, normalizedYAxis: r } = Nc(t, e);
    switch (this.componentProperty) {
      case rt.ComponentProperty.X_AXIS:
        this.value = this.states.includes(n) ? o : 0.5;
        break;
      case rt.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(n) ? r : 0.5;
        break;
      case rt.ComponentProperty.BUTTON:
        this.value = this.states.includes(n) ? i : 0;
        break;
      case rt.ComponentProperty.STATE:
        this.valueNodeProperty === rt.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(n) : this.value = this.states.includes(n) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class Jc {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(t, e) {
    if (!t || !e || !e.visualResponses || !e.gamepadIndices || Object.keys(e.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = t, this.type = e.type, this.rootNodeName = e.rootNodeName, this.touchPointNodeName = e.touchPointNodeName, this.visualResponses = {}, Object.keys(e.visualResponses).forEach((i) => {
      const n = new Ic(e.visualResponses[i]);
      this.visualResponses[i] = n;
    }), this.gamepadIndices = Object.assign({}, e.gamepadIndices), this.values = {
      state: rt.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(t) {
    if (this.values.state = rt.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && t.buttons.length > this.gamepadIndices.button) {
      const e = t.buttons[this.gamepadIndices.button];
      this.values.button = e.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, e.pressed || this.values.button === 1 ? this.values.state = rt.ComponentState.PRESSED : (e.touched || this.values.button > rt.ButtonTouchThreshold) && (this.values.state = rt.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && t.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = t.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === rt.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > rt.AxisTouchThreshold && (this.values.state = rt.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && t.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = t.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === rt.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > rt.AxisTouchThreshold && (this.values.state = rt.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((e) => {
      e.updateFromComponent(this.values);
    });
  }
}
class ku {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(t, e, i) {
    if (!t)
      throw new Error("No xrInputSource supplied");
    if (!e)
      throw new Error("No profile supplied");
    this.xrInputSource = t, this.assetUrl = i, this.id = e.profileId, this.layoutDescription = e.layouts[t.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((n) => {
      const o = this.layoutDescription.components[n];
      this.components[n] = new Jc(n, o);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const t = [];
    return Object.values(this.components).forEach((e) => {
      t.push(e.data);
    }), t;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((t) => {
      t.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const Rn = 2, Dt = 4, ae = 4, Uc = 4, Ze = new Int32Array(2), Fo = new Float32Array(Ze.buffer), Qo = new Float64Array(Ze.buffer), Rs = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
class ue {
  constructor(t, e) {
    this.low = t | 0, this.high = e | 0;
  }
  static create(t, e) {
    return t == 0 && e == 0 ? ue.ZERO : new ue(t, e);
  }
  toFloat64() {
    return (this.low >>> 0) + this.high * 4294967296;
  }
  equals(t) {
    return this.low == t.low && this.high == t.high;
  }
}
ue.ZERO = new ue(0, 0);
var An;
(function(s) {
  s[s.UTF8_BYTES = 1] = "UTF8_BYTES", s[s.UTF16_STRING = 2] = "UTF16_STRING";
})(An || (An = {}));
class on {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(t) {
    this.bytes_ = t, this.position_ = 0;
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(t) {
    return new on(new Uint8Array(t));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(t) {
    this.position_ = t;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(t) {
    return this.readUint8(t) << 24 >> 24;
  }
  readUint8(t) {
    return this.bytes_[t];
  }
  readInt16(t) {
    return this.readUint16(t) << 16 >> 16;
  }
  readUint16(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8;
  }
  readInt32(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24;
  }
  readUint32(t) {
    return this.readInt32(t) >>> 0;
  }
  readInt64(t) {
    return new ue(this.readInt32(t), this.readInt32(t + 4));
  }
  readUint64(t) {
    return new ue(this.readUint32(t), this.readUint32(t + 4));
  }
  readFloat32(t) {
    return Ze[0] = this.readInt32(t), Fo[0];
  }
  readFloat64(t) {
    return Ze[Rs ? 0 : 1] = this.readInt32(t), Ze[Rs ? 1 : 0] = this.readInt32(t + 4), Qo[0];
  }
  writeInt8(t, e) {
    this.bytes_[t] = e;
  }
  writeUint8(t, e) {
    this.bytes_[t] = e;
  }
  writeInt16(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;
  }
  writeUint16(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;
  }
  writeInt32(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;
  }
  writeUint32(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;
  }
  writeInt64(t, e) {
    this.writeInt32(t, e.low), this.writeInt32(t + 4, e.high);
  }
  writeUint64(t, e) {
    this.writeUint32(t, e.low), this.writeUint32(t + 4, e.high);
  }
  writeFloat32(t, e) {
    Fo[0] = e, this.writeInt32(t, Ze[0]);
  }
  writeFloat64(t, e) {
    Qo[0] = e, this.writeInt32(t, Ze[Rs ? 0 : 1]), this.writeInt32(t + 4, Ze[Rs ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + Dt + ae)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let t = "";
    for (let e = 0; e < ae; e++)
      t += String.fromCharCode(this.readInt8(this.position_ + Dt + e));
    return t;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(t, e) {
    const i = t - this.readInt32(t);
    return e < this.readInt16(i) ? this.readInt16(i + e) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, e) {
    return t.bb_pos = e + this.readInt32(e), t.bb = this, t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as
   * the "optionalEncoding" argument. This is useful for avoiding conversion to
   * and from UTF-16 when the data will just be packaged back up in another
   * FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(t, e) {
    t += this.readInt32(t);
    const i = this.readInt32(t);
    let n = "", o = 0;
    if (t += Dt, e === An.UTF8_BYTES)
      return this.bytes_.subarray(t, t + i);
    for (; o < i; ) {
      let r;
      const c = this.readUint8(t + o++);
      if (c < 192)
        r = c;
      else {
        const l = this.readUint8(t + o++);
        if (c < 224)
          r = (c & 31) << 6 | l & 63;
        else {
          const a = this.readUint8(t + o++);
          if (c < 240)
            r = (c & 15) << 12 | (l & 63) << 6 | a & 63;
          else {
            const d = this.readUint8(t + o++);
            r = (c & 7) << 18 | (l & 63) << 12 | (a & 63) << 6 | d & 63;
          }
        }
      }
      r < 65536 ? n += String.fromCharCode(r) : (r -= 65536, n += String.fromCharCode((r >> 10) + 55296, (r & 1024 - 1) + 56320));
    }
    return n;
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(t, e) {
    return typeof t == "string" ? this.__string(e) : this.__union(t, e);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(t) {
    return t + this.readInt32(t);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(t) {
    return t + this.readInt32(t) + Dt;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(t) {
    return this.readInt32(t + this.readInt32(t));
  }
  __has_identifier(t) {
    if (t.length != ae)
      throw new Error("FlatBuffers: file identifier must be length " + ae);
    for (let e = 0; e < ae; e++)
      if (t.charCodeAt(e) != this.readInt8(this.position() + Dt + e))
        return !1;
    return !0;
  }
  /**
   * A helper function to avoid generated code depending on this file directly.
   */
  createLong(t, e) {
    return ue.create(t, e);
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(t, e) {
    const i = [];
    for (let n = 0; n < e; ++n)
      t(n) !== null && i.push(t(n));
    return i;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(t, e) {
    const i = [];
    for (let n = 0; n < e; ++n) {
      const o = t(n);
      o !== null && i.push(o.unpack());
    }
    return i;
  }
}
class el {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(t) {
    this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null;
    let e;
    t ? e = t : e = 1024, this.bb = on.allocate(e), this.space = e;
  }
  clear() {
    this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(t) {
    this.force_defaults = t;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(t, e) {
    t > this.minalign && (this.minalign = t);
    const i = ~(this.bb.capacity() - this.space + e) + 1 & t - 1;
    for (; this.space < i + t + e; ) {
      const n = this.bb.capacity();
      this.bb = el.growByteBuffer(this.bb), this.space += this.bb.capacity() - n;
    }
    this.pad(i);
  }
  pad(t) {
    for (let e = 0; e < t; e++)
      this.bb.writeInt8(--this.space, 0);
  }
  writeInt8(t) {
    this.bb.writeInt8(this.space -= 1, t);
  }
  writeInt16(t) {
    this.bb.writeInt16(this.space -= 2, t);
  }
  writeInt32(t) {
    this.bb.writeInt32(this.space -= 4, t);
  }
  writeInt64(t) {
    this.bb.writeInt64(this.space -= 8, t);
  }
  writeFloat32(t) {
    this.bb.writeFloat32(this.space -= 4, t);
  }
  writeFloat64(t) {
    this.bb.writeFloat64(this.space -= 8, t);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the the buffer.
   */
  addInt8(t) {
    this.prep(1, 0), this.writeInt8(t);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the the buffer.
   */
  addInt16(t) {
    this.prep(2, 0), this.writeInt16(t);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the the buffer.
   */
  addInt32(t) {
    this.prep(4, 0), this.writeInt32(t);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the the buffer.
   */
  addInt64(t) {
    this.prep(8, 0), this.writeInt64(t);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the the buffer.
   */
  addFloat32(t) {
    this.prep(4, 0), this.writeFloat32(t);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the the buffer.
   */
  addFloat64(t) {
    this.prep(8, 0), this.writeFloat64(t);
  }
  addFieldInt8(t, e, i) {
    (this.force_defaults || e != i) && (this.addInt8(e), this.slot(t));
  }
  addFieldInt16(t, e, i) {
    (this.force_defaults || e != i) && (this.addInt16(e), this.slot(t));
  }
  addFieldInt32(t, e, i) {
    (this.force_defaults || e != i) && (this.addInt32(e), this.slot(t));
  }
  addFieldInt64(t, e, i) {
    (this.force_defaults || !e.equals(i)) && (this.addInt64(e), this.slot(t));
  }
  addFieldFloat32(t, e, i) {
    (this.force_defaults || e != i) && (this.addFloat32(e), this.slot(t));
  }
  addFieldFloat64(t, e, i) {
    (this.force_defaults || e != i) && (this.addFloat64(e), this.slot(t));
  }
  addFieldOffset(t, e, i) {
    (this.force_defaults || e != i) && (this.addOffset(e), this.slot(t));
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(t, e, i) {
    e != i && (this.nested(e), this.slot(t));
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(t) {
    if (t != this.offset())
      throw new Error("FlatBuffers: struct must be serialized inline.");
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested)
      throw new Error("FlatBuffers: object serialization must not be nested.");
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(t) {
    this.vtable !== null && (this.vtable[t] = this.offset());
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(t) {
    const e = t.capacity();
    if (e & 3221225472)
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    const i = e << 1, n = on.allocate(i);
    return n.setPosition(i - e), n.bytes().set(t.bytes(), i - e), n;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(t) {
    this.prep(Dt, 0), this.writeInt32(this.offset() - t + Dt);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(t) {
    this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = t;
    for (let e = 0; e < t; e++)
      this.vtable[e] = 0;
    this.isNested = !0, this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested)
      throw new Error("FlatBuffers: endObject called without startObject");
    this.addInt32(0);
    const t = this.offset();
    let e = this.vtable_in_use - 1;
    for (; e >= 0 && this.vtable[e] == 0; e--)
      ;
    const i = e + 1;
    for (; e >= 0; e--)
      this.addInt16(this.vtable[e] != 0 ? t - this.vtable[e] : 0);
    const n = 2;
    this.addInt16(t - this.object_start);
    const o = (i + n) * Rn;
    this.addInt16(o);
    let r = 0;
    const c = this.space;
    t:
      for (e = 0; e < this.vtables.length; e++) {
        const l = this.bb.capacity() - this.vtables[e];
        if (o == this.bb.readInt16(l)) {
          for (let a = Rn; a < o; a += Rn)
            if (this.bb.readInt16(c + a) != this.bb.readInt16(l + a))
              continue t;
          r = this.vtables[e];
          break;
        }
      }
    return r ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, r - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(t, e, i) {
    const n = i ? Uc : 0;
    if (e) {
      const o = e;
      if (this.prep(this.minalign, Dt + ae + n), o.length != ae)
        throw new Error("FlatBuffers: file identifier must be length " + ae);
      for (let r = ae - 1; r >= 0; r--)
        this.writeInt8(o.charCodeAt(r));
    }
    this.prep(this.minalign, Dt + n), this.addOffset(t), n && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(t, e) {
    this.finish(t, e, !0);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(t, e) {
    const i = this.bb.capacity() - t, n = i - this.bb.readInt32(i);
    if (!(this.bb.readInt16(n + e) != 0))
      throw new Error("FlatBuffers: field " + e + " must be set");
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(t, e, i) {
    this.notNested(), this.vector_num_elems = e, this.prep(Dt, t * e), this.prep(i, t * e);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    return this.writeInt32(this.vector_num_elems), this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(t) {
    if (!t)
      return 0;
    if (this.string_maps || (this.string_maps = /* @__PURE__ */ new Map()), this.string_maps.has(t))
      return this.string_maps.get(t);
    const e = this.createString(t);
    return this.string_maps.set(t, e), e;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(t) {
    if (!t)
      return 0;
    let e;
    if (t instanceof Uint8Array)
      e = t;
    else {
      e = [];
      let i = 0;
      for (; i < t.length; ) {
        let n;
        const o = t.charCodeAt(i++);
        if (o < 55296 || o >= 56320)
          n = o;
        else {
          const r = t.charCodeAt(i++);
          n = (o << 10) + r + (65536 - 56623104 - 56320);
        }
        n < 128 ? e.push(n) : (n < 2048 ? e.push(n >> 6 & 31 | 192) : (n < 65536 ? e.push(n >> 12 & 15 | 224) : e.push(n >> 18 & 7 | 240, n >> 12 & 63 | 128), e.push(n >> 6 & 63 | 128)), e.push(n & 63 | 128));
      }
    }
    this.addInt8(0), this.startVector(1, e.length, 1), this.bb.setPosition(this.space -= e.length);
    for (let i = 0, n = this.space, o = this.bb.bytes(); i < e.length; i++)
      o[n++] = e[i];
    return this.endVector();
  }
  /**
   * A helper function to avoid generated code depending on this file directly.
   */
  createLong(t, e) {
    return ue.create(t, e);
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(t) {
    return t === null ? 0 : typeof t == "string" ? this.createString(t) : t.pack(this);
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(t) {
    const e = [];
    for (let i = 0; i < t.length; ++i) {
      const n = t[i];
      if (n !== null)
        e.push(this.createObjectOffset(n));
      else
        throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
    }
    return e;
  }
  createStructOffsetList(t, e) {
    return e(this, t.length), this.createObjectOffsetList(t), this.endVector();
  }
}
function bn(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var il = { exports: {} };
(function(s) {
  var t = {};
  t.useBlobBuilder = function() {
    try {
      return new Blob([]), !1;
    } catch {
      return !0;
    }
  }(), t.useArrayBufferView = !t.useBlobBuilder && function() {
    try {
      return new Blob([new Uint8Array([])]).size === 0;
    } catch {
      return !0;
    }
  }(), s.exports.binaryFeatures = t;
  var e = s.exports.BlobBuilder;
  typeof window < "u" && (e = s.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder);
  function i() {
    this._pieces = [], this._parts = [];
  }
  i.prototype.append = function(n) {
    typeof n == "number" ? this._pieces.push(n) : (this.flush(), this._parts.push(n));
  }, i.prototype.flush = function() {
    if (this._pieces.length > 0) {
      var n = new Uint8Array(this._pieces);
      t.useArrayBufferView || (n = n.buffer), this._parts.push(n), this._pieces = [];
    }
  }, i.prototype.getBuffer = function() {
    if (this.flush(), t.useBlobBuilder) {
      for (var n = new e(), o = 0, r = this._parts.length; o < r; o++)
        n.append(this._parts[o]);
      return n.getBlob();
    } else
      return new Blob(this._parts);
  }, s.exports.BufferBuilder = i;
})(il);
var sl = il.exports, Pc = sl.BufferBuilder, wo = sl.binaryFeatures, Fc = {
  unpack: function(s) {
    var t = new ut(s);
    return t.unpack();
  },
  pack: function(s) {
    var t = new pt();
    t.pack(s);
    var e = t.getBuffer();
    return e;
  }
}, Qc = Fc;
function ut(s) {
  this.index = 0, this.dataBuffer = s, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength;
}
ut.prototype.unpack = function() {
  var s = this.unpack_uint8();
  if (s < 128)
    return s;
  if ((s ^ 224) < 32)
    return (s ^ 224) - 32;
  var t;
  if ((t = s ^ 160) <= 15)
    return this.unpack_raw(t);
  if ((t = s ^ 176) <= 15)
    return this.unpack_string(t);
  if ((t = s ^ 144) <= 15)
    return this.unpack_array(t);
  if ((t = s ^ 128) <= 15)
    return this.unpack_map(t);
  switch (s) {
    case 192:
      return null;
    case 193:
      return;
    case 194:
      return !1;
    case 195:
      return !0;
    case 202:
      return this.unpack_float();
    case 203:
      return this.unpack_double();
    case 204:
      return this.unpack_uint8();
    case 205:
      return this.unpack_uint16();
    case 206:
      return this.unpack_uint32();
    case 207:
      return this.unpack_uint64();
    case 208:
      return this.unpack_int8();
    case 209:
      return this.unpack_int16();
    case 210:
      return this.unpack_int32();
    case 211:
      return this.unpack_int64();
    case 212:
      return;
    case 213:
      return;
    case 214:
      return;
    case 215:
      return;
    case 216:
      return t = this.unpack_uint16(), this.unpack_string(t);
    case 217:
      return t = this.unpack_uint32(), this.unpack_string(t);
    case 218:
      return t = this.unpack_uint16(), this.unpack_raw(t);
    case 219:
      return t = this.unpack_uint32(), this.unpack_raw(t);
    case 220:
      return t = this.unpack_uint16(), this.unpack_array(t);
    case 221:
      return t = this.unpack_uint32(), this.unpack_array(t);
    case 222:
      return t = this.unpack_uint16(), this.unpack_map(t);
    case 223:
      return t = this.unpack_uint32(), this.unpack_map(t);
  }
};
ut.prototype.unpack_uint8 = function() {
  var s = this.dataView[this.index] & 255;
  return this.index++, s;
};
ut.prototype.unpack_uint16 = function() {
  var s = this.read(2), t = (s[0] & 255) * 256 + (s[1] & 255);
  return this.index += 2, t;
};
ut.prototype.unpack_uint32 = function() {
  var s = this.read(4), t = ((s[0] * 256 + s[1]) * 256 + s[2]) * 256 + s[3];
  return this.index += 4, t;
};
ut.prototype.unpack_uint64 = function() {
  var s = this.read(8), t = ((((((s[0] * 256 + s[1]) * 256 + s[2]) * 256 + s[3]) * 256 + s[4]) * 256 + s[5]) * 256 + s[6]) * 256 + s[7];
  return this.index += 8, t;
};
ut.prototype.unpack_int8 = function() {
  var s = this.unpack_uint8();
  return s < 128 ? s : s - 256;
};
ut.prototype.unpack_int16 = function() {
  var s = this.unpack_uint16();
  return s < 32768 ? s : s - 65536;
};
ut.prototype.unpack_int32 = function() {
  var s = this.unpack_uint32();
  return s < Math.pow(2, 31) ? s : s - Math.pow(2, 32);
};
ut.prototype.unpack_int64 = function() {
  var s = this.unpack_uint64();
  return s < Math.pow(2, 63) ? s : s - Math.pow(2, 64);
};
ut.prototype.unpack_raw = function(s) {
  if (this.length < this.index + s)
    throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + s + " " + this.length);
  var t = this.dataBuffer.slice(this.index, this.index + s);
  return this.index += s, t;
};
ut.prototype.unpack_string = function(s) {
  for (var t = this.read(s), e = 0, i = "", n, o; e < s; )
    n = t[e], n < 128 ? (i += String.fromCharCode(n), e++) : (n ^ 192) < 32 ? (o = (n ^ 192) << 6 | t[e + 1] & 63, i += String.fromCharCode(o), e += 2) : (o = (n & 15) << 12 | (t[e + 1] & 63) << 6 | t[e + 2] & 63, i += String.fromCharCode(o), e += 3);
  return this.index += s, i;
};
ut.prototype.unpack_array = function(s) {
  for (var t = new Array(s), e = 0; e < s; e++)
    t[e] = this.unpack();
  return t;
};
ut.prototype.unpack_map = function(s) {
  for (var t = {}, e = 0; e < s; e++) {
    var i = this.unpack(), n = this.unpack();
    t[i] = n;
  }
  return t;
};
ut.prototype.unpack_float = function() {
  var s = this.unpack_uint32(), t = s >> 31, e = (s >> 23 & 255) - 127, i = s & 8388607 | 8388608;
  return (t === 0 ? 1 : -1) * i * Math.pow(2, e - 23);
};
ut.prototype.unpack_double = function() {
  var s = this.unpack_uint32(), t = this.unpack_uint32(), e = s >> 31, i = (s >> 20 & 2047) - 1023, n = s & 1048575 | 1048576, o = n * Math.pow(2, i - 20) + t * Math.pow(2, i - 52);
  return (e === 0 ? 1 : -1) * o;
};
ut.prototype.read = function(s) {
  var t = this.index;
  if (t + s <= this.length)
    return this.dataView.subarray(t, t + s);
  throw new Error("BinaryPackFailure: read index out of range");
};
function pt() {
  this.bufferBuilder = new Pc();
}
pt.prototype.getBuffer = function() {
  return this.bufferBuilder.getBuffer();
};
pt.prototype.pack = function(s) {
  var t = typeof s;
  if (t === "string")
    this.pack_string(s);
  else if (t === "number")
    Math.floor(s) === s ? this.pack_integer(s) : this.pack_double(s);
  else if (t === "boolean")
    s === !0 ? this.bufferBuilder.append(195) : s === !1 && this.bufferBuilder.append(194);
  else if (t === "undefined")
    this.bufferBuilder.append(192);
  else if (t === "object")
    if (s === null)
      this.bufferBuilder.append(192);
    else {
      var e = s.constructor;
      if (e == Array)
        this.pack_array(s);
      else if (e == Blob || e == File || s instanceof Blob || s instanceof File)
        this.pack_bin(s);
      else if (e == ArrayBuffer)
        wo.useArrayBufferView ? this.pack_bin(new Uint8Array(s)) : this.pack_bin(s);
      else if ("BYTES_PER_ELEMENT" in s)
        wo.useArrayBufferView ? this.pack_bin(new Uint8Array(s.buffer)) : this.pack_bin(s.buffer);
      else if (e == Object || e.toString().startsWith("class"))
        this.pack_object(s);
      else if (e == Date)
        this.pack_string(s.toString());
      else if (typeof s.toBinaryPack == "function")
        this.bufferBuilder.append(s.toBinaryPack());
      else
        throw new Error('Type "' + e.toString() + '" not yet supported');
    }
  else
    throw new Error('Type "' + t + '" not yet supported');
  this.bufferBuilder.flush();
};
pt.prototype.pack_bin = function(s) {
  var t = s.length || s.byteLength || s.size;
  if (t <= 15)
    this.pack_uint8(160 + t);
  else if (t <= 65535)
    this.bufferBuilder.append(218), this.pack_uint16(t);
  else if (t <= 4294967295)
    this.bufferBuilder.append(219), this.pack_uint32(t);
  else
    throw new Error("Invalid length");
  this.bufferBuilder.append(s);
};
pt.prototype.pack_string = function(s) {
  var t = Bc(s);
  if (t <= 15)
    this.pack_uint8(176 + t);
  else if (t <= 65535)
    this.bufferBuilder.append(216), this.pack_uint16(t);
  else if (t <= 4294967295)
    this.bufferBuilder.append(217), this.pack_uint32(t);
  else
    throw new Error("Invalid length");
  this.bufferBuilder.append(s);
};
pt.prototype.pack_array = function(s) {
  var t = s.length;
  if (t <= 15)
    this.pack_uint8(144 + t);
  else if (t <= 65535)
    this.bufferBuilder.append(220), this.pack_uint16(t);
  else if (t <= 4294967295)
    this.bufferBuilder.append(221), this.pack_uint32(t);
  else
    throw new Error("Invalid length");
  for (var e = 0; e < t; e++)
    this.pack(s[e]);
};
pt.prototype.pack_integer = function(s) {
  if (s >= -32 && s <= 127)
    this.bufferBuilder.append(s & 255);
  else if (s >= 0 && s <= 255)
    this.bufferBuilder.append(204), this.pack_uint8(s);
  else if (s >= -128 && s <= 127)
    this.bufferBuilder.append(208), this.pack_int8(s);
  else if (s >= 0 && s <= 65535)
    this.bufferBuilder.append(205), this.pack_uint16(s);
  else if (s >= -32768 && s <= 32767)
    this.bufferBuilder.append(209), this.pack_int16(s);
  else if (s >= 0 && s <= 4294967295)
    this.bufferBuilder.append(206), this.pack_uint32(s);
  else if (s >= -2147483648 && s <= 2147483647)
    this.bufferBuilder.append(210), this.pack_int32(s);
  else if (s >= -9223372036854776e3 && s <= 9223372036854776e3)
    this.bufferBuilder.append(211), this.pack_int64(s);
  else if (s >= 0 && s <= 18446744073709552e3)
    this.bufferBuilder.append(207), this.pack_uint64(s);
  else
    throw new Error("Invalid integer");
};
pt.prototype.pack_double = function(s) {
  var t = 0;
  s < 0 && (t = 1, s = -s);
  var e = Math.floor(Math.log(s) / Math.LN2), i = s / Math.pow(2, e) - 1, n = Math.floor(i * Math.pow(2, 52)), o = Math.pow(2, 32), r = t << 31 | e + 1023 << 20 | n / o & 1048575, c = n % o;
  this.bufferBuilder.append(203), this.pack_int32(r), this.pack_int32(c);
};
pt.prototype.pack_object = function(s) {
  var t = Object.keys(s), e = t.length;
  if (e <= 15)
    this.pack_uint8(128 + e);
  else if (e <= 65535)
    this.bufferBuilder.append(222), this.pack_uint16(e);
  else if (e <= 4294967295)
    this.bufferBuilder.append(223), this.pack_uint32(e);
  else
    throw new Error("Invalid length");
  for (var i in s)
    s.hasOwnProperty(i) && (this.pack(i), this.pack(s[i]));
};
pt.prototype.pack_uint8 = function(s) {
  this.bufferBuilder.append(s);
};
pt.prototype.pack_uint16 = function(s) {
  this.bufferBuilder.append(s >> 8), this.bufferBuilder.append(s & 255);
};
pt.prototype.pack_uint32 = function(s) {
  var t = s & 4294967295;
  this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255);
};
pt.prototype.pack_uint64 = function(s) {
  var t = s / Math.pow(2, 32), e = s % Math.pow(2, 32);
  this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((e & 4278190080) >>> 24), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255);
};
pt.prototype.pack_int8 = function(s) {
  this.bufferBuilder.append(s & 255);
};
pt.prototype.pack_int16 = function(s) {
  this.bufferBuilder.append((s & 65280) >> 8), this.bufferBuilder.append(s & 255);
};
pt.prototype.pack_int32 = function(s) {
  this.bufferBuilder.append(s >>> 24 & 255), this.bufferBuilder.append((s & 16711680) >>> 16), this.bufferBuilder.append((s & 65280) >>> 8), this.bufferBuilder.append(s & 255);
};
pt.prototype.pack_int64 = function(s) {
  var t = Math.floor(s / Math.pow(2, 32)), e = s % Math.pow(2, 32);
  this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((e & 4278190080) >>> 24), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255);
};
function wc(s) {
  var t = s.charCodeAt(0);
  return t <= 2047 ? "00" : t <= 65535 ? "000" : t <= 2097151 ? "0000" : t <= 67108863 ? "00000" : "000000";
}
function Bc(s) {
  return s.length > 600 ? new Blob([s]).size : s.replace(/[^\u0000-\u007F]/g, wc).length;
}
const Bo = /* @__PURE__ */ bn(Qc);
let nl = !0, ol = !0;
function Ti(s, t, e) {
  const i = s.match(t);
  return i && i.length >= e && parseInt(i[e], 10);
}
function di(s, t, e) {
  if (!s.RTCPeerConnection)
    return;
  const i = s.RTCPeerConnection.prototype, n = i.addEventListener;
  i.addEventListener = function(r, c) {
    if (r !== t)
      return n.apply(this, arguments);
    const l = (a) => {
      const d = e(a);
      d && (c.handleEvent ? c.handleEvent(d) : c(d));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = /* @__PURE__ */ new Map()), this._eventMap[t].set(c, l), n.apply(this, [
      r,
      l
    ]);
  };
  const o = i.removeEventListener;
  i.removeEventListener = function(r, c) {
    if (r !== t || !this._eventMap || !this._eventMap[t])
      return o.apply(this, arguments);
    if (!this._eventMap[t].has(c))
      return o.apply(this, arguments);
    const l = this._eventMap[t].get(c);
    return this._eventMap[t].delete(c), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, o.apply(this, [
      r,
      l
    ]);
  }, Object.defineProperty(i, "on" + t, {
    get() {
      return this["_on" + t];
    },
    set(r) {
      this["_on" + t] && (this.removeEventListener(
        t,
        this["_on" + t]
      ), delete this["_on" + t]), r && this.addEventListener(
        t,
        this["_on" + t] = r
      );
    },
    enumerable: !0,
    configurable: !0
  });
}
function Ec(s) {
  return typeof s != "boolean" ? new Error("Argument type: " + typeof s + ". Please use a boolean.") : (nl = s, s ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function jc(s) {
  return typeof s != "boolean" ? new Error("Argument type: " + typeof s + ". Please use a boolean.") : (ol = !s, "adapter.js deprecation warnings " + (s ? "disabled" : "enabled"));
}
function Wo() {
  if (typeof window == "object") {
    if (nl)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function yn(s, t) {
  ol && console.warn(s + " is deprecated, please use " + t + " instead.");
}
function Oc(s) {
  const t = { browser: null, version: null };
  if (typeof s > "u" || !s.navigator)
    return t.browser = "Not a browser.", t;
  const { navigator: e } = s;
  if (e.mozGetUserMedia)
    t.browser = "firefox", t.version = Ti(
      e.userAgent,
      /Firefox\/(\d+)\./,
      1
    );
  else if (e.webkitGetUserMedia || s.isSecureContext === !1 && s.webkitRTCPeerConnection && !s.RTCIceGatherer)
    t.browser = "chrome", t.version = Ti(
      e.userAgent,
      /Chrom(e|ium)\/(\d+)\./,
      2
    );
  else if (e.mediaDevices && e.userAgent.match(/Edge\/(\d+).(\d+)$/))
    t.browser = "edge", t.version = Ti(
      e.userAgent,
      /Edge\/(\d+).(\d+)$/,
      2
    );
  else if (s.RTCPeerConnection && e.userAgent.match(/AppleWebKit\/(\d+)\./))
    t.browser = "safari", t.version = Ti(
      e.userAgent,
      /AppleWebKit\/(\d+)\./,
      1
    ), t.supportsUnifiedPlan = s.RTCRtpTransceiver && "currentDirection" in s.RTCRtpTransceiver.prototype;
  else
    return t.browser = "Not a supported browser.", t;
  return t;
}
function Eo(s) {
  return Object.prototype.toString.call(s) === "[object Object]";
}
function rl(s) {
  return Eo(s) ? Object.keys(s).reduce(function(t, e) {
    const i = Eo(s[e]), n = i ? rl(s[e]) : s[e], o = i && !Object.keys(n).length;
    return n === void 0 || o ? t : Object.assign(t, { [e]: n });
  }, {}) : s;
}
function qn(s, t, e) {
  !t || e.has(t.id) || (e.set(t.id, t), Object.keys(t).forEach((i) => {
    i.endsWith("Id") ? qn(s, s.get(t[i]), e) : i.endsWith("Ids") && t[i].forEach((n) => {
      qn(s, s.get(n), e);
    });
  }));
}
function jo(s, t, e) {
  const i = e ? "outbound-rtp" : "inbound-rtp", n = /* @__PURE__ */ new Map();
  if (t === null)
    return n;
  const o = [];
  return s.forEach((r) => {
    r.type === "track" && r.trackIdentifier === t.id && o.push(r);
  }), o.forEach((r) => {
    s.forEach((c) => {
      c.type === i && c.trackId === r.id && qn(s, c, n);
    });
  }), n;
}
const Oo = Wo;
function ll(s, t) {
  const e = s && s.navigator;
  if (!e.mediaDevices)
    return;
  const i = function(c) {
    if (typeof c != "object" || c.mandatory || c.optional)
      return c;
    const l = {};
    return Object.keys(c).forEach((a) => {
      if (a === "require" || a === "advanced" || a === "mediaSource")
        return;
      const d = typeof c[a] == "object" ? c[a] : { ideal: c[a] };
      d.exact !== void 0 && typeof d.exact == "number" && (d.min = d.max = d.exact);
      const h = function(u, p) {
        return u ? u + p.charAt(0).toUpperCase() + p.slice(1) : p === "deviceId" ? "sourceId" : p;
      };
      if (d.ideal !== void 0) {
        l.optional = l.optional || [];
        let u = {};
        typeof d.ideal == "number" ? (u[h("min", a)] = d.ideal, l.optional.push(u), u = {}, u[h("max", a)] = d.ideal, l.optional.push(u)) : (u[h("", a)] = d.ideal, l.optional.push(u));
      }
      d.exact !== void 0 && typeof d.exact != "number" ? (l.mandatory = l.mandatory || {}, l.mandatory[h("", a)] = d.exact) : ["min", "max"].forEach((u) => {
        d[u] !== void 0 && (l.mandatory = l.mandatory || {}, l.mandatory[h(u, a)] = d[u]);
      });
    }), c.advanced && (l.optional = (l.optional || []).concat(c.advanced)), l;
  }, n = function(c, l) {
    if (t.version >= 61)
      return l(c);
    if (c = JSON.parse(JSON.stringify(c)), c && typeof c.audio == "object") {
      const a = function(d, h, u) {
        h in d && !(u in d) && (d[u] = d[h], delete d[h]);
      };
      c = JSON.parse(JSON.stringify(c)), a(c.audio, "autoGainControl", "googAutoGainControl"), a(c.audio, "noiseSuppression", "googNoiseSuppression"), c.audio = i(c.audio);
    }
    if (c && typeof c.video == "object") {
      let a = c.video.facingMode;
      a = a && (typeof a == "object" ? a : { ideal: a });
      const d = t.version < 66;
      if (a && (a.exact === "user" || a.exact === "environment" || a.ideal === "user" || a.ideal === "environment") && !(e.mediaDevices.getSupportedConstraints && e.mediaDevices.getSupportedConstraints().facingMode && !d)) {
        delete c.video.facingMode;
        let h;
        if (a.exact === "environment" || a.ideal === "environment" ? h = ["back", "rear"] : (a.exact === "user" || a.ideal === "user") && (h = ["front"]), h)
          return e.mediaDevices.enumerateDevices().then((u) => {
            u = u.filter((m) => m.kind === "videoinput");
            let p = u.find((m) => h.some((b) => m.label.toLowerCase().includes(b)));
            return !p && u.length && h.includes("back") && (p = u[u.length - 1]), p && (c.video.deviceId = a.exact ? { exact: p.deviceId } : { ideal: p.deviceId }), c.video = i(c.video), Oo("chrome: " + JSON.stringify(c)), l(c);
          });
      }
      c.video = i(c.video);
    }
    return Oo("chrome: " + JSON.stringify(c)), l(c);
  }, o = function(c) {
    return t.version >= 64 ? c : {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[c.name] || c.name,
      message: c.message,
      constraint: c.constraint || c.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, r = function(c, l, a) {
    n(c, (d) => {
      e.webkitGetUserMedia(d, l, (h) => {
        a && a(o(h));
      });
    });
  };
  if (e.getUserMedia = r.bind(e), e.mediaDevices.getUserMedia) {
    const c = e.mediaDevices.getUserMedia.bind(e.mediaDevices);
    e.mediaDevices.getUserMedia = function(l) {
      return n(l, (a) => c(a).then((d) => {
        if (a.audio && !d.getAudioTracks().length || a.video && !d.getVideoTracks().length)
          throw d.getTracks().forEach((h) => {
            h.stop();
          }), new DOMException("", "NotFoundError");
        return d;
      }, (d) => Promise.reject(o(d))));
    };
  }
}
function _c(s, t) {
  if (!(s.navigator.mediaDevices && "getDisplayMedia" in s.navigator.mediaDevices) && s.navigator.mediaDevices) {
    if (typeof t != "function") {
      console.error("shimGetDisplayMedia: getSourceId argument is not a function");
      return;
    }
    s.navigator.mediaDevices.getDisplayMedia = function(i) {
      return t(i).then((n) => {
        const o = i.video && i.video.width, r = i.video && i.video.height, c = i.video && i.video.frameRate;
        return i.video = {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: n,
            maxFrameRate: c || 3
          }
        }, o && (i.video.mandatory.maxWidth = o), r && (i.video.mandatory.maxHeight = r), s.navigator.mediaDevices.getUserMedia(i);
      });
    };
  }
}
function cl(s) {
  s.MediaStream = s.MediaStream || s.webkitMediaStream;
}
function al(s) {
  if (typeof s == "object" && s.RTCPeerConnection && !("ontrack" in s.RTCPeerConnection.prototype)) {
    Object.defineProperty(s.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(e) {
        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e);
      },
      enumerable: !0,
      configurable: !0
    });
    const t = s.RTCPeerConnection.prototype.setRemoteDescription;
    s.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (i) => {
        i.stream.addEventListener("addtrack", (n) => {
          let o;
          s.RTCPeerConnection.prototype.getReceivers ? o = this.getReceivers().find((c) => c.track && c.track.id === n.track.id) : o = { track: n.track };
          const r = new Event("track");
          r.track = n.track, r.receiver = o, r.transceiver = { receiver: o }, r.streams = [i.stream], this.dispatchEvent(r);
        }), i.stream.getTracks().forEach((n) => {
          let o;
          s.RTCPeerConnection.prototype.getReceivers ? o = this.getReceivers().find((c) => c.track && c.track.id === n.id) : o = { track: n };
          const r = new Event("track");
          r.track = n, r.receiver = o, r.transceiver = { receiver: o }, r.streams = [i.stream], this.dispatchEvent(r);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments);
    };
  } else
    di(s, "track", (t) => (t.transceiver || Object.defineProperty(
      t,
      "transceiver",
      { value: { receiver: t.receiver } }
    ), t));
}
function dl(s) {
  if (typeof s == "object" && s.RTCPeerConnection && !("getSenders" in s.RTCPeerConnection.prototype) && "createDTMFSender" in s.RTCPeerConnection.prototype) {
    const t = function(n, o) {
      return {
        track: o,
        get dtmf() {
          return this._dtmf === void 0 && (o.kind === "audio" ? this._dtmf = n.createDTMFSender(o) : this._dtmf = null), this._dtmf;
        },
        _pc: n
      };
    };
    if (!s.RTCPeerConnection.prototype.getSenders) {
      s.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const n = s.RTCPeerConnection.prototype.addTrack;
      s.RTCPeerConnection.prototype.addTrack = function(c, l) {
        let a = n.apply(this, arguments);
        return a || (a = t(this, c), this._senders.push(a)), a;
      };
      const o = s.RTCPeerConnection.prototype.removeTrack;
      s.RTCPeerConnection.prototype.removeTrack = function(c) {
        o.apply(this, arguments);
        const l = this._senders.indexOf(c);
        l !== -1 && this._senders.splice(l, 1);
      };
    }
    const e = s.RTCPeerConnection.prototype.addStream;
    s.RTCPeerConnection.prototype.addStream = function(o) {
      this._senders = this._senders || [], e.apply(this, [o]), o.getTracks().forEach((r) => {
        this._senders.push(t(this, r));
      });
    };
    const i = s.RTCPeerConnection.prototype.removeStream;
    s.RTCPeerConnection.prototype.removeStream = function(o) {
      this._senders = this._senders || [], i.apply(this, [o]), o.getTracks().forEach((r) => {
        const c = this._senders.find((l) => l.track === r);
        c && this._senders.splice(this._senders.indexOf(c), 1);
      });
    };
  } else if (typeof s == "object" && s.RTCPeerConnection && "getSenders" in s.RTCPeerConnection.prototype && "createDTMFSender" in s.RTCPeerConnection.prototype && s.RTCRtpSender && !("dtmf" in s.RTCRtpSender.prototype)) {
    const t = s.RTCPeerConnection.prototype.getSenders;
    s.RTCPeerConnection.prototype.getSenders = function() {
      const i = t.apply(this, []);
      return i.forEach((n) => n._pc = this), i;
    }, Object.defineProperty(s.RTCRtpSender.prototype, "dtmf", {
      get() {
        return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
      }
    });
  }
}
function hl(s) {
  if (!s.RTCPeerConnection)
    return;
  const t = s.RTCPeerConnection.prototype.getStats;
  s.RTCPeerConnection.prototype.getStats = function() {
    const [i, n, o] = arguments;
    if (arguments.length > 0 && typeof i == "function")
      return t.apply(this, arguments);
    if (t.length === 0 && (arguments.length === 0 || typeof i != "function"))
      return t.apply(this, []);
    const r = function(l) {
      const a = {};
      return l.result().forEach((h) => {
        const u = {
          id: h.id,
          timestamp: h.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[h.type] || h.type
        };
        h.names().forEach((p) => {
          u[p] = h.stat(p);
        }), a[u.id] = u;
      }), a;
    }, c = function(l) {
      return new Map(Object.keys(l).map((a) => [a, l[a]]));
    };
    if (arguments.length >= 2) {
      const l = function(a) {
        n(c(r(a)));
      };
      return t.apply(this, [
        l,
        i
      ]);
    }
    return new Promise((l, a) => {
      t.apply(this, [
        function(d) {
          l(c(r(d)));
        },
        a
      ]);
    }).then(n, o);
  };
}
function ul(s) {
  if (!(typeof s == "object" && s.RTCPeerConnection && s.RTCRtpSender && s.RTCRtpReceiver))
    return;
  if (!("getStats" in s.RTCRtpSender.prototype)) {
    const e = s.RTCPeerConnection.prototype.getSenders;
    e && (s.RTCPeerConnection.prototype.getSenders = function() {
      const o = e.apply(this, []);
      return o.forEach((r) => r._pc = this), o;
    });
    const i = s.RTCPeerConnection.prototype.addTrack;
    i && (s.RTCPeerConnection.prototype.addTrack = function() {
      const o = i.apply(this, arguments);
      return o._pc = this, o;
    }), s.RTCRtpSender.prototype.getStats = function() {
      const o = this;
      return this._pc.getStats().then((r) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        jo(r, o.track, !0)
      ));
    };
  }
  if (!("getStats" in s.RTCRtpReceiver.prototype)) {
    const e = s.RTCPeerConnection.prototype.getReceivers;
    e && (s.RTCPeerConnection.prototype.getReceivers = function() {
      const n = e.apply(this, []);
      return n.forEach((o) => o._pc = this), n;
    }), di(s, "track", (i) => (i.receiver._pc = i.srcElement, i)), s.RTCRtpReceiver.prototype.getStats = function() {
      const n = this;
      return this._pc.getStats().then((o) => jo(o, n.track, !1));
    };
  }
  if (!("getStats" in s.RTCRtpSender.prototype && "getStats" in s.RTCRtpReceiver.prototype))
    return;
  const t = s.RTCPeerConnection.prototype.getStats;
  s.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof s.MediaStreamTrack) {
      const i = arguments[0];
      let n, o, r;
      return this.getSenders().forEach((c) => {
        c.track === i && (n ? r = !0 : n = c);
      }), this.getReceivers().forEach((c) => (c.track === i && (o ? r = !0 : o = c), c.track === i)), r || n && o ? Promise.reject(new DOMException(
        "There are more than one sender or receiver for the track.",
        "InvalidAccessError"
      )) : n ? n.getStats() : o ? o.getStats() : Promise.reject(new DOMException(
        "There is no sender or receiver for the track.",
        "InvalidAccessError"
      ));
    }
    return t.apply(this, arguments);
  };
}
function pl(s) {
  s.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((r) => this._shimmedLocalStreams[r][0]);
  };
  const t = s.RTCPeerConnection.prototype.addTrack;
  s.RTCPeerConnection.prototype.addTrack = function(r, c) {
    if (!c)
      return t.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const l = t.apply(this, arguments);
    return this._shimmedLocalStreams[c.id] ? this._shimmedLocalStreams[c.id].indexOf(l) === -1 && this._shimmedLocalStreams[c.id].push(l) : this._shimmedLocalStreams[c.id] = [c, l], l;
  };
  const e = s.RTCPeerConnection.prototype.addStream;
  s.RTCPeerConnection.prototype.addStream = function(r) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, r.getTracks().forEach((a) => {
      if (this.getSenders().find((h) => h.track === a))
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
    });
    const c = this.getSenders();
    e.apply(this, arguments);
    const l = this.getSenders().filter((a) => c.indexOf(a) === -1);
    this._shimmedLocalStreams[r.id] = [r].concat(l);
  };
  const i = s.RTCPeerConnection.prototype.removeStream;
  s.RTCPeerConnection.prototype.removeStream = function(r) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[r.id], i.apply(this, arguments);
  };
  const n = s.RTCPeerConnection.prototype.removeTrack;
  s.RTCPeerConnection.prototype.removeTrack = function(r) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, r && Object.keys(this._shimmedLocalStreams).forEach((c) => {
      const l = this._shimmedLocalStreams[c].indexOf(r);
      l !== -1 && this._shimmedLocalStreams[c].splice(l, 1), this._shimmedLocalStreams[c].length === 1 && delete this._shimmedLocalStreams[c];
    }), n.apply(this, arguments);
  };
}
function ml(s, t) {
  if (!s.RTCPeerConnection)
    return;
  if (s.RTCPeerConnection.prototype.addTrack && t.version >= 65)
    return pl(s);
  const e = s.RTCPeerConnection.prototype.getLocalStreams;
  s.RTCPeerConnection.prototype.getLocalStreams = function() {
    const d = e.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, d.map((h) => this._reverseStreams[h.id]);
  };
  const i = s.RTCPeerConnection.prototype.addStream;
  s.RTCPeerConnection.prototype.addStream = function(d) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, d.getTracks().forEach((h) => {
      if (this.getSenders().find((p) => p.track === h))
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
    }), !this._reverseStreams[d.id]) {
      const h = new s.MediaStream(d.getTracks());
      this._streams[d.id] = h, this._reverseStreams[h.id] = d, d = h;
    }
    i.apply(this, [d]);
  };
  const n = s.RTCPeerConnection.prototype.removeStream;
  s.RTCPeerConnection.prototype.removeStream = function(d) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, n.apply(this, [this._streams[d.id] || d]), delete this._reverseStreams[this._streams[d.id] ? this._streams[d.id].id : d.id], delete this._streams[d.id];
  }, s.RTCPeerConnection.prototype.addTrack = function(d, h) {
    if (this.signalingState === "closed")
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    const u = [].slice.call(arguments, 1);
    if (u.length !== 1 || !u[0].getTracks().find((b) => b === d))
      throw new DOMException(
        "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
        "NotSupportedError"
      );
    if (this.getSenders().find((b) => b.track === d))
      throw new DOMException(
        "Track already exists.",
        "InvalidAccessError"
      );
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const m = this._streams[h.id];
    if (m)
      m.addTrack(d), Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    else {
      const b = new s.MediaStream([d]);
      this._streams[h.id] = b, this._reverseStreams[b.id] = h, this.addStream(b);
    }
    return this.getSenders().find((b) => b.track === d);
  };
  function o(a, d) {
    let h = d.sdp;
    return Object.keys(a._reverseStreams || []).forEach((u) => {
      const p = a._reverseStreams[u], m = a._streams[p.id];
      h = h.replace(
        new RegExp(m.id, "g"),
        p.id
      );
    }), new RTCSessionDescription({
      type: d.type,
      sdp: h
    });
  }
  function r(a, d) {
    let h = d.sdp;
    return Object.keys(a._reverseStreams || []).forEach((u) => {
      const p = a._reverseStreams[u], m = a._streams[p.id];
      h = h.replace(
        new RegExp(p.id, "g"),
        m.id
      );
    }), new RTCSessionDescription({
      type: d.type,
      sdp: h
    });
  }
  ["createOffer", "createAnswer"].forEach(function(a) {
    const d = s.RTCPeerConnection.prototype[a], h = { [a]() {
      const u = arguments;
      return arguments.length && typeof arguments[0] == "function" ? d.apply(this, [
        (m) => {
          const b = o(this, m);
          u[0].apply(null, [b]);
        },
        (m) => {
          u[1] && u[1].apply(null, m);
        },
        arguments[2]
      ]) : d.apply(this, arguments).then((m) => o(this, m));
    } };
    s.RTCPeerConnection.prototype[a] = h[a];
  });
  const c = s.RTCPeerConnection.prototype.setLocalDescription;
  s.RTCPeerConnection.prototype.setLocalDescription = function() {
    return !arguments.length || !arguments[0].type ? c.apply(this, arguments) : (arguments[0] = r(this, arguments[0]), c.apply(this, arguments));
  };
  const l = Object.getOwnPropertyDescriptor(
    s.RTCPeerConnection.prototype,
    "localDescription"
  );
  Object.defineProperty(
    s.RTCPeerConnection.prototype,
    "localDescription",
    {
      get() {
        const a = l.get.apply(this);
        return a.type === "" ? a : o(this, a);
      }
    }
  ), s.RTCPeerConnection.prototype.removeTrack = function(d) {
    if (this.signalingState === "closed")
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    if (!d._pc)
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(d._pc === this))
      throw new DOMException(
        "Sender was not created by this connection.",
        "InvalidAccessError"
      );
    this._streams = this._streams || {};
    let u;
    Object.keys(this._streams).forEach((p) => {
      this._streams[p].getTracks().find((b) => d.track === b) && (u = this._streams[p]);
    }), u && (u.getTracks().length === 1 ? this.removeStream(this._reverseStreams[u.id]) : u.removeTrack(d.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function $n(s, t) {
  !s.RTCPeerConnection && s.webkitRTCPeerConnection && (s.RTCPeerConnection = s.webkitRTCPeerConnection), s.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(e) {
    const i = s.RTCPeerConnection.prototype[e], n = { [e]() {
      return arguments[0] = new (e === "addIceCandidate" ? s.RTCIceCandidate : s.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);
    } };
    s.RTCPeerConnection.prototype[e] = n[e];
  });
}
function bl(s, t) {
  di(s, "negotiationneeded", (e) => {
    const i = e.target;
    if (!((t.version < 72 || i.getConfiguration && i.getConfiguration().sdpSemantics === "plan-b") && i.signalingState !== "stable"))
      return e;
  });
}
const _o = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fixNegotiationNeeded: bl,
  shimAddTrackRemoveTrack: ml,
  shimAddTrackRemoveTrackWithNative: pl,
  shimGetDisplayMedia: _c,
  shimGetSendersWithDtmf: dl,
  shimGetStats: hl,
  shimGetUserMedia: ll,
  shimMediaStream: cl,
  shimOnTrack: al,
  shimPeerConnection: $n,
  shimSenderReceiverGetStats: ul
}, Symbol.toStringTag, { value: "Module" }));
function Dc(s, t) {
  let e = !1;
  return s = JSON.parse(JSON.stringify(s)), s.filter((i) => {
    if (i && (i.urls || i.url)) {
      let n = i.urls || i.url;
      i.url && !i.urls && yn("RTCIceServer.url", "RTCIceServer.urls");
      const o = typeof n == "string";
      return o && (n = [n]), n = n.filter((r) => {
        if (r.indexOf("stun:") === 0)
          return !1;
        const c = r.startsWith("turn") && !r.startsWith("turn:[") && r.includes("transport=udp");
        return c && !e ? (e = !0, !0) : c && !e;
      }), delete i.url, i.urls = o ? n[0] : n, !!n.length;
    }
  });
}
var yl = { exports: {} };
(function(s) {
  var t = {};
  t.generateIdentifier = function() {
    return Math.random().toString(36).substr(2, 10);
  }, t.localCName = t.generateIdentifier(), t.splitLines = function(e) {
    return e.trim().split(`
`).map(function(i) {
      return i.trim();
    });
  }, t.splitSections = function(e) {
    var i = e.split(`
m=`);
    return i.map(function(n, o) {
      return (o > 0 ? "m=" + n : n).trim() + `\r
`;
    });
  }, t.getDescription = function(e) {
    var i = t.splitSections(e);
    return i && i[0];
  }, t.getMediaSections = function(e) {
    var i = t.splitSections(e);
    return i.shift(), i;
  }, t.matchPrefix = function(e, i) {
    return t.splitLines(e).filter(function(n) {
      return n.indexOf(i) === 0;
    });
  }, t.parseCandidate = function(e) {
    var i;
    e.indexOf("a=candidate:") === 0 ? i = e.substring(12).split(" ") : i = e.substring(10).split(" ");
    for (var n = {
      foundation: i[0],
      component: parseInt(i[1], 10),
      protocol: i[2].toLowerCase(),
      priority: parseInt(i[3], 10),
      ip: i[4],
      address: i[4],
      // address is an alias for ip.
      port: parseInt(i[5], 10),
      // skip parts[6] == 'typ'
      type: i[7]
    }, o = 8; o < i.length; o += 2)
      switch (i[o]) {
        case "raddr":
          n.relatedAddress = i[o + 1];
          break;
        case "rport":
          n.relatedPort = parseInt(i[o + 1], 10);
          break;
        case "tcptype":
          n.tcpType = i[o + 1];
          break;
        case "ufrag":
          n.ufrag = i[o + 1], n.usernameFragment = i[o + 1];
          break;
        default:
          n[i[o]] = i[o + 1];
          break;
      }
    return n;
  }, t.writeCandidate = function(e) {
    var i = [];
    i.push(e.foundation), i.push(e.component), i.push(e.protocol.toUpperCase()), i.push(e.priority), i.push(e.address || e.ip), i.push(e.port);
    var n = e.type;
    return i.push("typ"), i.push(n), n !== "host" && e.relatedAddress && e.relatedPort && (i.push("raddr"), i.push(e.relatedAddress), i.push("rport"), i.push(e.relatedPort)), e.tcpType && e.protocol.toLowerCase() === "tcp" && (i.push("tcptype"), i.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (i.push("ufrag"), i.push(e.usernameFragment || e.ufrag)), "candidate:" + i.join(" ");
  }, t.parseIceOptions = function(e) {
    return e.substr(14).split(" ");
  }, t.parseRtpMap = function(e) {
    var i = e.substr(9).split(" "), n = {
      payloadType: parseInt(i.shift(), 10)
      // was: id
    };
    return i = i[0].split("/"), n.name = i[0], n.clockRate = parseInt(i[1], 10), n.channels = i.length === 3 ? parseInt(i[2], 10) : 1, n.numChannels = n.channels, n;
  }, t.writeRtpMap = function(e) {
    var i = e.payloadType;
    e.preferredPayloadType !== void 0 && (i = e.preferredPayloadType);
    var n = e.channels || e.numChannels || 1;
    return "a=rtpmap:" + i + " " + e.name + "/" + e.clockRate + (n !== 1 ? "/" + n : "") + `\r
`;
  }, t.parseExtmap = function(e) {
    var i = e.substr(9).split(" ");
    return {
      id: parseInt(i[0], 10),
      direction: i[0].indexOf("/") > 0 ? i[0].split("/")[1] : "sendrecv",
      uri: i[1]
    };
  }, t.writeExtmap = function(e) {
    return "a=extmap:" + (e.id || e.preferredId) + (e.direction && e.direction !== "sendrecv" ? "/" + e.direction : "") + " " + e.uri + `\r
`;
  }, t.parseFmtp = function(e) {
    for (var i = {}, n, o = e.substr(e.indexOf(" ") + 1).split(";"), r = 0; r < o.length; r++)
      n = o[r].trim().split("="), i[n[0].trim()] = n[1];
    return i;
  }, t.writeFmtp = function(e) {
    var i = "", n = e.payloadType;
    if (e.preferredPayloadType !== void 0 && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
      var o = [];
      Object.keys(e.parameters).forEach(function(r) {
        e.parameters[r] ? o.push(r + "=" + e.parameters[r]) : o.push(r);
      }), i += "a=fmtp:" + n + " " + o.join(";") + `\r
`;
    }
    return i;
  }, t.parseRtcpFb = function(e) {
    var i = e.substr(e.indexOf(" ") + 1).split(" ");
    return {
      type: i.shift(),
      parameter: i.join(" ")
    };
  }, t.writeRtcpFb = function(e) {
    var i = "", n = e.payloadType;
    return e.preferredPayloadType !== void 0 && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function(o) {
      i += "a=rtcp-fb:" + n + " " + o.type + (o.parameter && o.parameter.length ? " " + o.parameter : "") + `\r
`;
    }), i;
  }, t.parseSsrcMedia = function(e) {
    var i = e.indexOf(" "), n = {
      ssrc: parseInt(e.substr(7, i - 7), 10)
    }, o = e.indexOf(":", i);
    return o > -1 ? (n.attribute = e.substr(i + 1, o - i - 1), n.value = e.substr(o + 1)) : n.attribute = e.substr(i + 1), n;
  }, t.parseSsrcGroup = function(e) {
    var i = e.substr(13).split(" ");
    return {
      semantics: i.shift(),
      ssrcs: i.map(function(n) {
        return parseInt(n, 10);
      })
    };
  }, t.getMid = function(e) {
    var i = t.matchPrefix(e, "a=mid:")[0];
    if (i)
      return i.substr(6);
  }, t.parseFingerprint = function(e) {
    var i = e.substr(14).split(" ");
    return {
      algorithm: i[0].toLowerCase(),
      // algorithm is case-sensitive in Edge.
      value: i[1]
    };
  }, t.getDtlsParameters = function(e, i) {
    var n = t.matchPrefix(
      e + i,
      "a=fingerprint:"
    );
    return {
      role: "auto",
      fingerprints: n.map(t.parseFingerprint)
    };
  }, t.writeDtlsParameters = function(e, i) {
    var n = "a=setup:" + i + `\r
`;
    return e.fingerprints.forEach(function(o) {
      n += "a=fingerprint:" + o.algorithm + " " + o.value + `\r
`;
    }), n;
  }, t.parseCryptoLine = function(e) {
    var i = e.substr(9).split(" ");
    return {
      tag: parseInt(i[0], 10),
      cryptoSuite: i[1],
      keyParams: i[2],
      sessionParams: i.slice(3)
    };
  }, t.writeCryptoLine = function(e) {
    return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + (typeof e.keyParams == "object" ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + `\r
`;
  }, t.parseCryptoKeyParams = function(e) {
    if (e.indexOf("inline:") !== 0)
      return null;
    var i = e.substr(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: i[0],
      lifeTime: i[1],
      mkiValue: i[2] ? i[2].split(":")[0] : void 0,
      mkiLength: i[2] ? i[2].split(":")[1] : void 0
    };
  }, t.writeCryptoKeyParams = function(e) {
    return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "");
  }, t.getCryptoParameters = function(e, i) {
    var n = t.matchPrefix(
      e + i,
      "a=crypto:"
    );
    return n.map(t.parseCryptoLine);
  }, t.getIceParameters = function(e, i) {
    var n = t.matchPrefix(
      e + i,
      "a=ice-ufrag:"
    )[0], o = t.matchPrefix(
      e + i,
      "a=ice-pwd:"
    )[0];
    return n && o ? {
      usernameFragment: n.substr(12),
      password: o.substr(10)
    } : null;
  }, t.writeIceParameters = function(e) {
    return "a=ice-ufrag:" + e.usernameFragment + `\r
a=ice-pwd:` + e.password + `\r
`;
  }, t.parseRtpParameters = function(e) {
    for (var i = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    }, n = t.splitLines(e), o = n[0].split(" "), r = 3; r < o.length; r++) {
      var c = o[r], l = t.matchPrefix(
        e,
        "a=rtpmap:" + c + " "
      )[0];
      if (l) {
        var a = t.parseRtpMap(l), d = t.matchPrefix(
          e,
          "a=fmtp:" + c + " "
        );
        switch (a.parameters = d.length ? t.parseFmtp(d[0]) : {}, a.rtcpFeedback = t.matchPrefix(
          e,
          "a=rtcp-fb:" + c + " "
        ).map(t.parseRtcpFb), i.codecs.push(a), a.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            i.fecMechanisms.push(a.name.toUpperCase());
            break;
        }
      }
    }
    return t.matchPrefix(e, "a=extmap:").forEach(function(h) {
      i.headerExtensions.push(t.parseExtmap(h));
    }), i;
  }, t.writeRtpDescription = function(e, i) {
    var n = "";
    n += "m=" + e + " ", n += i.codecs.length > 0 ? "9" : "0", n += " UDP/TLS/RTP/SAVPF ", n += i.codecs.map(function(r) {
      return r.preferredPayloadType !== void 0 ? r.preferredPayloadType : r.payloadType;
    }).join(" ") + `\r
`, n += `c=IN IP4 0.0.0.0\r
`, n += `a=rtcp:9 IN IP4 0.0.0.0\r
`, i.codecs.forEach(function(r) {
      n += t.writeRtpMap(r), n += t.writeFmtp(r), n += t.writeRtcpFb(r);
    });
    var o = 0;
    return i.codecs.forEach(function(r) {
      r.maxptime > o && (o = r.maxptime);
    }), o > 0 && (n += "a=maxptime:" + o + `\r
`), n += `a=rtcp-mux\r
`, i.headerExtensions && i.headerExtensions.forEach(function(r) {
      n += t.writeExtmap(r);
    }), n;
  }, t.parseRtpEncodingParameters = function(e) {
    var i = [], n = t.parseRtpParameters(e), o = n.fecMechanisms.indexOf("RED") !== -1, r = n.fecMechanisms.indexOf("ULPFEC") !== -1, c = t.matchPrefix(e, "a=ssrc:").map(function(u) {
      return t.parseSsrcMedia(u);
    }).filter(function(u) {
      return u.attribute === "cname";
    }), l = c.length > 0 && c[0].ssrc, a, d = t.matchPrefix(e, "a=ssrc-group:FID").map(function(u) {
      var p = u.substr(17).split(" ");
      return p.map(function(m) {
        return parseInt(m, 10);
      });
    });
    d.length > 0 && d[0].length > 1 && d[0][0] === l && (a = d[0][1]), n.codecs.forEach(function(u) {
      if (u.name.toUpperCase() === "RTX" && u.parameters.apt) {
        var p = {
          ssrc: l,
          codecPayloadType: parseInt(u.parameters.apt, 10)
        };
        l && a && (p.rtx = { ssrc: a }), i.push(p), o && (p = JSON.parse(JSON.stringify(p)), p.fec = {
          ssrc: l,
          mechanism: r ? "red+ulpfec" : "red"
        }, i.push(p));
      }
    }), i.length === 0 && l && i.push({
      ssrc: l
    });
    var h = t.matchPrefix(e, "b=");
    return h.length && (h[0].indexOf("b=TIAS:") === 0 ? h = parseInt(h[0].substr(7), 10) : h[0].indexOf("b=AS:") === 0 ? h = parseInt(h[0].substr(5), 10) * 1e3 * 0.95 - 50 * 40 * 8 : h = void 0, i.forEach(function(u) {
      u.maxBitrate = h;
    })), i;
  }, t.parseRtcpParameters = function(e) {
    var i = {}, n = t.matchPrefix(e, "a=ssrc:").map(function(c) {
      return t.parseSsrcMedia(c);
    }).filter(function(c) {
      return c.attribute === "cname";
    })[0];
    n && (i.cname = n.value, i.ssrc = n.ssrc);
    var o = t.matchPrefix(e, "a=rtcp-rsize");
    i.reducedSize = o.length > 0, i.compound = o.length === 0;
    var r = t.matchPrefix(e, "a=rtcp-mux");
    return i.mux = r.length > 0, i;
  }, t.parseMsid = function(e) {
    var i, n = t.matchPrefix(e, "a=msid:");
    if (n.length === 1)
      return i = n[0].substr(7).split(" "), { stream: i[0], track: i[1] };
    var o = t.matchPrefix(e, "a=ssrc:").map(function(r) {
      return t.parseSsrcMedia(r);
    }).filter(function(r) {
      return r.attribute === "msid";
    });
    if (o.length > 0)
      return i = o[0].value.split(" "), { stream: i[0], track: i[1] };
  }, t.parseSctpDescription = function(e) {
    var i = t.parseMLine(e), n = t.matchPrefix(e, "a=max-message-size:"), o;
    n.length > 0 && (o = parseInt(n[0].substr(19), 10)), isNaN(o) && (o = 65536);
    var r = t.matchPrefix(e, "a=sctp-port:");
    if (r.length > 0)
      return {
        port: parseInt(r[0].substr(12), 10),
        protocol: i.fmt,
        maxMessageSize: o
      };
    var c = t.matchPrefix(e, "a=sctpmap:");
    if (c.length > 0) {
      var l = t.matchPrefix(e, "a=sctpmap:")[0].substr(10).split(" ");
      return {
        port: parseInt(l[0], 10),
        protocol: l[1],
        maxMessageSize: o
      };
    }
  }, t.writeSctpDescription = function(e, i) {
    var n = [];
    return e.protocol !== "DTLS/SCTP" ? n = [
      "m=" + e.kind + " 9 " + e.protocol + " " + i.protocol + `\r
`,
      `c=IN IP4 0.0.0.0\r
`,
      "a=sctp-port:" + i.port + `\r
`
    ] : n = [
      "m=" + e.kind + " 9 " + e.protocol + " " + i.port + `\r
`,
      `c=IN IP4 0.0.0.0\r
`,
      "a=sctpmap:" + i.port + " " + i.protocol + ` 65535\r
`
    ], i.maxMessageSize !== void 0 && n.push("a=max-message-size:" + i.maxMessageSize + `\r
`), n.join("");
  }, t.generateSessionId = function() {
    return Math.random().toString().substr(2, 21);
  }, t.writeSessionBoilerplate = function(e, i, n) {
    var o, r = i !== void 0 ? i : 2;
    e ? o = e : o = t.generateSessionId();
    var c = n || "thisisadapterortc";
    return `v=0\r
o=` + c + " " + o + " " + r + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
  }, t.writeMediaSection = function(e, i, n, o) {
    var r = t.writeRtpDescription(e.kind, i);
    if (r += t.writeIceParameters(
      e.iceGatherer.getLocalParameters()
    ), r += t.writeDtlsParameters(
      e.dtlsTransport.getLocalParameters(),
      n === "offer" ? "actpass" : "active"
    ), r += "a=mid:" + e.mid + `\r
`, e.direction ? r += "a=" + e.direction + `\r
` : e.rtpSender && e.rtpReceiver ? r += `a=sendrecv\r
` : e.rtpSender ? r += `a=sendonly\r
` : e.rtpReceiver ? r += `a=recvonly\r
` : r += `a=inactive\r
`, e.rtpSender) {
      var c = "msid:" + o.id + " " + e.rtpSender.track.id + `\r
`;
      r += "a=" + c, r += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + c, e.sendEncodingParameters[0].rtx && (r += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + c, r += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + `\r
`);
    }
    return r += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + t.localCName + `\r
`, e.rtpSender && e.sendEncodingParameters[0].rtx && (r += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + t.localCName + `\r
`), r;
  }, t.getDirection = function(e, i) {
    for (var n = t.splitLines(e), o = 0; o < n.length; o++)
      switch (n[o]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return n[o].substr(2);
      }
    return i ? t.getDirection(i) : "sendrecv";
  }, t.getKind = function(e) {
    var i = t.splitLines(e), n = i[0].split(" ");
    return n[0].substr(2);
  }, t.isRejected = function(e) {
    return e.split(" ", 2)[1] === "0";
  }, t.parseMLine = function(e) {
    var i = t.splitLines(e), n = i[0].substr(2).split(" ");
    return {
      kind: n[0],
      port: parseInt(n[1], 10),
      protocol: n[2],
      fmt: n.slice(3).join(" ")
    };
  }, t.parseOLine = function(e) {
    var i = t.matchPrefix(e, "o=")[0], n = i.substr(2).split(" ");
    return {
      username: n[0],
      sessionId: n[1],
      sessionVersion: parseInt(n[2], 10),
      netType: n[3],
      addressType: n[4],
      address: n[5]
    };
  }, t.isValidSDP = function(e) {
    if (typeof e != "string" || e.length === 0)
      return !1;
    for (var i = t.splitLines(e), n = 0; n < i.length; n++)
      if (i[n].length < 2 || i[n].charAt(1) !== "=")
        return !1;
    return !0;
  }, s.exports = t;
})(yl);
var Gl = yl.exports;
const As = /* @__PURE__ */ bn(Gl);
var H = Gl;
function Ac(s) {
  return {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }[s.type] || s.type;
}
function Do(s, t, e, i, n) {
  var o = H.writeRtpDescription(s.kind, t);
  if (o += H.writeIceParameters(
    s.iceGatherer.getLocalParameters()
  ), o += H.writeDtlsParameters(
    s.dtlsTransport.getLocalParameters(),
    e === "offer" ? "actpass" : n || "active"
  ), o += "a=mid:" + s.mid + `\r
`, s.rtpSender && s.rtpReceiver ? o += `a=sendrecv\r
` : s.rtpSender ? o += `a=sendonly\r
` : s.rtpReceiver ? o += `a=recvonly\r
` : o += `a=inactive\r
`, s.rtpSender) {
    var r = s.rtpSender._initialTrackId || s.rtpSender.track.id;
    s.rtpSender._initialTrackId = r;
    var c = "msid:" + (i ? i.id : "-") + " " + r + `\r
`;
    o += "a=" + c, o += "a=ssrc:" + s.sendEncodingParameters[0].ssrc + " " + c, s.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + s.sendEncodingParameters[0].rtx.ssrc + " " + c, o += "a=ssrc-group:FID " + s.sendEncodingParameters[0].ssrc + " " + s.sendEncodingParameters[0].rtx.ssrc + `\r
`);
  }
  return o += "a=ssrc:" + s.sendEncodingParameters[0].ssrc + " cname:" + H.localCName + `\r
`, s.rtpSender && s.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + s.sendEncodingParameters[0].rtx.ssrc + " cname:" + H.localCName + `\r
`), o;
}
function qc(s, t) {
  var e = !1;
  return s = JSON.parse(JSON.stringify(s)), s.filter(function(i) {
    if (i && (i.urls || i.url)) {
      var n = i.urls || i.url;
      i.url && !i.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead.");
      var o = typeof n == "string";
      return o && (n = [n]), n = n.filter(function(r) {
        var c = r.indexOf("turn:") === 0 && r.indexOf("transport=udp") !== -1 && r.indexOf("turn:[") === -1 && !e;
        return c ? (e = !0, !0) : r.indexOf("stun:") === 0 && t >= 14393 && r.indexOf("?transport=udp") === -1;
      }), delete i.url, i.urls = o ? n[0] : n, !!n.length;
    }
  });
}
function xs(s, t) {
  var e = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  }, i = function(o, r) {
    o = parseInt(o, 10);
    for (var c = 0; c < r.length; c++)
      if (r[c].payloadType === o || r[c].preferredPayloadType === o)
        return r[c];
  }, n = function(o, r, c, l) {
    var a = i(o.parameters.apt, c), d = i(r.parameters.apt, l);
    return a && d && a.name.toLowerCase() === d.name.toLowerCase();
  };
  return s.codecs.forEach(function(o) {
    for (var r = 0; r < t.codecs.length; r++) {
      var c = t.codecs[r];
      if (o.name.toLowerCase() === c.name.toLowerCase() && o.clockRate === c.clockRate) {
        if (o.name.toLowerCase() === "rtx" && o.parameters && c.parameters.apt && !n(
          o,
          c,
          s.codecs,
          t.codecs
        ))
          continue;
        c = JSON.parse(JSON.stringify(c)), c.numChannels = Math.min(
          o.numChannels,
          c.numChannels
        ), e.codecs.push(c), c.rtcpFeedback = c.rtcpFeedback.filter(function(l) {
          for (var a = 0; a < o.rtcpFeedback.length; a++)
            if (o.rtcpFeedback[a].type === l.type && o.rtcpFeedback[a].parameter === l.parameter)
              return !0;
          return !1;
        });
        break;
      }
    }
  }), s.headerExtensions.forEach(function(o) {
    for (var r = 0; r < t.headerExtensions.length; r++) {
      var c = t.headerExtensions[r];
      if (o.uri === c.uri) {
        e.headerExtensions.push(c);
        break;
      }
    }
  }), e;
}
function Ao(s, t, e) {
  return {
    offer: {
      setLocalDescription: ["stable", "have-local-offer"],
      setRemoteDescription: ["stable", "have-remote-offer"]
    },
    answer: {
      setLocalDescription: ["have-remote-offer", "have-local-pranswer"],
      setRemoteDescription: ["have-local-offer", "have-remote-pranswer"]
    }
  }[t][s].indexOf(e) !== -1;
}
function xn(s, t) {
  var e = s.getRemoteCandidates().find(function(i) {
    return t.foundation === i.foundation && t.ip === i.ip && t.port === i.port && t.priority === i.priority && t.protocol === i.protocol && t.type === i.type;
  });
  return e || s.addRemoteCandidate(t), !e;
}
function bt(s, t) {
  var e = new Error(t);
  return e.name = s, e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: void 0,
    OperationError: void 0
  }[s], e;
}
var $c = function(s, t) {
  function e(l, a) {
    a.addTrack(l), a.dispatchEvent(new s.MediaStreamTrackEvent(
      "addtrack",
      { track: l }
    ));
  }
  function i(l, a) {
    a.removeTrack(l), a.dispatchEvent(new s.MediaStreamTrackEvent(
      "removetrack",
      { track: l }
    ));
  }
  function n(l, a, d, h) {
    var u = new Event("track");
    u.track = a, u.receiver = d, u.transceiver = { receiver: d }, u.streams = h, s.setTimeout(function() {
      l._dispatchEvent("track", u);
    });
  }
  var o = function(l) {
    var a = this, d = document.createDocumentFragment();
    if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(u) {
      a[u] = d[u].bind(d);
    }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", l = JSON.parse(JSON.stringify(l || {})), this.usingBundle = l.bundlePolicy === "max-bundle", l.rtcpMuxPolicy === "negotiate")
      throw bt(
        "NotSupportedError",
        "rtcpMuxPolicy 'negotiate' is not supported"
      );
    switch (l.rtcpMuxPolicy || (l.rtcpMuxPolicy = "require"), l.iceTransportPolicy) {
      case "all":
      case "relay":
        break;
      default:
        l.iceTransportPolicy = "all";
        break;
    }
    switch (l.bundlePolicy) {
      case "balanced":
      case "max-compat":
      case "max-bundle":
        break;
      default:
        l.bundlePolicy = "balanced";
        break;
    }
    if (l.iceServers = qc(l.iceServers || [], t), this._iceGatherers = [], l.iceCandidatePoolSize)
      for (var h = l.iceCandidatePoolSize; h > 0; h--)
        this._iceGatherers.push(new s.RTCIceGatherer({
          iceServers: l.iceServers,
          gatherPolicy: l.iceTransportPolicy
        }));
    else
      l.iceCandidatePoolSize = 0;
    this._config = l, this.transceivers = [], this._sdpSessionId = H.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1;
  };
  Object.defineProperty(o.prototype, "localDescription", {
    configurable: !0,
    get: function() {
      return this._localDescription;
    }
  }), Object.defineProperty(o.prototype, "remoteDescription", {
    configurable: !0,
    get: function() {
      return this._remoteDescription;
    }
  }), o.prototype.onicecandidate = null, o.prototype.onaddstream = null, o.prototype.ontrack = null, o.prototype.onremovestream = null, o.prototype.onsignalingstatechange = null, o.prototype.oniceconnectionstatechange = null, o.prototype.onconnectionstatechange = null, o.prototype.onicegatheringstatechange = null, o.prototype.onnegotiationneeded = null, o.prototype.ondatachannel = null, o.prototype._dispatchEvent = function(l, a) {
    this._isClosed || (this.dispatchEvent(a), typeof this["on" + l] == "function" && this["on" + l](a));
  }, o.prototype._emitGatheringStateChange = function() {
    var l = new Event("icegatheringstatechange");
    this._dispatchEvent("icegatheringstatechange", l);
  }, o.prototype.getConfiguration = function() {
    return this._config;
  }, o.prototype.getLocalStreams = function() {
    return this.localStreams;
  }, o.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  }, o.prototype._createTransceiver = function(l, a) {
    var d = this.transceivers.length > 0, h = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: l,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: !0
    };
    if (this.usingBundle && d)
      h.iceTransport = this.transceivers[0].iceTransport, h.dtlsTransport = this.transceivers[0].dtlsTransport;
    else {
      var u = this._createIceAndDtlsTransports();
      h.iceTransport = u.iceTransport, h.dtlsTransport = u.dtlsTransport;
    }
    return a || this.transceivers.push(h), h;
  }, o.prototype.addTrack = function(l, a) {
    if (this._isClosed)
      throw bt(
        "InvalidStateError",
        "Attempted to call addTrack on a closed peerconnection."
      );
    var d = this.transceivers.find(function(p) {
      return p.track === l;
    });
    if (d)
      throw bt("InvalidAccessError", "Track already exists.");
    for (var h, u = 0; u < this.transceivers.length; u++)
      !this.transceivers[u].track && this.transceivers[u].kind === l.kind && (h = this.transceivers[u]);
    return h || (h = this._createTransceiver(l.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(a) === -1 && this.localStreams.push(a), h.track = l, h.stream = a, h.rtpSender = new s.RTCRtpSender(
      l,
      h.dtlsTransport
    ), h.rtpSender;
  }, o.prototype.addStream = function(l) {
    var a = this;
    if (t >= 15025)
      l.getTracks().forEach(function(h) {
        a.addTrack(h, l);
      });
    else {
      var d = l.clone();
      l.getTracks().forEach(function(h, u) {
        var p = d.getTracks()[u];
        h.addEventListener("enabled", function(m) {
          p.enabled = m.enabled;
        });
      }), d.getTracks().forEach(function(h) {
        a.addTrack(h, d);
      });
    }
  }, o.prototype.removeTrack = function(l) {
    if (this._isClosed)
      throw bt(
        "InvalidStateError",
        "Attempted to call removeTrack on a closed peerconnection."
      );
    if (!(l instanceof s.RTCRtpSender))
      throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
    var a = this.transceivers.find(function(u) {
      return u.rtpSender === l;
    });
    if (!a)
      throw bt(
        "InvalidAccessError",
        "Sender was not created by this connection."
      );
    var d = a.stream;
    a.rtpSender.stop(), a.rtpSender = null, a.track = null, a.stream = null;
    var h = this.transceivers.map(function(u) {
      return u.stream;
    });
    h.indexOf(d) === -1 && this.localStreams.indexOf(d) > -1 && this.localStreams.splice(this.localStreams.indexOf(d), 1), this._maybeFireNegotiationNeeded();
  }, o.prototype.removeStream = function(l) {
    var a = this;
    l.getTracks().forEach(function(d) {
      var h = a.getSenders().find(function(u) {
        return u.track === d;
      });
      h && a.removeTrack(h);
    });
  }, o.prototype.getSenders = function() {
    return this.transceivers.filter(function(l) {
      return !!l.rtpSender;
    }).map(function(l) {
      return l.rtpSender;
    });
  }, o.prototype.getReceivers = function() {
    return this.transceivers.filter(function(l) {
      return !!l.rtpReceiver;
    }).map(function(l) {
      return l.rtpReceiver;
    });
  }, o.prototype._createIceGatherer = function(l, a) {
    var d = this;
    if (a && l > 0)
      return this.transceivers[0].iceGatherer;
    if (this._iceGatherers.length)
      return this._iceGatherers.shift();
    var h = new s.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    return Object.defineProperty(
      h,
      "state",
      { value: "new", writable: !0 }
    ), this.transceivers[l].bufferedCandidateEvents = [], this.transceivers[l].bufferCandidates = function(u) {
      var p = !u.candidate || Object.keys(u.candidate).length === 0;
      h.state = p ? "completed" : "gathering", d.transceivers[l].bufferedCandidateEvents !== null && d.transceivers[l].bufferedCandidateEvents.push(u);
    }, h.addEventListener(
      "localcandidate",
      this.transceivers[l].bufferCandidates
    ), h;
  }, o.prototype._gather = function(l, a) {
    var d = this, h = this.transceivers[a].iceGatherer;
    if (!h.onlocalcandidate) {
      var u = this.transceivers[a].bufferedCandidateEvents;
      this.transceivers[a].bufferedCandidateEvents = null, h.removeEventListener(
        "localcandidate",
        this.transceivers[a].bufferCandidates
      ), h.onlocalcandidate = function(p) {
        if (!(d.usingBundle && a > 0)) {
          var m = new Event("icecandidate");
          m.candidate = { sdpMid: l, sdpMLineIndex: a };
          var b = p.candidate, G = !b || Object.keys(b).length === 0;
          if (G)
            (h.state === "new" || h.state === "gathering") && (h.state = "completed");
          else {
            h.state === "new" && (h.state = "gathering"), b.component = 1, b.ufrag = h.getLocalParameters().usernameFragment;
            var y = H.writeCandidate(b);
            m.candidate = Object.assign(
              m.candidate,
              H.parseCandidate(y)
            ), m.candidate.candidate = y, m.candidate.toJSON = function() {
              return {
                candidate: m.candidate.candidate,
                sdpMid: m.candidate.sdpMid,
                sdpMLineIndex: m.candidate.sdpMLineIndex,
                usernameFragment: m.candidate.usernameFragment
              };
            };
          }
          var Z = H.getMediaSections(d._localDescription.sdp);
          G ? Z[m.candidate.sdpMLineIndex] += `a=end-of-candidates\r
` : Z[m.candidate.sdpMLineIndex] += "a=" + m.candidate.candidate + `\r
`, d._localDescription.sdp = H.getDescription(d._localDescription.sdp) + Z.join("");
          var f = d.transceivers.every(function(V) {
            return V.iceGatherer && V.iceGatherer.state === "completed";
          });
          d.iceGatheringState !== "gathering" && (d.iceGatheringState = "gathering", d._emitGatheringStateChange()), G || d._dispatchEvent("icecandidate", m), f && (d._dispatchEvent("icecandidate", new Event("icecandidate")), d.iceGatheringState = "complete", d._emitGatheringStateChange());
        }
      }, s.setTimeout(function() {
        u.forEach(function(p) {
          h.onlocalcandidate(p);
        });
      }, 0);
    }
  }, o.prototype._createIceAndDtlsTransports = function() {
    var l = this, a = new s.RTCIceTransport(null);
    a.onicestatechange = function() {
      l._updateIceConnectionState(), l._updateConnectionState();
    };
    var d = new s.RTCDtlsTransport(a);
    return d.ondtlsstatechange = function() {
      l._updateConnectionState();
    }, d.onerror = function() {
      Object.defineProperty(
        d,
        "state",
        { value: "failed", writable: !0 }
      ), l._updateConnectionState();
    }, {
      iceTransport: a,
      dtlsTransport: d
    };
  }, o.prototype._disposeIceAndDtlsTransports = function(l) {
    var a = this.transceivers[l].iceGatherer;
    a && (delete a.onlocalcandidate, delete this.transceivers[l].iceGatherer);
    var d = this.transceivers[l].iceTransport;
    d && (delete d.onicestatechange, delete this.transceivers[l].iceTransport);
    var h = this.transceivers[l].dtlsTransport;
    h && (delete h.ondtlsstatechange, delete h.onerror, delete this.transceivers[l].dtlsTransport);
  }, o.prototype._transceive = function(l, a, d) {
    var h = xs(
      l.localCapabilities,
      l.remoteCapabilities
    );
    a && l.rtpSender && (h.encodings = l.sendEncodingParameters, h.rtcp = {
      cname: H.localCName,
      compound: l.rtcpParameters.compound
    }, l.recvEncodingParameters.length && (h.rtcp.ssrc = l.recvEncodingParameters[0].ssrc), l.rtpSender.send(h)), d && l.rtpReceiver && h.codecs.length > 0 && (l.kind === "video" && l.recvEncodingParameters && t < 15019 && l.recvEncodingParameters.forEach(function(u) {
      delete u.rtx;
    }), l.recvEncodingParameters.length ? h.encodings = l.recvEncodingParameters : h.encodings = [{}], h.rtcp = {
      compound: l.rtcpParameters.compound
    }, l.rtcpParameters.cname && (h.rtcp.cname = l.rtcpParameters.cname), l.sendEncodingParameters.length && (h.rtcp.ssrc = l.sendEncodingParameters[0].ssrc), l.rtpReceiver.receive(h));
  }, o.prototype.setLocalDescription = function(l) {
    var a = this;
    if (["offer", "answer"].indexOf(l.type) === -1)
      return Promise.reject(bt(
        "TypeError",
        'Unsupported type "' + l.type + '"'
      ));
    if (!Ao(
      "setLocalDescription",
      l.type,
      a.signalingState
    ) || a._isClosed)
      return Promise.reject(bt(
        "InvalidStateError",
        "Can not set local " + l.type + " in state " + a.signalingState
      ));
    var d, h;
    if (l.type === "offer")
      d = H.splitSections(l.sdp), h = d.shift(), d.forEach(function(p, m) {
        var b = H.parseRtpParameters(p);
        a.transceivers[m].localCapabilities = b;
      }), a.transceivers.forEach(function(p, m) {
        a._gather(p.mid, m);
      });
    else if (l.type === "answer") {
      d = H.splitSections(a._remoteDescription.sdp), h = d.shift();
      var u = H.matchPrefix(
        h,
        "a=ice-lite"
      ).length > 0;
      d.forEach(function(p, m) {
        var b = a.transceivers[m], G = b.iceGatherer, y = b.iceTransport, Z = b.dtlsTransport, f = b.localCapabilities, V = b.remoteCapabilities, X = H.isRejected(p) && H.matchPrefix(p, "a=bundle-only").length === 0;
        if (!X && !b.rejected) {
          var R = H.getIceParameters(
            p,
            h
          ), x = H.getDtlsParameters(
            p,
            h
          );
          u && (x.role = "server"), (!a.usingBundle || m === 0) && (a._gather(b.mid, m), y.state === "new" && y.start(
            G,
            R,
            u ? "controlling" : "controlled"
          ), Z.state === "new" && Z.start(x));
          var S = xs(
            f,
            V
          );
          a._transceive(
            b,
            S.codecs.length > 0,
            !1
          );
        }
      });
    }
    return a._localDescription = {
      type: l.type,
      sdp: l.sdp
    }, l.type === "offer" ? a._updateSignalingState("have-local-offer") : a._updateSignalingState("stable"), Promise.resolve();
  }, o.prototype.setRemoteDescription = function(l) {
    var a = this;
    if (["offer", "answer"].indexOf(l.type) === -1)
      return Promise.reject(bt(
        "TypeError",
        'Unsupported type "' + l.type + '"'
      ));
    if (!Ao(
      "setRemoteDescription",
      l.type,
      a.signalingState
    ) || a._isClosed)
      return Promise.reject(bt(
        "InvalidStateError",
        "Can not set remote " + l.type + " in state " + a.signalingState
      ));
    var d = {};
    a.remoteStreams.forEach(function(y) {
      d[y.id] = y;
    });
    var h = [], u = H.splitSections(l.sdp), p = u.shift(), m = H.matchPrefix(
      p,
      "a=ice-lite"
    ).length > 0, b = H.matchPrefix(
      p,
      "a=group:BUNDLE "
    ).length > 0;
    a.usingBundle = b;
    var G = H.matchPrefix(
      p,
      "a=ice-options:"
    )[0];
    return G ? a.canTrickleIceCandidates = G.substr(14).split(" ").indexOf("trickle") >= 0 : a.canTrickleIceCandidates = !1, u.forEach(function(y, Z) {
      var f = H.splitLines(y), V = H.getKind(y), X = H.isRejected(y) && H.matchPrefix(y, "a=bundle-only").length === 0, R = f[0].substr(2).split(" ")[2], x = H.getDirection(y, p), S = H.parseMsid(y), C = H.getMid(y) || H.generateIdentifier();
      if (X || V === "application" && (R === "DTLS/SCTP" || R === "UDP/DTLS/SCTP")) {
        a.transceivers[Z] = {
          mid: C,
          kind: V,
          protocol: R,
          rejected: !0
        };
        return;
      }
      !X && a.transceivers[Z] && a.transceivers[Z].rejected && (a.transceivers[Z] = a._createTransceiver(V, !0));
      var L, g, W, z, v, k, N, J, P, D = H.parseRtpParameters(y), st, et;
      X || (st = H.getIceParameters(
        y,
        p
      ), et = H.getDtlsParameters(
        y,
        p
      ), et.role = "client"), N = H.parseRtpEncodingParameters(y);
      var gt = H.parseRtcpParameters(y), Lt = H.matchPrefix(
        y,
        "a=end-of-candidates",
        p
      ).length > 0, nt = H.matchPrefix(y, "a=candidate:").map(function(A) {
        return H.parseCandidate(A);
      }).filter(function(A) {
        return A.component === 1;
      });
      if ((l.type === "offer" || l.type === "answer") && !X && b && Z > 0 && a.transceivers[Z] && (a._disposeIceAndDtlsTransports(Z), a.transceivers[Z].iceGatherer = a.transceivers[0].iceGatherer, a.transceivers[Z].iceTransport = a.transceivers[0].iceTransport, a.transceivers[Z].dtlsTransport = a.transceivers[0].dtlsTransport, a.transceivers[Z].rtpSender && a.transceivers[Z].rtpSender.setTransport(
        a.transceivers[0].dtlsTransport
      ), a.transceivers[Z].rtpReceiver && a.transceivers[Z].rtpReceiver.setTransport(
        a.transceivers[0].dtlsTransport
      )), l.type === "offer" && !X) {
        L = a.transceivers[Z] || a._createTransceiver(V), L.mid = C, L.iceGatherer || (L.iceGatherer = a._createIceGatherer(
          Z,
          b
        )), nt.length && L.iceTransport.state === "new" && (Lt && (!b || Z === 0) ? L.iceTransport.setRemoteCandidates(nt) : nt.forEach(function(A) {
          xn(L.iceTransport, A);
        })), J = s.RTCRtpReceiver.getCapabilities(V), t < 15019 && (J.codecs = J.codecs.filter(
          function(A) {
            return A.name !== "rtx";
          }
        )), k = L.sendEncodingParameters || [{
          ssrc: (2 * Z + 2) * 1001
        }];
        var mt = !1;
        if (x === "sendrecv" || x === "sendonly") {
          if (mt = !L.rtpReceiver, v = L.rtpReceiver || new s.RTCRtpReceiver(L.dtlsTransport, V), mt) {
            var it;
            P = v.track, S && S.stream === "-" || (S ? (d[S.stream] || (d[S.stream] = new s.MediaStream(), Object.defineProperty(d[S.stream], "id", {
              get: function() {
                return S.stream;
              }
            })), Object.defineProperty(P, "id", {
              get: function() {
                return S.track;
              }
            }), it = d[S.stream]) : (d.default || (d.default = new s.MediaStream()), it = d.default)), it && (e(P, it), L.associatedRemoteMediaStreams.push(it)), h.push([P, v, it]);
          }
        } else
          L.rtpReceiver && L.rtpReceiver.track && (L.associatedRemoteMediaStreams.forEach(function(A) {
            var Et = A.getTracks().find(function(ee) {
              return ee.id === L.rtpReceiver.track.id;
            });
            Et && i(Et, A);
          }), L.associatedRemoteMediaStreams = []);
        L.localCapabilities = J, L.remoteCapabilities = D, L.rtpReceiver = v, L.rtcpParameters = gt, L.sendEncodingParameters = k, L.recvEncodingParameters = N, a._transceive(
          a.transceivers[Z],
          !1,
          mt
        );
      } else if (l.type === "answer" && !X) {
        L = a.transceivers[Z], g = L.iceGatherer, W = L.iceTransport, z = L.dtlsTransport, v = L.rtpReceiver, k = L.sendEncodingParameters, J = L.localCapabilities, a.transceivers[Z].recvEncodingParameters = N, a.transceivers[Z].remoteCapabilities = D, a.transceivers[Z].rtcpParameters = gt, nt.length && W.state === "new" && ((m || Lt) && (!b || Z === 0) ? W.setRemoteCandidates(nt) : nt.forEach(function(A) {
          xn(L.iceTransport, A);
        })), (!b || Z === 0) && (W.state === "new" && W.start(
          g,
          st,
          "controlling"
        ), z.state === "new" && z.start(et));
        var O = xs(
          L.localCapabilities,
          L.remoteCapabilities
        ), me = O.codecs.filter(function(A) {
          return A.name.toLowerCase() === "rtx";
        }).length;
        !me && L.sendEncodingParameters[0].rtx && delete L.sendEncodingParameters[0].rtx, a._transceive(
          L,
          x === "sendrecv" || x === "recvonly",
          x === "sendrecv" || x === "sendonly"
        ), v && (x === "sendrecv" || x === "sendonly") ? (P = v.track, S ? (d[S.stream] || (d[S.stream] = new s.MediaStream()), e(P, d[S.stream]), h.push([P, v, d[S.stream]])) : (d.default || (d.default = new s.MediaStream()), e(P, d.default), h.push([P, v, d.default]))) : delete L.rtpReceiver;
      }
    }), a._dtlsRole === void 0 && (a._dtlsRole = l.type === "offer" ? "active" : "passive"), a._remoteDescription = {
      type: l.type,
      sdp: l.sdp
    }, l.type === "offer" ? a._updateSignalingState("have-remote-offer") : a._updateSignalingState("stable"), Object.keys(d).forEach(function(y) {
      var Z = d[y];
      if (Z.getTracks().length) {
        if (a.remoteStreams.indexOf(Z) === -1) {
          a.remoteStreams.push(Z);
          var f = new Event("addstream");
          f.stream = Z, s.setTimeout(function() {
            a._dispatchEvent("addstream", f);
          });
        }
        h.forEach(function(V) {
          var X = V[0], R = V[1];
          Z.id === V[2].id && n(a, X, R, [Z]);
        });
      }
    }), h.forEach(function(y) {
      y[2] || n(a, y[0], y[1], []);
    }), s.setTimeout(function() {
      a && a.transceivers && a.transceivers.forEach(function(y) {
        y.iceTransport && y.iceTransport.state === "new" && y.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), y.iceTransport.addRemoteCandidate({}));
      });
    }, 4e3), Promise.resolve();
  }, o.prototype.close = function() {
    this.transceivers.forEach(function(l) {
      l.iceTransport && l.iceTransport.stop(), l.dtlsTransport && l.dtlsTransport.stop(), l.rtpSender && l.rtpSender.stop(), l.rtpReceiver && l.rtpReceiver.stop();
    }), this._isClosed = !0, this._updateSignalingState("closed");
  }, o.prototype._updateSignalingState = function(l) {
    this.signalingState = l;
    var a = new Event("signalingstatechange");
    this._dispatchEvent("signalingstatechange", a);
  }, o.prototype._maybeFireNegotiationNeeded = function() {
    var l = this;
    this.signalingState !== "stable" || this.needNegotiation === !0 || (this.needNegotiation = !0, s.setTimeout(function() {
      if (l.needNegotiation) {
        l.needNegotiation = !1;
        var a = new Event("negotiationneeded");
        l._dispatchEvent("negotiationneeded", a);
      }
    }, 0));
  }, o.prototype._updateIceConnectionState = function() {
    var l, a = {
      new: 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    if (this.transceivers.forEach(function(h) {
      h.iceTransport && !h.rejected && a[h.iceTransport.state]++;
    }), l = "new", a.failed > 0 ? l = "failed" : a.checking > 0 ? l = "checking" : a.disconnected > 0 ? l = "disconnected" : a.new > 0 ? l = "new" : a.connected > 0 ? l = "connected" : a.completed > 0 && (l = "completed"), l !== this.iceConnectionState) {
      this.iceConnectionState = l;
      var d = new Event("iceconnectionstatechange");
      this._dispatchEvent("iceconnectionstatechange", d);
    }
  }, o.prototype._updateConnectionState = function() {
    var l, a = {
      new: 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    if (this.transceivers.forEach(function(h) {
      h.iceTransport && h.dtlsTransport && !h.rejected && (a[h.iceTransport.state]++, a[h.dtlsTransport.state]++);
    }), a.connected += a.completed, l = "new", a.failed > 0 ? l = "failed" : a.connecting > 0 ? l = "connecting" : a.disconnected > 0 ? l = "disconnected" : a.new > 0 ? l = "new" : a.connected > 0 && (l = "connected"), l !== this.connectionState) {
      this.connectionState = l;
      var d = new Event("connectionstatechange");
      this._dispatchEvent("connectionstatechange", d);
    }
  }, o.prototype.createOffer = function() {
    var l = this;
    if (l._isClosed)
      return Promise.reject(bt(
        "InvalidStateError",
        "Can not call createOffer after close"
      ));
    var a = l.transceivers.filter(function(m) {
      return m.kind === "audio";
    }).length, d = l.transceivers.filter(function(m) {
      return m.kind === "video";
    }).length, h = arguments[0];
    if (h) {
      if (h.mandatory || h.optional)
        throw new TypeError(
          "Legacy mandatory/optional constraints not supported."
        );
      h.offerToReceiveAudio !== void 0 && (h.offerToReceiveAudio === !0 ? a = 1 : h.offerToReceiveAudio === !1 ? a = 0 : a = h.offerToReceiveAudio), h.offerToReceiveVideo !== void 0 && (h.offerToReceiveVideo === !0 ? d = 1 : h.offerToReceiveVideo === !1 ? d = 0 : d = h.offerToReceiveVideo);
    }
    for (l.transceivers.forEach(function(m) {
      m.kind === "audio" ? (a--, a < 0 && (m.wantReceive = !1)) : m.kind === "video" && (d--, d < 0 && (m.wantReceive = !1));
    }); a > 0 || d > 0; )
      a > 0 && (l._createTransceiver("audio"), a--), d > 0 && (l._createTransceiver("video"), d--);
    var u = H.writeSessionBoilerplate(
      l._sdpSessionId,
      l._sdpSessionVersion++
    );
    l.transceivers.forEach(function(m, b) {
      var G = m.track, y = m.kind, Z = m.mid || H.generateIdentifier();
      m.mid = Z, m.iceGatherer || (m.iceGatherer = l._createIceGatherer(
        b,
        l.usingBundle
      ));
      var f = s.RTCRtpSender.getCapabilities(y);
      t < 15019 && (f.codecs = f.codecs.filter(
        function(X) {
          return X.name !== "rtx";
        }
      )), f.codecs.forEach(function(X) {
        X.name === "H264" && X.parameters["level-asymmetry-allowed"] === void 0 && (X.parameters["level-asymmetry-allowed"] = "1"), m.remoteCapabilities && m.remoteCapabilities.codecs && m.remoteCapabilities.codecs.forEach(function(R) {
          X.name.toLowerCase() === R.name.toLowerCase() && X.clockRate === R.clockRate && (X.preferredPayloadType = R.payloadType);
        });
      }), f.headerExtensions.forEach(function(X) {
        var R = m.remoteCapabilities && m.remoteCapabilities.headerExtensions || [];
        R.forEach(function(x) {
          X.uri === x.uri && (X.id = x.id);
        });
      });
      var V = m.sendEncodingParameters || [{
        ssrc: (2 * b + 1) * 1001
      }];
      G && t >= 15019 && y === "video" && !V[0].rtx && (V[0].rtx = {
        ssrc: V[0].ssrc + 1
      }), m.wantReceive && (m.rtpReceiver = new s.RTCRtpReceiver(
        m.dtlsTransport,
        y
      )), m.localCapabilities = f, m.sendEncodingParameters = V;
    }), l._config.bundlePolicy !== "max-compat" && (u += "a=group:BUNDLE " + l.transceivers.map(function(m) {
      return m.mid;
    }).join(" ") + `\r
`), u += `a=ice-options:trickle\r
`, l.transceivers.forEach(function(m, b) {
      u += Do(
        m,
        m.localCapabilities,
        "offer",
        m.stream,
        l._dtlsRole
      ), u += `a=rtcp-rsize\r
`, m.iceGatherer && l.iceGatheringState !== "new" && (b === 0 || !l.usingBundle) && (m.iceGatherer.getLocalCandidates().forEach(function(G) {
        G.component = 1, u += "a=" + H.writeCandidate(G) + `\r
`;
      }), m.iceGatherer.state === "completed" && (u += `a=end-of-candidates\r
`));
    });
    var p = new s.RTCSessionDescription({
      type: "offer",
      sdp: u
    });
    return Promise.resolve(p);
  }, o.prototype.createAnswer = function() {
    var l = this;
    if (l._isClosed)
      return Promise.reject(bt(
        "InvalidStateError",
        "Can not call createAnswer after close"
      ));
    if (!(l.signalingState === "have-remote-offer" || l.signalingState === "have-local-pranswer"))
      return Promise.reject(bt(
        "InvalidStateError",
        "Can not call createAnswer in signalingState " + l.signalingState
      ));
    var a = H.writeSessionBoilerplate(
      l._sdpSessionId,
      l._sdpSessionVersion++
    );
    l.usingBundle && (a += "a=group:BUNDLE " + l.transceivers.map(function(u) {
      return u.mid;
    }).join(" ") + `\r
`), a += `a=ice-options:trickle\r
`;
    var d = H.getMediaSections(
      l._remoteDescription.sdp
    ).length;
    l.transceivers.forEach(function(u, p) {
      if (!(p + 1 > d)) {
        if (u.rejected) {
          u.kind === "application" ? u.protocol === "DTLS/SCTP" ? a += `m=application 0 DTLS/SCTP 5000\r
` : a += "m=application 0 " + u.protocol + ` webrtc-datachannel\r
` : u.kind === "audio" ? a += `m=audio 0 UDP/TLS/RTP/SAVPF 0\r
a=rtpmap:0 PCMU/8000\r
` : u.kind === "video" && (a += `m=video 0 UDP/TLS/RTP/SAVPF 120\r
a=rtpmap:120 VP8/90000\r
`), a += `c=IN IP4 0.0.0.0\r
a=inactive\r
a=mid:` + u.mid + `\r
`;
          return;
        }
        if (u.stream) {
          var m;
          u.kind === "audio" ? m = u.stream.getAudioTracks()[0] : u.kind === "video" && (m = u.stream.getVideoTracks()[0]), m && t >= 15019 && u.kind === "video" && !u.sendEncodingParameters[0].rtx && (u.sendEncodingParameters[0].rtx = {
            ssrc: u.sendEncodingParameters[0].ssrc + 1
          });
        }
        var b = xs(
          u.localCapabilities,
          u.remoteCapabilities
        ), G = b.codecs.filter(function(y) {
          return y.name.toLowerCase() === "rtx";
        }).length;
        !G && u.sendEncodingParameters[0].rtx && delete u.sendEncodingParameters[0].rtx, a += Do(
          u,
          b,
          "answer",
          u.stream,
          l._dtlsRole
        ), u.rtcpParameters && u.rtcpParameters.reducedSize && (a += `a=rtcp-rsize\r
`);
      }
    });
    var h = new s.RTCSessionDescription({
      type: "answer",
      sdp: a
    });
    return Promise.resolve(h);
  }, o.prototype.addIceCandidate = function(l) {
    var a = this, d;
    return l && !(l.sdpMLineIndex !== void 0 || l.sdpMid) ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function(h, u) {
      if (a._remoteDescription)
        if (!l || l.candidate === "")
          for (var p = 0; p < a.transceivers.length && !(!a.transceivers[p].rejected && (a.transceivers[p].iceTransport.addRemoteCandidate({}), d = H.getMediaSections(a._remoteDescription.sdp), d[p] += `a=end-of-candidates\r
`, a._remoteDescription.sdp = H.getDescription(a._remoteDescription.sdp) + d.join(""), a.usingBundle)); p++)
            ;
        else {
          var m = l.sdpMLineIndex;
          if (l.sdpMid) {
            for (var b = 0; b < a.transceivers.length; b++)
              if (a.transceivers[b].mid === l.sdpMid) {
                m = b;
                break;
              }
          }
          var G = a.transceivers[m];
          if (G) {
            if (G.rejected)
              return h();
            var y = Object.keys(l.candidate).length > 0 ? H.parseCandidate(l.candidate) : {};
            if (y.protocol === "tcp" && (y.port === 0 || y.port === 9) || y.component && y.component !== 1)
              return h();
            if ((m === 0 || m > 0 && G.iceTransport !== a.transceivers[0].iceTransport) && !xn(G.iceTransport, y))
              return u(bt(
                "OperationError",
                "Can not add ICE candidate"
              ));
            var Z = l.candidate.trim();
            Z.indexOf("a=") === 0 && (Z = Z.substr(2)), d = H.getMediaSections(a._remoteDescription.sdp), d[m] += "a=" + (y.type ? Z : "end-of-candidates") + `\r
`, a._remoteDescription.sdp = H.getDescription(a._remoteDescription.sdp) + d.join("");
          } else
            return u(bt(
              "OperationError",
              "Can not add ICE candidate"
            ));
        }
      else
        return u(bt(
          "InvalidStateError",
          "Can not add ICE candidate without a remote description"
        ));
      h();
    });
  }, o.prototype.getStats = function(l) {
    if (l && l instanceof s.MediaStreamTrack) {
      var a = null;
      if (this.transceivers.forEach(function(h) {
        h.rtpSender && h.rtpSender.track === l ? a = h.rtpSender : h.rtpReceiver && h.rtpReceiver.track === l && (a = h.rtpReceiver);
      }), !a)
        throw bt("InvalidAccessError", "Invalid selector.");
      return a.getStats();
    }
    var d = [];
    return this.transceivers.forEach(function(h) {
      [
        "rtpSender",
        "rtpReceiver",
        "iceGatherer",
        "iceTransport",
        "dtlsTransport"
      ].forEach(function(u) {
        h[u] && d.push(h[u].getStats());
      });
    }), Promise.all(d).then(function(h) {
      var u = /* @__PURE__ */ new Map();
      return h.forEach(function(p) {
        p.forEach(function(m) {
          u.set(m.id, m);
        });
      }), u;
    });
  };
  var r = [
    "RTCRtpSender",
    "RTCRtpReceiver",
    "RTCIceGatherer",
    "RTCIceTransport",
    "RTCDtlsTransport"
  ];
  r.forEach(function(l) {
    var a = s[l];
    if (a && a.prototype && a.prototype.getStats) {
      var d = a.prototype.getStats;
      a.prototype.getStats = function() {
        return d.apply(this).then(function(h) {
          var u = /* @__PURE__ */ new Map();
          return Object.keys(h).forEach(function(p) {
            h[p].type = Ac(h[p]), u.set(p, h[p]);
          }), u;
        });
      };
    }
  });
  var c = ["createOffer", "createAnswer"];
  return c.forEach(function(l) {
    var a = o.prototype[l];
    o.prototype[l] = function() {
      var d = arguments;
      return typeof d[0] == "function" || typeof d[1] == "function" ? a.apply(this, [arguments[2]]).then(function(h) {
        typeof d[0] == "function" && d[0].apply(null, [h]);
      }, function(h) {
        typeof d[1] == "function" && d[1].apply(null, [h]);
      }) : a.apply(this, arguments);
    };
  }), c = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"], c.forEach(function(l) {
    var a = o.prototype[l];
    o.prototype[l] = function() {
      var d = arguments;
      return typeof d[1] == "function" || typeof d[2] == "function" ? a.apply(this, arguments).then(function() {
        typeof d[1] == "function" && d[1].apply(null);
      }, function(h) {
        typeof d[2] == "function" && d[2].apply(null, [h]);
      }) : a.apply(this, arguments);
    };
  }), ["getStats"].forEach(function(l) {
    var a = o.prototype[l];
    o.prototype[l] = function() {
      var d = arguments;
      return typeof d[1] == "function" ? a.apply(this, arguments).then(function() {
        typeof d[1] == "function" && d[1].apply(null);
      }) : a.apply(this, arguments);
    };
  }), o;
};
const ta = /* @__PURE__ */ bn($c);
function Zl(s) {
  const t = s && s.navigator, e = function(n) {
    return {
      name: { PermissionDeniedError: "NotAllowedError" }[n.name] || n.name,
      message: n.message,
      constraint: n.constraint,
      toString() {
        return this.name;
      }
    };
  }, i = t.mediaDevices.getUserMedia.bind(t.mediaDevices);
  t.mediaDevices.getUserMedia = function(n) {
    return i(n).catch((o) => Promise.reject(e(o)));
  };
}
function Xl(s) {
  "getDisplayMedia" in s.navigator && s.navigator.mediaDevices && (s.navigator.mediaDevices && "getDisplayMedia" in s.navigator.mediaDevices || (s.navigator.mediaDevices.getDisplayMedia = s.navigator.getDisplayMedia.bind(s.navigator)));
}
function to(s, t) {
  if (s.RTCIceGatherer && (s.RTCIceCandidate || (s.RTCIceCandidate = function(n) {
    return n;
  }), s.RTCSessionDescription || (s.RTCSessionDescription = function(n) {
    return n;
  }), t.version < 15025)) {
    const i = Object.getOwnPropertyDescriptor(
      s.MediaStreamTrack.prototype,
      "enabled"
    );
    Object.defineProperty(s.MediaStreamTrack.prototype, "enabled", {
      set(n) {
        i.set.call(this, n);
        const o = new Event("enabled");
        o.enabled = n, this.dispatchEvent(o);
      }
    });
  }
  s.RTCRtpSender && !("dtmf" in s.RTCRtpSender.prototype) && Object.defineProperty(s.RTCRtpSender.prototype, "dtmf", {
    get() {
      return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new s.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf;
    }
  }), s.RTCDtmfSender && !s.RTCDTMFSender && (s.RTCDTMFSender = s.RTCDtmfSender);
  const e = ta(
    s,
    t.version
  );
  s.RTCPeerConnection = function(n) {
    return n && n.iceServers && (n.iceServers = Dc(
      n.iceServers,
      t.version
    ), Wo("ICE servers after filtering:", n.iceServers)), new e(n);
  }, s.RTCPeerConnection.prototype = e.prototype;
}
function fl(s) {
  s.RTCRtpSender && !("replaceTrack" in s.RTCRtpSender.prototype) && (s.RTCRtpSender.prototype.replaceTrack = s.RTCRtpSender.prototype.setTrack);
}
const qo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shimGetDisplayMedia: Xl,
  shimGetUserMedia: Zl,
  shimPeerConnection: to,
  shimReplaceTrack: fl
}, Symbol.toStringTag, { value: "Module" }));
function Vl(s, t) {
  const e = s && s.navigator, i = s && s.MediaStreamTrack;
  if (e.getUserMedia = function(n, o, r) {
    yn(
      "navigator.getUserMedia",
      "navigator.mediaDevices.getUserMedia"
    ), e.mediaDevices.getUserMedia(n).then(o, r);
  }, !(t.version > 55 && "autoGainControl" in e.mediaDevices.getSupportedConstraints())) {
    const n = function(r, c, l) {
      c in r && !(l in r) && (r[l] = r[c], delete r[c]);
    }, o = e.mediaDevices.getUserMedia.bind(e.mediaDevices);
    if (e.mediaDevices.getUserMedia = function(r) {
      return typeof r == "object" && typeof r.audio == "object" && (r = JSON.parse(JSON.stringify(r)), n(r.audio, "autoGainControl", "mozAutoGainControl"), n(r.audio, "noiseSuppression", "mozNoiseSuppression")), o(r);
    }, i && i.prototype.getSettings) {
      const r = i.prototype.getSettings;
      i.prototype.getSettings = function() {
        const c = r.apply(this, arguments);
        return n(c, "mozAutoGainControl", "autoGainControl"), n(c, "mozNoiseSuppression", "noiseSuppression"), c;
      };
    }
    if (i && i.prototype.applyConstraints) {
      const r = i.prototype.applyConstraints;
      i.prototype.applyConstraints = function(c) {
        return this.kind === "audio" && typeof c == "object" && (c = JSON.parse(JSON.stringify(c)), n(c, "autoGainControl", "mozAutoGainControl"), n(c, "noiseSuppression", "mozNoiseSuppression")), r.apply(this, [c]);
      };
    }
  }
}
function ea(s, t) {
  s.navigator.mediaDevices && "getDisplayMedia" in s.navigator.mediaDevices || s.navigator.mediaDevices && (s.navigator.mediaDevices.getDisplayMedia = function(i) {
    if (!(i && i.video)) {
      const n = new DOMException("getDisplayMedia without video constraints is undefined");
      return n.name = "NotFoundError", n.code = 8, Promise.reject(n);
    }
    return i.video === !0 ? i.video = { mediaSource: t } : i.video.mediaSource = t, s.navigator.mediaDevices.getUserMedia(i);
  });
}
function Rl(s) {
  typeof s == "object" && s.RTCTrackEvent && "receiver" in s.RTCTrackEvent.prototype && !("transceiver" in s.RTCTrackEvent.prototype) && Object.defineProperty(s.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return { receiver: this.receiver };
    }
  });
}
function eo(s, t) {
  if (typeof s != "object" || !(s.RTCPeerConnection || s.mozRTCPeerConnection))
    return;
  !s.RTCPeerConnection && s.mozRTCPeerConnection && (s.RTCPeerConnection = s.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(n) {
    const o = s.RTCPeerConnection.prototype[n], r = { [n]() {
      return arguments[0] = new (n === "addIceCandidate" ? s.RTCIceCandidate : s.RTCSessionDescription)(arguments[0]), o.apply(this, arguments);
    } };
    s.RTCPeerConnection.prototype[n] = r[n];
  });
  const e = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }, i = s.RTCPeerConnection.prototype.getStats;
  s.RTCPeerConnection.prototype.getStats = function() {
    const [o, r, c] = arguments;
    return i.apply(this, [o || null]).then((l) => {
      if (t.version < 53 && !r)
        try {
          l.forEach((a) => {
            a.type = e[a.type] || a.type;
          });
        } catch (a) {
          if (a.name !== "TypeError")
            throw a;
          l.forEach((d, h) => {
            l.set(h, Object.assign({}, d, {
              type: e[d.type] || d.type
            }));
          });
        }
      return l;
    }).then(r, c);
  };
}
function xl(s) {
  if (!(typeof s == "object" && s.RTCPeerConnection && s.RTCRtpSender) || s.RTCRtpSender && "getStats" in s.RTCRtpSender.prototype)
    return;
  const t = s.RTCPeerConnection.prototype.getSenders;
  t && (s.RTCPeerConnection.prototype.getSenders = function() {
    const n = t.apply(this, []);
    return n.forEach((o) => o._pc = this), n;
  });
  const e = s.RTCPeerConnection.prototype.addTrack;
  e && (s.RTCPeerConnection.prototype.addTrack = function() {
    const n = e.apply(this, arguments);
    return n._pc = this, n;
  }), s.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function Ll(s) {
  if (!(typeof s == "object" && s.RTCPeerConnection && s.RTCRtpSender) || s.RTCRtpSender && "getStats" in s.RTCRtpReceiver.prototype)
    return;
  const t = s.RTCPeerConnection.prototype.getReceivers;
  t && (s.RTCPeerConnection.prototype.getReceivers = function() {
    const i = t.apply(this, []);
    return i.forEach((n) => n._pc = this), i;
  }), di(s, "track", (e) => (e.receiver._pc = e.srcElement, e)), s.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function Sl(s) {
  !s.RTCPeerConnection || "removeStream" in s.RTCPeerConnection.prototype || (s.RTCPeerConnection.prototype.removeStream = function(e) {
    yn("removeStream", "removeTrack"), this.getSenders().forEach((i) => {
      i.track && e.getTracks().includes(i.track) && this.removeTrack(i);
    });
  });
}
function Wl(s) {
  s.DataChannel && !s.RTCDataChannel && (s.RTCDataChannel = s.DataChannel);
}
function Cl(s) {
  if (!(typeof s == "object" && s.RTCPeerConnection))
    return;
  const t = s.RTCPeerConnection.prototype.addTransceiver;
  t && (s.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    const i = arguments[1], n = i && "sendEncodings" in i;
    n && i.sendEncodings.forEach((r) => {
      if ("rid" in r && !/^[a-z0-9]{0,16}$/i.test(r.rid))
        throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in r && !(parseFloat(r.scaleResolutionDownBy) >= 1))
        throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in r && !(parseFloat(r.maxFramerate) >= 0))
        throw new RangeError("max_framerate must be >= 0.0");
    });
    const o = t.apply(this, arguments);
    if (n) {
      const { sender: r } = o, c = r.getParameters();
      (!("encodings" in c) || // Avoid being fooled by patched getParameters() below.
      c.encodings.length === 1 && Object.keys(c.encodings[0]).length === 0) && (c.encodings = i.sendEncodings, r.sendEncodings = i.sendEncodings, this.setParametersPromises.push(
        r.setParameters(c).then(() => {
          delete r.sendEncodings;
        }).catch(() => {
          delete r.sendEncodings;
        })
      ));
    }
    return o;
  });
}
function gl(s) {
  if (!(typeof s == "object" && s.RTCRtpSender))
    return;
  const t = s.RTCRtpSender.prototype.getParameters;
  t && (s.RTCRtpSender.prototype.getParameters = function() {
    const i = t.apply(this, arguments);
    return "encodings" in i || (i.encodings = [].concat(this.sendEncodings || [{}])), i;
  });
}
function zl(s) {
  if (!(typeof s == "object" && s.RTCPeerConnection))
    return;
  const t = s.RTCPeerConnection.prototype.createOffer;
  s.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t.apply(this, arguments);
  };
}
function vl(s) {
  if (!(typeof s == "object" && s.RTCPeerConnection))
    return;
  const t = s.RTCPeerConnection.prototype.createAnswer;
  s.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t.apply(this, arguments);
  };
}
const $o = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shimAddTransceiver: Cl,
  shimCreateAnswer: vl,
  shimCreateOffer: zl,
  shimGetDisplayMedia: ea,
  shimGetParameters: gl,
  shimGetUserMedia: Vl,
  shimOnTrack: Rl,
  shimPeerConnection: eo,
  shimRTCDataChannel: Wl,
  shimReceiverGetStats: Ll,
  shimRemoveStream: Sl,
  shimSenderGetStats: xl
}, Symbol.toStringTag, { value: "Module" }));
function Kl(s) {
  if (!(typeof s != "object" || !s.RTCPeerConnection)) {
    if ("getLocalStreams" in s.RTCPeerConnection.prototype || (s.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in s.RTCPeerConnection.prototype)) {
      const t = s.RTCPeerConnection.prototype.addTrack;
      s.RTCPeerConnection.prototype.addStream = function(i) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(i) || this._localStreams.push(i), i.getAudioTracks().forEach((n) => t.call(
          this,
          n,
          i
        )), i.getVideoTracks().forEach((n) => t.call(
          this,
          n,
          i
        ));
      }, s.RTCPeerConnection.prototype.addTrack = function(i, ...n) {
        return n && n.forEach((o) => {
          this._localStreams ? this._localStreams.includes(o) || this._localStreams.push(o) : this._localStreams = [o];
        }), t.apply(this, arguments);
      };
    }
    "removeStream" in s.RTCPeerConnection.prototype || (s.RTCPeerConnection.prototype.removeStream = function(e) {
      this._localStreams || (this._localStreams = []);
      const i = this._localStreams.indexOf(e);
      if (i === -1)
        return;
      this._localStreams.splice(i, 1);
      const n = e.getTracks();
      this.getSenders().forEach((o) => {
        n.includes(o.track) && this.removeTrack(o);
      });
    });
  }
}
function Tl(s) {
  if (!(typeof s != "object" || !s.RTCPeerConnection) && ("getRemoteStreams" in s.RTCPeerConnection.prototype || (s.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in s.RTCPeerConnection.prototype))) {
    Object.defineProperty(s.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(e) {
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = (i) => {
          i.streams.forEach((n) => {
            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(n))
              return;
            this._remoteStreams.push(n);
            const o = new Event("addstream");
            o.stream = n, this.dispatchEvent(o);
          });
        });
      }
    });
    const t = s.RTCPeerConnection.prototype.setRemoteDescription;
    s.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const i = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(n) {
        n.streams.forEach((o) => {
          if (i._remoteStreams || (i._remoteStreams = []), i._remoteStreams.indexOf(o) >= 0)
            return;
          i._remoteStreams.push(o);
          const r = new Event("addstream");
          r.stream = o, i.dispatchEvent(r);
        });
      }), t.apply(i, arguments);
    };
  }
}
function Ml(s) {
  if (typeof s != "object" || !s.RTCPeerConnection)
    return;
  const t = s.RTCPeerConnection.prototype, e = t.createOffer, i = t.createAnswer, n = t.setLocalDescription, o = t.setRemoteDescription, r = t.addIceCandidate;
  t.createOffer = function(a, d) {
    const h = arguments.length >= 2 ? arguments[2] : arguments[0], u = e.apply(this, [h]);
    return d ? (u.then(a, d), Promise.resolve()) : u;
  }, t.createAnswer = function(a, d) {
    const h = arguments.length >= 2 ? arguments[2] : arguments[0], u = i.apply(this, [h]);
    return d ? (u.then(a, d), Promise.resolve()) : u;
  };
  let c = function(l, a, d) {
    const h = n.apply(this, [l]);
    return d ? (h.then(a, d), Promise.resolve()) : h;
  };
  t.setLocalDescription = c, c = function(l, a, d) {
    const h = o.apply(this, [l]);
    return d ? (h.then(a, d), Promise.resolve()) : h;
  }, t.setRemoteDescription = c, c = function(l, a, d) {
    const h = r.apply(this, [l]);
    return d ? (h.then(a, d), Promise.resolve()) : h;
  }, t.addIceCandidate = c;
}
function Yl(s) {
  const t = s && s.navigator;
  if (t.mediaDevices && t.mediaDevices.getUserMedia) {
    const e = t.mediaDevices, i = e.getUserMedia.bind(e);
    t.mediaDevices.getUserMedia = (n) => i(kl(n));
  }
  !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(i, n, o) {
    t.mediaDevices.getUserMedia(i).then(n, o);
  }.bind(t));
}
function kl(s) {
  return s && s.video !== void 0 ? Object.assign(
    {},
    s,
    { video: rl(s.video) }
  ) : s;
}
function Hl(s) {
  if (!s.RTCPeerConnection)
    return;
  const t = s.RTCPeerConnection;
  s.RTCPeerConnection = function(i, n) {
    if (i && i.iceServers) {
      const o = [];
      for (let r = 0; r < i.iceServers.length; r++) {
        let c = i.iceServers[r];
        !c.hasOwnProperty("urls") && c.hasOwnProperty("url") ? (yn("RTCIceServer.url", "RTCIceServer.urls"), c = JSON.parse(JSON.stringify(c)), c.urls = c.url, delete c.url, o.push(c)) : o.push(i.iceServers[r]);
      }
      i.iceServers = o;
    }
    return new t(i, n);
  }, s.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(s.RTCPeerConnection, "generateCertificate", {
    get() {
      return t.generateCertificate;
    }
  });
}
function Nl(s) {
  typeof s == "object" && s.RTCTrackEvent && "receiver" in s.RTCTrackEvent.prototype && !("transceiver" in s.RTCTrackEvent.prototype) && Object.defineProperty(s.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return { receiver: this.receiver };
    }
  });
}
function Il(s) {
  const t = s.RTCPeerConnection.prototype.createOffer;
  s.RTCPeerConnection.prototype.createOffer = function(i) {
    if (i) {
      typeof i.offerToReceiveAudio < "u" && (i.offerToReceiveAudio = !!i.offerToReceiveAudio);
      const n = this.getTransceivers().find((r) => r.receiver.track.kind === "audio");
      i.offerToReceiveAudio === !1 && n ? n.direction === "sendrecv" ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : n.direction === "recvonly" && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : i.offerToReceiveAudio === !0 && !n && this.addTransceiver("audio"), typeof i.offerToReceiveVideo < "u" && (i.offerToReceiveVideo = !!i.offerToReceiveVideo);
      const o = this.getTransceivers().find((r) => r.receiver.track.kind === "video");
      i.offerToReceiveVideo === !1 && o ? o.direction === "sendrecv" ? o.setDirection ? o.setDirection("sendonly") : o.direction = "sendonly" : o.direction === "recvonly" && (o.setDirection ? o.setDirection("inactive") : o.direction = "inactive") : i.offerToReceiveVideo === !0 && !o && this.addTransceiver("video");
    }
    return t.apply(this, arguments);
  };
}
function Jl(s) {
  typeof s != "object" || s.AudioContext || (s.AudioContext = s.webkitAudioContext);
}
const tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shimAudioContext: Jl,
  shimCallbacksAPI: Ml,
  shimConstraints: kl,
  shimCreateOfferLegacy: Il,
  shimGetUserMedia: Yl,
  shimLocalStreamsAPI: Kl,
  shimRTCIceServerUrls: Hl,
  shimRemoteStreamsAPI: Tl,
  shimTrackEventTransceiver: Nl
}, Symbol.toStringTag, { value: "Module" }));
function qs(s) {
  if (!s.RTCIceCandidate || s.RTCIceCandidate && "foundation" in s.RTCIceCandidate.prototype)
    return;
  const t = s.RTCIceCandidate;
  s.RTCIceCandidate = function(i) {
    if (typeof i == "object" && i.candidate && i.candidate.indexOf("a=") === 0 && (i = JSON.parse(JSON.stringify(i)), i.candidate = i.candidate.substr(2)), i.candidate && i.candidate.length) {
      const n = new t(i), o = As.parseCandidate(i.candidate), r = Object.assign(
        n,
        o
      );
      return r.toJSON = function() {
        return {
          candidate: r.candidate,
          sdpMid: r.sdpMid,
          sdpMLineIndex: r.sdpMLineIndex,
          usernameFragment: r.usernameFragment
        };
      }, r;
    }
    return new t(i);
  }, s.RTCIceCandidate.prototype = t.prototype, di(s, "icecandidate", (e) => (e.candidate && Object.defineProperty(e, "candidate", {
    value: new s.RTCIceCandidate(e.candidate),
    writable: "false"
  }), e));
}
function Mi(s, t) {
  if (!s.RTCPeerConnection)
    return;
  "sctp" in s.RTCPeerConnection.prototype || Object.defineProperty(s.RTCPeerConnection.prototype, "sctp", {
    get() {
      return typeof this._sctp > "u" ? null : this._sctp;
    }
  });
  const e = function(c) {
    if (!c || !c.sdp)
      return !1;
    const l = As.splitSections(c.sdp);
    return l.shift(), l.some((a) => {
      const d = As.parseMLine(a);
      return d && d.kind === "application" && d.protocol.indexOf("SCTP") !== -1;
    });
  }, i = function(c) {
    const l = c.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (l === null || l.length < 2)
      return -1;
    const a = parseInt(l[1], 10);
    return a !== a ? -1 : a;
  }, n = function(c) {
    let l = 65536;
    return t.browser === "firefox" && (t.version < 57 ? c === -1 ? l = 16384 : l = 2147483637 : t.version < 60 ? l = t.version === 57 ? 65535 : 65536 : l = 2147483637), l;
  }, o = function(c, l) {
    let a = 65536;
    t.browser === "firefox" && t.version === 57 && (a = 65535);
    const d = As.matchPrefix(
      c.sdp,
      "a=max-message-size:"
    );
    return d.length > 0 ? a = parseInt(d[0].substr(19), 10) : t.browser === "firefox" && l !== -1 && (a = 2147483637), a;
  }, r = s.RTCPeerConnection.prototype.setRemoteDescription;
  s.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, t.browser === "chrome" && t.version >= 76) {
      const { sdpSemantics: l } = this.getConfiguration();
      l === "plan-b" && Object.defineProperty(this, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
        enumerable: !0,
        configurable: !0
      });
    }
    if (e(arguments[0])) {
      const l = i(arguments[0]), a = n(l), d = o(arguments[0], l);
      let h;
      a === 0 && d === 0 ? h = Number.POSITIVE_INFINITY : a === 0 || d === 0 ? h = Math.max(a, d) : h = Math.min(a, d);
      const u = {};
      Object.defineProperty(u, "maxMessageSize", {
        get() {
          return h;
        }
      }), this._sctp = u;
    }
    return r.apply(this, arguments);
  };
}
function Yi(s) {
  if (!(s.RTCPeerConnection && "createDataChannel" in s.RTCPeerConnection.prototype))
    return;
  function t(i, n) {
    const o = i.send;
    i.send = function() {
      const c = arguments[0], l = c.length || c.size || c.byteLength;
      if (i.readyState === "open" && n.sctp && l > n.sctp.maxMessageSize)
        throw new TypeError("Message too large (can send a maximum of " + n.sctp.maxMessageSize + " bytes)");
      return o.apply(i, arguments);
    };
  }
  const e = s.RTCPeerConnection.prototype.createDataChannel;
  s.RTCPeerConnection.prototype.createDataChannel = function() {
    const n = e.apply(this, arguments);
    return t(n, this), n;
  }, di(s, "datachannel", (i) => (t(i.channel, i.target), i));
}
function io(s) {
  if (!s.RTCPeerConnection || "connectionState" in s.RTCPeerConnection.prototype)
    return;
  const t = s.RTCPeerConnection.prototype;
  Object.defineProperty(t, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(e) {
      this._onconnectionstatechange && (this.removeEventListener(
        "connectionstatechange",
        this._onconnectionstatechange
      ), delete this._onconnectionstatechange), e && this.addEventListener(
        "connectionstatechange",
        this._onconnectionstatechange = e
      );
    },
    enumerable: !0,
    configurable: !0
  }), ["setLocalDescription", "setRemoteDescription"].forEach((e) => {
    const i = t[e];
    t[e] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (n) => {
        const o = n.target;
        if (o._lastConnectionState !== o.connectionState) {
          o._lastConnectionState = o.connectionState;
          const r = new Event("connectionstatechange", n);
          o.dispatchEvent(r);
        }
        return n;
      }, this.addEventListener(
        "iceconnectionstatechange",
        this._connectionstatechangepoly
      )), i.apply(this, arguments);
    };
  });
}
function so(s, t) {
  if (!s.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605)
    return;
  const e = s.RTCPeerConnection.prototype.setRemoteDescription;
  s.RTCPeerConnection.prototype.setRemoteDescription = function(n) {
    if (n && n.sdp && n.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const o = n.sdp.split(`
`).filter((r) => r.trim() !== "a=extmap-allow-mixed").join(`
`);
      s.RTCSessionDescription && n instanceof s.RTCSessionDescription ? arguments[0] = new s.RTCSessionDescription({
        type: n.type,
        sdp: o
      }) : n.sdp = o;
    }
    return e.apply(this, arguments);
  };
}
function $s(s, t) {
  if (!(s.RTCPeerConnection && s.RTCPeerConnection.prototype))
    return;
  const e = s.RTCPeerConnection.prototype.addIceCandidate;
  !e || e.length === 0 || (s.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
const ia = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  removeExtmapAllowMixed: so,
  shimAddIceCandidateNullOrEmpty: $s,
  shimConnectionState: io,
  shimMaxMessageSize: Mi,
  shimRTCIceCandidate: qs,
  shimSendThrowTypeError: Yi
}, Symbol.toStringTag, { value: "Module" }));
function sa({ window: s } = {}, t = {
  shimChrome: !0,
  shimFirefox: !0,
  shimEdge: !0,
  shimSafari: !0
}) {
  const e = Wo, i = Oc(s), n = {
    browserDetails: i,
    commonShim: ia,
    extractVersion: Ti,
    disableLog: Ec,
    disableWarnings: jc
  };
  switch (i.browser) {
    case "chrome":
      if (!_o || !$n || !t.shimChrome)
        return e("Chrome shim is not included in this adapter release."), n;
      if (i.version === null)
        return e("Chrome shim can not determine version, not shimming."), n;
      e("adapter.js shimming chrome."), n.browserShim = _o, $s(s, i), ll(s, i), cl(s), $n(s, i), al(s), ml(s, i), dl(s), hl(s), ul(s), bl(s, i), qs(s), io(s), Mi(s, i), Yi(s), so(s, i);
      break;
    case "firefox":
      if (!$o || !eo || !t.shimFirefox)
        return e("Firefox shim is not included in this adapter release."), n;
      e("adapter.js shimming firefox."), n.browserShim = $o, $s(s, i), Vl(s, i), eo(s, i), Rl(s), Sl(s), xl(s), Ll(s), Wl(s), Cl(s), gl(s), zl(s), vl(s), qs(s), io(s), Mi(s, i), Yi(s);
      break;
    case "edge":
      if (!qo || !to || !t.shimEdge)
        return e("MS edge shim is not included in this adapter release."), n;
      e("adapter.js shimming edge."), n.browserShim = qo, Zl(s), Xl(s), to(s, i), fl(s), Mi(s, i), Yi(s);
      break;
    case "safari":
      if (!tr || !t.shimSafari)
        return e("Safari shim is not included in this adapter release."), n;
      e("adapter.js shimming safari."), n.browserShim = tr, $s(s, i), Hl(s), Il(s), Ml(s), Kl(s), Tl(s), Nl(s), Yl(s), Jl(s), qs(s), Mi(s, i), Yi(s), so(s, i);
      break;
    default:
      e("Unsupported browser!");
      break;
  }
  return n;
}
const er = sa({ window: typeof window > "u" ? void 0 : window });
function te(s, t, e, i) {
  Object.defineProperty(s, t, { get: e, set: i, enumerable: !0, configurable: !0 });
}
var Ln = (
  //@ts-ignore
  er.default || er
), Gi = new /** @class */
(function() {
  function s() {
    this.isIOS = [
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform), this.supportedBrowsers = [
      "firefox",
      "chrome",
      "safari"
    ], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605;
  }
  return s.prototype.isWebRTCSupported = function() {
    return typeof RTCPeerConnection < "u";
  }, s.prototype.isBrowserSupported = function() {
    var t = this.getBrowser(), e = this.getVersion(), i = this.supportedBrowsers.includes(t);
    return i ? t === "chrome" ? e >= this.minChromeVersion : t === "firefox" ? e >= this.minFirefoxVersion : t === "safari" ? !this.isIOS && e >= this.minSafariVersion : !1 : !1;
  }, s.prototype.getBrowser = function() {
    return Ln.browserDetails.browser;
  }, s.prototype.getVersion = function() {
    return Ln.browserDetails.version || 0;
  }, s.prototype.isUnifiedPlanSupported = function() {
    var t = this.getBrowser(), e = Ln.browserDetails.version || 0;
    if (t === "chrome" && e < this.minChromeVersion)
      return !1;
    if (t === "firefox" && e >= this.minFirefoxVersion)
      return !0;
    if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype))
      return !1;
    var i, n = !1;
    try {
      i = new RTCPeerConnection(), i.addTransceiver("audio"), n = !0;
    } catch {
    } finally {
      i && i.close();
    }
    return n;
  }, s.prototype.toString = function() {
    return `Supports:
    browser:`.concat(this.getBrowser(), `
    version:`).concat(this.getVersion(), `
    isIOS:`).concat(this.isIOS, `
    isWebRTCSupported:`).concat(this.isWebRTCSupported(), `
    isBrowserSupported:`).concat(this.isBrowserSupported(), `
    isUnifiedPlanSupported:`).concat(this.isUnifiedPlanSupported());
  }, s;
}())(), ir = {
  iceServers: [
    {
      urls: "stun:stun.l.google.com:19302"
    },
    {
      urls: [
        "turn:eu-0.turn.peerjs.com:3478",
        "turn:us-0.turn.peerjs.com:3478"
      ],
      username: "peerjs",
      credential: "peerjsp"
    }
  ],
  sdpSemantics: "unified-plan"
}, na = (
  /** @class */
  function() {
    function s() {
      this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443, this.chunkedBrowsers = {
        Chrome: 1,
        chrome: 1
      }, this.chunkedMTU = 16300, this.defaultConfig = ir, this.browser = Gi.getBrowser(), this.browserVersion = Gi.getVersion(), this.supports = function() {
        var t = {
          browser: Gi.isBrowserSupported(),
          webRTC: Gi.isWebRTCSupported(),
          audioVideo: !1,
          data: !1,
          binaryBlob: !1,
          reliable: !1
        };
        if (!t.webRTC)
          return t;
        var e;
        try {
          e = new RTCPeerConnection(ir), t.audioVideo = !0;
          var i = void 0;
          try {
            i = e.createDataChannel("_PEERJSTEST", {
              ordered: !0
            }), t.data = !0, t.reliable = !!i.ordered;
            try {
              i.binaryType = "blob", t.binaryBlob = !Gi.isIOS;
            } catch {
            }
          } catch {
          } finally {
            i && i.close();
          }
        } catch {
        } finally {
          e && e.close();
        }
        return t;
      }(), this.pack = Bo.pack, this.unpack = Bo.unpack, this._dataCount = 1;
    }
    return s.prototype.noop = function() {
    }, s.prototype.validateId = function(t) {
      return !t || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(t);
    }, s.prototype.chunk = function(t) {
      for (var e = [], i = t.size, n = Math.ceil(i / U.chunkedMTU), o = 0, r = 0; r < i; ) {
        var c = Math.min(i, r + U.chunkedMTU), l = t.slice(r, c), a = {
          __peerData: this._dataCount,
          n: o,
          data: l,
          total: n
        };
        e.push(a), r = c, o++;
      }
      return this._dataCount++, e;
    }, s.prototype.blobToArrayBuffer = function(t, e) {
      var i = new FileReader();
      return i.onload = function(n) {
        n.target && e(n.target.result);
      }, i.readAsArrayBuffer(t), i;
    }, s.prototype.binaryStringToArrayBuffer = function(t) {
      for (var e = new Uint8Array(t.length), i = 0; i < t.length; i++)
        e[i] = t.charCodeAt(i) & 255;
      return e.buffer;
    }, s.prototype.randomToken = function() {
      return Math.random().toString(36).slice(2);
    }, s.prototype.isSecure = function() {
      return location.protocol === "https:";
    }, s;
  }()
), U = new na(), Ul = {};
te(Ul, "Peer", () => ro, (s) => ro = s);
var fs = {}, oa = Object.prototype.hasOwnProperty, xt = "~";
function Pi() {
}
Object.create && (Pi.prototype = /* @__PURE__ */ Object.create(null), new Pi().__proto__ || (xt = !1));
function ra(s, t, e) {
  this.fn = s, this.context = t, this.once = e || !1;
}
function Pl(s, t, e, i, n) {
  if (typeof e != "function")
    throw new TypeError("The listener must be a function");
  var o = new ra(e, i || s, n), r = xt ? xt + t : t;
  return s._events[r] ? s._events[r].fn ? s._events[r] = [
    s._events[r],
    o
  ] : s._events[r].push(o) : (s._events[r] = o, s._eventsCount++), s;
}
function tn(s, t) {
  --s._eventsCount === 0 ? s._events = new Pi() : delete s._events[t];
}
function Zt() {
  this._events = new Pi(), this._eventsCount = 0;
}
Zt.prototype.eventNames = function() {
  var t = [], e, i;
  if (this._eventsCount === 0)
    return t;
  for (i in e = this._events)
    oa.call(e, i) && t.push(xt ? i.slice(1) : i);
  return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(e)) : t;
};
Zt.prototype.listeners = function(t) {
  var e = xt ? xt + t : t, i = this._events[e];
  if (!i)
    return [];
  if (i.fn)
    return [
      i.fn
    ];
  for (var n = 0, o = i.length, r = new Array(o); n < o; n++)
    r[n] = i[n].fn;
  return r;
};
Zt.prototype.listenerCount = function(t) {
  var e = xt ? xt + t : t, i = this._events[e];
  return i ? i.fn ? 1 : i.length : 0;
};
Zt.prototype.emit = function(t, e, i, n, o, r) {
  var c = xt ? xt + t : t;
  if (!this._events[c])
    return !1;
  var l = this._events[c], a = arguments.length, d, h;
  if (l.fn) {
    switch (l.once && this.removeListener(t, l.fn, void 0, !0), a) {
      case 1:
        return l.fn.call(l.context), !0;
      case 2:
        return l.fn.call(l.context, e), !0;
      case 3:
        return l.fn.call(l.context, e, i), !0;
      case 4:
        return l.fn.call(l.context, e, i, n), !0;
      case 5:
        return l.fn.call(l.context, e, i, n, o), !0;
      case 6:
        return l.fn.call(l.context, e, i, n, o, r), !0;
    }
    for (h = 1, d = new Array(a - 1); h < a; h++)
      d[h - 1] = arguments[h];
    l.fn.apply(l.context, d);
  } else {
    var u = l.length, p;
    for (h = 0; h < u; h++)
      switch (l[h].once && this.removeListener(t, l[h].fn, void 0, !0), a) {
        case 1:
          l[h].fn.call(l[h].context);
          break;
        case 2:
          l[h].fn.call(l[h].context, e);
          break;
        case 3:
          l[h].fn.call(l[h].context, e, i);
          break;
        case 4:
          l[h].fn.call(l[h].context, e, i, n);
          break;
        default:
          if (!d)
            for (p = 1, d = new Array(a - 1); p < a; p++)
              d[p - 1] = arguments[p];
          l[h].fn.apply(l[h].context, d);
      }
  }
  return !0;
};
Zt.prototype.on = function(t, e, i) {
  return Pl(this, t, e, i, !1);
};
Zt.prototype.once = function(t, e, i) {
  return Pl(this, t, e, i, !0);
};
Zt.prototype.removeListener = function(t, e, i, n) {
  var o = xt ? xt + t : t;
  if (!this._events[o])
    return this;
  if (!e)
    return tn(this, o), this;
  var r = this._events[o];
  if (r.fn)
    r.fn === e && (!n || r.once) && (!i || r.context === i) && tn(this, o);
  else {
    for (var c = 0, l = [], a = r.length; c < a; c++)
      (r[c].fn !== e || n && !r[c].once || i && r[c].context !== i) && l.push(r[c]);
    l.length ? this._events[o] = l.length === 1 ? l[0] : l : tn(this, o);
  }
  return this;
};
Zt.prototype.removeAllListeners = function(t) {
  var e;
  return t ? (e = xt ? xt + t : t, this._events[e] && tn(this, e)) : (this._events = new Pi(), this._eventsCount = 0), this;
};
Zt.prototype.off = Zt.prototype.removeListener;
Zt.prototype.addListener = Zt.prototype.on;
Zt.prefixed = xt;
Zt.EventEmitter = Zt;
fs = Zt;
var T = {};
te(T, "LogLevel", () => St, (s) => St = s);
te(T, "default", () => sr, (s) => sr = s);
var Ye = function(s, t) {
  var e = typeof Symbol == "function" && s[Symbol.iterator];
  if (!e)
    return s;
  var i = e.call(s), n, o = [], r;
  try {
    for (; (t === void 0 || t-- > 0) && !(n = i.next()).done; )
      o.push(n.value);
  } catch (c) {
    r = {
      error: c
    };
  } finally {
    try {
      n && !n.done && (e = i.return) && e.call(i);
    } finally {
      if (r)
        throw r.error;
    }
  }
  return o;
}, ke = function(s, t, e) {
  if (e || arguments.length === 2)
    for (var i = 0, n = t.length, o; i < n; i++)
      (o || !(i in t)) && (o || (o = Array.prototype.slice.call(t, 0, i)), o[i] = t[i]);
  return s.concat(o || Array.prototype.slice.call(t));
}, la = "PeerJS: ", St;
(function(s) {
  s[s.Disabled = 0] = "Disabled", s[s.Errors = 1] = "Errors", s[s.Warnings = 2] = "Warnings", s[s.All = 3] = "All";
})(St || (St = {}));
var ca = (
  /** @class */
  function() {
    function s() {
      this._logLevel = St.Disabled;
    }
    return Object.defineProperty(s.prototype, "logLevel", {
      get: function() {
        return this._logLevel;
      },
      set: function(t) {
        this._logLevel = t;
      },
      enumerable: !1,
      configurable: !0
    }), s.prototype.log = function() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t[e] = arguments[e];
      this._logLevel >= St.All && this._print.apply(this, ke([
        St.All
      ], Ye(t), !1));
    }, s.prototype.warn = function() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t[e] = arguments[e];
      this._logLevel >= St.Warnings && this._print.apply(this, ke([
        St.Warnings
      ], Ye(t), !1));
    }, s.prototype.error = function() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t[e] = arguments[e];
      this._logLevel >= St.Errors && this._print.apply(this, ke([
        St.Errors
      ], Ye(t), !1));
    }, s.prototype.setLogFunction = function(t) {
      this._print = t;
    }, s.prototype._print = function(t) {
      for (var e = [], i = 1; i < arguments.length; i++)
        e[i - 1] = arguments[i];
      var n = ke([
        la
      ], Ye(e), !1);
      for (var o in n)
        n[o] instanceof Error && (n[o] = "(" + n[o].name + ") " + n[o].message);
      t >= St.All ? console.log.apply(console, ke([], Ye(n), !1)) : t >= St.Warnings ? console.warn.apply(console, ke([
        "WARNING"
      ], Ye(n), !1)) : t >= St.Errors && console.error.apply(console, ke([
        "ERROR"
      ], Ye(n), !1));
    }, s;
  }()
), sr = new ca(), Fl = {};
te(Fl, "Socket", () => nr, (s) => nr = s);
var Bt;
(function(s) {
  s.Data = "data", s.Media = "media";
})(Bt || (Bt = {}));
var q;
(function(s) {
  s.BrowserIncompatible = "browser-incompatible", s.Disconnected = "disconnected", s.InvalidID = "invalid-id", s.InvalidKey = "invalid-key", s.Network = "network", s.PeerUnavailable = "peer-unavailable", s.SslUnavailable = "ssl-unavailable", s.ServerError = "server-error", s.SocketError = "socket-error", s.SocketClosed = "socket-closed", s.UnavailableID = "unavailable-id", s.WebRTC = "webrtc";
})(q || (q = {}));
var ce;
(function(s) {
  s.Binary = "binary", s.BinaryUTF8 = "binary-utf8", s.JSON = "json";
})(ce || (ce = {}));
var de;
(function(s) {
  s.Message = "message", s.Disconnected = "disconnected", s.Error = "error", s.Close = "close";
})(de || (de = {}));
var ht;
(function(s) {
  s.Heartbeat = "HEARTBEAT", s.Candidate = "CANDIDATE", s.Offer = "OFFER", s.Answer = "ANSWER", s.Open = "OPEN", s.Error = "ERROR", s.IdTaken = "ID-TAKEN", s.InvalidKey = "INVALID-KEY", s.Leave = "LEAVE", s.Expire = "EXPIRE";
})(ht || (ht = {}));
var Co = {};
Co = JSON.parse('{"name":"peerjs","version":"1.4.7","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz Stckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","Soren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}');
var aa = function() {
  var s = function(t, e) {
    return s = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, n) {
      i.__proto__ = n;
    } || function(i, n) {
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (i[o] = n[o]);
    }, s(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    s(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), da = function(s, t) {
  var e = typeof Symbol == "function" && s[Symbol.iterator];
  if (!e)
    return s;
  var i = e.call(s), n, o = [], r;
  try {
    for (; (t === void 0 || t-- > 0) && !(n = i.next()).done; )
      o.push(n.value);
  } catch (c) {
    r = {
      error: c
    };
  } finally {
    try {
      n && !n.done && (e = i.return) && e.call(i);
    } finally {
      if (r)
        throw r.error;
    }
  }
  return o;
}, ha = function(s, t, e) {
  if (e || arguments.length === 2)
    for (var i = 0, n = t.length, o; i < n; i++)
      (o || !(i in t)) && (o || (o = Array.prototype.slice.call(t, 0, i)), o[i] = t[i]);
  return s.concat(o || Array.prototype.slice.call(t));
}, ua = function(s) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && s[t], i = 0;
  if (e)
    return e.call(s);
  if (s && typeof s.length == "number")
    return {
      next: function() {
        return s && i >= s.length && (s = void 0), {
          value: s && s[i++],
          done: !s
        };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, nr = (
  /** @class */
  function(s) {
    aa(t, s);
    function t(e, i, n, o, r, c) {
      c === void 0 && (c = 5e3);
      var l = s.call(this) || this;
      l.pingInterval = c, l._disconnected = !0, l._messagesQueue = [];
      var a = e ? "wss://" : "ws://";
      return l._baseUrl = a + i + ":" + n + o + "peerjs?key=" + r, l;
    }
    return t.prototype.start = function(e, i) {
      var n = this;
      this._id = e;
      var o = "".concat(this._baseUrl, "&id=").concat(e, "&token=").concat(i);
      this._socket || !this._disconnected || (this._socket = new WebSocket(o + "&version=" + Co.version), this._disconnected = !1, this._socket.onmessage = function(r) {
        var c;
        try {
          c = JSON.parse(r.data), T.default.log("Server message received:", c);
        } catch {
          T.default.log("Invalid server message", r.data);
          return;
        }
        n.emit(de.Message, c);
      }, this._socket.onclose = function(r) {
        n._disconnected || (T.default.log("Socket closed.", r), n._cleanup(), n._disconnected = !0, n.emit(de.Disconnected));
      }, this._socket.onopen = function() {
        n._disconnected || (n._sendQueuedMessages(), T.default.log("Socket open"), n._scheduleHeartbeat());
      });
    }, t.prototype._scheduleHeartbeat = function() {
      var e = this;
      this._wsPingTimer = setTimeout(function() {
        e._sendHeartbeat();
      }, this.pingInterval);
    }, t.prototype._sendHeartbeat = function() {
      if (!this._wsOpen()) {
        T.default.log("Cannot send heartbeat, because socket closed");
        return;
      }
      var e = JSON.stringify({
        type: ht.Heartbeat
      });
      this._socket.send(e), this._scheduleHeartbeat();
    }, t.prototype._wsOpen = function() {
      return !!this._socket && this._socket.readyState === 1;
    }, t.prototype._sendQueuedMessages = function() {
      var e, i, n = ha([], da(this._messagesQueue), !1);
      this._messagesQueue = [];
      try {
        for (var o = ua(n), r = o.next(); !r.done; r = o.next()) {
          var c = r.value;
          this.send(c);
        }
      } catch (l) {
        e = {
          error: l
        };
      } finally {
        try {
          r && !r.done && (i = o.return) && i.call(o);
        } finally {
          if (e)
            throw e.error;
        }
      }
    }, t.prototype.send = function(e) {
      if (!this._disconnected) {
        if (!this._id) {
          this._messagesQueue.push(e);
          return;
        }
        if (!e.type) {
          this.emit(de.Error, "Invalid message");
          return;
        }
        if (this._wsOpen()) {
          var i = JSON.stringify(e);
          this._socket.send(i);
        }
      }
    }, t.prototype.close = function() {
      this._disconnected || (this._cleanup(), this._disconnected = !0);
    }, t.prototype._cleanup = function() {
      this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer);
    }, t;
  }(fs.EventEmitter)
), no = {};
te(no, "MediaConnection", () => lr, (s) => lr = s);
var go = {};
te(go, "Negotiator", () => or, (s) => or = s);
var rn = function() {
  return rn = Object.assign || function(s) {
    for (var t, e = 1, i = arguments.length; e < i; e++) {
      t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (s[n] = t[n]);
    }
    return s;
  }, rn.apply(this, arguments);
}, Ls = function(s, t, e, i) {
  function n(o) {
    return o instanceof e ? o : new e(function(r) {
      r(o);
    });
  }
  return new (e || (e = Promise))(function(o, r) {
    function c(d) {
      try {
        a(i.next(d));
      } catch (h) {
        r(h);
      }
    }
    function l(d) {
      try {
        a(i.throw(d));
      } catch (h) {
        r(h);
      }
    }
    function a(d) {
      d.done ? o(d.value) : n(d.value).then(c, l);
    }
    a((i = i.apply(s, t || [])).next());
  });
}, Ss = function(s, t) {
  var e = {
    label: 0,
    sent: function() {
      if (o[0] & 1)
        throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  }, i, n, o, r;
  return r = {
    next: c(0),
    throw: c(1),
    return: c(2)
  }, typeof Symbol == "function" && (r[Symbol.iterator] = function() {
    return this;
  }), r;
  function c(a) {
    return function(d) {
      return l([
        a,
        d
      ]);
    };
  }
  function l(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, n && (o = a[0] & 2 ? n.return : a[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, a[1])).done)
          return o;
        switch (n = 0, o && (a = [
          a[0] & 2,
          o.value
        ]), a[0]) {
          case 0:
          case 1:
            o = a;
            break;
          case 4:
            return e.label++, {
              value: a[1],
              done: !1
            };
          case 5:
            e.label++, n = a[1], a = [
              0
            ];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (o = e.trys, !(o = o.length > 0 && o[o.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!o || a[1] > o[0] && a[1] < o[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < o[1]) {
              e.label = o[1], o = a;
              break;
            }
            if (o && e.label < o[2]) {
              e.label = o[2], e.ops.push(a);
              break;
            }
            o[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = t.call(s, e);
      } catch (d) {
        a = [
          6,
          d
        ], n = 0;
      } finally {
        i = o = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return {
      value: a[0] ? a[1] : void 0,
      done: !0
    };
  }
}, or = (
  /** @class */
  function() {
    function s(t) {
      this.connection = t;
    }
    return s.prototype.startConnection = function(t) {
      var e = this._startPeerConnection();
      if (this.connection.peerConnection = e, this.connection.type === Bt.Media && t._stream && this._addTracksToConnection(t._stream, e), t.originator) {
        if (this.connection.type === Bt.Data) {
          var i = this.connection, n = {
            ordered: !!t.reliable
          }, o = e.createDataChannel(i.label, n);
          i.initialize(o);
        }
        this._makeOffer();
      } else
        this.handleSDP("OFFER", t.sdp);
    }, s.prototype._startPeerConnection = function() {
      T.default.log("Creating RTCPeerConnection.");
      var t = new RTCPeerConnection(this.connection.provider.options.config);
      return this._setupListeners(t), t;
    }, s.prototype._setupListeners = function(t) {
      var e = this, i = this.connection.peer, n = this.connection.connectionId, o = this.connection.type, r = this.connection.provider;
      T.default.log("Listening for ICE candidates."), t.onicecandidate = function(c) {
        !c.candidate || !c.candidate.candidate || (T.default.log("Received ICE candidates for ".concat(i, ":"), c.candidate), r.socket.send({
          type: ht.Candidate,
          payload: {
            candidate: c.candidate,
            type: o,
            connectionId: n
          },
          dst: i
        }));
      }, t.oniceconnectionstatechange = function() {
        switch (t.iceConnectionState) {
          case "failed":
            T.default.log("iceConnectionState is failed, closing connections to " + i), e.connection.emit("error", new Error("Negotiation of connection to " + i + " failed.")), e.connection.close();
            break;
          case "closed":
            T.default.log("iceConnectionState is closed, closing connections to " + i), e.connection.emit("error", new Error("Connection to " + i + " closed.")), e.connection.close();
            break;
          case "disconnected":
            T.default.log("iceConnectionState changed to disconnected on the connection with " + i);
            break;
          case "completed":
            t.onicecandidate = U.noop;
            break;
        }
        e.connection.emit("iceStateChanged", t.iceConnectionState);
      }, T.default.log("Listening for data channel"), t.ondatachannel = function(c) {
        T.default.log("Received data channel");
        var l = c.channel, a = r.getConnection(i, n);
        a.initialize(l);
      }, T.default.log("Listening for remote stream"), t.ontrack = function(c) {
        T.default.log("Received remote stream");
        var l = c.streams[0], a = r.getConnection(i, n);
        if (a.type === Bt.Media) {
          var d = a;
          e._addStreamToMediaConnection(l, d);
        }
      };
    }, s.prototype.cleanup = function() {
      T.default.log("Cleaning up PeerConnection to " + this.connection.peer);
      var t = this.connection.peerConnection;
      if (t) {
        this.connection.peerConnection = null, t.onicecandidate = t.oniceconnectionstatechange = t.ondatachannel = t.ontrack = function() {
        };
        var e = t.signalingState !== "closed", i = !1;
        if (this.connection.type === Bt.Data) {
          var n = this.connection, o = n.dataChannel;
          o && (i = !!o.readyState && o.readyState !== "closed");
        }
        (e || i) && t.close();
      }
    }, s.prototype._makeOffer = function() {
      return Ls(this, void 0, Promise, function() {
        var t, e, i, n, o, r, c;
        return Ss(this, function(l) {
          switch (l.label) {
            case 0:
              t = this.connection.peerConnection, e = this.connection.provider, l.label = 1;
            case 1:
              return l.trys.push([
                1,
                7,
                ,
                8
              ]), [
                4,
                t.createOffer(this.connection.options.constraints)
              ];
            case 2:
              i = l.sent(), T.default.log("Created offer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (i.sdp = this.connection.options.sdpTransform(i.sdp) || i.sdp), l.label = 3;
            case 3:
              return l.trys.push([
                3,
                5,
                ,
                6
              ]), [
                4,
                t.setLocalDescription(i)
              ];
            case 4:
              return l.sent(), T.default.log("Set localDescription:", i, "for:".concat(this.connection.peer)), n = {
                sdp: i,
                type: this.connection.type,
                connectionId: this.connection.connectionId,
                metadata: this.connection.metadata,
                browser: U.browser
              }, this.connection.type === Bt.Data && (o = this.connection, n = rn(rn({}, n), {
                label: o.label,
                reliable: o.reliable,
                serialization: o.serialization
              })), e.socket.send({
                type: ht.Offer,
                payload: n,
                dst: this.connection.peer
              }), [
                3,
                6
              ];
            case 5:
              return r = l.sent(), r != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" && (e.emitError(q.WebRTC, r), T.default.log("Failed to setLocalDescription, ", r)), [
                3,
                6
              ];
            case 6:
              return [
                3,
                8
              ];
            case 7:
              return c = l.sent(), e.emitError(q.WebRTC, c), T.default.log("Failed to createOffer, ", c), [
                3,
                8
              ];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, s.prototype._makeAnswer = function() {
      return Ls(this, void 0, Promise, function() {
        var t, e, i, n, o;
        return Ss(this, function(r) {
          switch (r.label) {
            case 0:
              t = this.connection.peerConnection, e = this.connection.provider, r.label = 1;
            case 1:
              return r.trys.push([
                1,
                7,
                ,
                8
              ]), [
                4,
                t.createAnswer()
              ];
            case 2:
              i = r.sent(), T.default.log("Created answer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (i.sdp = this.connection.options.sdpTransform(i.sdp) || i.sdp), r.label = 3;
            case 3:
              return r.trys.push([
                3,
                5,
                ,
                6
              ]), [
                4,
                t.setLocalDescription(i)
              ];
            case 4:
              return r.sent(), T.default.log("Set localDescription:", i, "for:".concat(this.connection.peer)), e.socket.send({
                type: ht.Answer,
                payload: {
                  sdp: i,
                  type: this.connection.type,
                  connectionId: this.connection.connectionId,
                  browser: U.browser
                },
                dst: this.connection.peer
              }), [
                3,
                6
              ];
            case 5:
              return n = r.sent(), e.emitError(q.WebRTC, n), T.default.log("Failed to setLocalDescription, ", n), [
                3,
                6
              ];
            case 6:
              return [
                3,
                8
              ];
            case 7:
              return o = r.sent(), e.emitError(q.WebRTC, o), T.default.log("Failed to create answer, ", o), [
                3,
                8
              ];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, s.prototype.handleSDP = function(t, e) {
      return Ls(this, void 0, Promise, function() {
        var i, n, o, r;
        return Ss(this, function(c) {
          switch (c.label) {
            case 0:
              e = new RTCSessionDescription(e), i = this.connection.peerConnection, n = this.connection.provider, T.default.log("Setting remote description", e), o = this, c.label = 1;
            case 1:
              return c.trys.push([
                1,
                5,
                ,
                6
              ]), [
                4,
                i.setRemoteDescription(e)
              ];
            case 2:
              return c.sent(), T.default.log("Set remoteDescription:".concat(t, " for:").concat(this.connection.peer)), t !== "OFFER" ? [
                3,
                4
              ] : [
                4,
                o._makeAnswer()
              ];
            case 3:
              c.sent(), c.label = 4;
            case 4:
              return [
                3,
                6
              ];
            case 5:
              return r = c.sent(), n.emitError(q.WebRTC, r), T.default.log("Failed to setRemoteDescription, ", r), [
                3,
                6
              ];
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, s.prototype.handleCandidate = function(t) {
      return Ls(this, void 0, Promise, function() {
        var e, i, n, o, r, c;
        return Ss(this, function(l) {
          switch (l.label) {
            case 0:
              T.default.log("handleCandidate:", t), e = t.candidate, i = t.sdpMLineIndex, n = t.sdpMid, o = this.connection.peerConnection, r = this.connection.provider, l.label = 1;
            case 1:
              return l.trys.push([
                1,
                3,
                ,
                4
              ]), [
                4,
                o.addIceCandidate(new RTCIceCandidate({
                  sdpMid: n,
                  sdpMLineIndex: i,
                  candidate: e
                }))
              ];
            case 2:
              return l.sent(), T.default.log("Added ICE candidate for:".concat(this.connection.peer)), [
                3,
                4
              ];
            case 3:
              return c = l.sent(), r.emitError(q.WebRTC, c), T.default.log("Failed to handleCandidate, ", c), [
                3,
                4
              ];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, s.prototype._addTracksToConnection = function(t, e) {
      if (T.default.log("add tracks from stream ".concat(t.id, " to peer connection")), !e.addTrack)
        return T.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored.");
      t.getTracks().forEach(function(i) {
        e.addTrack(i, t);
      });
    }, s.prototype._addStreamToMediaConnection = function(t, e) {
      T.default.log("add stream ".concat(t.id, " to media connection ").concat(e.connectionId)), e.addStream(t);
    }, s;
  }()
), zo = {};
te(zo, "BaseConnection", () => rr, (s) => rr = s);
var pa = function() {
  var s = function(t, e) {
    return s = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, n) {
      i.__proto__ = n;
    } || function(i, n) {
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (i[o] = n[o]);
    }, s(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    s(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), rr = (
  /** @class */
  function(s) {
    pa(t, s);
    function t(e, i, n) {
      var o = s.call(this) || this;
      return o.peer = e, o.provider = i, o.options = n, o._open = !1, o.metadata = n.metadata, o;
    }
    return Object.defineProperty(t.prototype, "open", {
      get: function() {
        return this._open;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(fs.EventEmitter)
), ma = function() {
  var s = function(t, e) {
    return s = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, n) {
      i.__proto__ = n;
    } || function(i, n) {
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (i[o] = n[o]);
    }, s(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    s(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), ln = function() {
  return ln = Object.assign || function(s) {
    for (var t, e = 1, i = arguments.length; e < i; e++) {
      t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (s[n] = t[n]);
    }
    return s;
  }, ln.apply(this, arguments);
}, ba = function(s) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && s[t], i = 0;
  if (e)
    return e.call(s);
  if (s && typeof s.length == "number")
    return {
      next: function() {
        return s && i >= s.length && (s = void 0), {
          value: s && s[i++],
          done: !s
        };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, lr = (
  /** @class */
  function(s) {
    ma(t, s);
    function t(e, i, n) {
      var o = s.call(this, e, i, n) || this;
      return o._localStream = o.options._stream, o.connectionId = o.options.connectionId || t.ID_PREFIX + U.randomToken(), o._negotiator = new go.Negotiator(o), o._localStream && o._negotiator.startConnection({
        _stream: o._localStream,
        originator: !0
      }), o;
    }
    return Object.defineProperty(t.prototype, "type", {
      get: function() {
        return Bt.Media;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "localStream", {
      get: function() {
        return this._localStream;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "remoteStream", {
      get: function() {
        return this._remoteStream;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.addStream = function(e) {
      T.default.log("Receiving stream", e), this._remoteStream = e, s.prototype.emit.call(this, "stream", e);
    }, t.prototype.handleMessage = function(e) {
      var i = e.type, n = e.payload;
      switch (e.type) {
        case ht.Answer:
          this._negotiator.handleSDP(i, n.sdp), this._open = !0;
          break;
        case ht.Candidate:
          this._negotiator.handleCandidate(n.candidate);
          break;
        default:
          T.default.warn("Unrecognized message type:".concat(i, " from peer:").concat(this.peer));
          break;
      }
    }, t.prototype.answer = function(e, i) {
      var n, o;
      if (i === void 0 && (i = {}), this._localStream) {
        T.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?");
        return;
      }
      this._localStream = e, i && i.sdpTransform && (this.options.sdpTransform = i.sdpTransform), this._negotiator.startConnection(ln(ln({}, this.options._payload), {
        _stream: e
      }));
      var r = this.provider._getMessages(this.connectionId);
      try {
        for (var c = ba(r), l = c.next(); !l.done; l = c.next()) {
          var a = l.value;
          this.handleMessage(a);
        }
      } catch (d) {
        n = {
          error: d
        };
      } finally {
        try {
          l && !l.done && (o = c.return) && o.call(c);
        } finally {
          if (n)
            throw n.error;
        }
      }
      this._open = !0;
    }, t.prototype.close = function() {
      this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, s.prototype.emit.call(this, "close"));
    }, t.ID_PREFIX = "mc_", t;
  }(zo.BaseConnection)
), oo = {};
te(oo, "DataConnection", () => ar, (s) => ar = s);
var Ql = {};
te(Ql, "EncodingQueue", () => cr, (s) => cr = s);
var ya = function() {
  var s = function(t, e) {
    return s = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, n) {
      i.__proto__ = n;
    } || function(i, n) {
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (i[o] = n[o]);
    }, s(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    s(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), cr = (
  /** @class */
  function(s) {
    ya(t, s);
    function t() {
      var e = s.call(this) || this;
      return e.fileReader = new FileReader(), e._queue = [], e._processing = !1, e.fileReader.onload = function(i) {
        e._processing = !1, i.target && e.emit("done", i.target.result), e.doNextTask();
      }, e.fileReader.onerror = function(i) {
        T.default.error("EncodingQueue error:", i), e._processing = !1, e.destroy(), e.emit("error", i);
      }, e;
    }
    return Object.defineProperty(t.prototype, "queue", {
      get: function() {
        return this._queue;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "size", {
      get: function() {
        return this.queue.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "processing", {
      get: function() {
        return this._processing;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.enque = function(e) {
      this.queue.push(e), !this.processing && this.doNextTask();
    }, t.prototype.destroy = function() {
      this.fileReader.abort(), this._queue = [];
    }, t.prototype.doNextTask = function() {
      this.size !== 0 && (this.processing || (this._processing = !0, this.fileReader.readAsArrayBuffer(this.queue.shift())));
    }, t;
  }(fs.EventEmitter)
), Ga = function() {
  var s = function(t, e) {
    return s = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, n) {
      i.__proto__ = n;
    } || function(i, n) {
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (i[o] = n[o]);
    }, s(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    s(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), Za = function(s) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && s[t], i = 0;
  if (e)
    return e.call(s);
  if (s && typeof s.length == "number")
    return {
      next: function() {
        return s && i >= s.length && (s = void 0), {
          value: s && s[i++],
          done: !s
        };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, ar = (
  /** @class */
  function(s) {
    Ga(t, s);
    function t(e, i, n) {
      var o = s.call(this, e, i, n) || this;
      return o.stringify = JSON.stringify, o.parse = JSON.parse, o._buffer = [], o._bufferSize = 0, o._buffering = !1, o._chunkedData = {}, o._encodingQueue = new Ql.EncodingQueue(), o.connectionId = o.options.connectionId || t.ID_PREFIX + U.randomToken(), o.label = o.options.label || o.connectionId, o.serialization = o.options.serialization || ce.Binary, o.reliable = !!o.options.reliable, o._encodingQueue.on("done", function(r) {
        o._bufferedSend(r);
      }), o._encodingQueue.on("error", function() {
        T.default.error("DC#".concat(o.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC")), o.close();
      }), o._negotiator = new go.Negotiator(o), o._negotiator.startConnection(o.options._payload || {
        originator: !0
      }), o;
    }
    return Object.defineProperty(t.prototype, "type", {
      get: function() {
        return Bt.Data;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "dataChannel", {
      get: function() {
        return this._dc;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "bufferSize", {
      get: function() {
        return this._bufferSize;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.initialize = function(e) {
      this._dc = e, this._configureDataChannel();
    }, t.prototype._configureDataChannel = function() {
      var e = this;
      (!U.supports.binaryBlob || U.supports.reliable) && (this.dataChannel.binaryType = "arraybuffer"), this.dataChannel.onopen = function() {
        T.default.log("DC#".concat(e.connectionId, " dc connection success")), e._open = !0, e.emit("open");
      }, this.dataChannel.onmessage = function(i) {
        T.default.log("DC#".concat(e.connectionId, " dc onmessage:"), i.data), e._handleDataMessage(i);
      }, this.dataChannel.onclose = function() {
        T.default.log("DC#".concat(e.connectionId, " dc closed for:"), e.peer), e.close();
      };
    }, t.prototype._handleDataMessage = function(e) {
      var i = this, n = e.data, o = n.constructor, r = this.serialization === ce.Binary || this.serialization === ce.BinaryUTF8, c = n;
      if (r) {
        if (o === Blob) {
          U.blobToArrayBuffer(n, function(a) {
            var d = U.unpack(a);
            i.emit("data", d);
          });
          return;
        } else if (o === ArrayBuffer)
          c = U.unpack(n);
        else if (o === String) {
          var l = U.binaryStringToArrayBuffer(n);
          c = U.unpack(l);
        }
      } else
        this.serialization === ce.JSON && (c = this.parse(n));
      if (c.__peerData) {
        this._handleChunk(c);
        return;
      }
      s.prototype.emit.call(this, "data", c);
    }, t.prototype._handleChunk = function(e) {
      var i = e.__peerData, n = this._chunkedData[i] || {
        data: [],
        count: 0,
        total: e.total
      };
      if (n.data[e.n] = e.data, n.count++, this._chunkedData[i] = n, n.total === n.count) {
        delete this._chunkedData[i];
        var o = new Blob(n.data);
        this._handleDataMessage({
          data: o
        });
      }
    }, t.prototype.close = function() {
      this._buffer = [], this._bufferSize = 0, this._chunkedData = {}, this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this._dc = null), this._encodingQueue && (this._encodingQueue.destroy(), this._encodingQueue.removeAllListeners(), this._encodingQueue = null), this.open && (this._open = !1, s.prototype.emit.call(this, "close"));
    }, t.prototype.send = function(e, i) {
      if (!this.open) {
        s.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages."));
        return;
      }
      if (this.serialization === ce.JSON)
        this._bufferedSend(this.stringify(e));
      else if (this.serialization === ce.Binary || this.serialization === ce.BinaryUTF8) {
        var n = U.pack(e);
        if (!i && n.size > U.chunkedMTU) {
          this._sendChunks(n);
          return;
        }
        U.supports.binaryBlob ? this._bufferedSend(n) : this._encodingQueue.enque(n);
      } else
        this._bufferedSend(e);
    }, t.prototype._bufferedSend = function(e) {
      (this._buffering || !this._trySend(e)) && (this._buffer.push(e), this._bufferSize = this._buffer.length);
    }, t.prototype._trySend = function(e) {
      var i = this;
      if (!this.open)
        return !1;
      if (this.dataChannel.bufferedAmount > t.MAX_BUFFERED_AMOUNT)
        return this._buffering = !0, setTimeout(function() {
          i._buffering = !1, i._tryBuffer();
        }, 50), !1;
      try {
        this.dataChannel.send(e);
      } catch (n) {
        return T.default.error("DC#:".concat(this.connectionId, " Error when sending:"), n), this._buffering = !0, this.close(), !1;
      }
      return !0;
    }, t.prototype._tryBuffer = function() {
      if (this.open && this._buffer.length !== 0) {
        var e = this._buffer[0];
        this._trySend(e) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer());
      }
    }, t.prototype._sendChunks = function(e) {
      var i, n, o = U.chunk(e);
      T.default.log("DC#".concat(this.connectionId, " Try to send ").concat(o.length, " chunks..."));
      try {
        for (var r = Za(o), c = r.next(); !c.done; c = r.next()) {
          var l = c.value;
          this.send(l, !0);
        }
      } catch (a) {
        i = {
          error: a
        };
      } finally {
        try {
          c && !c.done && (n = r.return) && n.call(r);
        } finally {
          if (i)
            throw i.error;
        }
      }
    }, t.prototype.handleMessage = function(e) {
      var i = e.payload;
      switch (e.type) {
        case ht.Answer:
          this._negotiator.handleSDP(e.type, i.sdp);
          break;
        case ht.Candidate:
          this._negotiator.handleCandidate(i.candidate);
          break;
        default:
          T.default.warn("Unrecognized message type:", e.type, "from peer:", this.peer);
          break;
      }
    }, t.ID_PREFIX = "dc_", t.MAX_BUFFERED_AMOUNT = 8388608, t;
  }(zo.BaseConnection)
), wl = {};
te(wl, "API", () => ur, (s) => ur = s);
var dr = function(s, t, e, i) {
  function n(o) {
    return o instanceof e ? o : new e(function(r) {
      r(o);
    });
  }
  return new (e || (e = Promise))(function(o, r) {
    function c(d) {
      try {
        a(i.next(d));
      } catch (h) {
        r(h);
      }
    }
    function l(d) {
      try {
        a(i.throw(d));
      } catch (h) {
        r(h);
      }
    }
    function a(d) {
      d.done ? o(d.value) : n(d.value).then(c, l);
    }
    a((i = i.apply(s, t || [])).next());
  });
}, hr = function(s, t) {
  var e = {
    label: 0,
    sent: function() {
      if (o[0] & 1)
        throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  }, i, n, o, r;
  return r = {
    next: c(0),
    throw: c(1),
    return: c(2)
  }, typeof Symbol == "function" && (r[Symbol.iterator] = function() {
    return this;
  }), r;
  function c(a) {
    return function(d) {
      return l([
        a,
        d
      ]);
    };
  }
  function l(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, n && (o = a[0] & 2 ? n.return : a[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, a[1])).done)
          return o;
        switch (n = 0, o && (a = [
          a[0] & 2,
          o.value
        ]), a[0]) {
          case 0:
          case 1:
            o = a;
            break;
          case 4:
            return e.label++, {
              value: a[1],
              done: !1
            };
          case 5:
            e.label++, n = a[1], a = [
              0
            ];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (o = e.trys, !(o = o.length > 0 && o[o.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!o || a[1] > o[0] && a[1] < o[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < o[1]) {
              e.label = o[1], o = a;
              break;
            }
            if (o && e.label < o[2]) {
              e.label = o[2], e.ops.push(a);
              break;
            }
            o[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = t.call(s, e);
      } catch (d) {
        a = [
          6,
          d
        ], n = 0;
      } finally {
        i = o = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return {
      value: a[0] ? a[1] : void 0,
      done: !0
    };
  }
}, ur = (
  /** @class */
  function() {
    function s(t) {
      this._options = t;
    }
    return s.prototype._buildRequest = function(t) {
      var e = this._options.secure ? "https" : "http", i = this._options, n = i.host, o = i.port, r = i.path, c = i.key, l = new URL("".concat(e, "://").concat(n, ":").concat(o).concat(r).concat(c, "/").concat(t));
      return l.searchParams.set("ts", "".concat(Date.now()).concat(Math.random())), l.searchParams.set("version", Co.version), fetch(l.href, {
        referrerPolicy: this._options.referrerPolicy
      });
    }, s.prototype.retrieveId = function() {
      return dr(this, void 0, Promise, function() {
        var t, e, i;
        return hr(this, function(n) {
          switch (n.label) {
            case 0:
              return n.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                this._buildRequest("id")
              ];
            case 1:
              if (t = n.sent(), t.status !== 200)
                throw new Error("Error. Status:".concat(t.status));
              return [
                2,
                t.text()
              ];
            case 2:
              throw e = n.sent(), T.default.error("Error retrieving ID", e), i = "", this._options.path === "/" && this._options.host !== U.CLOUD_HOST && (i = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), new Error("Could not get an ID from the server." + i);
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, s.prototype.listAllPeers = function() {
      return dr(this, void 0, Promise, function() {
        var t, e, i;
        return hr(this, function(n) {
          switch (n.label) {
            case 0:
              return n.trys.push([
                0,
                2,
                ,
                3
              ]), [
                4,
                this._buildRequest("peers")
              ];
            case 1:
              if (t = n.sent(), t.status !== 200)
                throw t.status === 401 ? (e = "", this._options.host === U.CLOUD_HOST ? e = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : e = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", new Error("It doesn't look like you have permission to list peers IDs. " + e)) : new Error("Error. Status:".concat(t.status));
              return [
                2,
                t.json()
              ];
            case 2:
              throw i = n.sent(), T.default.error("Error retrieving list peers", i), new Error("Could not get list peers from the server." + i);
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, s;
  }()
), Xa = function() {
  var s = function(t, e) {
    return s = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(i, n) {
      i.__proto__ = n;
    } || function(i, n) {
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (i[o] = n[o]);
    }, s(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    s(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), Ji = function() {
  return Ji = Object.assign || function(s) {
    for (var t, e = 1, i = arguments.length; e < i; e++) {
      t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (s[n] = t[n]);
    }
    return s;
  }, Ji.apply(this, arguments);
}, Zi = function(s) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && s[t], i = 0;
  if (e)
    return e.call(s);
  if (s && typeof s.length == "number")
    return {
      next: function() {
        return s && i >= s.length && (s = void 0), {
          value: s && s[i++],
          done: !s
        };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, fa = function(s, t) {
  var e = typeof Symbol == "function" && s[Symbol.iterator];
  if (!e)
    return s;
  var i = e.call(s), n, o = [], r;
  try {
    for (; (t === void 0 || t-- > 0) && !(n = i.next()).done; )
      o.push(n.value);
  } catch (c) {
    r = {
      error: c
    };
  } finally {
    try {
      n && !n.done && (e = i.return) && e.call(i);
    } finally {
      if (r)
        throw r.error;
    }
  }
  return o;
}, ro = (
  /** @class */
  function(s) {
    Xa(t, s);
    function t(e, i) {
      var n = s.call(this) || this;
      n._id = null, n._lastServerId = null, n._destroyed = !1, n._disconnected = !1, n._open = !1, n._connections = /* @__PURE__ */ new Map(), n._lostMessages = /* @__PURE__ */ new Map();
      var o;
      return e && e.constructor == Object ? i = e : e && (o = e.toString()), i = Ji({
        debug: 0,
        host: U.CLOUD_HOST,
        port: U.CLOUD_PORT,
        path: "/",
        key: t.DEFAULT_KEY,
        token: U.randomToken(),
        config: U.defaultConfig,
        referrerPolicy: "strict-origin-when-cross-origin"
      }, i), n._options = i, n._options.host === "/" && (n._options.host = window.location.hostname), n._options.path && (n._options.path[0] !== "/" && (n._options.path = "/" + n._options.path), n._options.path[n._options.path.length - 1] !== "/" && (n._options.path += "/")), n._options.secure === void 0 && n._options.host !== U.CLOUD_HOST ? n._options.secure = U.isSecure() : n._options.host == U.CLOUD_HOST && (n._options.secure = !0), n._options.logFunction && T.default.setLogFunction(n._options.logFunction), T.default.logLevel = n._options.debug || 0, n._api = new wl.API(i), n._socket = n._createServerConnection(), !U.supports.audioVideo && !U.supports.data ? (n._delayedAbort(q.BrowserIncompatible, "The current browser does not support WebRTC"), n) : o && !U.validateId(o) ? (n._delayedAbort(q.InvalidID, 'ID "'.concat(o, '" is invalid')), n) : (o ? n._initialize(o) : n._api.retrieveId().then(function(r) {
        return n._initialize(r);
      }).catch(function(r) {
        return n._abort(q.ServerError, r);
      }), n);
    }
    return Object.defineProperty(t.prototype, "id", {
      /**
       * The brokering ID of this peer
       */
      get: function() {
        return this._id;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "options", {
      get: function() {
        return this._options;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "open", {
      get: function() {
        return this._open;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "socket", {
      get: function() {
        return this._socket;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "connections", {
      /**
       * A hash of all connections associated with this peer, keyed by the remote peer's ID.
       * @deprecated
       * Return type will change from Object to Map<string,[]>
       */
      get: function() {
        var e, i, n = /* @__PURE__ */ Object.create(null);
        try {
          for (var o = Zi(this._connections), r = o.next(); !r.done; r = o.next()) {
            var c = fa(r.value, 2), l = c[0], a = c[1];
            n[l] = a;
          }
        } catch (d) {
          e = {
            error: d
          };
        } finally {
          try {
            r && !r.done && (i = o.return) && i.call(o);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "destroyed", {
      /**
       * true if this peer and all of its connections can no longer be used.
       */
      get: function() {
        return this._destroyed;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "disconnected", {
      /**
       * false if there is an active connection to the PeerServer.
       */
      get: function() {
        return this._disconnected;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._createServerConnection = function() {
      var e = this, i = new Fl.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);
      return i.on(de.Message, function(n) {
        e._handleMessage(n);
      }), i.on(de.Error, function(n) {
        e._abort(q.SocketError, n);
      }), i.on(de.Disconnected, function() {
        e.disconnected || (e.emitError(q.Network, "Lost connection to server."), e.disconnect());
      }), i.on(de.Close, function() {
        e.disconnected || e._abort(q.SocketClosed, "Underlying socket is already closed.");
      }), i;
    }, t.prototype._initialize = function(e) {
      this._id = e, this.socket.start(e, this._options.token);
    }, t.prototype._handleMessage = function(e) {
      var i, n, o = e.type, r = e.payload, c = e.src;
      switch (o) {
        case ht.Open:
          this._lastServerId = this.id, this._open = !0, this.emit("open", this.id);
          break;
        case ht.Error:
          this._abort(q.ServerError, r.msg);
          break;
        case ht.IdTaken:
          this._abort(q.UnavailableID, 'ID "'.concat(this.id, '" is taken'));
          break;
        case ht.InvalidKey:
          this._abort(q.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid'));
          break;
        case ht.Leave:
          T.default.log("Received leave message from ".concat(c)), this._cleanupPeer(c), this._connections.delete(c);
          break;
        case ht.Expire:
          this.emitError(q.PeerUnavailable, "Could not connect to peer ".concat(c));
          break;
        case ht.Offer:
          var m = r.connectionId, b = this.getConnection(c, m);
          if (b && (b.close(), T.default.warn("Offer received for existing Connection ID:".concat(m))), r.type === Bt.Media) {
            var l = new no.MediaConnection(c, this, {
              connectionId: m,
              _payload: r,
              metadata: r.metadata
            });
            b = l, this._addConnection(c, b), this.emit("call", l);
          } else if (r.type === Bt.Data) {
            var a = new oo.DataConnection(c, this, {
              connectionId: m,
              _payload: r,
              metadata: r.metadata,
              label: r.label,
              serialization: r.serialization,
              reliable: r.reliable
            });
            b = a, this._addConnection(c, b), this.emit("connection", a);
          } else {
            T.default.warn("Received malformed connection type:".concat(r.type));
            return;
          }
          var d = this._getMessages(m);
          try {
            for (var h = Zi(d), u = h.next(); !u.done; u = h.next()) {
              var p = u.value;
              b.handleMessage(p);
            }
          } catch (G) {
            i = {
              error: G
            };
          } finally {
            try {
              u && !u.done && (n = h.return) && n.call(h);
            } finally {
              if (i)
                throw i.error;
            }
          }
          break;
        default:
          if (!r) {
            T.default.warn("You received a malformed message from ".concat(c, " of type ").concat(o));
            return;
          }
          var m = r.connectionId, b = this.getConnection(c, m);
          b && b.peerConnection ? b.handleMessage(e) : m ? this._storeMessage(m, e) : T.default.warn("You received an unrecognized message:", e);
          break;
      }
    }, t.prototype._storeMessage = function(e, i) {
      this._lostMessages.has(e) || this._lostMessages.set(e, []), this._lostMessages.get(e).push(i);
    }, t.prototype._getMessages = function(e) {
      var i = this._lostMessages.get(e);
      return i ? (this._lostMessages.delete(e), i) : [];
    }, t.prototype.connect = function(e, i) {
      if (i === void 0 && (i = {}), this.disconnected) {
        T.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(q.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
        return;
      }
      var n = new oo.DataConnection(e, this, i);
      return this._addConnection(e, n), n;
    }, t.prototype.call = function(e, i, n) {
      if (n === void 0 && (n = {}), this.disconnected) {
        T.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(q.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
        return;
      }
      if (!i) {
        T.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`.");
        return;
      }
      var o = new no.MediaConnection(e, this, Ji(Ji({}, n), {
        _stream: i
      }));
      return this._addConnection(e, o), o;
    }, t.prototype._addConnection = function(e, i) {
      T.default.log("add connection ".concat(i.type, ":").concat(i.connectionId, " to peerId:").concat(e)), this._connections.has(e) || this._connections.set(e, []), this._connections.get(e).push(i);
    }, t.prototype._removeConnection = function(e) {
      var i = this._connections.get(e.peer);
      if (i) {
        var n = i.indexOf(e);
        n !== -1 && i.splice(n, 1);
      }
      this._lostMessages.delete(e.connectionId);
    }, t.prototype.getConnection = function(e, i) {
      var n, o, r = this._connections.get(e);
      if (!r)
        return null;
      try {
        for (var c = Zi(r), l = c.next(); !l.done; l = c.next()) {
          var a = l.value;
          if (a.connectionId === i)
            return a;
        }
      } catch (d) {
        n = {
          error: d
        };
      } finally {
        try {
          l && !l.done && (o = c.return) && o.call(c);
        } finally {
          if (n)
            throw n.error;
        }
      }
      return null;
    }, t.prototype._delayedAbort = function(e, i) {
      var n = this;
      setTimeout(function() {
        n._abort(e, i);
      }, 0);
    }, t.prototype._abort = function(e, i) {
      T.default.error("Aborting!"), this.emitError(e, i), this._lastServerId ? this.disconnect() : this.destroy();
    }, t.prototype.emitError = function(e, i) {
      T.default.error("Error:", i);
      var n;
      typeof i == "string" ? n = new Error(i) : n = i, n.type = e, this.emit("error", n);
    }, t.prototype.destroy = function() {
      this.destroyed || (T.default.log("Destroy peer with ID:".concat(this.id)), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close"));
    }, t.prototype._cleanup = function() {
      var e, i;
      try {
        for (var n = Zi(this._connections.keys()), o = n.next(); !o.done; o = n.next()) {
          var r = o.value;
          this._cleanupPeer(r), this._connections.delete(r);
        }
      } catch (c) {
        e = {
          error: c
        };
      } finally {
        try {
          o && !o.done && (i = n.return) && i.call(n);
        } finally {
          if (e)
            throw e.error;
        }
      }
      this.socket.removeAllListeners();
    }, t.prototype._cleanupPeer = function(e) {
      var i, n, o = this._connections.get(e);
      if (o)
        try {
          for (var r = Zi(o), c = r.next(); !c.done; c = r.next()) {
            var l = c.value;
            l.close();
          }
        } catch (a) {
          i = {
            error: a
          };
        } finally {
          try {
            c && !c.done && (n = r.return) && n.call(r);
          } finally {
            if (i)
              throw i.error;
          }
        }
    }, t.prototype.disconnect = function() {
      if (!this.disconnected) {
        var e = this.id;
        T.default.log("Disconnect peer with ID:".concat(e)), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = e, this._id = null, this.emit("disconnected", e);
      }
    }, t.prototype.reconnect = function() {
      if (this.disconnected && !this.destroyed)
        T.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId)), this._disconnected = !1, this._initialize(this._lastServerId);
      else {
        if (this.destroyed)
          throw new Error("This peer cannot reconnect to the server. It has already been destroyed.");
        if (!this.disconnected && !this.open)
          T.default.error("In a hurry? We're still trying to make the initial connection!");
        else
          throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!"));
      }
    }, t.prototype.listAllPeers = function(e) {
      var i = this;
      e === void 0 && (e = function(n) {
      }), this._api.listAllPeers().then(function(n) {
        return e(n);
      }).catch(function(n) {
        return i._abort(q.ServerError, n);
      });
    }, t.DEFAULT_KEY = "peerjs", t;
  }(fs.EventEmitter)
), Va = Ul.Peer;
const Hu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get Peer() {
    return ro;
  },
  default: Va,
  util: U
}, Symbol.toStringTag, { value: "Module" })), Ra = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function xa(s) {
  return typeof s == "string" && Ra.test(s);
}
const dt = [];
for (let s = 0; s < 256; ++s)
  dt.push((s + 256).toString(16).slice(1));
function La(s, t = 0) {
  return dt[s[t + 0]] + dt[s[t + 1]] + dt[s[t + 2]] + dt[s[t + 3]] + "-" + dt[s[t + 4]] + dt[s[t + 5]] + "-" + dt[s[t + 6]] + dt[s[t + 7]] + "-" + dt[s[t + 8]] + dt[s[t + 9]] + "-" + dt[s[t + 10]] + dt[s[t + 11]] + dt[s[t + 12]] + dt[s[t + 13]] + dt[s[t + 14]] + dt[s[t + 15]];
}
function Sa(s) {
  if (!xa(s))
    throw TypeError("Invalid UUID");
  let t;
  const e = new Uint8Array(16);
  return e[0] = (t = parseInt(s.slice(0, 8), 16)) >>> 24, e[1] = t >>> 16 & 255, e[2] = t >>> 8 & 255, e[3] = t & 255, e[4] = (t = parseInt(s.slice(9, 13), 16)) >>> 8, e[5] = t & 255, e[6] = (t = parseInt(s.slice(14, 18), 16)) >>> 8, e[7] = t & 255, e[8] = (t = parseInt(s.slice(19, 23), 16)) >>> 8, e[9] = t & 255, e[10] = (t = parseInt(s.slice(24, 36), 16)) / 1099511627776 & 255, e[11] = t / 4294967296 & 255, e[12] = t >>> 24 & 255, e[13] = t >>> 16 & 255, e[14] = t >>> 8 & 255, e[15] = t & 255, e;
}
function Wa(s) {
  s = unescape(encodeURIComponent(s));
  const t = [];
  for (let e = 0; e < s.length; ++e)
    t.push(s.charCodeAt(e));
  return t;
}
const Ca = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", ga = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function za(s, t, e) {
  function i(n, o, r, c) {
    var l;
    if (typeof n == "string" && (n = Wa(n)), typeof o == "string" && (o = Sa(o)), ((l = o) === null || l === void 0 ? void 0 : l.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let a = new Uint8Array(16 + n.length);
    if (a.set(o), a.set(n, o.length), a = e(a), a[6] = a[6] & 15 | t, a[8] = a[8] & 63 | 128, r) {
      c = c || 0;
      for (let d = 0; d < 16; ++d)
        r[c + d] = a[d];
      return r;
    }
    return La(a);
  }
  try {
    i.name = s;
  } catch {
  }
  return i.DNS = Ca, i.URL = ga, i;
}
function va(s, t, e, i) {
  switch (s) {
    case 0:
      return t & e ^ ~t & i;
    case 1:
      return t ^ e ^ i;
    case 2:
      return t & e ^ t & i ^ e & i;
    case 3:
      return t ^ e ^ i;
  }
}
function Sn(s, t) {
  return s << t | s >>> 32 - t;
}
function Ka(s) {
  const t = [1518500249, 1859775393, 2400959708, 3395469782], e = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof s == "string") {
    const r = unescape(encodeURIComponent(s));
    s = [];
    for (let c = 0; c < r.length; ++c)
      s.push(r.charCodeAt(c));
  } else
    Array.isArray(s) || (s = Array.prototype.slice.call(s));
  s.push(128);
  const i = s.length / 4 + 2, n = Math.ceil(i / 16), o = new Array(n);
  for (let r = 0; r < n; ++r) {
    const c = new Uint32Array(16);
    for (let l = 0; l < 16; ++l)
      c[l] = s[r * 64 + l * 4] << 24 | s[r * 64 + l * 4 + 1] << 16 | s[r * 64 + l * 4 + 2] << 8 | s[r * 64 + l * 4 + 3];
    o[r] = c;
  }
  o[n - 1][14] = (s.length - 1) * 8 / Math.pow(2, 32), o[n - 1][14] = Math.floor(o[n - 1][14]), o[n - 1][15] = (s.length - 1) * 8 & 4294967295;
  for (let r = 0; r < n; ++r) {
    const c = new Uint32Array(80);
    for (let p = 0; p < 16; ++p)
      c[p] = o[r][p];
    for (let p = 16; p < 80; ++p)
      c[p] = Sn(c[p - 3] ^ c[p - 8] ^ c[p - 14] ^ c[p - 16], 1);
    let l = e[0], a = e[1], d = e[2], h = e[3], u = e[4];
    for (let p = 0; p < 80; ++p) {
      const m = Math.floor(p / 20), b = Sn(l, 5) + va(m, a, d, h) + u + t[m] + c[p] >>> 0;
      u = h, h = d, d = Sn(a, 30) >>> 0, a = l, l = b;
    }
    e[0] = e[0] + l >>> 0, e[1] = e[1] + a >>> 0, e[2] = e[2] + d >>> 0, e[3] = e[3] + h >>> 0, e[4] = e[4] + u >>> 0;
  }
  return [e[0] >> 24 & 255, e[0] >> 16 & 255, e[0] >> 8 & 255, e[0] & 255, e[1] >> 24 & 255, e[1] >> 16 & 255, e[1] >> 8 & 255, e[1] & 255, e[2] >> 24 & 255, e[2] >> 16 & 255, e[2] >> 8 & 255, e[2] & 255, e[3] >> 24 & 255, e[3] >> 16 & 255, e[3] >> 8 & 255, e[3] & 255, e[4] >> 24 & 255, e[4] >> 16 & 255, e[4] >> 8 & 255, e[4] & 255];
}
const Ta = za("v5", 80, Ka), Nu = Ta;
var Bl = { exports: {} }, El = { exports: {} };
(function() {
  var s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = {
    // Bit-wise rotation left
    rotl: function(e, i) {
      return e << i | e >>> 32 - i;
    },
    // Bit-wise rotation right
    rotr: function(e, i) {
      return e << 32 - i | e >>> i;
    },
    // Swap big-endian to little-endian and vice versa
    endian: function(e) {
      if (e.constructor == Number)
        return t.rotl(e, 8) & 16711935 | t.rotl(e, 24) & 4278255360;
      for (var i = 0; i < e.length; i++)
        e[i] = t.endian(e[i]);
      return e;
    },
    // Generate an array of any length of random bytes
    randomBytes: function(e) {
      for (var i = []; e > 0; e--)
        i.push(Math.floor(Math.random() * 256));
      return i;
    },
    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(e) {
      for (var i = [], n = 0, o = 0; n < e.length; n++, o += 8)
        i[o >>> 5] |= e[n] << 24 - o % 32;
      return i;
    },
    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(e) {
      for (var i = [], n = 0; n < e.length * 32; n += 8)
        i.push(e[n >>> 5] >>> 24 - n % 32 & 255);
      return i;
    },
    // Convert a byte array to a hex string
    bytesToHex: function(e) {
      for (var i = [], n = 0; n < e.length; n++)
        i.push((e[n] >>> 4).toString(16)), i.push((e[n] & 15).toString(16));
      return i.join("");
    },
    // Convert a hex string to a byte array
    hexToBytes: function(e) {
      for (var i = [], n = 0; n < e.length; n += 2)
        i.push(parseInt(e.substr(n, 2), 16));
      return i;
    },
    // Convert a byte array to a base-64 string
    bytesToBase64: function(e) {
      for (var i = [], n = 0; n < e.length; n += 3)
        for (var o = e[n] << 16 | e[n + 1] << 8 | e[n + 2], r = 0; r < 4; r++)
          n * 8 + r * 6 <= e.length * 8 ? i.push(s.charAt(o >>> 6 * (3 - r) & 63)) : i.push("=");
      return i.join("");
    },
    // Convert a base-64 string to a byte array
    base64ToBytes: function(e) {
      e = e.replace(/[^A-Z0-9+\/]/ig, "");
      for (var i = [], n = 0, o = 0; n < e.length; o = ++n % 4)
        o != 0 && i.push((s.indexOf(e.charAt(n - 1)) & Math.pow(2, -2 * o + 8) - 1) << o * 2 | s.indexOf(e.charAt(n)) >>> 6 - o * 2);
      return i;
    }
  };
  El.exports = t;
})();
var Ma = El.exports, lo = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(s) {
      return lo.bin.stringToBytes(unescape(encodeURIComponent(s)));
    },
    // Convert a byte array to a string
    bytesToString: function(s) {
      return decodeURIComponent(escape(lo.bin.bytesToString(s)));
    }
  },
  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(s) {
      for (var t = [], e = 0; e < s.length; e++)
        t.push(s.charCodeAt(e) & 255);
      return t;
    },
    // Convert a byte array to a string
    bytesToString: function(s) {
      for (var t = [], e = 0; e < s.length; e++)
        t.push(String.fromCharCode(s[e]));
      return t.join("");
    }
  }
}, pr = lo;
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var Ya = function(s) {
  return s != null && (jl(s) || ka(s) || !!s._isBuffer);
};
function jl(s) {
  return !!s.constructor && typeof s.constructor.isBuffer == "function" && s.constructor.isBuffer(s);
}
function ka(s) {
  return typeof s.readFloatLE == "function" && typeof s.slice == "function" && jl(s.slice(0, 0));
}
(function() {
  var s = Ma, t = pr.utf8, e = Ya, i = pr.bin, n = function(o, r) {
    o.constructor == String ? r && r.encoding === "binary" ? o = i.stringToBytes(o) : o = t.stringToBytes(o) : e(o) ? o = Array.prototype.slice.call(o, 0) : !Array.isArray(o) && o.constructor !== Uint8Array && (o = o.toString());
    for (var c = s.bytesToWords(o), l = o.length * 8, a = 1732584193, d = -271733879, h = -1732584194, u = 271733878, p = 0; p < c.length; p++)
      c[p] = (c[p] << 8 | c[p] >>> 24) & 16711935 | (c[p] << 24 | c[p] >>> 8) & 4278255360;
    c[l >>> 5] |= 128 << l % 32, c[(l + 64 >>> 9 << 4) + 14] = l;
    for (var m = n._ff, b = n._gg, G = n._hh, y = n._ii, p = 0; p < c.length; p += 16) {
      var Z = a, f = d, V = h, X = u;
      a = m(a, d, h, u, c[p + 0], 7, -680876936), u = m(u, a, d, h, c[p + 1], 12, -389564586), h = m(h, u, a, d, c[p + 2], 17, 606105819), d = m(d, h, u, a, c[p + 3], 22, -1044525330), a = m(a, d, h, u, c[p + 4], 7, -176418897), u = m(u, a, d, h, c[p + 5], 12, 1200080426), h = m(h, u, a, d, c[p + 6], 17, -1473231341), d = m(d, h, u, a, c[p + 7], 22, -45705983), a = m(a, d, h, u, c[p + 8], 7, 1770035416), u = m(u, a, d, h, c[p + 9], 12, -1958414417), h = m(h, u, a, d, c[p + 10], 17, -42063), d = m(d, h, u, a, c[p + 11], 22, -1990404162), a = m(a, d, h, u, c[p + 12], 7, 1804603682), u = m(u, a, d, h, c[p + 13], 12, -40341101), h = m(h, u, a, d, c[p + 14], 17, -1502002290), d = m(d, h, u, a, c[p + 15], 22, 1236535329), a = b(a, d, h, u, c[p + 1], 5, -165796510), u = b(u, a, d, h, c[p + 6], 9, -1069501632), h = b(h, u, a, d, c[p + 11], 14, 643717713), d = b(d, h, u, a, c[p + 0], 20, -373897302), a = b(a, d, h, u, c[p + 5], 5, -701558691), u = b(u, a, d, h, c[p + 10], 9, 38016083), h = b(h, u, a, d, c[p + 15], 14, -660478335), d = b(d, h, u, a, c[p + 4], 20, -405537848), a = b(a, d, h, u, c[p + 9], 5, 568446438), u = b(u, a, d, h, c[p + 14], 9, -1019803690), h = b(h, u, a, d, c[p + 3], 14, -187363961), d = b(d, h, u, a, c[p + 8], 20, 1163531501), a = b(a, d, h, u, c[p + 13], 5, -1444681467), u = b(u, a, d, h, c[p + 2], 9, -51403784), h = b(h, u, a, d, c[p + 7], 14, 1735328473), d = b(d, h, u, a, c[p + 12], 20, -1926607734), a = G(a, d, h, u, c[p + 5], 4, -378558), u = G(u, a, d, h, c[p + 8], 11, -2022574463), h = G(h, u, a, d, c[p + 11], 16, 1839030562), d = G(d, h, u, a, c[p + 14], 23, -35309556), a = G(a, d, h, u, c[p + 1], 4, -1530992060), u = G(u, a, d, h, c[p + 4], 11, 1272893353), h = G(h, u, a, d, c[p + 7], 16, -155497632), d = G(d, h, u, a, c[p + 10], 23, -1094730640), a = G(a, d, h, u, c[p + 13], 4, 681279174), u = G(u, a, d, h, c[p + 0], 11, -358537222), h = G(h, u, a, d, c[p + 3], 16, -722521979), d = G(d, h, u, a, c[p + 6], 23, 76029189), a = G(a, d, h, u, c[p + 9], 4, -640364487), u = G(u, a, d, h, c[p + 12], 11, -421815835), h = G(h, u, a, d, c[p + 15], 16, 530742520), d = G(d, h, u, a, c[p + 2], 23, -995338651), a = y(a, d, h, u, c[p + 0], 6, -198630844), u = y(u, a, d, h, c[p + 7], 10, 1126891415), h = y(h, u, a, d, c[p + 14], 15, -1416354905), d = y(d, h, u, a, c[p + 5], 21, -57434055), a = y(a, d, h, u, c[p + 12], 6, 1700485571), u = y(u, a, d, h, c[p + 3], 10, -1894986606), h = y(h, u, a, d, c[p + 10], 15, -1051523), d = y(d, h, u, a, c[p + 1], 21, -2054922799), a = y(a, d, h, u, c[p + 8], 6, 1873313359), u = y(u, a, d, h, c[p + 15], 10, -30611744), h = y(h, u, a, d, c[p + 6], 15, -1560198380), d = y(d, h, u, a, c[p + 13], 21, 1309151649), a = y(a, d, h, u, c[p + 4], 6, -145523070), u = y(u, a, d, h, c[p + 11], 10, -1120210379), h = y(h, u, a, d, c[p + 2], 15, 718787259), d = y(d, h, u, a, c[p + 9], 21, -343485551), a = a + Z >>> 0, d = d + f >>> 0, h = h + V >>> 0, u = u + X >>> 0;
    }
    return s.endian([a, d, h, u]);
  };
  n._ff = function(o, r, c, l, a, d, h) {
    var u = o + (r & c | ~r & l) + (a >>> 0) + h;
    return (u << d | u >>> 32 - d) + r;
  }, n._gg = function(o, r, c, l, a, d, h) {
    var u = o + (r & l | c & ~l) + (a >>> 0) + h;
    return (u << d | u >>> 32 - d) + r;
  }, n._hh = function(o, r, c, l, a, d, h) {
    var u = o + (r ^ c ^ l) + (a >>> 0) + h;
    return (u << d | u >>> 32 - d) + r;
  }, n._ii = function(o, r, c, l, a, d, h) {
    var u = o + (c ^ (r | ~l)) + (a >>> 0) + h;
    return (u << d | u >>> 32 - d) + r;
  }, n._blocksize = 16, n._digestsize = 16, Bl.exports = function(o, r) {
    if (o == null)
      throw new Error("Illegal argument " + o);
    var c = s.wordsToBytes(n(o, r));
    return r && r.asBytes ? c : r && r.asString ? i.bytesToString(c) : s.bytesToHex(c);
  };
})();
var Ha = Bl.exports;
const Iu = /* @__PURE__ */ bn(Ha), yt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let mr = 1234567;
const Ol = Math.PI / 180, _l = 180 / Math.PI;
function Na() {
  const s = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (yt[s & 255] + yt[s >> 8 & 255] + yt[s >> 16 & 255] + yt[s >> 24 & 255] + "-" + yt[t & 255] + yt[t >> 8 & 255] + "-" + yt[t >> 16 & 15 | 64] + yt[t >> 24 & 255] + "-" + yt[e & 63 | 128] + yt[e >> 8 & 255] + "-" + yt[e >> 16 & 255] + yt[e >> 24 & 255] + yt[i & 255] + yt[i >> 8 & 255] + yt[i >> 16 & 255] + yt[i >> 24 & 255]).toLowerCase();
}
function _t(s, t, e) {
  return Math.max(t, Math.min(e, s));
}
function Dl(s, t) {
  return (s % t + t) % t;
}
function Ia(s, t, e, i, n) {
  return i + (s - t) * (n - i) / (e - t);
}
function Ja(s, t, e) {
  return s !== t ? (e - s) / (t - s) : 0;
}
function Al(s, t, e) {
  return (1 - e) * s + e * t;
}
function Ua(s, t, e, i) {
  return Al(s, t, 1 - Math.exp(-e * i));
}
function Pa(s, t = 1) {
  return t - Math.abs(Dl(s, t * 2) - t);
}
function Fa(s, t, e) {
  return s <= t ? 0 : s >= e ? 1 : (s = (s - t) / (e - t), s * s * (3 - 2 * s));
}
function Qa(s, t, e) {
  return s <= t ? 0 : s >= e ? 1 : (s = (s - t) / (e - t), s * s * s * (s * (s * 6 - 15) + 10));
}
function wa(s, t) {
  return s + Math.floor(Math.random() * (t - s + 1));
}
function Ba(s, t) {
  return s + Math.random() * (t - s);
}
function Ea(s) {
  return s * (0.5 - Math.random());
}
function ja(s) {
  s !== void 0 && (mr = s);
  let t = mr += 1831565813;
  return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function Oa(s) {
  return s * Ol;
}
function _a(s) {
  return s * _l;
}
function Da(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function Aa(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function qa(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function $a(s, t, e, i, n) {
  const o = Math.cos, r = Math.sin, c = o(e / 2), l = r(e / 2), a = o((t + i) / 2), d = r((t + i) / 2), h = o((t - i) / 2), u = r((t - i) / 2), p = o((i - t) / 2), m = r((i - t) / 2);
  switch (n) {
    case "XYX":
      s.set(c * d, l * h, l * u, c * a);
      break;
    case "YZY":
      s.set(l * u, c * d, l * h, c * a);
      break;
    case "ZXZ":
      s.set(l * h, l * u, c * d, c * a);
      break;
    case "XZX":
      s.set(c * d, l * m, l * p, c * a);
      break;
    case "YXY":
      s.set(l * p, c * d, l * m, c * a);
      break;
    case "ZYZ":
      s.set(l * m, l * p, c * d, c * a);
      break;
    default:
      console.warn("../math.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
  }
}
function td(s, t) {
  switch (t.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ed(s, t) {
  switch (t.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const hi = {
  DEG2RAD: Ol,
  RAD2DEG: _l,
  generateUUID: Na,
  clamp: _t,
  euclideanModulo: Dl,
  mapLinear: Ia,
  inverseLerp: Ja,
  lerp: Al,
  damp: Ua,
  pingpong: Pa,
  smoothstep: Fa,
  smootherstep: Qa,
  randInt: wa,
  randFloat: Ba,
  randFloatSpread: Ea,
  seededRandom: ja,
  degToRad: Oa,
  radToDeg: _a,
  isPowerOfTwo: Da,
  ceilPowerOfTwo: Aa,
  floorPowerOfTwo: qa,
  setQuaternionFromProperEuler: $a,
  normalize: ed,
  denormalize: td
};
class w {
  constructor(t = 0, e = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = i, this._w = n;
  }
  static slerpFlat(t, e, i, n, o, r, c) {
    let l = i[n + 0], a = i[n + 1], d = i[n + 2], h = i[n + 3];
    const u = o[r + 0], p = o[r + 1], m = o[r + 2], b = o[r + 3];
    if (c === 0) {
      t[e + 0] = l, t[e + 1] = a, t[e + 2] = d, t[e + 3] = h;
      return;
    }
    if (c === 1) {
      t[e + 0] = u, t[e + 1] = p, t[e + 2] = m, t[e + 3] = b;
      return;
    }
    if (h !== b || l !== u || a !== p || d !== m) {
      let G = 1 - c;
      const y = l * u + a * p + d * m + h * b, Z = y >= 0 ? 1 : -1, f = 1 - y * y;
      if (f > Number.EPSILON) {
        const X = Math.sqrt(f), R = Math.atan2(X, y * Z);
        G = Math.sin(G * R) / X, c = Math.sin(c * R) / X;
      }
      const V = c * Z;
      if (l = l * G + u * V, a = a * G + p * V, d = d * G + m * V, h = h * G + b * V, G === 1 - c) {
        const X = 1 / Math.sqrt(l * l + a * a + d * d + h * h);
        l *= X, a *= X, d *= X, h *= X;
      }
    }
    t[e] = l, t[e + 1] = a, t[e + 2] = d, t[e + 3] = h;
  }
  static multiplyQuaternionsFlat(t, e, i, n, o, r) {
    const c = i[n], l = i[n + 1], a = i[n + 2], d = i[n + 3], h = o[r], u = o[r + 1], p = o[r + 2], m = o[r + 3];
    return t[e] = c * m + d * h + l * p - a * u, t[e + 1] = l * m + d * u + a * h - c * p, t[e + 2] = a * m + d * p + c * u - l * h, t[e + 3] = d * m - c * h - l * u - a * p, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, i, n) {
    return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new w(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e = !0) {
    const i = t._x, n = t._y, o = t._z, r = t._order, c = Math.cos, l = Math.sin, a = c(i / 2), d = c(n / 2), h = c(o / 2), u = l(i / 2), p = l(n / 2), m = l(o / 2);
    switch (r) {
      case "XYZ":
        this._x = u * d * h + a * p * m, this._y = a * p * h - u * d * m, this._z = a * d * m + u * p * h, this._w = a * d * h - u * p * m;
        break;
      case "YXZ":
        this._x = u * d * h + a * p * m, this._y = a * p * h - u * d * m, this._z = a * d * m - u * p * h, this._w = a * d * h + u * p * m;
        break;
      case "ZXY":
        this._x = u * d * h - a * p * m, this._y = a * p * h + u * d * m, this._z = a * d * m + u * p * h, this._w = a * d * h - u * p * m;
        break;
      case "ZYX":
        this._x = u * d * h - a * p * m, this._y = a * p * h + u * d * m, this._z = a * d * m - u * p * h, this._w = a * d * h + u * p * m;
        break;
      case "YZX":
        this._x = u * d * h + a * p * m, this._y = a * p * h + u * d * m, this._z = a * d * m - u * p * h, this._w = a * d * h - u * p * m;
        break;
      case "XZY":
        this._x = u * d * h - a * p * m, this._y = a * p * h - u * d * m, this._z = a * d * m + u * p * h, this._w = a * d * h + u * p * m;
        break;
      default:
        console.warn("../math.Quaternion: .setFromEuler() encountered an unknown order: " + r);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const i = e / 2, n = Math.sin(i);
    return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const e = t.elements, i = e[0], n = e[4], o = e[8], r = e[1], c = e[5], l = e[9], a = e[2], d = e[6], h = e[10], u = i + c + h;
    if (u > 0) {
      const p = 0.5 / Math.sqrt(u + 1);
      this._w = 0.25 / p, this._x = (d - l) * p, this._y = (o - a) * p, this._z = (r - n) * p;
    } else if (i > c && i > h) {
      const p = 2 * Math.sqrt(1 + i - c - h);
      this._w = (d - l) / p, this._x = 0.25 * p, this._y = (n + r) / p, this._z = (o + a) / p;
    } else if (c > h) {
      const p = 2 * Math.sqrt(1 + c - i - h);
      this._w = (o - a) / p, this._x = (n + r) / p, this._y = 0.25 * p, this._z = (l + d) / p;
    } else {
      const p = 2 * Math.sqrt(1 + h - i - c);
      this._w = (r - n) / p, this._x = (o + a) / p, this._y = (l + d) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let i = t.dot(e) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(_t(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const i = this.angleTo(t);
    if (i === 0)
      return this;
    const n = Math.min(1, e / i);
    return this.slerp(t, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const i = t._x, n = t._y, o = t._z, r = t._w, c = e._x, l = e._y, a = e._z, d = e._w;
    return this._x = i * d + r * c + n * a - o * l, this._y = n * d + r * l + o * c - i * a, this._z = o * d + r * a + i * l - n * c, this._w = r * d - i * c - n * l - o * a, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(t);
    const i = this._x, n = this._y, o = this._z, r = this._w;
    let c = r * t._w + i * t._x + n * t._y + o * t._z;
    if (c < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, c = -c) : this.copy(t), c >= 1)
      return this._w = r, this._x = i, this._y = n, this._z = o, this;
    const l = 1 - c * c;
    if (l <= Number.EPSILON) {
      const p = 1 - e;
      return this._w = p * r + e * this._w, this._x = p * i + e * this._x, this._y = p * n + e * this._y, this._z = p * o + e * this._z, this.normalize(), this;
    }
    const a = Math.sqrt(l), d = Math.atan2(a, c), h = Math.sin((1 - e) * d) / a, u = Math.sin(e * d) / a;
    return this._w = r * h + this._w * u, this._x = i * h + this._x * u, this._y = n * h + this._y * u, this._z = o * h + this._z * u, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, i) {
    return this.copy(t).slerp(e, i);
  }
  random() {
    const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), o = Math.sqrt(i);
    return this.set(n * Math.sin(t), n * Math.cos(t), o * Math.sin(e), o * Math.cos(e));
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Y {
  constructor(t = 0, e = 0, i = 0) {
    this.isVector3 = !0, Y.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = i;
  }
  set(t, e, i) {
    return i === void 0 && (i = this.z), this.x = t, this.y = e, this.z = i, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new Y(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(br.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(br.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x, i = this.y, n = this.z, o = t.elements;
    return this.x = o[0] * e + o[3] * i + o[6] * n, this.y = o[1] * e + o[4] * i + o[7] * n, this.z = o[2] * e + o[5] * i + o[8] * n, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x, i = this.y, n = this.z, o = t.elements, r = 1 / (o[3] * e + o[7] * i + o[11] * n + o[15]);
    return this.x = (o[0] * e + o[4] * i + o[8] * n + o[12]) * r, this.y = (o[1] * e + o[5] * i + o[9] * n + o[13]) * r, this.z = (o[2] * e + o[6] * i + o[10] * n + o[14]) * r, this;
  }
  applyQuaternion(t) {
    const e = this.x, i = this.y, n = this.z, o = t.x, r = t.y, c = t.z, l = t.w, a = 2 * (r * n - c * i), d = 2 * (c * e - o * n), h = 2 * (o * i - r * e);
    return this.x = e + l * a + r * h - c * d, this.y = i + l * d + c * a - o * h, this.z = n + l * h + o * d - r * a, this;
  }
  transformDirection(t) {
    const e = this.x, i = this.y, n = this.z, o = t.elements;
    return this.x = o[0] * e + o[4] * i + o[8] * n, this.y = o[1] * e + o[5] * i + o[9] * n, this.z = o[2] * e + o[6] * i + o[10] * n, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const i = t.x, n = t.y, o = t.z, r = e.x, c = e.y, l = e.z;
    return this.x = n * l - o * c, this.y = o * r - i * l, this.z = i * c - n * r, this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const i = t.dot(this) / e;
    return this.copy(t).multiplyScalar(i);
  }
  projectOnPlane(t) {
    return Wn.copy(this).projectOnVector(t), this.sub(Wn);
  }
  reflect(t) {
    return this.sub(Wn.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(_t(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, i = this.y - t.y, n = this.z - t.z;
    return e * e + i * i + n * n;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSphericalCoords(t, e, i) {
    const n = Math.sin(e) * t;
    return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
  }
  setFromCylindricalCoords(t, e, i) {
    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), n = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = i, this.z = n, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, i = Math.sqrt(1 - e * e);
    return this.x = i * Math.cos(t), this.y = e, this.z = i * Math.sin(t), this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this.z = Math.abs(this.z), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Wn = new Y(), br = new w(), Ws = 2e3, yr = 2001;
class $t {
  constructor(t, e, i, n, o, r, c, l, a, d, h, u, p, m, b, G) {
    this.isMatrix4 = !0, $t.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], t !== void 0 && this.set(t, e, i, n, o, r, c, l, a, d, h, u, p, m, b, G);
  }
  extractPosition(t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
  }
  multiplyToArray(t, e, i) {
    return console.error("THREE.Matrix4: .multiplyToArray() has been removed."), this;
  }
  setRotationFromQuaternion(t) {
    return this.makeRotationFromQuaternion(t);
  }
  set(t, e, i, n, o, r, c, l, a, d, h, u, p, m, b, G) {
    const y = this.elements;
    return y[0] = t, y[4] = e, y[8] = i, y[12] = n, y[1] = o, y[5] = r, y[9] = c, y[13] = l, y[2] = a, y[6] = d, y[10] = h, y[14] = u, y[3] = p, y[7] = m, y[11] = b, y[15] = G, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new $t().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements, i = t.elements;
    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this;
  }
  copyPosition(t) {
    const e = this.elements, i = t.elements;
    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(t, e, i) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, e, i) {
    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(t) {
    const e = this.elements, i = t.elements, n = 1 / je.setFromMatrixColumn(t, 0).length(), o = 1 / je.setFromMatrixColumn(t, 1).length(), r = 1 / je.setFromMatrixColumn(t, 2).length();
    return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * o, e[5] = i[5] * o, e[6] = i[6] * o, e[7] = 0, e[8] = i[8] * r, e[9] = i[9] * r, e[10] = i[10] * r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    const e = this.elements, i = t.x, n = t.y, o = t.z, r = Math.cos(i), c = Math.sin(i), l = Math.cos(n), a = Math.sin(n), d = Math.cos(o), h = Math.sin(o);
    if (t.order === "XYZ") {
      const u = r * d, p = r * h, m = c * d, b = c * h;
      e[0] = l * d, e[4] = -l * h, e[8] = a, e[1] = p + m * a, e[5] = u - b * a, e[9] = -c * l, e[2] = b - u * a, e[6] = m + p * a, e[10] = r * l;
    } else if (t.order === "YXZ") {
      const u = l * d, p = l * h, m = a * d, b = a * h;
      e[0] = u + b * c, e[4] = m * c - p, e[8] = r * a, e[1] = r * h, e[5] = r * d, e[9] = -c, e[2] = p * c - m, e[6] = b + u * c, e[10] = r * l;
    } else if (t.order === "ZXY") {
      const u = l * d, p = l * h, m = a * d, b = a * h;
      e[0] = u - b * c, e[4] = -r * h, e[8] = m + p * c, e[1] = p + m * c, e[5] = r * d, e[9] = b - u * c, e[2] = -r * a, e[6] = c, e[10] = r * l;
    } else if (t.order === "ZYX") {
      const u = r * d, p = r * h, m = c * d, b = c * h;
      e[0] = l * d, e[4] = m * a - p, e[8] = u * a + b, e[1] = l * h, e[5] = b * a + u, e[9] = p * a - m, e[2] = -a, e[6] = c * l, e[10] = r * l;
    } else if (t.order === "YZX") {
      const u = r * l, p = r * a, m = c * l, b = c * a;
      e[0] = l * d, e[4] = b - u * h, e[8] = m * h + p, e[1] = h, e[5] = r * d, e[9] = -c * d, e[2] = -a * d, e[6] = p * h + m, e[10] = u - b * h;
    } else if (t.order === "XZY") {
      const u = r * l, p = r * a, m = c * l, b = c * a;
      e[0] = l * d, e[4] = -h, e[8] = a * d, e[1] = u * h + b, e[5] = r * d, e[9] = p * h - m, e[2] = m * h - p, e[6] = c * d, e[10] = b * h + u;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(id, t, sd);
  }
  lookAt(t, e, i) {
    const n = this.elements;
    return zt.subVectors(t, e), zt.lengthSq() === 0 && (zt.z = 1), zt.normalize(), be.crossVectors(i, zt), be.lengthSq() === 0 && (Math.abs(i.z) === 1 ? zt.x += 1e-4 : zt.z += 1e-4, zt.normalize(), be.crossVectors(i, zt)), be.normalize(), Cs.crossVectors(zt, be), n[0] = be.x, n[4] = Cs.x, n[8] = zt.x, n[1] = be.y, n[5] = Cs.y, n[9] = zt.y, n[2] = be.z, n[6] = Cs.z, n[10] = zt.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const i = t.elements, n = e.elements, o = this.elements, r = i[0], c = i[4], l = i[8], a = i[12], d = i[1], h = i[5], u = i[9], p = i[13], m = i[2], b = i[6], G = i[10], y = i[14], Z = i[3], f = i[7], V = i[11], X = i[15], R = n[0], x = n[4], S = n[8], C = n[12], L = n[1], g = n[5], W = n[9], z = n[13], v = n[2], k = n[6], N = n[10], J = n[14], P = n[3], D = n[7], st = n[11], et = n[15];
    return o[0] = r * R + c * L + l * v + a * P, o[4] = r * x + c * g + l * k + a * D, o[8] = r * S + c * W + l * N + a * st, o[12] = r * C + c * z + l * J + a * et, o[1] = d * R + h * L + u * v + p * P, o[5] = d * x + h * g + u * k + p * D, o[9] = d * S + h * W + u * N + p * st, o[13] = d * C + h * z + u * J + p * et, o[2] = m * R + b * L + G * v + y * P, o[6] = m * x + b * g + G * k + y * D, o[10] = m * S + b * W + G * N + y * st, o[14] = m * C + b * z + G * J + y * et, o[3] = Z * R + f * L + V * v + X * P, o[7] = Z * x + f * g + V * k + X * D, o[11] = Z * S + f * W + V * N + X * st, o[15] = Z * C + f * z + V * J + X * et, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], i = t[4], n = t[8], o = t[12], r = t[1], c = t[5], l = t[9], a = t[13], d = t[2], h = t[6], u = t[10], p = t[14], m = t[3], b = t[7], G = t[11], y = t[15];
    return m * (+o * l * h - n * a * h - o * c * u + i * a * u + n * c * p - i * l * p) + b * (+e * l * p - e * a * u + o * r * u - n * r * p + n * a * d - o * l * d) + G * (+e * a * h - e * c * p - o * r * h + i * r * p + o * c * d - i * a * d) + y * (-n * c * d - e * l * h + e * c * u + n * r * h - i * r * u + i * l * d);
  }
  transpose() {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  setPosition(t, e, i) {
    const n = this.elements;
    return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this;
  }
  invert() {
    const t = this.elements, e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], c = t[5], l = t[6], a = t[7], d = t[8], h = t[9], u = t[10], p = t[11], m = t[12], b = t[13], G = t[14], y = t[15], Z = h * G * a - b * u * a + b * l * p - c * G * p - h * l * y + c * u * y, f = m * u * a - d * G * a - m * l * p + r * G * p + d * l * y - r * u * y, V = d * b * a - m * h * a + m * c * p - r * b * p - d * c * y + r * h * y, X = m * h * l - d * b * l - m * c * u + r * b * u + d * c * G - r * h * G, R = e * Z + i * f + n * V + o * X;
    if (R === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / R;
    return t[0] = Z * x, t[1] = (b * u * o - h * G * o - b * n * p + i * G * p + h * n * y - i * u * y) * x, t[2] = (c * G * o - b * l * o + b * n * a - i * G * a - c * n * y + i * l * y) * x, t[3] = (h * l * o - c * u * o - h * n * a + i * u * a + c * n * p - i * l * p) * x, t[4] = f * x, t[5] = (d * G * o - m * u * o + m * n * p - e * G * p - d * n * y + e * u * y) * x, t[6] = (m * l * o - r * G * o - m * n * a + e * G * a + r * n * y - e * l * y) * x, t[7] = (r * u * o - d * l * o + d * n * a - e * u * a - r * n * p + e * l * p) * x, t[8] = V * x, t[9] = (m * h * o - d * b * o - m * i * p + e * b * p + d * i * y - e * h * y) * x, t[10] = (r * b * o - m * c * o + m * i * a - e * b * a - r * i * y + e * c * y) * x, t[11] = (d * c * o - r * h * o - d * i * a + e * h * a + r * i * p - e * c * p) * x, t[12] = X * x, t[13] = (d * b * n - m * h * n + m * i * u - e * b * u - d * i * G + e * h * G) * x, t[14] = (m * c * n - r * b * n - m * i * l + e * b * l + r * i * G - e * c * G) * x, t[15] = (r * h * n - d * c * n + d * i * l - e * h * l - r * i * u + e * c * u) * x, this;
  }
  scale(t) {
    const e = this.elements, i = t.x, n = t.y, o = t.z;
    return e[0] *= i, e[4] *= n, e[8] *= o, e[1] *= i, e[5] *= n, e[9] *= o, e[2] *= i, e[6] *= n, e[10] *= o, e[3] *= i, e[7] *= n, e[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, i, n));
  }
  makeTranslation(t, e, i) {
    return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    const i = Math.cos(e), n = Math.sin(e), o = 1 - i, r = t.x, c = t.y, l = t.z, a = o * r, d = o * c;
    return this.set(a * r + i, a * c - n * l, a * l + n * c, 0, a * c + n * l, d * c + i, d * l - n * r, 0, a * l - n * c, d * l + n * r, o * l * l + i, 0, 0, 0, 0, 1), this;
  }
  makeScale(t, e, i) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, i, n, o, r) {
    return this.set(1, i, o, 0, t, 1, r, 0, e, n, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, i) {
    const n = this.elements, o = e._x, r = e._y, c = e._z, l = e._w, a = o + o, d = r + r, h = c + c, u = o * a, p = o * d, m = o * h, b = r * d, G = r * h, y = c * h, Z = l * a, f = l * d, V = l * h, X = i.x, R = i.y, x = i.z;
    return n[0] = (1 - (b + y)) * X, n[1] = (p + V) * X, n[2] = (m - f) * X, n[3] = 0, n[4] = (p - V) * R, n[5] = (1 - (u + y)) * R, n[6] = (G + Z) * R, n[7] = 0, n[8] = (m + f) * x, n[9] = (G - Z) * x, n[10] = (1 - (u + b)) * x, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this;
  }
  decompose(t, e, i) {
    const n = this.elements;
    let o = je.set(n[0], n[1], n[2]).length();
    const r = je.set(n[4], n[5], n[6]).length(), c = je.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (o = -o), t.x = n[12], t.y = n[13], t.z = n[14], Pt.copy(this);
    const a = 1 / o, d = 1 / r, h = 1 / c;
    return Pt.elements[0] *= a, Pt.elements[1] *= a, Pt.elements[2] *= a, Pt.elements[4] *= d, Pt.elements[5] *= d, Pt.elements[6] *= d, Pt.elements[8] *= h, Pt.elements[9] *= h, Pt.elements[10] *= h, e.setFromRotationMatrix(Pt), i.x = o, i.y = r, i.z = c, this;
  }
  makePerspective(t, e, i, n, o, r, c = Ws) {
    const l = this.elements, a = 2 * o / (e - t), d = 2 * o / (i - n), h = (e + t) / (e - t), u = (i + n) / (i - n);
    let p, m;
    if (c === Ws)
      p = -(r + o) / (r - o), m = -2 * r * o / (r - o);
    else if (c === yr)
      p = -r / (r - o), m = -r * o / (r - o);
    else
      throw new Error("Matrix4.makePerspective(): Invalid coordinate system: " + c);
    return l[0] = a, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = d, l[9] = u, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(t, e, i, n, o, r, c = Ws) {
    const l = this.elements, a = 1 / (e - t), d = 1 / (i - n), h = 1 / (r - o), u = (e + t) * a, p = (i + n) * d;
    let m, b;
    if (c === Ws)
      m = (r + o) * h, b = -2 * h;
    else if (c === yr)
      m = o * h, b = -1 * h;
    else
      throw new Error("../math.Matrix4.makeOrthographic(): Invalid coordinate system: " + c);
    return l[0] = 2 * a, l[4] = 0, l[8] = 0, l[12] = -u, l[1] = 0, l[5] = 2 * d, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = b, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(t) {
    const e = this.elements, i = t.elements;
    for (let n = 0; n < 16; n++)
      if (e[n] !== i[n])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = t[i + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const i = this.elements;
    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
  }
}
const je = new Y(), Pt = new $t(), id = new Y(0, 0, 0), sd = new Y(1, 1, 1), be = new Y(), Cs = new Y(), zt = new Y(), Gr = new $t(), Zr = new w();
class Fi {
  constructor(t = 0, e = 0, i = 0, n = Fi.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = t, this._y = e, this._z = i, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, e, i, n = this._order) {
    return this._x = t, this._y = e, this._z = i, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new Fi(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, e = this._order, i = !0) {
    const n = t.elements, o = n[0], r = n[4], c = n[8], l = n[1], a = n[5], d = n[9], h = n[2], u = n[6], p = n[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(_t(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-d, p), this._z = Math.atan2(-r, o)) : (this._x = Math.atan2(u, a), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-_t(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(c, p), this._z = Math.atan2(l, a)) : (this._y = Math.atan2(-h, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(_t(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-r, a)) : (this._y = 0, this._z = Math.atan2(l, o));
        break;
      case "ZYX":
        this._y = Math.asin(-_t(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(u, p), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-r, a));
        break;
      case "YZX":
        this._z = Math.asin(_t(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-d, a), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(c, p));
        break;
      case "XZY":
        this._z = Math.asin(-_t(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math.atan2(u, a), this._y = Math.atan2(c, o)) : (this._x = Math.atan2(-d, p), this._y = 0);
        break;
      default:
        console.warn("../math.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, i) {
    return Gr.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Gr, e, i);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return Zr.setFromEuler(this), this.setFromQuaternion(Zr, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback(t) {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Fi.DEFAULT_ORDER = "XYZ";
class ri {
  constructor(t = 0, e = 0) {
    this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new ri(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x, i = this.y, n = t.elements;
    return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(_t(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, i = this.y - t.y;
    return e * e + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  rotateAround(t, e) {
    const i = Math.cos(e), n = Math.sin(e), o = this.x - t.x, r = this.y - t.y;
    return this.x = o * i - r * n + t.x, this.y = o * n + r * i + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
ri.isVector2 = !0;
class Tt {
  constructor(t = 0, e = 0, i = 0, n = 1) {
    Tt.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = i, this.w = n;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, i, n) {
    return this.x = t, this.y = e, this.z = i, this.w = n, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new Tt(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    const e = this.x, i = this.y, n = this.z, o = this.w, r = t.elements;
    return this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * o, this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * o, this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * o, this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * o, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, i, n, o;
    const l = t.elements, a = l[0], d = l[4], h = l[8], u = l[1], p = l[5], m = l[9], b = l[2], G = l[6], y = l[10];
    if (Math.abs(d - u) < 0.01 && Math.abs(h - b) < 0.01 && Math.abs(m - G) < 0.01) {
      if (Math.abs(d + u) < 0.1 && Math.abs(h + b) < 0.1 && Math.abs(m + G) < 0.1 && Math.abs(a + p + y - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const f = (a + 1) / 2, V = (p + 1) / 2, X = (y + 1) / 2, R = (d + u) / 4, x = (h + b) / 4, S = (m + G) / 4;
      return f > V && f > X ? f < 0.01 ? (i = 0, n = 0.707106781, o = 0.707106781) : (i = Math.sqrt(f), n = R / i, o = x / i) : V > X ? V < 0.01 ? (i = 0.707106781, n = 0, o = 0.707106781) : (n = Math.sqrt(V), i = R / n, o = S / n) : X < 0.01 ? (i = 0.707106781, n = 0.707106781, o = 0) : (o = Math.sqrt(X), i = x / o, n = S / o), this.set(i, n, o, e), this;
    }
    let Z = Math.sqrt((G - m) * (G - m) + (h - b) * (h - b) + (u - d) * (u - d));
    return Math.abs(Z) < 1e-3 && (Z = 1), this.x = (G - m) / Z, this.y = (h - b) / Z, this.z = (u - d) / Z, this.w = Math.acos((a + p + y - 1) / 2), this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class At {
  constructor(t, e, i, n, o, r, c, l, a) {
    At.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], t !== void 0 && this.set(t, e, i, n, o, r, c, l, a);
  }
  set(t, e, i, n, o, r, c, l, a) {
    const d = this.elements;
    return d[0] = t, d[1] = n, d[2] = c, d[3] = e, d[4] = o, d[5] = l, d[6] = i, d[7] = r, d[8] = a, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t) {
    const e = this.elements, i = t.elements;
    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this;
  }
  extractBasis(t, e, i) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const i = t.elements, n = e.elements, o = this.elements, r = i[0], c = i[3], l = i[6], a = i[1], d = i[4], h = i[7], u = i[2], p = i[5], m = i[8], b = n[0], G = n[3], y = n[6], Z = n[1], f = n[4], V = n[7], X = n[2], R = n[5], x = n[8];
    return o[0] = r * b + c * Z + l * X, o[3] = r * G + c * f + l * R, o[6] = r * y + c * V + l * x, o[1] = a * b + d * Z + h * X, o[4] = a * G + d * f + h * R, o[7] = a * y + d * V + h * x, o[2] = u * b + p * Z + m * X, o[5] = u * G + p * f + m * R, o[8] = u * y + p * V + m * x, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], c = t[5], l = t[6], a = t[7], d = t[8];
    return e * r * d - e * c * a - i * o * d + i * c * l + n * o * a - n * r * l;
  }
  invert() {
    const t = this.elements, e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], c = t[5], l = t[6], a = t[7], d = t[8], h = d * r - c * a, u = c * l - d * o, p = a * o - r * l, m = e * h + i * u + n * p;
    if (m === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const b = 1 / m;
    return t[0] = h * b, t[1] = (n * a - d * i) * b, t[2] = (c * i - n * r) * b, t[3] = u * b, t[4] = (d * e - n * l) * b, t[5] = (n * o - c * e) * b, t[6] = p * b, t[7] = (i * l - a * e) * b, t[8] = (r * e - i * o) * b, this;
  }
  transpose() {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  }
  setUvTransform(t, e, i, n, o, r, c) {
    const l = Math.cos(o), a = Math.sin(o);
    return this.set(i * l, i * a, -i * (l * r + a * c) + r + t, -n * a, n * l, -n * (-a * r + l * c) + c + e, 0, 0, 1), this;
  }
  scale(t, e) {
    return this.premultiply(Cn.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(Cn.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(Cn.makeTranslation(t, e)), this;
  }
  makeTranslation(t, e) {
    return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
  }
  makeRotation(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(e, -i, 0, i, e, 0, 0, 0, 1), this;
  }
  makeScale(t, e) {
    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
  }
  equals(t) {
    const e = this.elements, i = t.elements;
    for (let n = 0; n < 9; n++)
      if (e[n] !== i[n])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = t[i + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const i = this.elements;
    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
  }
  clone() {
    return new At().fromArray(this.elements);
  }
}
const Cn = new At();
var Rt;
(function(s) {
  s[s.Random = 0] = "Random", s[s.Loop = 1] = "Loop", s[s.PingPong = 2] = "PingPong", s[s.Burst = 3] = "Burst";
})(Rt || (Rt = {}));
function Vs(s, t, e, i) {
  let n;
  switch (Rt.Random === s ? t = Math.random() : Rt.Burst === s && i.isBursting && (t = i.burstParticleIndex / i.burstParticleCount), e > 0 ? n = Math.floor(t / e) * e : n = t, s) {
    case Rt.Loop:
      n = n % 1;
      break;
    case Rt.PingPong:
      n = Math.abs(n % 2 - 1);
      break;
  }
  return n;
}
class Fe {
  constructor(t, e, i, n) {
    this.p = [t, e, i, n];
  }
  genValue(t) {
    const e = t * t, i = t * t * t, n = 1 - t, o = n * n, r = o * n;
    return this.p[0] * r + this.p[1] * o * t * 3 + this.p[2] * n * e * 3 + this.p[3] * i;
  }
  derivativeCoefficients(t) {
    const e = [];
    for (let i = t, n = i.length - 1; n > 0; n--) {
      const o = [];
      for (let r = 0; r < n; r++) {
        const c = n * (i[r + 1] - i[r]);
        o.push(c);
      }
      e.push(o), i = o;
    }
    return e;
  }
  getSlope(t) {
    const e = this.derivativeCoefficients(this.p)[0], i = 1 - t, n = i * i, o = i * t * 2, r = t * t;
    return n * e[0] + o * e[1] + r * e[2];
  }
  controlCurve(t, e) {
    this.p[1] = t / 3 + this.p[0], this.p[2] = this.p[3] - e / 3;
  }
  hull(t) {
    let e = this.p, i = [], n, o = 0, r = 0, c = 0;
    const l = [];
    for (l[o++] = e[0], l[o++] = e[1], l[o++] = e[2], l[o++] = e[3]; e.length > 1; ) {
      for (i = [], r = 0, c = e.length - 1; r < c; r++)
        n = t * e[r] + (1 - t) * e[r + 1], l[o++] = n, i.push(n);
      e = i;
    }
    return l;
  }
  split(t) {
    const e = this.hull(t);
    return {
      left: new Fe(e[0], e[4], e[7], e[9]),
      right: new Fe(e[9], e[8], e[6], e[3]),
      span: e
    };
  }
  clone() {
    return new Fe(this.p[0], this.p[1], this.p[2], this.p[3]);
  }
  toJSON() {
    return {
      p0: this.p[0],
      p1: this.p[1],
      p2: this.p[2],
      p3: this.p[3]
    };
  }
  static fromJSON(t) {
    return new Fe(t.p0, t.p1, t.p2, t.p3);
  }
}
const Qi = (s) => ({ r: s.x, g: s.y, b: s.z, a: s.w }), wi = (s) => new Tt(s.r, s.g, s.b, s.a), nd = (s, t) => {
  switch (t) {
    case "Vector3":
      return new Y(s.x, s.y, s.z);
    case "Vector4":
      return new Tt(s.x, s.y, s.z, s.w);
    case "Color":
      return new Y(s.r, s.g, s.b);
    case "Number":
      return s;
    default:
      return s;
  }
}, od = (s, t) => {
  switch (t) {
    case "Vector3":
      return { x: s.x, y: s.y, z: s.z };
    case "Vector4":
      return { x: s.x, y: s.y, z: s.z, w: s.w };
    case "Color":
      return { r: s.x, g: s.y, b: s.z };
    case "Number":
      return s;
    default:
      return s;
  }
};
class cn {
  constructor(t, e) {
    this.a = t, this.b = e, this.type = "value";
  }
  startGen(t) {
  }
  genColor(t, e) {
    const i = Math.random();
    return e.copy(this.a).lerp(this.b, i);
  }
  toJSON() {
    return {
      type: "RandomColor",
      a: Qi(this.a),
      b: Qi(this.b)
    };
  }
  static fromJSON(t) {
    return new cn(wi(t.a), wi(t.b));
  }
  clone() {
    return new cn(this.a.clone(), this.b.clone());
  }
}
class li {
  constructor(t, e) {
    this.a = t, this.b = e, this.indexCount = -1, this.type = "value";
  }
  startGen(t) {
    this.indexCount = t.length, t.push(Math.random());
  }
  genColor(t, e) {
    return this.indexCount === -1 && this.startGen(t), e.copy(this.a).lerp(this.b, t[this.indexCount]);
  }
  toJSON() {
    return {
      type: "ColorRange",
      a: Qi(this.a),
      b: Qi(this.b)
    };
  }
  static fromJSON(t) {
    return new li(wi(t.a), wi(t.b));
  }
  clone() {
    return new li(this.a.clone(), this.b.clone());
  }
}
class fe {
  constructor(t, e) {
    this.subType = e, this.type = "function", this.keys = t;
  }
  findKey(t) {
    let e = 0, i = 0, n = this.keys.length - 1;
    for (; i + 1 < n; )
      if (e = Math.floor((i + n) / 2), t < this.getStartX(e))
        n = e - 1;
      else if (t > this.getEndX(e))
        i = e + 1;
      else
        return e;
    for (let o = i; o <= n; o++)
      if (t >= this.getStartX(o) && t <= this.getEndX(o))
        return o;
    return -1;
  }
  getStartX(t) {
    return this.keys[t][1];
  }
  getEndX(t) {
    return t + 1 < this.keys.length ? this.keys[t + 1][1] : 1;
  }
  genValue(t, e) {
    const i = this.findKey(e);
    return this.subType === "Number" ? i === -1 ? this.keys[0][0] : i + 1 >= this.keys.length ? this.keys[this.keys.length - 1][0] : (this.keys[i + 1][0] - this.keys[i][0]) * ((e - this.getStartX(i)) / (this.getEndX(i) - this.getStartX(i))) + this.keys[i][0] : i === -1 ? t.copy(this.keys[0][0]) : i + 1 >= this.keys.length ? t.copy(this.keys[this.keys.length - 1][0]) : t.copy(this.keys[i][0]).lerp(this.keys[i + 1][0], (e - this.getStartX(i)) / (this.getEndX(i) - this.getStartX(i)));
  }
  toJSON() {
    return this.keys[0][0].constructor.name, {
      type: "CLinearFunction",
      subType: this.subType,
      keys: this.keys.map(([t, e]) => ({ value: od(t, this.subType), pos: e }))
    };
  }
  static fromJSON(t) {
    return new fe(t.keys.map((e) => [nd(e.value, t.subType), e.pos]), t.subType);
  }
  clone() {
    return this.subType === "Number" ? new fe(this.keys.map(([t, e]) => [t, e]), this.subType) : new fe(this.keys.map(([t, e]) => [t.clone(), e]), this.subType);
  }
}
const gs = new Y();
class Qe {
  constructor(t = [
    [new Y(0, 0, 0), 0],
    [new Y(1, 1, 1), 0]
  ], e = [
    [1, 0],
    [1, 1]
  ]) {
    this.type = "function", this.color = new fe(t, "Color"), this.alpha = new fe(e, "Number");
  }
  genColor(t, e, i) {
    return this.color.genValue(gs, i), e.set(gs.x, gs.y, gs.z, this.alpha.genValue(1, i));
  }
  toJSON() {
    return {
      type: "Gradient",
      color: this.color.toJSON(),
      alpha: this.alpha.toJSON()
    };
  }
  static fromJSON(t) {
    if (t.functions) {
      const e = t.functions.map((i) => [li.fromJSON(i.function).a, i.start]);
      return t.functions.length > 0 && e.push([li.fromJSON(t.functions[t.functions.length - 1].function).b, 1]), new Qe(e.map((i) => [new Y(i[0].x, i[0].y, i[0].z), i[1]]), e.map((i) => [i[0].w, i[1]]));
    } else {
      const e = new Qe();
      return e.alpha = fe.fromJSON(t.alpha), e.color = fe.fromJSON(t.color), e;
    }
  }
  clone() {
    const t = new Qe();
    return t.alpha = this.alpha.clone(), t.color = this.color.clone(), t;
  }
  startGen(t) {
  }
}
const gn = new Tt();
class an {
  constructor(t, e) {
    this.indexCount = 0, this.type = "function", this.gradient1 = t, this.gradient2 = e;
  }
  startGen(t) {
    this.indexCount = t.length, t.push(Math.random());
  }
  genColor(t, e, i) {
    return this.gradient1.genColor(t, e, i), this.gradient2.genColor(t, gn, i), t && t[this.indexCount] !== void 0 ? e.lerp(gn, t[this.indexCount]) : e.lerp(gn, Math.random()), e;
  }
  toJSON() {
    return {
      type: "RandomColorBetweenGradient",
      gradient1: this.gradient1.toJSON(),
      gradient2: this.gradient2.toJSON()
    };
  }
  static fromJSON(t) {
    return new an(Qe.fromJSON(t.gradient1), Qe.fromJSON(t.gradient2));
  }
  clone() {
    return new an(this.gradient1.clone(), this.gradient2.clone());
  }
}
class ci {
  constructor(t) {
    this.color = t, this.type = "value";
  }
  startGen(t) {
  }
  genColor(t, e) {
    return e.copy(this.color);
  }
  toJSON() {
    return {
      type: "ConstantColor",
      color: Qi(this.color)
    };
  }
  static fromJSON(t) {
    return new ci(wi(t.color));
  }
  clone() {
    return new ci(this.color.clone());
  }
}
function vo(s) {
  switch (s.type) {
    case "ConstantColor":
      return ci.fromJSON(s);
    case "ColorRange":
      return li.fromJSON(s);
    case "RandomColor":
      return cn.fromJSON(s);
    case "Gradient":
      return Qe.fromJSON(s);
    case "RandomColorBetweenGradient":
      return an.fromJSON(s);
    default:
      return new ci(new Tt(1, 1, 1, 1));
  }
}
class Q {
  constructor(t) {
    this.value = t, this.type = "value";
  }
  startGen(t) {
  }
  genValue(t) {
    return this.value;
  }
  toJSON() {
    return {
      type: "ConstantValue",
      value: this.value
    };
  }
  static fromJSON(t) {
    return new Q(t.value);
  }
  clone() {
    return new Q(this.value);
  }
}
class we {
  constructor(t, e) {
    this.a = t, this.b = e, this.indexCount = -1, this.type = "value";
  }
  startGen(t) {
    this.indexCount = t.length, t.push(Math.random());
  }
  genValue(t) {
    return this.indexCount === -1 && this.startGen(t), hi.lerp(this.a, this.b, t[this.indexCount]);
  }
  toJSON() {
    return {
      type: "IntervalValue",
      a: this.a,
      b: this.b
    };
  }
  static fromJSON(t) {
    return new we(t.a, t.b);
  }
  clone() {
    return new we(this.a, this.b);
  }
}
class rd {
  constructor() {
    this.functions = new Array();
  }
  findFunction(t) {
    let e = 0, i = 0, n = this.functions.length - 1;
    for (; i + 1 < n; )
      if (e = Math.floor((i + n) / 2), t < this.getStartX(e))
        n = e - 1;
      else if (t > this.getEndX(e))
        i = e + 1;
      else
        return e;
    for (let o = i; o <= n; o++)
      if (t >= this.functions[o][1] && t <= this.getEndX(o))
        return o;
    return -1;
  }
  getStartX(t) {
    return this.functions[t][1];
  }
  setStartX(t, e) {
    t > 0 && (this.functions[t][1] = e);
  }
  getEndX(t) {
    return t + 1 < this.functions.length ? this.functions[t + 1][1] : 1;
  }
  setEndX(t, e) {
    t + 1 < this.functions.length && (this.functions[t + 1][1] = e);
  }
  insertFunction(t, e) {
    const i = this.findFunction(t);
    this.functions.splice(i + 1, 0, [e, t]);
  }
  removeFunction(t) {
    return this.functions.splice(t, 1)[0][0];
  }
  getFunction(t) {
    return this.functions[t][0];
  }
  setFunction(t, e) {
    this.functions[t][0] = e;
  }
  get numOfFunctions() {
    return this.functions.length;
  }
}
class Bi extends rd {
  constructor(t = [[new Fe(0, 1 / 3, 1 / 3 * 2, 1), 0]]) {
    super(), this.type = "function", this.functions = t;
  }
  genValue(t, e = 0) {
    const i = this.findFunction(e);
    return i === -1 ? 0 : this.functions[i][0].genValue((e - this.getStartX(i)) / (this.getEndX(i) - this.getStartX(i)));
  }
  toSVG(t, e) {
    if (e < 1)
      return "";
    let i = ["M", 0, this.functions[0][0].p[0]].join(" ");
    for (let n = 1 / e; n <= 1; n += 1 / e)
      i = [i, "L", n * t, this.genValue(void 0, n)].join(" ");
    return i;
  }
  toJSON() {
    return {
      type: "PiecewiseBezier",
      functions: this.functions.map(([t, e]) => ({ function: t.toJSON(), start: e }))
    };
  }
  static fromJSON(t) {
    return new Bi(t.functions.map((e) => [
      Fe.fromJSON(e.function),
      e.start
    ]));
  }
  clone() {
    return new Bi(this.functions.map(([t, e]) => [t.clone(), e]));
  }
  startGen(t) {
  }
}
function I(s) {
  switch (s.type) {
    case "ConstantValue":
      return Q.fromJSON(s);
    case "IntervalValue":
      return we.fromJSON(s);
    case "PiecewiseBezier":
      return Bi.fromJSON(s);
    default:
      return new Q(0);
  }
}
class Ei {
  constructor() {
    this.indexCount = 0, this.type = "rotation";
  }
  startGen(t) {
    this.indexCount = t.length, t.push(new w());
    let e, i, n, o, r, c;
    do
      e = Math.random() * 2 - 1, i = Math.random() * 2 - 1, n = e * e + i * i;
    while (n > 1);
    do
      o = Math.random() * 2 - 1, r = Math.random() * 2 - 1, c = o * o + r * r;
    while (c > 1);
    const l = Math.sqrt((1 - n) / c);
    t[this.indexCount].set(e, i, l * o, l * r);
  }
  genValue(t, e, i, n) {
    return this.indexCount === -1 && this.startGen(t), e.copy(t[this.indexCount]), e;
  }
  toJSON() {
    return {
      type: "RandomQuat"
    };
  }
  static fromJSON(t) {
    return new Ei();
  }
  clone() {
    return new Ei();
  }
}
class ji {
  constructor(t, e) {
    this.axis = t, this.angle = e, this.type = "rotation";
  }
  startGen(t) {
    this.angle.startGen(t);
  }
  genValue(t, e, i, n) {
    return e.setFromAxisAngle(this.axis, this.angle.genValue(t, n) * i);
  }
  toJSON() {
    return {
      type: "AxisAngle",
      axis: { x: this.axis.x, y: this.axis.y, z: this.axis.z },
      angle: this.angle.toJSON()
    };
  }
  static fromJSON(t) {
    return new ji(new Y(t.axis.x, t.axis.y, t.axis.z), I(t.angle));
  }
  clone() {
    return new ji(this.axis.clone(), this.angle.clone());
  }
}
class dn {
  constructor(t, e, i, n) {
    this.angleX = t, this.angleY = e, this.angleZ = i, this.type = "rotation", this.eular = new Fi(0, 0, 0, n);
  }
  startGen(t) {
    this.angleX.startGen(t), this.angleY.startGen(t), this.angleZ.startGen(t);
  }
  genValue(t, e, i, n) {
    return this.eular.set(this.angleX.genValue(t, n) * i, this.angleY.genValue(t, n) * i, this.angleZ.genValue(t, n) * i), e.setFromEuler(this.eular);
  }
  toJSON() {
    return {
      type: "Euler",
      angleX: this.angleX.toJSON(),
      angleY: this.angleY.toJSON(),
      angleZ: this.angleZ.toJSON(),
      eulerOrder: this.eular.order
    };
  }
  static fromJSON(t) {
    return new dn(I(t.angleX), I(t.angleY), I(t.angleZ), t.eulerOrder);
  }
  clone() {
    return new dn(this.angleX, this.angleY, this.angleZ, this.eular.order);
  }
}
function ql(s) {
  switch (s.type) {
    case "AxisAngle":
      return ji.fromJSON(s);
    case "Euler":
      return dn.fromJSON(s);
    case "RandomQuat":
      return Ei.fromJSON(s);
    default:
      return new Ei();
  }
}
class Be {
  constructor(t, e, i) {
    this.x = t, this.y = e, this.z = i, this.type = "vec3function";
  }
  startGen(t) {
    this.x.startGen(t), this.y.startGen(t), this.z.startGen(t);
  }
  genValue(t, e, i) {
    return e.set(this.x.genValue(t, i), this.y.genValue(t, i), this.z.genValue(t, i));
  }
  toJSON() {
    return {
      type: "Vector3Function",
      x: this.x.toJSON(),
      y: this.y.toJSON(),
      z: this.z.toJSON()
    };
  }
  static fromJSON(t) {
    return new Be(I(t.x), I(t.y), I(t.z));
  }
  clone() {
    return new Be(this.x, this.y, this.z);
  }
}
function ld(s) {
  switch (s.type) {
    case "Vector3Function":
      return Be.fromJSON(s);
    default:
      return new Be(new Q(0), new Q(0), new Q(0));
  }
}
function hn(s) {
  switch (s.type) {
    case "ConstantValue":
    case "IntervalValue":
    case "PiecewiseBezier":
      return I(s);
    case "AxisAngle":
    case "RandomQuat":
    case "Euler":
      return ql(s);
    case "Vector3Function":
      return ld(s);
    default:
      return new Q(0);
  }
}
class Oi {
  constructor(t = {}) {
    var e, i, n, o, r, c, l;
    this.type = "cone", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (n = t.thickness) !== null && n !== void 0 ? n : 1, this.angle = (o = t.angle) !== null && o !== void 0 ? o : Math.PI / 6, this.mode = (r = t.mode) !== null && r !== void 0 ? r : Rt.Random, this.spread = (c = t.spread) !== null && c !== void 0 ? c : 0, this.speed = (l = t.speed) !== null && l !== void 0 ? l : new Q(1), this.memory = [];
  }
  update(t, e) {
    Rt.Random != this.mode && (this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e);
  }
  initialize(t, e) {
    const i = Vs(this.mode, this.currentValue, this.spread, e), n = hi.lerp(1 - this.thickness, 1, Math.random()), o = i * this.arc, r = Math.sqrt(n), c = Math.sin(o), l = Math.cos(o);
    t.position.x = r * l, t.position.y = r * c, t.position.z = 0;
    const a = this.angle * r;
    t.velocity.set(0, 0, Math.cos(a)).addScaledVector(t.position, Math.sin(a)).multiplyScalar(t.startSpeed), t.position.multiplyScalar(this.radius);
  }
  toJSON() {
    return {
      type: "cone",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      angle: this.angle,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new Oi({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      angle: t.angle,
      mode: t.mode,
      speed: t.speed ? I(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new Oi({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      angle: this.angle,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
class _i {
  constructor(t = {}) {
    var e, i, n, o, r, c;
    this.type = "circle", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (n = t.thickness) !== null && n !== void 0 ? n : 1, this.mode = (o = t.mode) !== null && o !== void 0 ? o : Rt.Random, this.spread = (r = t.spread) !== null && r !== void 0 ? r : 0, this.speed = (c = t.speed) !== null && c !== void 0 ? c : new Q(1), this.memory = [];
  }
  update(t, e) {
    this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e;
  }
  initialize(t, e) {
    const i = Vs(this.mode, this.currentValue, this.spread, e), n = hi.lerp(1 - this.thickness, 1, Math.random()), o = i * this.arc;
    t.position.x = Math.cos(o), t.position.y = Math.sin(o), t.position.z = 0, t.velocity.copy(t.position).multiplyScalar(t.startSpeed), t.position.multiplyScalar(this.radius * n);
  }
  toJSON() {
    return {
      type: "circle",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new _i({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      mode: t.mode,
      speed: t.speed ? I(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new _i({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
function zs(s, t) {
  return Math.floor(Math.random() * (t - s)) + s;
}
const Gn = new Y(0, 1, 0), Zn = new Y(0, 0, 0), cd = new Y(1, 1, 1), Xr = new Y(0, 0, 1);
class Di {
  constructor(t = {}) {
    var e, i, n, o, r, c, l;
    this.type = "donut", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (n = t.thickness) !== null && n !== void 0 ? n : 1, this.donutRadius = (o = t.donutRadius) !== null && o !== void 0 ? o : this.radius * 0.2, this.mode = (r = t.mode) !== null && r !== void 0 ? r : Rt.Random, this.spread = (c = t.spread) !== null && c !== void 0 ? c : 0, this.speed = (l = t.speed) !== null && l !== void 0 ? l : new Q(1), this.memory = [], this._m1 = new $t();
  }
  update(t, e) {
    Rt.Random != this.mode && (this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e);
  }
  initialize(t, e) {
    const i = Vs(this.mode, this.currentValue, this.spread, e), n = Math.random(), o = hi.lerp(1 - this.thickness, 1, Math.random()), r = i * this.arc, c = n * Math.PI * 2, l = Math.sin(r), a = Math.cos(r);
    t.position.x = this.radius * a, t.position.y = this.radius * l, t.position.z = 0, t.velocity.z = this.donutRadius * o * Math.sin(c), t.velocity.x = this.donutRadius * o * Math.cos(c) * a, t.velocity.y = this.donutRadius * o * Math.cos(c) * l, t.position.add(t.velocity), t.velocity.normalize().multiplyScalar(t.startSpeed), t.rotation instanceof w && (this._m1.lookAt(Zn, t.velocity, Gn), t.rotation.setFromRotationMatrix(this._m1));
  }
  toJSON() {
    return {
      type: "donut",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      donutRadius: this.donutRadius,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new Di({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      donutRadius: t.donutRadius,
      mode: t.mode,
      speed: t.speed ? I(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new Di({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      donutRadius: this.donutRadius,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
class Ai {
  constructor() {
    this.type = "point", this._m1 = new $t();
  }
  update(t, e) {
  }
  initialize(t) {
    const e = Math.random(), i = Math.random(), n = e * Math.PI * 2, o = Math.acos(2 * i - 1), r = Math.cbrt(Math.random()), c = Math.sin(n), l = Math.cos(n), a = Math.sin(o), d = Math.cos(o);
    t.velocity.x = r * a * l, t.velocity.y = r * a * c, t.velocity.z = r * d, t.velocity.multiplyScalar(t.startSpeed), t.position.setScalar(0), t.rotation instanceof w && (this._m1.lookAt(Zn, t.position, Gn), t.rotation.setFromRotationMatrix(this._m1));
  }
  toJSON() {
    return {
      type: "point"
    };
  }
  static fromJSON(t) {
    return new Ai();
  }
  clone() {
    return new Ai();
  }
}
class ai {
  constructor(t = {}) {
    var e, i, n, o, r, c;
    this.type = "sphere", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (n = t.thickness) !== null && n !== void 0 ? n : 1, this.mode = (o = t.mode) !== null && o !== void 0 ? o : Rt.Random, this.spread = (r = t.spread) !== null && r !== void 0 ? r : 0, this.speed = (c = t.speed) !== null && c !== void 0 ? c : new Q(1), this.memory = [], this._m1 = new $t();
  }
  update(t, e) {
    Rt.Random != this.mode && (this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e);
  }
  initialize(t, e) {
    const i = Vs(this.mode, this.currentValue, this.spread, e), n = Math.random(), o = hi.lerp(1 - this.thickness, 1, Math.random()), r = i * this.arc, c = Math.acos(2 * n - 1), l = Math.sin(r), a = Math.cos(r), d = Math.sin(c), h = Math.cos(c);
    t.position.x = d * a, t.position.y = d * l, t.position.z = h, t.velocity.copy(t.position).multiplyScalar(t.startSpeed), t.position.multiplyScalar(this.radius * o), t.rotation instanceof w && (this._m1.lookAt(Zn, t.position, Gn), t.rotation.setFromRotationMatrix(this._m1));
  }
  toJSON() {
    return {
      type: "sphere",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new ai({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      mode: t.mode,
      speed: t.speed ? I(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new ai({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
class qi {
  constructor(t = {}) {
    var e, i, n, o, r, c;
    this.type = "sphere", this.currentValue = 0, this.radius = (e = t.radius) !== null && e !== void 0 ? e : 10, this.arc = (i = t.arc) !== null && i !== void 0 ? i : 2 * Math.PI, this.thickness = (n = t.thickness) !== null && n !== void 0 ? n : 1, this.mode = (o = t.mode) !== null && o !== void 0 ? o : Rt.Random, this.spread = (r = t.spread) !== null && r !== void 0 ? r : 0, this.speed = (c = t.speed) !== null && c !== void 0 ? c : new Q(1), this.memory = [], this._m1 = new $t();
  }
  update(t, e) {
    Rt.Random != this.mode && (this.currentValue += this.speed.genValue(this.memory, t.emissionState.time / t.duration) * e);
  }
  initialize(t, e) {
    const i = Vs(this.mode, this.currentValue, this.spread, e), n = Math.random(), o = hi.lerp(1 - this.thickness, 1, Math.random()), r = i * this.arc, c = Math.acos(n), l = Math.sin(r), a = Math.cos(r), d = Math.sin(c), h = Math.cos(c);
    t.position.x = d * a, t.position.y = d * l, t.position.z = h, t.velocity.copy(t.position).multiplyScalar(t.startSpeed), t.position.multiplyScalar(this.radius * o), t.rotation instanceof w && (this._m1.lookAt(Zn, t.position, Gn), t.rotation.setFromRotationMatrix(this._m1));
  }
  toJSON() {
    return {
      type: "hemisphere",
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      spread: this.spread,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new qi({
      radius: t.radius,
      arc: t.arc,
      thickness: t.thickness,
      mode: t.mode,
      speed: t.speed ? I(t.speed) : void 0,
      spread: t.spread
    });
  }
  clone() {
    return new qi({
      radius: this.radius,
      arc: this.arc,
      thickness: this.thickness,
      mode: this.mode,
      speed: this.speed.clone(),
      spread: this.spread
    });
  }
}
class $i {
  constructor(t = {}) {
    var e, i, n, o;
    this.type = "grid", this.width = (e = t.width) !== null && e !== void 0 ? e : 1, this.height = (i = t.height) !== null && i !== void 0 ? i : 1, this.column = (n = t.column) !== null && n !== void 0 ? n : 10, this.row = (o = t.row) !== null && o !== void 0 ? o : 10;
  }
  initialize(t) {
    const e = Math.floor(Math.random() * this.row), i = Math.floor(Math.random() * this.column);
    t.position.x = i * this.width / this.column - this.width / 2, t.position.y = e * this.height / this.row - this.height / 2, t.position.z = 0, t.velocity.set(0, 0, t.startSpeed);
  }
  toJSON() {
    return {
      type: "grid",
      width: this.width,
      height: this.height,
      column: this.column,
      row: this.row
    };
  }
  static fromJSON(t) {
    return new $i(t);
  }
  clone() {
    return new $i({
      width: this.width,
      height: this.height,
      column: this.column,
      row: this.row
    });
  }
  update(t, e) {
  }
}
const co = {
  circle: {
    type: "circle",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: _i,
    loadJSON: _i.fromJSON
  },
  cone: {
    type: "cone",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: Oi,
    loadJSON: Oi.fromJSON
  },
  donut: {
    type: "donut",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["donutRadius", ["number"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: Di,
    loadJSON: Di.fromJSON
  },
  point: { type: "point", params: [], constructor: Ai, loadJSON: Ai.fromJSON },
  sphere: {
    type: "sphere",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: ai,
    loadJSON: ai.fromJSON
  },
  hemisphere: {
    type: "hemisphere",
    params: [
      ["radius", ["number"]],
      ["arc", ["radian"]],
      ["thickness", ["number"]],
      ["angle", ["radian"]],
      ["mode", ["emitterMode"]],
      ["spread", ["number"]],
      ["speed", ["valueFunc"]]
    ],
    constructor: qi,
    loadJSON: qi.fromJSON
  },
  grid: {
    type: "grid",
    params: [
      ["width", ["number"]],
      ["height", ["number"]],
      ["rows", ["number"]],
      ["column", ["number"]]
    ],
    constructor: $i,
    loadJSON: $i.fromJSON
  }
};
function ad(s, t) {
  return co[s.type].loadJSON(s, t);
}
class ts {
  constructor(t) {
    this.color = t, this.type = "ColorOverLife";
  }
  initialize(t) {
    this.color.startGen(t.memory);
  }
  update(t, e) {
    this.color.genColor(t.memory, t.color, t.age / t.life), t.color.x *= t.startColor.x, t.color.y *= t.startColor.y, t.color.z *= t.startColor.z, t.color.w *= t.startColor.w;
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      color: this.color.toJSON()
    };
  }
  static fromJSON(t) {
    return new ts(vo(t.color));
  }
  clone() {
    return new ts(this.color.clone());
  }
  reset() {
  }
}
class es {
  constructor(t) {
    this.angularVelocity = t, this.type = "RotationOverLife";
  }
  initialize(t) {
    typeof t.rotation == "number" && this.angularVelocity.startGen(t.memory);
  }
  update(t, e) {
    typeof t.rotation == "number" && (t.rotation += e * this.angularVelocity.genValue(t.memory, t.age / t.life));
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON()
    };
  }
  static fromJSON(t) {
    return new es(I(t.angularVelocity));
  }
  frameUpdate(t) {
  }
  clone() {
    return new es(this.angularVelocity.clone());
  }
  reset() {
  }
}
class is {
  constructor(t) {
    this.angularVelocity = t, this.type = "Rotation3DOverLife", this.tempQuat = new w(), this.tempQuat2 = new w();
  }
  initialize(t) {
    t.rotation instanceof w && (t.angularVelocity = new w(), this.angularVelocity.startGen(t.memory));
  }
  update(t, e) {
    t.rotation instanceof w && (this.angularVelocity.genValue(t.memory, this.tempQuat, e, t.age / t.life), t.rotation.multiply(this.tempQuat));
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON()
    };
  }
  static fromJSON(t) {
    return new is(ql(t.angularVelocity));
  }
  frameUpdate(t) {
  }
  clone() {
    return new is(this.angularVelocity.clone());
  }
  reset() {
  }
}
class ss {
  initialize(t, e) {
    this.ps = e, this.x.startGen(t.memory), this.y.startGen(t.memory), this.z.startGen(t.memory);
  }
  constructor(t, e, i) {
    this.x = t, this.y = e, this.z = i, this.type = "ForceOverLife", this._temp = new Y(), this._tempScale = new Y(), this._tempQ = new w();
  }
  update(t, e) {
    this._temp.set(this.x.genValue(t.memory, t.age / t.life), this.y.genValue(t.memory, t.age / t.life), this.z.genValue(t.memory, t.age / t.life)), this.ps.worldSpace ? t.velocity.addScaledVector(this._temp, e) : (this._temp.multiply(this._tempScale).applyQuaternion(this._tempQ), t.velocity.addScaledVector(this._temp, e));
  }
  toJSON() {
    return {
      type: this.type,
      x: this.x.toJSON(),
      y: this.y.toJSON(),
      z: this.z.toJSON()
    };
  }
  static fromJSON(t) {
    return new ss(I(t.x), I(t.y), I(t.z));
  }
  frameUpdate(t) {
    if (this.ps && !this.ps.worldSpace) {
      const e = this._temp, i = this._tempQ, n = this._tempScale;
      this.ps.emitter.matrixWorld.decompose(e, i, n), i.invert(), n.set(1 / n.x, 1 / n.y, 1 / n.z);
    }
  }
  clone() {
    return new ss(this.x.clone(), this.y.clone(), this.z.clone());
  }
  reset() {
  }
}
class ns {
  initialize(t) {
    this.size.startGen(t.memory);
  }
  constructor(t) {
    this.size = t, this.type = "SizeOverLife";
  }
  update(t) {
    this.size instanceof Be ? this.size.genValue(t.memory, t.size, t.age / t.life).multiply(t.startSize) : t.size.copy(t.startSize).multiplyScalar(this.size.genValue(t.memory, t.age / t.life));
  }
  toJSON() {
    return {
      type: this.type,
      size: this.size.toJSON()
    };
  }
  static fromJSON(t) {
    return new ns(hn(t.size));
  }
  frameUpdate(t) {
  }
  clone() {
    return new ns(this.size.clone());
  }
  reset() {
  }
}
class os {
  initialize(t) {
    this.speed.startGen(t.memory);
  }
  constructor(t) {
    this.speed = t, this.type = "SpeedOverLife";
  }
  update(t) {
    t.speedModifier = this.speed.genValue(t.memory, t.age / t.life);
  }
  toJSON() {
    return {
      type: this.type,
      speed: this.speed.toJSON()
    };
  }
  static fromJSON(t) {
    return new os(I(t.speed));
  }
  frameUpdate(t) {
  }
  clone() {
    return new os(this.speed.clone());
  }
  reset() {
  }
}
class rs {
  constructor(t) {
    this.frame = t, this.type = "FrameOverLife";
  }
  initialize(t) {
    this.frame.startGen(t.memory);
  }
  update(t, e) {
    this.frame instanceof Bi && (t.uvTile = this.frame.genValue(t.memory, t.age / t.life));
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      frame: this.frame.toJSON()
    };
  }
  static fromJSON(t) {
    return new rs(I(t.frame));
  }
  clone() {
    return new rs(this.frame.clone());
  }
  reset() {
  }
}
class ls {
  constructor(t, e = new Y(0, 1, 0)) {
    this.orbitSpeed = t, this.axis = e, this.type = "OrbitOverLife", this.temp = new Y(), this.rotation = new w();
  }
  initialize(t) {
    this.orbitSpeed.startGen(t.memory);
  }
  update(t, e) {
    this.temp.copy(t.position).projectOnVector(this.axis), this.rotation.setFromAxisAngle(this.axis, this.orbitSpeed.genValue(t.memory, t.age / t.life) * e), t.position.sub(this.temp), t.position.applyQuaternion(this.rotation), t.position.add(this.temp);
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      orbitSpeed: this.orbitSpeed.toJSON(),
      axis: [this.axis.x, this.axis.y, this.axis.z]
    };
  }
  static fromJSON(t) {
    return new ls(I(t.orbitSpeed), t.axis ? new Y(t.axis[0], t.axis[1], t.axis[2]) : void 0);
  }
  clone() {
    return new ls(this.orbitSpeed.clone());
  }
  reset() {
  }
}
class zn {
  constructor(t) {
    this.data = t, this.next = null, this.prev = null;
  }
  hasPrev() {
    return this.prev !== null;
  }
  hasNext() {
    return this.next !== null;
  }
}
class dd {
  constructor() {
    this.length = 0, this.head = this.tail = null;
  }
  isEmpty() {
    return this.head === null;
  }
  clear() {
    this.length = 0, this.head = this.tail = null;
  }
  front() {
    return this.head === null ? null : this.head.data;
  }
  back() {
    return this.tail === null ? null : this.tail.data;
  }
  dequeue() {
    if (this.head) {
      const t = this.head.data;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, t;
    }
  }
  pop() {
    if (this.tail) {
      const t = this.tail.data;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, t;
    }
  }
  queue(t) {
    const e = new zn(t);
    this.tail || (this.tail = e), this.head && (this.head.prev = e, e.next = this.head), this.head = e, this.length++;
  }
  push(t) {
    const e = new zn(t);
    this.head || (this.head = e), this.tail && (this.tail.next = e, e.prev = this.tail), this.tail = e, this.length++;
  }
  insertBefore(t, e) {
    const i = new zn(e);
    i.next = t, i.prev = t.prev, i.prev !== null && (i.prev.next = i), i.next.prev = i, t == this.head && (this.head = i), this.length++;
  }
  remove(t) {
    if (this.head === null || this.tail === null)
      return;
    let e = this.head;
    for (t === this.head.data && (this.head = this.head.next), t === this.tail.data && (this.tail = this.tail.prev); e.next !== null && e.data !== t; )
      e = e.next;
    e.data === t && (e.prev !== null && (e.prev.next = e.next), e.next !== null && (e.next.prev = e.prev), this.length--);
  }
  *values() {
    let t = this.head;
    for (; t !== null; )
      yield t.data, t = t.next;
  }
}
class hd {
  constructor() {
    this.startSpeed = 0, this.startColor = new Tt(), this.startSize = new Y(1, 1, 1), this.position = new Y(), this.velocity = new Y(), this.age = 0, this.life = 1, this.size = new Y(1, 1, 1), this.speedModifier = 1, this.rotation = 0, this.color = new Tt(), this.uvTile = 0, this.memory = [];
  }
  get died() {
    return this.age >= this.life;
  }
  reset() {
    this.memory.length = 0;
  }
}
class ud {
  constructor(t, e, i) {
    this.position = t, this.size = e, this.color = i;
  }
}
class ao {
  constructor() {
    this.startSpeed = 0, this.startColor = new Tt(), this.startSize = new Y(1, 1, 1), this.position = new Y(), this.velocity = new Y(), this.age = 0, this.life = 1, this.size = new Y(1, 1, 1), this.length = 100, this.speedModifier = 1, this.color = new Tt(), this.previous = new dd(), this.uvTile = 0, this.memory = [];
  }
  update() {
    for (this.age <= this.life ? this.previous.push(new ud(this.position.clone(), this.size.x, this.color.clone())) : this.previous.length > 0 && this.previous.dequeue(); this.previous.length > this.length; )
      this.previous.dequeue();
  }
  get died() {
    return this.age >= this.life;
  }
  reset() {
    this.memory.length = 0, this.previous.clear();
  }
}
class cs {
  initialize(t) {
    this.width.startGen(t.memory);
  }
  constructor(t) {
    this.width = t, this.type = "WidthOverLength";
  }
  update(t) {
    if (t instanceof ao) {
      const e = t.previous.values();
      for (let i = 0; i < t.previous.length; i++) {
        const n = e.next();
        n.value.size = this.width.genValue(t.memory, (t.previous.length - i) / t.length);
      }
    }
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      width: this.width.toJSON()
    };
  }
  static fromJSON(t) {
    return new cs(I(t.width));
  }
  clone() {
    return new cs(this.width.clone());
  }
  reset() {
  }
}
class as {
  constructor(t, e) {
    this.direction = t, this.magnitude = e, this.type = "ApplyForce", this.memory = {
      data: [],
      dataCount: 0
    }, this.magnitudeValue = this.magnitude.genValue(this.memory);
  }
  initialize(t) {
  }
  update(t, e) {
    t.velocity.addScaledVector(this.direction, this.magnitudeValue * e);
  }
  frameUpdate(t) {
    this.magnitudeValue = this.magnitude.genValue(this.memory);
  }
  toJSON() {
    return {
      type: this.type,
      direction: [this.direction.x, this.direction.y, this.direction.z],
      magnitude: this.magnitude.toJSON()
    };
  }
  static fromJSON(t) {
    var e;
    return new as(new Y(t.direction[0], t.direction[1], t.direction[2]), I((e = t.magnitude) !== null && e !== void 0 ? e : t.force));
  }
  clone() {
    return new as(this.direction.clone(), this.magnitude.clone());
  }
  reset() {
  }
}
class ds {
  constructor(t, e) {
    this.center = t, this.magnitude = e, this.type = "GravityForce", this.temp = new Y();
  }
  initialize(t) {
  }
  update(t, e) {
    this.temp.copy(this.center).sub(t.position).normalize(), t.velocity.addScaledVector(this.temp, this.magnitude / t.position.distanceToSquared(this.center) * e);
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      center: [this.center.x, this.center.y, this.center.z],
      magnitude: this.magnitude
    };
  }
  static fromJSON(t) {
    return new ds(new Y(t.center[0], t.center[1], t.center[2]), t.magnitude);
  }
  clone() {
    return new ds(this.center.clone(), this.magnitude);
  }
  reset() {
  }
}
class hs {
  constructor(t) {
    this.angle = t, this.type = "ChangeEmitDirection", this._temp = new Y(), this._q = new w(), this.memory = { data: [], dataCount: 0 };
  }
  initialize(t) {
    const e = t.velocity.length();
    e != 0 && (t.velocity.normalize(), t.velocity.x === 0 && t.velocity.y === 0 ? this._temp.set(0, t.velocity.z, 0) : this._temp.set(-t.velocity.y, t.velocity.x, 0), this.angle.startGen(this.memory), this._q.setFromAxisAngle(this._temp.normalize(), this.angle.genValue(this.memory)), this._temp.copy(t.velocity), t.velocity.applyQuaternion(this._q), this._q.setFromAxisAngle(this._temp, Math.random() * Math.PI * 2), t.velocity.applyQuaternion(this._q), t.velocity.setLength(e));
  }
  update(t, e) {
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      angle: this.angle.toJSON()
    };
  }
  static fromJSON(t) {
    return new hs(I(t.angle));
  }
  clone() {
    return new hs(this.angle);
  }
  reset() {
  }
}
var si;
(function(s) {
  s[s.Death = 0] = "Death", s[s.Birth = 1] = "Birth", s[s.Frame = 2] = "Frame";
})(si || (si = {}));
class us {
  constructor(t, e, i, n = si.Frame, o = 1) {
    this.particleSystem = t, this.useVelocityAsBasis = e, this.subParticleSystem = i, this.mode = n, this.emitProbability = o, this.type = "EmitSubParticleSystem", this.q_ = new w(), this.v_ = new Y(), this.v2_ = new Y(), this.subEmissions = new Array(), this.subParticleSystem && this.subParticleSystem.system && (this.subParticleSystem.system.onlyUsedByOther = !0);
  }
  initialize(t) {
  }
  update(t, e) {
    this.mode === si.Frame ? this.emit(t, e) : this.mode === si.Birth && t.age === 0 ? this.emit(t, e) : this.mode === si.Death && t.age + e >= t.life && this.emit(t, e);
  }
  emit(t, e) {
    if (!this.subParticleSystem || Math.random() > this.emitProbability)
      return;
    const i = new $t();
    this.setMatrixFromParticle(i, t), this.subEmissions.push({
      burstParticleCount: 0,
      burstParticleIndex: 0,
      isBursting: !1,
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0,
      matrix: i,
      travelDistance: 0,
      particle: t
    });
  }
  frameUpdate(t) {
    if (this.subParticleSystem)
      for (let e = 0; e < this.subEmissions.length; e++)
        if (this.subEmissions[e].time >= this.subParticleSystem.system.duration)
          this.subEmissions[e] = this.subEmissions[this.subEmissions.length - 1], this.subEmissions.length = this.subEmissions.length - 1, e--;
        else {
          const i = this.subEmissions[e];
          i.particle && i.particle.age < i.particle.life ? this.setMatrixFromParticle(i.matrix, i.particle) : i.particle = void 0, this.subParticleSystem.system.emit(t, i, i.matrix);
        }
  }
  toJSON() {
    return {
      type: this.type,
      subParticleSystem: this.subParticleSystem ? this.subParticleSystem.uuid : "",
      useVelocityAsBasis: this.useVelocityAsBasis,
      mode: this.mode,
      emitProbability: this.emitProbability
    };
  }
  static fromJSON(t, e) {
    return new us(e, t.useVelocityAsBasis, t.subParticleSystem, t.mode, t.emitProbability);
  }
  clone() {
    return new us(this.particleSystem, this.useVelocityAsBasis, this.subParticleSystem, this.mode, this.emitProbability);
  }
  reset() {
  }
  setMatrixFromParticle(t, e) {
    let i;
    if (e.rotation === void 0 || this.useVelocityAsBasis)
      if (e.velocity.x === 0 && e.velocity.y === 0 && (e.velocity.z === 1 || e.velocity.z === 0))
        t.set(1, 0, 0, e.position.x, 0, 1, 0, e.position.y, 0, 0, 1, e.position.z, 0, 0, 0, 1);
      else {
        this.v_.copy(Xr).cross(e.velocity), this.v2_.copy(e.velocity).cross(this.v_);
        const n = this.v_.length(), o = this.v2_.length();
        t.set(this.v_.x / n, this.v2_.x / o, e.velocity.x, e.position.x, this.v_.y / n, this.v2_.y / o, e.velocity.y, e.position.y, this.v_.z / n, this.v2_.z / o, e.velocity.z, e.position.z, 0, 0, 0, 1);
      }
    else
      e.rotation instanceof w ? i = e.rotation : (this.q_.setFromAxisAngle(Xr, e.rotation), i = this.q_), t.compose(e.position, i, cd);
    this.particleSystem.worldSpace || t.multiplyMatrices(this.particleSystem.emitter.matrixWorld, t);
  }
}
const pd = 0.5 * (Math.sqrt(3) - 1), Xi = (3 - Math.sqrt(3)) / 6, md = 1 / 3, jt = 1 / 6, bd = (Math.sqrt(5) - 1) / 4, lt = (5 - Math.sqrt(5)) / 20, ot = new Float32Array([
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1,
  0,
  1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  -1,
  0,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1
]), $ = new Float32Array([
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0
]);
class $l {
  constructor(t = Math.random) {
    const e = typeof t == "function" ? t : Gd(t);
    this.p = yd(e), this.perm = new Uint8Array(512), this.permMod12 = new Uint8Array(512);
    for (let i = 0; i < 512; i++)
      this.perm[i] = this.p[i & 255], this.permMod12[i] = this.perm[i] % 12;
  }
  noise2D(t, e) {
    const i = this.permMod12, n = this.perm;
    let o = 0, r = 0, c = 0;
    const l = (t + e) * pd, a = Math.floor(t + l), d = Math.floor(e + l), h = (a + d) * Xi, u = a - h, p = d - h, m = t - u, b = e - p;
    let G, y;
    m > b ? (G = 1, y = 0) : (G = 0, y = 1);
    const Z = m - G + Xi, f = b - y + Xi, V = m - 1 + 2 * Xi, X = b - 1 + 2 * Xi, R = a & 255, x = d & 255;
    let S = 0.5 - m * m - b * b;
    if (S >= 0) {
      const g = i[R + n[x]] * 3;
      S *= S, o = S * S * (ot[g] * m + ot[g + 1] * b);
    }
    let C = 0.5 - Z * Z - f * f;
    if (C >= 0) {
      const g = i[R + G + n[x + y]] * 3;
      C *= C, r = C * C * (ot[g] * Z + ot[g + 1] * f);
    }
    let L = 0.5 - V * V - X * X;
    if (L >= 0) {
      const g = i[R + 1 + n[x + 1]] * 3;
      L *= L, c = L * L * (ot[g] * V + ot[g + 1] * X);
    }
    return 70 * (o + r + c);
  }
  noise3D(t, e, i) {
    const n = this.permMod12, o = this.perm;
    let r, c, l, a;
    const d = (t + e + i) * md, h = Math.floor(t + d), u = Math.floor(e + d), p = Math.floor(i + d), m = (h + u + p) * jt, b = h - m, G = u - m, y = p - m, Z = t - b, f = e - G, V = i - y;
    let X, R, x, S, C, L;
    Z >= f ? f >= V ? (X = 1, R = 0, x = 0, S = 1, C = 1, L = 0) : Z >= V ? (X = 1, R = 0, x = 0, S = 1, C = 0, L = 1) : (X = 0, R = 0, x = 1, S = 1, C = 0, L = 1) : f < V ? (X = 0, R = 0, x = 1, S = 0, C = 1, L = 1) : Z < V ? (X = 0, R = 1, x = 0, S = 0, C = 1, L = 1) : (X = 0, R = 1, x = 0, S = 1, C = 1, L = 0);
    const g = Z - X + jt, W = f - R + jt, z = V - x + jt, v = Z - S + 2 * jt, k = f - C + 2 * jt, N = V - L + 2 * jt, J = Z - 1 + 3 * jt, P = f - 1 + 3 * jt, D = V - 1 + 3 * jt, st = h & 255, et = u & 255, gt = p & 255;
    let Lt = 0.6 - Z * Z - f * f - V * V;
    if (Lt < 0)
      r = 0;
    else {
      const O = n[st + o[et + o[gt]]] * 3;
      Lt *= Lt, r = Lt * Lt * (ot[O] * Z + ot[O + 1] * f + ot[O + 2] * V);
    }
    let nt = 0.6 - g * g - W * W - z * z;
    if (nt < 0)
      c = 0;
    else {
      const O = n[st + X + o[et + R + o[gt + x]]] * 3;
      nt *= nt, c = nt * nt * (ot[O] * g + ot[O + 1] * W + ot[O + 2] * z);
    }
    let mt = 0.6 - v * v - k * k - N * N;
    if (mt < 0)
      l = 0;
    else {
      const O = n[st + S + o[et + C + o[gt + L]]] * 3;
      mt *= mt, l = mt * mt * (ot[O] * v + ot[O + 1] * k + ot[O + 2] * N);
    }
    let it = 0.6 - J * J - P * P - D * D;
    if (it < 0)
      a = 0;
    else {
      const O = n[st + 1 + o[et + 1 + o[gt + 1]]] * 3;
      it *= it, a = it * it * (ot[O] * J + ot[O + 1] * P + ot[O + 2] * D);
    }
    return 32 * (r + c + l + a);
  }
  noise4D(t, e, i, n) {
    const o = this.perm;
    let r, c, l, a, d;
    const h = (t + e + i + n) * bd, u = Math.floor(t + h), p = Math.floor(e + h), m = Math.floor(i + h), b = Math.floor(n + h), G = (u + p + m + b) * lt, y = u - G, Z = p - G, f = m - G, V = b - G, X = t - y, R = e - Z, x = i - f, S = n - V;
    let C = 0, L = 0, g = 0, W = 0;
    X > R ? C++ : L++, X > x ? C++ : g++, X > S ? C++ : W++, R > x ? L++ : g++, R > S ? L++ : W++, x > S ? g++ : W++;
    const z = C >= 3 ? 1 : 0, v = L >= 3 ? 1 : 0, k = g >= 3 ? 1 : 0, N = W >= 3 ? 1 : 0, J = C >= 2 ? 1 : 0, P = L >= 2 ? 1 : 0, D = g >= 2 ? 1 : 0, st = W >= 2 ? 1 : 0, et = C >= 1 ? 1 : 0, gt = L >= 1 ? 1 : 0, Lt = g >= 1 ? 1 : 0, nt = W >= 1 ? 1 : 0, mt = X - z + lt, it = R - v + lt, O = x - k + lt, me = S - N + lt, A = X - J + 2 * lt, Et = R - P + 2 * lt, ee = x - D + 2 * lt, Le = S - st + 2 * lt, Se = X - et + 3 * lt, We = R - gt + 3 * lt, Ce = x - Lt + 3 * lt, ge = S - nt + 3 * lt, ze = X - 1 + 4 * lt, ve = R - 1 + 4 * lt, Ke = x - 1 + 4 * lt, Te = S - 1 + 4 * lt, ie = u & 255, se = p & 255, ne = m & 255, oe = b & 255;
    let re = 0.6 - X * X - R * R - x * x - S * S;
    if (re < 0)
      r = 0;
    else {
      const F = o[ie + o[se + o[ne + o[oe]]]] % 32 * 4;
      re *= re, r = re * re * ($[F] * X + $[F + 1] * R + $[F + 2] * x + $[F + 3] * S);
    }
    let Nt = 0.6 - mt * mt - it * it - O * O - me * me;
    if (Nt < 0)
      c = 0;
    else {
      const F = o[ie + z + o[se + v + o[ne + k + o[oe + N]]]] % 32 * 4;
      Nt *= Nt, c = Nt * Nt * ($[F] * mt + $[F + 1] * it + $[F + 2] * O + $[F + 3] * me);
    }
    let It = 0.6 - A * A - Et * Et - ee * ee - Le * Le;
    if (It < 0)
      l = 0;
    else {
      const F = o[ie + J + o[se + P + o[ne + D + o[oe + st]]]] % 32 * 4;
      It *= It, l = It * It * ($[F] * A + $[F + 1] * Et + $[F + 2] * ee + $[F + 3] * Le);
    }
    let Jt = 0.6 - Se * Se - We * We - Ce * Ce - ge * ge;
    if (Jt < 0)
      a = 0;
    else {
      const F = o[ie + et + o[se + gt + o[ne + Lt + o[oe + nt]]]] % 32 * 4;
      Jt *= Jt, a = Jt * Jt * ($[F] * Se + $[F + 1] * We + $[F + 2] * Ce + $[F + 3] * ge);
    }
    let Ut = 0.6 - ze * ze - ve * ve - Ke * Ke - Te * Te;
    if (Ut < 0)
      d = 0;
    else {
      const F = o[ie + 1 + o[se + 1 + o[ne + 1 + o[oe + 1]]]] % 32 * 4;
      Ut *= Ut, d = Ut * Ut * ($[F] * ze + $[F + 1] * ve + $[F + 2] * Ke + $[F + 3] * Te);
    }
    return 27 * (r + c + l + a + d);
  }
}
function yd(s) {
  const t = new Uint8Array(256);
  for (let e = 0; e < 256; e++)
    t[e] = e;
  for (let e = 0; e < 255; e++) {
    const i = e + ~~(s() * (256 - e)), n = t[e];
    t[e] = t[i], t[i] = n;
  }
  return t;
}
function Gd(s) {
  let t = 0, e = 0, i = 0, n = 1;
  const o = Zd();
  return t = o(" "), e = o(" "), i = o(" "), t -= o(s), t < 0 && (t += 1), e -= o(s), e < 0 && (e += 1), i -= o(s), i < 0 && (i += 1), function() {
    const r = 2091639 * t + n * 23283064365386963e-26;
    return t = e, e = i, i = r - (n = r | 0);
  };
}
function Zd() {
  let s = 4022871197;
  return function(t) {
    t = t.toString();
    for (let e = 0; e < t.length; e++) {
      s += t.charCodeAt(e);
      let i = 0.02519603282416938 * s;
      s = i >>> 0, i -= s, i *= s, s = i >>> 0, i -= s, s += i * 4294967296;
    }
    return (s >>> 0) * 23283064365386963e-26;
  };
}
class ps {
  constructor(t, e, i, n) {
    this.scale = t, this.octaves = e, this.velocityMultiplier = i, this.timeScale = n, this.type = "TurbulenceField", this.generator = new $l(), this.timeOffset = new Y(), this.temp = new Y(), this.temp2 = new Y(), this.timeOffset.x = Math.random() / this.scale.x * this.timeScale.x, this.timeOffset.y = Math.random() / this.scale.y * this.timeScale.y, this.timeOffset.z = Math.random() / this.scale.z * this.timeScale.z;
  }
  initialize(t) {
  }
  update(t, e) {
    const i = t.position.x / this.scale.x, n = t.position.y / this.scale.y, o = t.position.z / this.scale.z;
    this.temp.set(0, 0, 0);
    let r = 1;
    for (let c = 0; c < this.octaves; c++)
      this.temp2.set(this.generator.noise4D(i * r, n * r, o * r, this.timeOffset.x * r) / r, this.generator.noise4D(i * r, n * r, o * r, this.timeOffset.y * r) / r, this.generator.noise4D(i * r, n * r, o * r, this.timeOffset.z * r) / r), this.temp.add(this.temp2), r *= 2;
    this.temp.multiply(this.velocityMultiplier), t.velocity.addScaledVector(this.temp, e);
  }
  toJSON() {
    return {
      type: this.type,
      scale: [this.scale.x, this.scale.y, this.scale.z],
      octaves: this.octaves,
      velocityMultiplier: [this.velocityMultiplier.x, this.velocityMultiplier.y, this.velocityMultiplier.z],
      timeScale: [this.timeScale.x, this.timeScale.y, this.timeScale.z]
    };
  }
  frameUpdate(t) {
    this.timeOffset.x += t * this.timeScale.x, this.timeOffset.y += t * this.timeScale.y, this.timeOffset.z += t * this.timeScale.z;
  }
  static fromJSON(t) {
    return new ps(new Y(t.scale[0], t.scale[1], t.scale[2]), t.octaves, new Y(t.velocityMultiplier[0], t.velocityMultiplier[1], t.velocityMultiplier[2]), new Y(t.timeScale[0], t.timeScale[1], t.timeScale[2]));
  }
  clone() {
    return new ps(this.scale.clone(), this.octaves, this.velocityMultiplier.clone(), this.timeScale.clone());
  }
  reset() {
  }
}
const Ot = [], vn = new Y(), Kn = new w();
class ms {
  constructor(t, e, i = new Q(1), n = new Q(0)) {
    if (this.frequency = t, this.power = e, this.positionAmount = i, this.rotationAmount = n, this.type = "Noise", this.duration = 0, Ot.length === 0)
      for (let o = 0; o < 100; o++)
        Ot.push(new $l());
  }
  initialize(t) {
    t.lastPosNoise = new Y(), typeof t.rotation == "number" ? t.lastRotNoise = 0 : t.lastRotNoise = new w(), t.generatorIndex = [zs(0, 100), zs(0, 100), zs(0, 100), zs(0, 100)], this.positionAmount.startGen(t.memory), this.rotationAmount.startGen(t.memory), this.frequency.startGen(t.memory), this.power.startGen(t.memory);
  }
  update(t, e) {
    let i = this.frequency.genValue(t.memory, t.age / t.life), n = this.power.genValue(t.memory, t.age / t.life), o = this.positionAmount.genValue(t.memory, t.age / t.life), r = this.rotationAmount.genValue(t.memory, t.age / t.life);
    o > 0 && t.lastPosNoise !== void 0 && (t.position.sub(t.lastPosNoise), vn.set(Ot[t.generatorIndex[0]].noise2D(0, t.age * i) * n * o, Ot[t.generatorIndex[1]].noise2D(0, t.age * i) * n * o, Ot[t.generatorIndex[2]].noise2D(0, t.age * i) * n * o), t.position.add(vn), t.lastPosNoise.copy(vn)), r > 0 && t.lastRotNoise !== void 0 && (typeof t.rotation == "number" ? (t.rotation -= t.lastRotNoise, t.rotation += Ot[t.generatorIndex[3]].noise2D(0, t.age * i) * Math.PI * n * r) : (t.lastRotNoise.invert(), t.rotation.multiply(t.lastRotNoise), Kn.set(Ot[t.generatorIndex[0]].noise2D(0, t.age * i) * n * r, Ot[t.generatorIndex[1]].noise2D(0, t.age * i) * n * r, Ot[t.generatorIndex[2]].noise2D(0, t.age * i) * n * r, Ot[t.generatorIndex[3]].noise2D(0, t.age * i) * n * r).normalize(), t.rotation.multiply(Kn), t.lastRotNoise.copy(Kn)));
  }
  toJSON() {
    return {
      type: this.type,
      frequency: this.frequency.toJSON(),
      power: this.power.toJSON(),
      positionAmount: this.positionAmount.toJSON(),
      rotationAmount: this.rotationAmount.toJSON()
    };
  }
  frameUpdate(t) {
    this.duration += t;
  }
  static fromJSON(t) {
    return new ms(I(t.frequency), I(t.power), I(t.positionAmount), I(t.rotationAmount));
  }
  clone() {
    return new ms(this.frequency.clone(), this.power.clone(), this.positionAmount.clone(), this.rotationAmount.clone());
  }
  reset() {
  }
}
class bs {
  constructor(t, e) {
    this.color = t, this.speedRange = e, this.type = "ColorBySpeed";
  }
  initialize(t) {
    this.color.startGen(t.memory);
  }
  update(t, e) {
    const i = (t.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
    this.color.genColor(t.memory, t.color, i), t.color.x *= t.startColor.x, t.color.y *= t.startColor.y, t.color.z *= t.startColor.z, t.color.w *= t.startColor.w;
  }
  frameUpdate(t) {
  }
  toJSON() {
    return {
      type: this.type,
      color: this.color.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(t) {
    return new bs(vo(t.color), we.fromJSON(t.speedRange));
  }
  clone() {
    return new bs(this.color.clone(), this.speedRange.clone());
  }
  reset() {
  }
}
class ys {
  initialize(t) {
    this.size.startGen(t.memory);
  }
  constructor(t, e) {
    this.size = t, this.speedRange = e, this.type = "SizeBySpeed";
  }
  update(t) {
    const e = (t.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
    this.size instanceof Be ? this.size.genValue(t.memory, t.size, e).multiply(t.startSize) : t.size.copy(t.startSize).multiplyScalar(this.size.genValue(t.memory, e));
  }
  toJSON() {
    return {
      type: this.type,
      size: this.size.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(t) {
    return new ys(hn(t.size), we.fromJSON(t.speedRange));
  }
  frameUpdate(t) {
  }
  clone() {
    return new ys(this.size.clone(), this.speedRange.clone());
  }
  reset() {
  }
}
class Gs {
  constructor(t, e) {
    this.angularVelocity = t, this.speedRange = e, this.type = "RotationBySpeed", this.tempQuat = new w();
  }
  initialize(t) {
    typeof t.rotation == "number" && this.angularVelocity.startGen(t.memory);
  }
  update(t, e) {
    if (typeof t.rotation == "number") {
      const i = (t.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);
      t.rotation += e * this.angularVelocity.genValue(t.memory, i);
    }
  }
  toJSON() {
    return {
      type: this.type,
      angularVelocity: this.angularVelocity.toJSON(),
      speedRange: this.speedRange.toJSON()
    };
  }
  static fromJSON(t) {
    return new Gs(I(t.angularVelocity), we.fromJSON(t.speedRange));
  }
  frameUpdate(t) {
  }
  clone() {
    return new Gs(this.angularVelocity.clone(), this.speedRange.clone());
  }
  reset() {
  }
}
class Zs {
  initialize(t) {
    this.speed.startGen(t.memory);
  }
  constructor(t, e) {
    this.speed = t, this.dampen = e, this.type = "LimitSpeedOverLife";
  }
  update(t, e) {
    let i = t.velocity.length(), n = this.speed.genValue(t.memory, t.age / t.life);
    if (i > n) {
      const o = (i - n) / i;
      t.velocity.multiplyScalar(1 - o * this.dampen * e * 20);
    }
  }
  toJSON() {
    return {
      type: this.type,
      speed: this.speed.toJSON(),
      dampen: this.dampen
    };
  }
  static fromJSON(t) {
    return new Zs(I(t.speed), t.dampen);
  }
  frameUpdate(t) {
  }
  clone() {
    return new Zs(this.speed.clone(), this.dampen);
  }
  reset() {
  }
}
const un = {
  ApplyForce: {
    type: "ApplyForce",
    constructor: as,
    params: [
      ["direction", ["vec3"]],
      ["magnitude", ["value"]]
    ],
    loadJSON: as.fromJSON
  },
  Noise: {
    type: "Noise",
    constructor: ms,
    params: [
      ["frequency", ["value"]],
      ["power", ["value"]],
      ["positionAmount", ["value"]],
      ["rotationAmount", ["value"]]
    ],
    loadJSON: ms.fromJSON
  },
  TurbulenceField: {
    type: "TurbulenceField",
    constructor: ps,
    params: [
      ["scale", ["vec3"]],
      ["octaves", ["number"]],
      ["velocityMultiplier", ["vec3"]],
      ["timeScale", ["vec3"]]
    ],
    loadJSON: ps.fromJSON
  },
  GravityForce: {
    type: "GravityForce",
    constructor: ds,
    params: [
      ["center", ["vec3"]],
      ["magnitude", ["number"]]
    ],
    loadJSON: ds.fromJSON
  },
  ColorOverLife: {
    type: "ColorOverLife",
    constructor: ts,
    params: [["color", ["colorFunc"]]],
    loadJSON: ts.fromJSON
  },
  RotationOverLife: {
    type: "RotationOverLife",
    constructor: es,
    params: [["angularVelocity", ["value", "valueFunc"]]],
    loadJSON: es.fromJSON
  },
  Rotation3DOverLife: {
    type: "Rotation3DOverLife",
    constructor: is,
    params: [["angularVelocity", ["rotationFunc"]]],
    loadJSON: is.fromJSON
  },
  SizeOverLife: {
    type: "SizeOverLife",
    constructor: ns,
    params: [["size", ["value", "valueFunc", "vec3Func"]]],
    loadJSON: ns.fromJSON
  },
  ColorBySpeed: {
    type: "ColorBySpeed",
    constructor: bs,
    params: [
      ["color", ["colorFunc"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: bs.fromJSON
  },
  RotationBySpeed: {
    type: "RotationBySpeed",
    constructor: Gs,
    params: [
      ["angularVelocity", ["value", "valueFunc"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: Gs.fromJSON
  },
  SizeBySpeed: {
    type: "SizeBySpeed",
    constructor: ys,
    params: [
      ["size", ["value", "valueFunc", "vec3Func"]],
      ["speedRange", ["range"]]
    ],
    loadJSON: ys.fromJSON
  },
  SpeedOverLife: {
    type: "SpeedOverLife",
    constructor: os,
    params: [["speed", ["value", "valueFunc"]]],
    loadJSON: os.fromJSON
  },
  FrameOverLife: {
    type: "FrameOverLife",
    constructor: rs,
    params: [["frame", ["value", "valueFunc"]]],
    loadJSON: rs.fromJSON
  },
  ForceOverLife: {
    type: "ForceOverLife",
    constructor: ss,
    params: [
      ["x", ["value", "valueFunc"]],
      ["y", ["value", "valueFunc"]],
      ["z", ["value", "valueFunc"]]
    ],
    loadJSON: ss.fromJSON
  },
  OrbitOverLife: {
    type: "OrbitOverLife",
    constructor: ls,
    params: [
      ["orbitSpeed", ["value", "valueFunc"]],
      ["axis", ["vec3"]]
    ],
    loadJSON: ls.fromJSON
  },
  WidthOverLength: {
    type: "WidthOverLength",
    constructor: cs,
    params: [["width", ["value", "valueFunc"]]],
    loadJSON: cs.fromJSON
  },
  ChangeEmitDirection: {
    type: "ChangeEmitDirection",
    constructor: hs,
    params: [["angle", ["value"]]],
    loadJSON: hs.fromJSON
  },
  EmitSubParticleSystem: {
    type: "EmitSubParticleSystem",
    constructor: us,
    params: [
      ["particleSystem", ["self"]],
      ["useVelocityAsBasis", ["boolean"]],
      ["subParticleSystem", ["particleSystem"]],
      ["mode", ["number"]],
      ["emitProbability", ["number"]]
    ],
    loadJSON: us.fromJSON
  },
  LimitSpeedOverLife: {
    type: "LimitSpeedOverLife",
    constructor: Zs,
    params: [
      ["speed", ["value", "valueFunc"]],
      ["dampen", ["number"]]
    ],
    loadJSON: Zs.fromJSON
  }
};
function Xd(s, t) {
  return un[s.type] ? un[s.type].loadJSON(s, t) : null;
}
const fd = [];
function Vd(s) {
  if (!fd.find((e) => e.id === s.id)) {
    s.initialize();
    for (const e of s.emitterShapes)
      co[e.type] || (co[e.type] = e);
    for (const e of s.behaviors)
      un[e.type] || (un[e.type] = e);
  }
}
var Rd = `
#ifdef SOFT_PARTICLES

    /* #ifdef LOGDEPTH
    float distSample = linearize_depth_log(sampleDepth, near, far);
    #else
    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);
    #endif */

    vec2 p2 = projPosition.xy / projPosition.w;
    
    p2 = 0.5 * p2 + 0.5;

    float readDepth = texture2D(depthTexture, p2.xy).r;
    float viewDepth = linearize_depth(readDepth);

    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));
    
    gl_FragColor *= softParticlesFade;

    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);
#endif
`, xd = `
#ifdef SOFT_PARTICLES

    uniform sampler2D depthTexture;
    uniform vec4 projParams;
    uniform vec2 softParams;

    varying vec4 projPosition;
    varying float linearDepth;

    #define SOFT_NEAR_FADE softParams.x
    #define SOFT_INV_FADE_DISTANCE softParams.y

    #define zNear projParams.x
    #define zFar projParams.y

    float linearize_depth(float d)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }

#endif
`, Ld = `
#ifdef SOFT_PARTICLES
    varying vec4 projPosition;
    varying float linearDepth;
#endif
`, Sd = `
#ifdef SOFT_PARTICLES
    projPosition = gl_Position;
    linearDepth = -mvPosition.z;
#endif
`, Wd = `
#ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv);
    #ifdef TILE_BLEND
        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );
    #endif
    diffuseColor *= texelColor;
#endif
`, Cd = `
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;
#ifdef TILE_BLEND
    varying vec2 vUvNext;
    varying float vUvBlend;
#endif

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#ifdef TILE_BLEND
    varying vec2 vMapUvNext;
#endif

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`, gd = `
#ifdef UV_TILE
    attribute float uvTile;
    uniform vec2 tileCount;
    
    mat3 makeTileTransform(float uvTile) {
        float col = mod(uvTile, tileCount.x);
        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);
        
        return mat3(
          1.0 / tileCount.x, 0.0, 0.0,
          0.0, 1.0 / tileCount.y, 0.0, 
          col / tileCount.x, row / tileCount.y, 1.0);
    }
#else
    mat3 makeTileTransform(float uvTile) {
        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    }
#endif

#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;
#ifdef TILE_BLEND
    varying vec2 vUvNext;
    varying float vUvBlend;
#endif

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#ifdef TILE_BLEND
    varying vec2 vMapUvNext;
#endif

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`, zd = `
#ifdef UV_TILE
    mat3 tileTransform = makeTileTransform(floor(uvTile));
    #ifdef TILE_BLEND
        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));
        vUvBlend = fract(uvTile);
    #endif
#else
    mat3 tileTransform = makeTileTransform(0.0);
#endif

#if defined( USE_UV ) || defined( USE_ANISOTROPY )

vUv = (tileTransform *vec3( uv, 1 )).xy;
#if defined( TILE_BLEND ) && defined( UV_TILE )
    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;
#endif

#endif
#ifdef USE_MAP

vMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;
#if defined( TILE_BLEND ) && defined( UV_TILE )
    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;
#endif

#endif
#ifdef USE_ALPHAMAP

vAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;
    
#endif
#ifdef USE_LIGHTMAP

vLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_AOMAP

vAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_BUMPMAP

vBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_NORMALMAP

vNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_DISPLACEMENTMAP

vDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_EMISSIVEMAP

vEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_METALNESSMAP

vMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_ROUGHNESSMAP

vRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_ANISOTROPYMAP

vAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOATMAP

vClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

vClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

vClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_IRIDESCENCEMAP

vIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

vIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SHEEN_COLORMAP

vSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

vSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULARMAP

vSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULAR_COLORMAP

vSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

vSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_TRANSMISSIONMAP

vTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;

#endif
#ifdef USE_THICKNESSMAP

vThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;

#endif

`;
const ye = fc;
function vd() {
  ye.tile_pars_vertex = gd, ye.tile_vertex = zd, ye.tile_pars_fragment = Cd, ye.tile_fragment = Wd, ye.soft_pars_vertex = Ld, ye.soft_vertex = Sd, ye.soft_pars_fragment = xd, ye.soft_fragment = Rd;
}
class Kd extends Lo {
  constructor(t) {
    super(), this.type = "ParticleEmitter", this.system = t;
  }
  clone() {
    const t = this.system.clone();
    return t.emitter.copy(this, !0), t.emitter;
  }
  dispose() {
  }
  extractFromCache(t) {
    const e = [];
    for (const i in t) {
      const n = t[i];
      delete n.metadata, e.push(n);
    }
    return e;
  }
  toJSON(t, e = {}) {
    const i = this.children;
    this.children = this.children.filter((o) => o.type !== "ParticleSystemPreview");
    const n = super.toJSON(t);
    return this.children = i, this.system !== null && (n.object.ps = this.system.toJSON(t, e)), n;
  }
}
var K;
(function(s) {
  s[s.BillBoard = 0] = "BillBoard", s[s.StretchedBillBoard = 1] = "StretchedBillBoard", s[s.Mesh = 2] = "Mesh", s[s.Trail = 3] = "Trail", s[s.HorizontalBillBoard = 4] = "HorizontalBillBoard", s[s.VerticalBillBoard = 5] = "VerticalBillBoard";
})(K || (K = {}));
class tc extends mn {
  constructor(t) {
    super(), this.type = "VFXBatch", this.maxParticles = 1e3, this.systems = /* @__PURE__ */ new Set();
    const e = new _s();
    e.mask = t.layers.mask;
    const i = t.material.clone();
    i.defines = {}, Object.assign(i.defines, t.material.defines), this.settings = {
      instancingGeometry: t.instancingGeometry,
      renderMode: t.renderMode,
      renderOrder: t.renderOrder,
      material: i,
      uTileCount: t.uTileCount,
      vTileCount: t.vTileCount,
      blendTiles: t.blendTiles,
      softParticles: t.softParticles,
      softNearFade: t.softNearFade,
      softFarFade: t.softFarFade,
      layers: e
    }, this.frustumCulled = !1, this.renderOrder = this.settings.renderOrder;
  }
  addSystem(t) {
    this.systems.add(t);
  }
  removeSystem(t) {
    this.systems.delete(t);
  }
  applyDepthTexture(t) {
    const e = this.material.uniforms.depthTexture;
    e && e.value !== t && (e.value = t, this.material.needsUpdate = !0);
  }
}
const Td = new Y(0, 0, 1), Tn = new w(), Md = new Y(), Yd = new Y();
new Y();
const fr = 60, kd = new Or(1, 1, 1, 1);
class ho {
  set time(t) {
    this.emissionState.time = t;
  }
  get time() {
    return this.emissionState.time;
  }
  get layers() {
    return this.rendererSettings.layers;
  }
  get texture() {
    return this.rendererSettings.material.map;
  }
  set texture(t) {
    this.rendererSettings.material.map = t, this.neededToUpdateRender = !0;
  }
  get material() {
    return this.rendererSettings.material;
  }
  set material(t) {
    this.rendererSettings.material = t, this.neededToUpdateRender = !0;
  }
  get uTileCount() {
    return this.rendererSettings.uTileCount;
  }
  set uTileCount(t) {
    this.rendererSettings.uTileCount = t, this.neededToUpdateRender = !0;
  }
  get vTileCount() {
    return this.rendererSettings.vTileCount;
  }
  set vTileCount(t) {
    this.rendererSettings.vTileCount = t, this.neededToUpdateRender = !0;
  }
  get blendTiles() {
    return this.rendererSettings.blendTiles;
  }
  set blendTiles(t) {
    this.rendererSettings.blendTiles = t, this.neededToUpdateRender = !0;
  }
  get softParticles() {
    return this.rendererSettings.softParticles;
  }
  set softParticles(t) {
    this.rendererSettings.softParticles = t, this.neededToUpdateRender = !0;
  }
  get softNearFade() {
    return this.rendererSettings.softNearFade;
  }
  set softNearFade(t) {
    this.rendererSettings.softNearFade = t, this.neededToUpdateRender = !0;
  }
  get softFarFade() {
    return this.rendererSettings.softFarFade;
  }
  set softFarFade(t) {
    this.rendererSettings.softFarFade = t, this.neededToUpdateRender = !0;
  }
  get instancingGeometry() {
    return this.rendererSettings.instancingGeometry;
  }
  set instancingGeometry(t) {
    this.restart(), this.particles.length = 0, this.rendererSettings.instancingGeometry = t, this.neededToUpdateRender = !0;
  }
  get renderMode() {
    return this.rendererSettings.renderMode;
  }
  set renderMode(t) {
    if ((this.rendererSettings.renderMode != K.Trail && t === K.Trail || this.rendererSettings.renderMode == K.Trail && t !== K.Trail) && (this.restart(), this.particles.length = 0), this.rendererSettings.renderMode !== t)
      switch (t) {
        case K.Trail:
          this.rendererEmitterSettings = {
            startLength: new Q(30),
            followLocalOrigin: !1
          };
          break;
        case K.Mesh:
          this.rendererEmitterSettings = {
            geometry: new Or(1, 1)
          }, this.startRotation = new ji(new Y(0, 1, 0), new Q(0));
          break;
        case K.StretchedBillBoard:
          this.rendererEmitterSettings = { speedFactor: 0, lengthFactor: 2 }, this.rendererSettings.renderMode === K.Mesh && (this.startRotation = new Q(0));
          break;
        case K.BillBoard:
        case K.VerticalBillBoard:
        case K.HorizontalBillBoard:
          this.rendererEmitterSettings = {}, this.rendererSettings.renderMode === K.Mesh && (this.startRotation = new Q(0));
          break;
      }
    this.rendererSettings.renderMode = t, this.neededToUpdateRender = !0;
  }
  get renderOrder() {
    return this.rendererSettings.renderOrder;
  }
  set renderOrder(t) {
    this.rendererSettings.renderOrder = t, this.neededToUpdateRender = !0;
  }
  get blending() {
    return this.rendererSettings.material.blending;
  }
  set blending(t) {
    this.rendererSettings.material.blending = t, this.neededToUpdateRender = !0;
  }
  constructor(t) {
    var e, i, n, o, r, c, l, a, d, h, u, p, m, b, G, y, Z, f, V, X, R, x, S, C, L, g;
    if (this.temp = new Y(), this.travelDistance = 0, this.normalMatrix = new At(), this.memory = [], this.listeners = {}, this.firstTimeUpdate = !0, this.autoDestroy = t.autoDestroy === void 0 ? !1 : t.autoDestroy, this.duration = (e = t.duration) !== null && e !== void 0 ? e : 1, this.looping = t.looping === void 0 ? !0 : t.looping, this.prewarm = t.prewarm === void 0 ? !1 : t.prewarm, this.startLife = (i = t.startLife) !== null && i !== void 0 ? i : new Q(5), this.startSpeed = (n = t.startSpeed) !== null && n !== void 0 ? n : new Q(0), this.startRotation = (o = t.startRotation) !== null && o !== void 0 ? o : new Q(0), this.startSize = (r = t.startSize) !== null && r !== void 0 ? r : new Q(1), this.startColor = (c = t.startColor) !== null && c !== void 0 ? c : new ci(new Tt(1, 1, 1, 1)), this.emissionOverTime = (l = t.emissionOverTime) !== null && l !== void 0 ? l : new Q(10), this.emissionOverDistance = (a = t.emissionOverDistance) !== null && a !== void 0 ? a : new Q(0), this.emissionBursts = (d = t.emissionBursts) !== null && d !== void 0 ? d : [], this.onlyUsedByOther = (h = t.onlyUsedByOther) !== null && h !== void 0 ? h : !1, this.emitterShape = (u = t.shape) !== null && u !== void 0 ? u : new ai(), this.behaviors = (p = t.behaviors) !== null && p !== void 0 ? p : new Array(), this.worldSpace = (m = t.worldSpace) !== null && m !== void 0 ? m : !1, this.rendererEmitterSettings = (b = t.rendererEmitterSettings) !== null && b !== void 0 ? b : {}, t.renderMode === K.StretchedBillBoard) {
      const W = this.rendererEmitterSettings;
      t.speedFactor !== void 0 && (W.speedFactor = t.speedFactor), W.speedFactor = (G = W.speedFactor) !== null && G !== void 0 ? G : 0, W.lengthFactor = (y = W.lengthFactor) !== null && y !== void 0 ? y : 0;
    }
    this.rendererSettings = {
      instancingGeometry: (Z = t.instancingGeometry) !== null && Z !== void 0 ? Z : kd,
      renderMode: (f = t.renderMode) !== null && f !== void 0 ? f : K.BillBoard,
      renderOrder: (V = t.renderOrder) !== null && V !== void 0 ? V : 0,
      material: t.material,
      uTileCount: (X = t.uTileCount) !== null && X !== void 0 ? X : 1,
      vTileCount: (R = t.vTileCount) !== null && R !== void 0 ? R : 1,
      blendTiles: (x = t.blendTiles) !== null && x !== void 0 ? x : !1,
      softParticles: (S = t.softParticles) !== null && S !== void 0 ? S : !1,
      softNearFade: (C = t.softNearFade) !== null && C !== void 0 ? C : 0,
      softFarFade: (L = t.softFarFade) !== null && L !== void 0 ? L : 0,
      layers: (g = t.layers) !== null && g !== void 0 ? g : new _s()
    }, this.neededToUpdateRender = !0, this.particles = new Array(), this.startTileIndex = t.startTileIndex || new Q(0), this.emitter = new Kd(this), this.paused = !1, this.particleNum = 0, this.emissionState = {
      isBursting: !1,
      burstParticleIndex: 0,
      burstParticleCount: 0,
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0,
      travelDistance: 0
    }, this.emissionBursts.forEach((W) => W.count.startGen(this.memory)), this.emissionOverDistance.startGen(this.memory), this.emitEnded = !1, this.markForDestroy = !1, this.prewarmed = !1;
  }
  pause() {
    this.paused = !0;
  }
  play() {
    this.paused = !1;
  }
  stop() {
    this.restart(), this.pause();
  }
  spawn(t, e, i) {
    Tn.setFromRotationMatrix(i);
    const n = Md, o = Tn, r = Yd;
    i.decompose(n, o, r);
    for (let c = 0; c < t; c++) {
      for (e.burstParticleIndex = c, this.particleNum++; this.particles.length < this.particleNum; )
        this.rendererSettings.renderMode === K.Trail ? this.particles.push(new ao()) : this.particles.push(new hd());
      const l = this.particles[this.particleNum - 1];
      if (l.reset(), l.speedModifier = 1, this.startColor.startGen(l.memory), this.startColor.genColor(l.memory, l.startColor, this.emissionState.time), l.color.copy(l.startColor), this.startSpeed.startGen(l.memory), l.startSpeed = this.startSpeed.genValue(l.memory, e.time / this.duration), this.startLife.startGen(l.memory), l.life = this.startLife.genValue(l.memory, e.time / this.duration), l.age = 0, this.startSize.startGen(l.memory), this.startSize.type === "vec3function")
        this.startSize.genValue(l.memory, l.startSize, e.time / this.duration);
      else {
        const a = this.startSize.genValue(l.memory, e.time / this.duration);
        l.startSize.set(a, a, a);
      }
      if (this.startTileIndex.startGen(l.memory), l.uvTile = this.startTileIndex.genValue(l.memory), l.size.copy(l.startSize), this.rendererSettings.renderMode === K.Mesh || this.rendererSettings.renderMode === K.BillBoard || this.rendererSettings.renderMode === K.VerticalBillBoard || this.rendererSettings.renderMode === K.HorizontalBillBoard || this.rendererSettings.renderMode === K.StretchedBillBoard) {
        const a = l;
        this.startRotation.startGen(l.memory), this.rendererSettings.renderMode === K.Mesh ? (a.rotation instanceof w || (a.rotation = new w()), this.startRotation.type === "rotation" ? this.startRotation.genValue(l.memory, a.rotation, 1, e.time / this.duration) : a.rotation.setFromAxisAngle(Td, this.startRotation.genValue(a.memory, e.time / this.duration))) : this.startRotation.type === "rotation" ? a.rotation = 0 : a.rotation = this.startRotation.genValue(a.memory, e.time / this.duration);
      } else if (this.rendererSettings.renderMode === K.Trail) {
        const a = l;
        this.rendererEmitterSettings.startLength.startGen(a.memory), a.length = this.rendererEmitterSettings.startLength.genValue(a.memory, e.time / this.duration);
      }
      if (this.emitterShape.initialize(l, e), this.rendererSettings.renderMode === K.Trail && this.rendererEmitterSettings.followLocalOrigin) {
        const a = l;
        a.localPosition = new Y().copy(a.position);
      }
      this.worldSpace ? (l.position.applyMatrix4(i), l.startSize.multiply(r).abs(), l.size.copy(l.startSize), l.velocity.multiply(r).applyMatrix3(this.normalMatrix), l.rotation && l.rotation instanceof w && l.rotation.multiplyQuaternions(Tn, l.rotation)) : this.onlyUsedByOther && (l.parentMatrix = i);
      for (let a = 0; a < this.behaviors.length; a++)
        this.behaviors[a].initialize(l, this);
    }
  }
  endEmit() {
    this.emitEnded = !0, this.autoDestroy && (this.markForDestroy = !0), this.fire({ type: "emitEnd", particleSystem: this });
  }
  dispose() {
    this._renderer && this._renderer.deleteSystem(this), this.emitter.dispose(), this.emitter.parent && this.emitter.parent.remove(this.emitter), this.fire({ type: "destroy", particleSystem: this });
  }
  restart() {
    this.memory.length = 0, this.paused = !1, this.particleNum = 0, this.emissionState.isBursting = !1, this.emissionState.burstIndex = 0, this.emissionState.burstWaveIndex = 0, this.emissionState.time = 0, this.emissionState.waitEmiting = 0, this.behaviors.forEach((t) => {
      t.reset();
    }), this.emitEnded = !1, this.markForDestroy = !1, this.prewarmed = !1, this.emissionBursts.forEach((t) => t.count.startGen(this.memory)), this.emissionOverDistance.startGen(this.memory);
  }
  update(t) {
    if (this.paused)
      return;
    let e = this.emitter;
    for (; e.parent; )
      e = e.parent;
    if (e.type !== "Scene") {
      this.dispose();
      return;
    }
    if (this.firstTimeUpdate && (this.firstTimeUpdate = !1, this.emitter.updateWorldMatrix(!0, !1)), this.emitEnded && this.particleNum === 0) {
      this.markForDestroy && this.emitter.parent && this.dispose();
      return;
    }
    if (this.looping && this.prewarm && !this.prewarmed) {
      this.prewarmed = !0;
      for (let i = 0; i < this.duration * fr; i++)
        this.update(1 / fr);
    }
    t > 0.1 && (t = 0.1), this.neededToUpdateRender && (this._renderer && this._renderer.updateSystem(this), this.neededToUpdateRender = !1), this.onlyUsedByOther || this.emit(t, this.emissionState, this.emitter.matrixWorld), this.emitterShape.update(this, t);
    for (let i = 0; i < this.behaviors.length; i++) {
      this.behaviors[i].frameUpdate(t);
      for (let n = 0; n < this.particleNum; n++)
        this.particles[n].died || this.behaviors[i].update(this.particles[n], t);
    }
    for (let i = 0; i < this.particleNum; i++)
      this.rendererEmitterSettings.followLocalOrigin && this.particles[i].localPosition ? (this.particles[i].position.copy(this.particles[i].localPosition), this.particles[i].parentMatrix ? this.particles[i].position.applyMatrix4(this.particles[i].parentMatrix) : this.particles[i].position.applyMatrix4(this.emitter.matrixWorld)) : this.particles[i].position.addScaledVector(this.particles[i].velocity, t * this.particles[i].speedModifier), this.particles[i].age += t;
    if (this.rendererSettings.renderMode === K.Trail)
      for (let i = 0; i < this.particleNum; i++)
        this.particles[i].update();
    for (let i = 0; i < this.particleNum; i++) {
      const n = this.particles[i];
      n.died && (!(n instanceof ao) || n.previous.length === 0) && (this.particles[i] = this.particles[this.particleNum - 1], this.particles[this.particleNum - 1] = n, this.particleNum--, i--, this.fire({ type: "particleDied", particleSystem: this, particle: n }));
    }
  }
  emit(t, e, i) {
    e.time > this.duration && (this.looping ? (e.time -= this.duration, e.burstIndex = 0, this.behaviors.forEach((o) => {
      o.reset();
    })) : !this.emitEnded && !this.onlyUsedByOther && this.endEmit()), this.normalMatrix.getNormalMatrix(i);
    const n = Math.ceil(e.waitEmiting);
    for (this.spawn(n, e, i), e.waitEmiting -= n; e.burstIndex < this.emissionBursts.length && this.emissionBursts[e.burstIndex].time <= e.time; ) {
      if (Math.random() < this.emissionBursts[e.burstIndex].probability) {
        const o = this.emissionBursts[e.burstIndex].count.genValue(this.memory, this.time);
        e.isBursting = !0, e.burstParticleCount = o, this.spawn(o, e, i), e.isBursting = !1;
      }
      e.burstIndex++;
    }
    if (!this.emitEnded && (e.waitEmiting += t * this.emissionOverTime.genValue(this.memory, e.time / this.duration), e.previousWorldPos != null)) {
      this.temp.set(i.elements[12], i.elements[13], i.elements[14]), e.travelDistance += e.previousWorldPos.distanceTo(this.temp);
      const o = this.emissionOverDistance.genValue(this.memory, e.time / this.duration);
      if (e.travelDistance * o > 0) {
        const r = Math.floor(e.travelDistance * o);
        e.travelDistance -= r / o, e.waitEmiting += r;
      }
    }
    e.previousWorldPos === void 0 && (e.previousWorldPos = new Y()), e.previousWorldPos.set(i.elements[12], i.elements[13], i.elements[14]), e.time += t;
  }
  toJSON(t, e = {}) {
    var i;
    if ((t === void 0 || typeof t == "string") && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }), t.materials[this.rendererSettings.material.uuid] = this.rendererSettings.material.toJSON(t), e.useUrlForImage && ((i = this.texture) === null || i === void 0 ? void 0 : i.source) !== void 0) {
      const c = this.texture.source;
      t.images[c.uuid] = {
        uuid: c.uuid,
        url: this.texture.image.url
      };
    }
    let o;
    this.renderMode === K.Trail ? o = {
      startLength: this.rendererEmitterSettings.startLength.toJSON(),
      followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin
    } : this.renderMode === K.Mesh ? o = {} : this.renderMode === K.StretchedBillBoard ? o = {
      speedFactor: this.rendererEmitterSettings.speedFactor,
      lengthFactor: this.rendererEmitterSettings.lengthFactor
    } : o = {};
    const r = this.rendererSettings.instancingGeometry;
    return t.geometries && !t.geometries[r.uuid] && (t.geometries[r.uuid] = r.toJSON()), {
      version: "3.0",
      autoDestroy: this.autoDestroy,
      looping: this.looping,
      prewarm: this.prewarm,
      duration: this.duration,
      shape: this.emitterShape.toJSON(),
      startLife: this.startLife.toJSON(),
      startSpeed: this.startSpeed.toJSON(),
      startRotation: this.startRotation.toJSON(),
      startSize: this.startSize.toJSON(),
      startColor: this.startColor.toJSON(),
      emissionOverTime: this.emissionOverTime.toJSON(),
      emissionOverDistance: this.emissionOverDistance.toJSON(),
      emissionBursts: this.emissionBursts.map((c) => ({
        time: c.time,
        count: c.count.toJSON(),
        probability: c.probability,
        interval: c.interval,
        cycle: c.cycle
      })),
      onlyUsedByOther: this.onlyUsedByOther,
      instancingGeometry: this.rendererSettings.instancingGeometry.uuid,
      renderOrder: this.renderOrder,
      renderMode: this.renderMode,
      rendererEmitterSettings: o,
      material: this.rendererSettings.material.uuid,
      layers: this.layers.mask,
      startTileIndex: this.startTileIndex.toJSON(),
      uTileCount: this.uTileCount,
      vTileCount: this.vTileCount,
      blendTiles: this.blendTiles,
      softParticles: this.rendererSettings.softParticles,
      softFarFade: this.rendererSettings.softFarFade,
      softNearFade: this.rendererSettings.softNearFade,
      behaviors: this.behaviors.map((c) => c.toJSON()),
      worldSpace: this.worldSpace
    };
  }
  static fromJSON(t, e, i) {
    var n, o;
    const r = ad(t.shape, e);
    let c;
    if (t.renderMode === K.Trail) {
      const d = t.rendererEmitterSettings;
      c = {
        startLength: d.startLength != null ? I(d.startLength) : new Q(30),
        followLocalOrigin: d.followLocalOrigin
      };
    } else
      t.renderMode === K.Mesh ? c = {} : t.renderMode === K.StretchedBillBoard ? (c = t.rendererEmitterSettings, t.speedFactor != null && (c.speedFactor = t.speedFactor)) : c = {};
    const l = new _s();
    t.layers && (l.mask = t.layers);
    const a = new ho({
      autoDestroy: t.autoDestroy,
      looping: t.looping,
      prewarm: t.prewarm,
      duration: t.duration,
      shape: r,
      startLife: I(t.startLife),
      startSpeed: I(t.startSpeed),
      startRotation: hn(t.startRotation),
      startSize: hn(t.startSize),
      startColor: vo(t.startColor),
      emissionOverTime: I(t.emissionOverTime),
      emissionOverDistance: I(t.emissionOverDistance),
      emissionBursts: (n = t.emissionBursts) === null || n === void 0 ? void 0 : n.map((d) => {
        var h, u, p;
        return {
          time: d.time,
          count: typeof d.count == "number" ? new Q(d.count) : I(d.count),
          probability: (h = d.probability) !== null && h !== void 0 ? h : 1,
          interval: (u = d.interval) !== null && u !== void 0 ? u : 0.1,
          cycle: (p = d.cycle) !== null && p !== void 0 ? p : 1
        };
      }),
      onlyUsedByOther: t.onlyUsedByOther,
      instancingGeometry: e.geometries[t.instancingGeometry],
      renderMode: t.renderMode,
      rendererEmitterSettings: c,
      renderOrder: t.renderOrder,
      layers: l,
      material: t.material ? e.materials[t.material] : t.texture ? new En({
        map: e.textures[t.texture],
        transparent: (o = t.transparent) !== null && o !== void 0 ? o : !0,
        blending: t.blending,
        side: jn
      }) : new En({
        color: 16777215,
        transparent: !0,
        blending: _r,
        side: jn
      }),
      startTileIndex: typeof t.startTileIndex == "number" ? new Q(t.startTileIndex) : I(t.startTileIndex),
      uTileCount: t.uTileCount,
      vTileCount: t.vTileCount,
      blendTiles: t.blendTiles,
      softParticles: t.softParticles,
      softFarFade: t.softFarFade,
      softNearFade: t.softNearFade,
      behaviors: [],
      worldSpace: t.worldSpace
    });
    return a.behaviors = t.behaviors.map((d) => {
      const h = Xd(d, a);
      return h.type === "EmitSubParticleSystem" && (i[d.subParticleSystem] = h), h;
    }), a;
  }
  addBehavior(t) {
    this.behaviors.push(t);
  }
  getRendererSettings() {
    return this.rendererSettings;
  }
  addEventListener(t, e) {
    this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e);
  }
  removeAllEventListeners(t) {
    this.listeners[t] && (this.listeners[t] = []);
  }
  removeEventListener(t, e) {
    if (this.listeners[t]) {
      const i = this.listeners[t].indexOf(e);
      i !== -1 && this.listeners[t].splice(i, 1);
    }
  }
  fire(t) {
    this.listeners[t.type] && this.listeners[t.type].forEach((e) => e(t));
  }
  clone() {
    const t = [];
    for (const o of this.emissionBursts) {
      const r = {};
      Object.assign(r, o), t.push(r);
    }
    const e = [];
    for (const o of this.behaviors)
      e.push(o.clone());
    let i;
    this.renderMode === K.Trail ? i = {
      startLength: this.rendererEmitterSettings.startLength.clone(),
      followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin
    } : this.renderMode === K.StretchedBillBoard ? i = {
      lengthFactor: this.rendererEmitterSettings.lengthFactor,
      speedFactor: this.rendererEmitterSettings.speedFactor
    } : i = {};
    const n = new _s();
    return n.mask = this.layers.mask, new ho({
      autoDestroy: this.autoDestroy,
      looping: this.looping,
      duration: this.duration,
      shape: this.emitterShape.clone(),
      startLife: this.startLife.clone(),
      startSpeed: this.startSpeed.clone(),
      startRotation: this.startRotation.clone(),
      startSize: this.startSize.clone(),
      startColor: this.startColor.clone(),
      emissionOverTime: this.emissionOverTime.clone(),
      emissionOverDistance: this.emissionOverDistance.clone(),
      emissionBursts: t,
      onlyUsedByOther: this.onlyUsedByOther,
      instancingGeometry: this.rendererSettings.instancingGeometry,
      renderMode: this.renderMode,
      renderOrder: this.renderOrder,
      rendererEmitterSettings: i,
      material: this.rendererSettings.material,
      startTileIndex: this.startTileIndex,
      uTileCount: this.uTileCount,
      vTileCount: this.vTileCount,
      blendTiles: this.blendTiles,
      softParticles: this.softParticles,
      softFarFade: this.softFarFade,
      softNearFade: this.softNearFade,
      behaviors: e,
      worldSpace: this.worldSpace,
      layers: n
    });
  }
}
var Mn = `

#include <common>
#include <color_pars_fragment>
#include <map_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
#include <alphatest_pars_fragment>

#include <tile_pars_fragment>
#include <soft_pars_fragment>

void main() {

    #include <clipping_planes_fragment>
    
    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vColor;
    
    #include <logdepthbuf_fragment>
    
    #include <tile_fragment>
    #include <alphatest_fragment>

    outgoingLight = diffuseColor.rgb;
    
    #ifdef USE_COLOR_AS_ALPHA
    gl_FragColor = vec4( outgoingLight, diffuseColor.r );
    #else
    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    #endif
    
    #include <soft_fragment>
    #include <tonemapping_fragment>
}
`, Ko = `
#define STANDARD

#ifdef PHYSICAL
#define IOR
#define USE_SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
uniform float ior;
#endif

#ifdef USE_SPECULAR
uniform float specularIntensity;
uniform vec3 specularColor;

#ifdef USE_SPECULAR_COLORMAP
uniform sampler2D specularColorMap;
#endif

#ifdef USE_SPECULAR_INTENSITYMAP
uniform sampler2D specularIntensityMap;
#endif
#endif

#ifdef USE_CLEARCOAT
uniform float clearcoat;
uniform float clearcoatRoughness;
#endif

#ifdef USE_DISPERSION
uniform float dispersion;
#endif

#ifdef USE_IRIDESCENCE
uniform float iridescence;
uniform float iridescenceIOR;
uniform float iridescenceThicknessMinimum;
uniform float iridescenceThicknessMaximum;
#endif

#ifdef USE_SHEEN
uniform vec3 sheenColor;
uniform float sheenRoughness;

#ifdef USE_SHEEN_COLORMAP
uniform sampler2D sheenColorMap;
#endif

#ifdef USE_SHEEN_ROUGHNESSMAP
uniform sampler2D sheenRoughnessMap;
#endif
#endif

#ifdef USE_ANISOTROPY
uniform vec2 anisotropyVector;

#ifdef USE_ANISOTROPYMAP
uniform sampler2D anisotropyMap;
#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

vec4 diffuseColor = vec4( diffuse, opacity );
#include <clipping_planes_fragment>

ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
vec3 totalEmissiveRadiance = emissive;

#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <alphahash_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>

// accumulation
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>

// modulation
#include <aomap_fragment>

vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

#include <transmission_fragment>

vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

#ifdef USE_SHEEN

// Sheen energy compensation approximation calculation can be found at the end of
// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;

#endif

#ifdef USE_CLEARCOAT

float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );

vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;

#endif

#include <opaque_fragment>
#include <tonemapping_fragment>
#include <colorspace_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`, Hd = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute float rotation;
attribute vec3 size;

void main() {
	
    vec2 alignedPosition = position.xy * size.xy;
    
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
#ifdef HORIZONTAL
    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );
    mvPosition.x += rotatedPosition.x;
    mvPosition.z -= rotatedPosition.y;
    mvPosition = viewMatrix * mvPosition;
#elif defined(VERTICAL)
    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );
    mvPosition.y += rotatedPosition.y;
    mvPosition = viewMatrix * mvPosition;
    mvPosition.x += rotatedPosition.x;
#else
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    mvPosition.xy += rotatedPosition;
#endif

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>

	#include <clipping_planes_vertex>

	#include <tile_vertex>
	#include <soft_vertex>
}
`, Nd = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute vec4 rotation;
attribute vec3 size;
// attribute vec4 color;

void main() {

    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;
    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;
    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;
    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;
    float sx = size.x, sy = size.y, sz = size.z;
    
    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column
                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column
                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column
                      offset.x, offset.y, offset.z, 1.0);
    
    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
    #include <tile_vertex>
    #include <soft_vertex>
}
`, To = `
#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>

attribute vec3 offset;
attribute vec4 rotation;
attribute vec3 size;
#include <tile_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <tile_vertex>
    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;
    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;
    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;
    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;
    float sx = size.x, sy = size.y, sz = size.z;

    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column
                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column
                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column
                      offset.x, offset.y, offset.z, 1.0);

#include <color_vertex>
#include <morphinstance_vertex>
#include <morphcolor_vertex>
#include <batching_vertex>

#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>

	// replace defaultnormal_vertex
	vec3 transformedNormal = objectNormal;
    mat3 m = mat3( particleMatrix );
    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
    transformedNormal = m * transformedNormal;
    transformedNormal = normalMatrix * transformedNormal;
    #ifdef FLIP_SIDED
        transformedNormal = - transformedNormal;
    #endif
    #ifdef USE_TANGENT
        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
        #ifdef FLIP_SIDED
        transformedTangent = - transformedTangent;
        #endif
    #endif

	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>

	// replace include <project_vertex>
  vec4 mvPosition = vec4( transformed, 1.0 );
  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);
	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	
	vViewPosition = - mvPosition.xyz;
	
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
    vWorldPosition = worldPosition.xyz;
#endif
}
`, Id = `
#include <common>
#include <color_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#include <tile_pars_vertex>
#include <soft_pars_vertex>

attribute vec3 offset;
attribute float rotation;
attribute vec3 size;
attribute vec4 velocity;

uniform float speedFactor;

void main() {
    float lengthFactor = velocity.w;
    float avgSize = (size.x + size.y) * 0.5;
#ifdef USE_SKEW
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    vec3 viewVelocity = normalMatrix * velocity.xyz;

    vec3 scaledPos = vec3(position.xy * size.xy, position.z);
    float vlength = length(viewVelocity);
    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;
    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);
#else
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    vec3 viewVelocity = normalMatrix * velocity.xyz;
    float vlength = length(viewVelocity); 
    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation
    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation
#endif
	vColor = color;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <tile_vertex>
	#include <soft_vertex>
}
`;
function uo(s) {
  return s === 0 ? "uv" : `uv${s}`;
}
class Jd extends Rc {
  constructor(t) {
    super(t);
  }
  onBeforeCompile(t, e) {
    super.onBeforeCompile(t, e), t.vertexShader = To, t.fragmentShader = Ko;
  }
}
class Ud extends xc {
  constructor(t) {
    super(t);
  }
  onBeforeCompile(t, e) {
    super.onBeforeCompile(t, e), t.vertexShader = To, t.fragmentShader = Ko;
  }
}
class Pd extends tc {
  constructor(t) {
    super(t), this.vector_ = new Y(), this.vector2_ = new Y(), this.vector3_ = new Y(), this.quaternion_ = new w(), this.quaternion2_ = new w(), this.quaternion3_ = new w(), this.rotationMat_ = new At(), this.rotationMat2_ = new At(), this.maxParticles = 1e3, this.setupBuffers(), this.rebuildMaterial();
  }
  buildExpandableBuffers() {
    this.offsetBuffer = new Me(new Float32Array(this.maxParticles * 3), 3), this.offsetBuffer.setUsage(ft), this.geometry.setAttribute("offset", this.offsetBuffer), this.colorBuffer = new Me(new Float32Array(this.maxParticles * 4), 4), this.colorBuffer.setUsage(ft), this.geometry.setAttribute("color", this.colorBuffer), this.settings.renderMode === K.Mesh ? (this.rotationBuffer = new Me(new Float32Array(this.maxParticles * 4), 4), this.rotationBuffer.setUsage(ft), this.geometry.setAttribute("rotation", this.rotationBuffer)) : (this.settings.renderMode === K.BillBoard || this.settings.renderMode === K.HorizontalBillBoard || this.settings.renderMode === K.VerticalBillBoard || this.settings.renderMode === K.StretchedBillBoard) && (this.rotationBuffer = new Me(new Float32Array(this.maxParticles), 1), this.rotationBuffer.setUsage(ft), this.geometry.setAttribute("rotation", this.rotationBuffer)), this.sizeBuffer = new Me(new Float32Array(this.maxParticles * 3), 3), this.sizeBuffer.setUsage(ft), this.geometry.setAttribute("size", this.sizeBuffer), this.uvTileBuffer = new Me(new Float32Array(this.maxParticles), 1), this.uvTileBuffer.setUsage(ft), this.geometry.setAttribute("uvTile", this.uvTileBuffer), this.settings.renderMode === K.StretchedBillBoard && (this.velocityBuffer = new Me(new Float32Array(this.maxParticles * 4), 4), this.velocityBuffer.setUsage(ft), this.geometry.setAttribute("velocity", this.velocityBuffer));
  }
  setupBuffers() {
    this.geometry && this.geometry.dispose(), this.geometry = new Vc(), this.geometry.setIndex(this.settings.instancingGeometry.getIndex()), this.settings.instancingGeometry.hasAttribute("normal") && this.geometry.setAttribute("normal", this.settings.instancingGeometry.getAttribute("normal")), this.geometry.setAttribute("position", this.settings.instancingGeometry.getAttribute("position")), this.geometry.setAttribute("uv", this.settings.instancingGeometry.getAttribute("uv")), this.buildExpandableBuffers();
  }
  expandBuffers(t) {
    for (; t >= this.maxParticles; )
      this.maxParticles *= 2;
    this.setupBuffers();
  }
  rebuildMaterial() {
    this.layers.mask = this.settings.layers.mask;
    const t = {}, e = {};
    this.settings.material.type !== "MeshStandardMaterial" && this.settings.material.type !== "MeshPhysicalMaterial" && (t.map = new Qt(this.settings.material.map)), this.settings.material.alphaTest && (e.USE_ALPHATEST = "", t.alphaTest = new Qt(this.settings.material.alphaTest)), e.USE_UV = "";
    const i = this.settings.uTileCount, n = this.settings.vTileCount;
    (i > 1 || n > 1) && (e.UV_TILE = "", t.tileCount = new Qt(new ri(i, n))), this.settings.material.defines && this.settings.material.defines.USE_COLOR_AS_ALPHA !== void 0 && (e.USE_COLOR_AS_ALPHA = ""), this.settings.material.normalMap && (e.USE_NORMALMAP = "", e.NORMALMAP_UV = uo(this.settings.material.normalMap.channel), t.normalMapTransform = new Qt(new At().copy(this.settings.material.normalMap.matrix))), this.settings.material.map && (e.USE_MAP = "", this.settings.blendTiles && (e.TILE_BLEND = ""), e.MAP_UV = uo(this.settings.material.map.channel), t.mapTransform = new Qt(new At().copy(this.settings.material.map.matrix))), e.USE_COLOR_ALPHA = "";
    let o;
    if (this.settings.softParticles) {
      e.SOFT_PARTICLES = "";
      const c = this.settings.softNearFade, l = 1 / (this.settings.softFarFade - this.settings.softNearFade);
      t.softParams = new Qt(new ri(c, l)), t.depthTexture = new Qt(null);
      const a = t.projParams = new Qt(new Tt());
      o = (d, h, u) => {
        a.value.set(u.near, u.far, 0, 0);
      };
    }
    let r = !1;
    if (this.settings.renderMode === K.BillBoard || this.settings.renderMode === K.VerticalBillBoard || this.settings.renderMode === K.HorizontalBillBoard || this.settings.renderMode === K.Mesh) {
      let c, l;
      this.settings.renderMode === K.Mesh ? this.settings.material.type === "MeshStandardMaterial" || this.settings.material.type === "MeshPhysicalMaterial" ? (e.USE_COLOR = "", c = To, l = Ko, r = !0) : (c = Nd, l = Mn) : (c = Hd, l = Mn), this.settings.renderMode === K.VerticalBillBoard ? e.VERTICAL = "" : this.settings.renderMode === K.HorizontalBillBoard && (e.HORIZONTAL = "");
      let a = !1;
      this.settings.renderMode === K.Mesh && (this.settings.material.type === "MeshStandardMaterial" ? (this.material = new Jd({}), this.material.copy(this.settings.material), this.material.uniforms = t, this.material.defines = e, a = !0) : this.settings.material.type === "MeshPhysicalMaterial" && (this.material = new Ud({}), this.material.copy(this.settings.material), this.material.uniforms = t, this.material.defines = e, a = !0)), a || (this.material = new On({
        uniforms: t,
        defines: e,
        vertexShader: c,
        fragmentShader: l,
        transparent: this.settings.material.transparent,
        depthWrite: !this.settings.material.transparent,
        blending: this.settings.material.blending,
        blendDst: this.settings.material.blendDst,
        blendSrc: this.settings.material.blendSrc,
        blendEquation: this.settings.material.blendEquation,
        premultipliedAlpha: this.settings.material.premultipliedAlpha,
        side: this.settings.material.side,
        alphaTest: this.settings.material.alphaTest,
        depthTest: this.settings.material.depthTest,
        lights: r
      }));
    } else if (this.settings.renderMode === K.StretchedBillBoard)
      t.speedFactor = new Qt(1), this.material = new On({
        uniforms: t,
        defines: e,
        vertexShader: Id,
        fragmentShader: Mn,
        transparent: this.settings.material.transparent,
        depthWrite: !this.settings.material.transparent,
        blending: this.settings.material.blending,
        blendDst: this.settings.material.blendDst,
        blendSrc: this.settings.material.blendSrc,
        blendEquation: this.settings.material.blendEquation,
        premultipliedAlpha: this.settings.material.premultipliedAlpha,
        side: this.settings.material.side,
        alphaTest: this.settings.material.alphaTest,
        depthTest: this.settings.material.depthTest
      });
    else
      throw new Error("render mode unavailable");
    this.material && o && (this.material.onBeforeRender = o);
  }
  update() {
    let t = 0, e = 0;
    this.systems.forEach((i) => {
      e += i.particleNum;
    }), e > this.maxParticles && this.expandBuffers(e), this.systems.forEach((i) => {
      i.emitter.updateMatrixWorld && (i.emitter.updateWorldMatrix(!0, !1), i.emitter.updateMatrixWorld(!0));
      const n = i.particles, o = i.particleNum, r = this.quaternion2_, c = this.vector2_, l = this.vector3_;
      i.emitter.matrixWorld.decompose(c, r, l), this.rotationMat_.setFromMatrix4(i.emitter.matrixWorld);
      for (let a = 0; a < o; a++, t++) {
        const d = n[a];
        if (this.settings.renderMode === K.Mesh) {
          let u;
          if (i.worldSpace)
            u = d.rotation;
          else {
            let p;
            d.parentMatrix ? p = this.quaternion3_.setFromRotationMatrix(d.parentMatrix) : p = r, u = this.quaternion_, u.copy(p).multiply(d.rotation);
          }
          this.rotationBuffer.setXYZW(t, u.x, u.y, u.z, u.w);
        } else
          (this.settings.renderMode === K.StretchedBillBoard || this.settings.renderMode === K.VerticalBillBoard || this.settings.renderMode === K.HorizontalBillBoard || this.settings.renderMode === K.BillBoard) && this.rotationBuffer.setX(t, d.rotation);
        let h;
        if (i.worldSpace ? h = d.position : (h = this.vector_, d.parentMatrix ? h.copy(d.position).applyMatrix4(d.parentMatrix) : h.copy(d.position).applyMatrix4(i.emitter.matrixWorld)), this.offsetBuffer.setXYZ(t, h.x, h.y, h.z), this.colorBuffer.setXYZW(t, d.color.x, d.color.y, d.color.z, d.color.w), i.worldSpace ? this.sizeBuffer.setXYZ(t, d.size.x, d.size.y, d.size.z) : d.parentMatrix ? this.sizeBuffer.setXYZ(t, d.size.x, d.size.y, d.size.z) : this.sizeBuffer.setXYZ(t, d.size.x * Math.abs(l.x), d.size.y * Math.abs(l.y), d.size.z * Math.abs(l.z)), this.uvTileBuffer.setX(t, d.uvTile), this.settings.renderMode === K.StretchedBillBoard && this.velocityBuffer) {
          let u = i.rendererEmitterSettings.speedFactor;
          u === 0 && (u = 1e-3);
          const p = i.rendererEmitterSettings.lengthFactor;
          let m;
          i.worldSpace ? m = d.velocity : (m = this.vector_, d.parentMatrix ? (this.rotationMat2_.setFromMatrix4(d.parentMatrix), m.copy(d.velocity).applyMatrix3(this.rotationMat2_)) : m.copy(d.velocity).applyMatrix3(this.rotationMat_)), this.velocityBuffer.setXYZW(t, m.x * u, m.y * u, m.z * u, p);
        }
      }
    }), this.geometry.instanceCount = t, t > 0 && (this.offsetBuffer.clearUpdateRanges(), this.offsetBuffer.addUpdateRange(0, t * 3), this.offsetBuffer.needsUpdate = !0, this.sizeBuffer.clearUpdateRanges(), this.sizeBuffer.addUpdateRange(0, t * 3), this.sizeBuffer.needsUpdate = !0, this.colorBuffer.clearUpdateRanges(), this.colorBuffer.addUpdateRange(0, t * 4), this.colorBuffer.needsUpdate = !0, this.uvTileBuffer.clearUpdateRanges(), this.uvTileBuffer.addUpdateRange(0, t), this.uvTileBuffer.needsUpdate = !0, this.settings.renderMode === K.StretchedBillBoard && this.velocityBuffer && (this.velocityBuffer.clearUpdateRanges(), this.velocityBuffer.addUpdateRange(0, t * 4), this.velocityBuffer.needsUpdate = !0), this.settings.renderMode === K.Mesh ? (this.rotationBuffer.clearUpdateRanges(), this.rotationBuffer.addUpdateRange(0, t * 4), this.rotationBuffer.needsUpdate = !0) : (this.settings.renderMode === K.StretchedBillBoard || this.settings.renderMode === K.HorizontalBillBoard || this.settings.renderMode === K.VerticalBillBoard || this.settings.renderMode === K.BillBoard) && (this.rotationBuffer.clearUpdateRanges(), this.rotationBuffer.addUpdateRange(0, t), this.rotationBuffer.needsUpdate = !0));
  }
  dispose() {
    this.geometry.dispose();
  }
}
var Fd = `

#include <common>
#include <tile_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

uniform sampler2D alphaMap;
uniform float useAlphaMap;
uniform float visibility;
uniform float alphaTest;

varying vec4 vColor;
    
void main() {
    #include <clipping_planes_fragment>
    #include <logdepthbuf_fragment>

    vec4 diffuseColor = vColor;
    
    #ifdef USE_MAP
    #include <tile_fragment>
    #ifndef USE_COLOR_AS_ALPHA
    #endif
    #endif
    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;
    if( diffuseColor.a < alphaTest ) discard;
    gl_FragColor = diffuseColor;

    #include <fog_fragment>
    #include <tonemapping_fragment>
}`, Qd = `
#include <common>
#include <tile_pars_vertex>
#include <color_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <fog_pars_vertex>

attribute vec3 previous;
attribute vec3 next;
attribute float side;
attribute float width;

uniform vec2 resolution;
uniform float lineWidth;
uniform float sizeAttenuation;
    
vec2 fix(vec4 i, float aspect) {
    vec2 res = i.xy / i.w;
    res.x *= aspect;
    return res;
}
    
void main() {

    #include <tile_vertex>
    
    float aspect = resolution.x / resolution.y;

    vColor = color;

    mat4 m = projectionMatrix * modelViewMatrix;
    vec4 finalPosition = m * vec4( position, 1.0 );
    vec4 prevPos = m * vec4( previous, 1.0 );
    vec4 nextPos = m * vec4( next, 1.0 );

    vec2 currentP = fix( finalPosition, aspect );
    vec2 prevP = fix( prevPos, aspect );
    vec2 nextP = fix( nextPos, aspect );

    float w = lineWidth * width;

    vec2 dir;
    if( nextP == currentP ) dir = normalize( currentP - prevP );
    else if( prevP == currentP ) dir = normalize( nextP - currentP );
    else {
        vec2 dir1 = normalize( currentP - prevP );
        vec2 dir2 = normalize( nextP - currentP );
        dir = normalize( dir1 + dir2 );

        vec2 perp = vec2( -dir1.y, dir1.x );
        vec2 miter = vec2( -dir.y, dir.x );
        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );

    }

    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;
    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );
    normal.xy *= .5 * w;
    normal *= projectionMatrix;
    if( sizeAttenuation == 0. ) {
        normal.xy *= finalPosition.w;
        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;
    }

    finalPosition.xy += normal.xy * side;

    gl_Position = finalPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
	#include <fog_vertex>
}`;
class wd extends tc {
  constructor(t) {
    super(t), this.vector_ = new Y(), this.vector2_ = new Y(), this.vector3_ = new Y(), this.quaternion_ = new w(), this.maxParticles = 1e4, this.setupBuffers(), this.rebuildMaterial();
  }
  setupBuffers() {
    this.geometry && this.geometry.dispose(), this.geometry = new oi(), this.indexBuffer = new Gt(new Uint32Array(this.maxParticles * 6), 1), this.indexBuffer.setUsage(ft), this.geometry.setIndex(this.indexBuffer), this.positionBuffer = new Gt(new Float32Array(this.maxParticles * 6), 3), this.positionBuffer.setUsage(ft), this.geometry.setAttribute("position", this.positionBuffer), this.previousBuffer = new Gt(new Float32Array(this.maxParticles * 6), 3), this.previousBuffer.setUsage(ft), this.geometry.setAttribute("previous", this.previousBuffer), this.nextBuffer = new Gt(new Float32Array(this.maxParticles * 6), 3), this.nextBuffer.setUsage(ft), this.geometry.setAttribute("next", this.nextBuffer), this.widthBuffer = new Gt(new Float32Array(this.maxParticles * 2), 1), this.widthBuffer.setUsage(ft), this.geometry.setAttribute("width", this.widthBuffer), this.sideBuffer = new Gt(new Float32Array(this.maxParticles * 2), 1), this.sideBuffer.setUsage(ft), this.geometry.setAttribute("side", this.sideBuffer), this.uvBuffer = new Gt(new Float32Array(this.maxParticles * 4), 2), this.uvBuffer.setUsage(ft), this.geometry.setAttribute("uv", this.uvBuffer), this.colorBuffer = new Gt(new Float32Array(this.maxParticles * 8), 4), this.colorBuffer.setUsage(ft), this.geometry.setAttribute("color", this.colorBuffer);
  }
  expandBuffers(t) {
    for (; t >= this.maxParticles; )
      this.maxParticles *= 2;
    this.setupBuffers();
  }
  rebuildMaterial() {
    this.layers.mask = this.settings.layers.mask;
    const t = {
      lineWidth: { value: 1 },
      map: { value: null },
      useMap: { value: 0 },
      alphaMap: { value: null },
      useAlphaMap: { value: 0 },
      resolution: { value: new ri(1, 1) },
      sizeAttenuation: { value: 1 },
      visibility: { value: 1 },
      alphaTest: { value: 0 }
    }, e = {};
    if (e.USE_UV = "", e.USE_COLOR_ALPHA = "", this.settings.material.map && (e.USE_MAP = "", e.MAP_UV = uo(this.settings.material.map.channel), t.map = new Qt(this.settings.material.map), t.mapTransform = new Qt(new At().copy(this.settings.material.map.matrix))), this.settings.material.defines && this.settings.material.defines.USE_COLOR_AS_ALPHA !== void 0 && (e.USE_COLOR_AS_ALPHA = ""), this.settings.renderMode === K.Trail)
      this.material = new On({
        uniforms: t,
        defines: e,
        vertexShader: Qd,
        fragmentShader: Fd,
        transparent: this.settings.material.transparent,
        depthWrite: !this.settings.material.transparent,
        side: this.settings.material.side,
        blending: this.settings.material.blending || _r,
        blendDst: this.settings.material.blendDst,
        blendSrc: this.settings.material.blendSrc,
        blendEquation: this.settings.material.blendEquation,
        premultipliedAlpha: this.settings.material.premultipliedAlpha
      });
    else
      throw new Error("render mode unavailable");
  }
  update() {
    let t = 0, e = 0, i = 0;
    this.systems.forEach((n) => {
      for (let o = 0; o < n.particleNum; o++)
        i += n.particles[o].previous.length * 2;
    }), i > this.maxParticles && this.expandBuffers(i), this.systems.forEach((n) => {
      n.emitter.updateMatrixWorld && (n.emitter.updateWorldMatrix(!0, !1), n.emitter.updateMatrixWorld(!0));
      const o = this.quaternion_, r = this.vector2_, c = this.vector3_;
      n.emitter.matrixWorld.decompose(r, o, c);
      const l = n.particles, a = n.particleNum, d = this.settings.uTileCount, h = this.settings.vTileCount, u = 1 / d, p = 1 / h;
      for (let m = 0; m < a; m++) {
        const b = l[m], G = b.uvTile % h, y = Math.floor(b.uvTile / h + 1e-3), Z = b.previous.values();
        let f = Z.next(), V = f.value, X = V;
        f.done || (f = Z.next());
        let R;
        f.value !== void 0 ? R = f.value : R = X;
        for (let x = 0; x < b.previous.length; x++, t += 2) {
          if (this.positionBuffer.setXYZ(t, X.position.x, X.position.y, X.position.z), this.positionBuffer.setXYZ(t + 1, X.position.x, X.position.y, X.position.z), n.worldSpace ? (this.positionBuffer.setXYZ(t, X.position.x, X.position.y, X.position.z), this.positionBuffer.setXYZ(t + 1, X.position.x, X.position.y, X.position.z)) : (b.parentMatrix ? this.vector_.copy(X.position).applyMatrix4(b.parentMatrix) : this.vector_.copy(X.position).applyMatrix4(n.emitter.matrixWorld), this.positionBuffer.setXYZ(t, this.vector_.x, this.vector_.y, this.vector_.z), this.positionBuffer.setXYZ(t + 1, this.vector_.x, this.vector_.y, this.vector_.z)), n.worldSpace ? (this.previousBuffer.setXYZ(t, V.position.x, V.position.y, V.position.z), this.previousBuffer.setXYZ(t + 1, V.position.x, V.position.y, V.position.z)) : (b.parentMatrix ? this.vector_.copy(V.position).applyMatrix4(b.parentMatrix) : this.vector_.copy(V.position).applyMatrix4(n.emitter.matrixWorld), this.previousBuffer.setXYZ(t, this.vector_.x, this.vector_.y, this.vector_.z), this.previousBuffer.setXYZ(t + 1, this.vector_.x, this.vector_.y, this.vector_.z)), n.worldSpace ? (this.nextBuffer.setXYZ(t, R.position.x, R.position.y, R.position.z), this.nextBuffer.setXYZ(t + 1, R.position.x, R.position.y, R.position.z)) : (b.parentMatrix ? this.vector_.copy(R.position).applyMatrix4(b.parentMatrix) : this.vector_.copy(R.position).applyMatrix4(n.emitter.matrixWorld), this.nextBuffer.setXYZ(t, this.vector_.x, this.vector_.y, this.vector_.z), this.nextBuffer.setXYZ(t + 1, this.vector_.x, this.vector_.y, this.vector_.z)), this.sideBuffer.setX(t, -1), this.sideBuffer.setX(t + 1, 1), n.worldSpace)
            this.widthBuffer.setX(t, X.size), this.widthBuffer.setX(t + 1, X.size);
          else if (b.parentMatrix)
            this.widthBuffer.setX(t, X.size), this.widthBuffer.setX(t + 1, X.size);
          else {
            const S = (Math.abs(c.x) + Math.abs(c.y) + Math.abs(c.z)) / 3;
            this.widthBuffer.setX(t, X.size * S), this.widthBuffer.setX(t + 1, X.size * S);
          }
          this.uvBuffer.setXY(t, (x / b.previous.length + G) * u, (h - y - 1) * p), this.uvBuffer.setXY(t + 1, (x / b.previous.length + G) * u, (h - y) * p), this.colorBuffer.setXYZW(t, X.color.x, X.color.y, X.color.z, X.color.w), this.colorBuffer.setXYZW(t + 1, X.color.x, X.color.y, X.color.z, X.color.w), x + 1 < b.previous.length && (this.indexBuffer.setX(e * 3, t), this.indexBuffer.setX(e * 3 + 1, t + 1), this.indexBuffer.setX(e * 3 + 2, t + 2), e++, this.indexBuffer.setX(e * 3, t + 2), this.indexBuffer.setX(e * 3 + 1, t + 1), this.indexBuffer.setX(e * 3 + 2, t + 3), e++), V = X, X = R, f.done || (f = Z.next(), f.value !== void 0 && (R = f.value));
        }
      }
    }), this.positionBuffer.clearUpdateRanges(), this.positionBuffer.addUpdateRange(0, t * 3), this.positionBuffer.needsUpdate = !0, this.previousBuffer.clearUpdateRanges(), this.previousBuffer.addUpdateRange(0, t * 3), this.previousBuffer.needsUpdate = !0, this.nextBuffer.clearUpdateRanges(), this.nextBuffer.addUpdateRange(0, t * 3), this.nextBuffer.needsUpdate = !0, this.sideBuffer.clearUpdateRanges(), this.sideBuffer.addUpdateRange(0, t), this.sideBuffer.needsUpdate = !0, this.widthBuffer.clearUpdateRanges(), this.widthBuffer.addUpdateRange(0, t), this.widthBuffer.needsUpdate = !0, this.uvBuffer.clearUpdateRanges(), this.uvBuffer.addUpdateRange(0, t * 2), this.uvBuffer.needsUpdate = !0, this.colorBuffer.clearUpdateRanges(), this.colorBuffer.addUpdateRange(0, t * 4), this.colorBuffer.needsUpdate = !0, this.indexBuffer.clearUpdateRanges(), this.indexBuffer.addUpdateRange(0, e * 3), this.indexBuffer.needsUpdate = !0, this.geometry.setDrawRange(0, e * 3);
  }
  dispose() {
    this.geometry.dispose();
  }
}
class Xs {
  get geometry() {
    return this._geometry;
  }
  set geometry(t) {
    if (this._geometry = t, t === void 0 || typeof t == "string")
      return;
    const e = new wt();
    this._triangleIndexToArea.length = 0;
    let i = 0;
    if (!t.getIndex())
      return;
    const n = t.getIndex().array, o = n.length / 3;
    this._triangleIndexToArea.push(0);
    for (let r = 0; r < o; r++)
      e.setFromAttributeAndIndices(t.getAttribute("position"), n[r * 3], n[r * 3 + 1], n[r * 3 + 2]), i += e.getArea(), this._triangleIndexToArea.push(i);
    t.userData.triangleIndexToArea = this._triangleIndexToArea;
  }
  constructor(t) {
    this.type = "mesh_surface", this._triangleIndexToArea = [], this._tempA = new M(), this._tempB = new M(), this._tempC = new M(), t && (this.geometry = t);
  }
  initialize(t) {
    const e = this._geometry;
    if (!e || e.getIndex() === null) {
      t.position.set(0, 0, 0), t.velocity.set(0, 0, 1).multiplyScalar(t.startSpeed);
      return;
    }
    const i = this._triangleIndexToArea.length - 1;
    let n = 0, o = i;
    const r = Math.random() * this._triangleIndexToArea[i];
    for (; n + 1 < o; ) {
      const p = Math.floor((n + o) / 2);
      r < this._triangleIndexToArea[p] ? o = p : n = p;
    }
    let c = Math.random(), l = Math.random();
    c + l > 1 && (c = 1 - c, l = 1 - l);
    const a = e.getIndex().array[n * 3], d = e.getIndex().array[n * 3 + 1], h = e.getIndex().array[n * 3 + 2], u = e.getAttribute("position");
    this._tempA.fromBufferAttribute(u, a), this._tempB.fromBufferAttribute(u, d), this._tempC.fromBufferAttribute(u, h), this._tempB.sub(this._tempA), this._tempC.sub(this._tempA), this._tempA.addScaledVector(this._tempB, c).addScaledVector(this._tempC, l), t.position.copy(this._tempA), this._tempA.copy(this._tempB).cross(this._tempC).normalize(), t.velocity.copy(this._tempA).normalize().multiplyScalar(t.startSpeed);
  }
  toJSON() {
    return {
      type: "mesh_surface",
      mesh: this._geometry ? this._geometry.uuid : ""
    };
  }
  static fromJSON(t, e) {
    return new Xs(e.geometries[t.geometry]);
  }
  clone() {
    return new Xs(this._geometry);
  }
  update(t, e) {
  }
}
Vd({
  id: "three.quarks",
  initialize: () => {
  },
  emitterShapes: [{
    type: "mesh_surface",
    params: [["geometry", ["geometry"]]],
    constructor: Xs,
    loadJSON: Xs.fromJSON
  }],
  behaviors: []
});
class Mo extends Lo {
  constructor() {
    super(), this.batches = [], this.systemToBatchIndex = /* @__PURE__ */ new Map(), this.type = "BatchedRenderer", this.depthTexture = null;
  }
  static equals(t, e) {
    return t.material.side === e.material.side && t.material.blending === e.material.blending && t.material.blendSrc === e.material.blendSrc && t.material.blendDst === e.material.blendDst && t.material.blendEquation === e.material.blendEquation && t.material.premultipliedAlpha === e.material.premultipliedAlpha && t.material.transparent === e.material.transparent && t.material.depthTest === e.material.depthTest && t.material.type === e.material.type && t.material.alphaTest === e.material.alphaTest && t.material.map === e.material.map && t.renderMode === e.renderMode && t.blendTiles === e.blendTiles && t.softParticles === e.softParticles && t.softFarFade === e.softFarFade && t.softNearFade === e.softNearFade && t.uTileCount === e.uTileCount && t.vTileCount === e.vTileCount && t.instancingGeometry === e.instancingGeometry && t.renderOrder === e.renderOrder && t.layers.mask === e.layers.mask;
  }
  addSystem(t) {
    t._renderer = this;
    const e = t.getRendererSettings();
    for (let n = 0; n < this.batches.length; n++)
      if (Mo.equals(this.batches[n].settings, e)) {
        this.batches[n].addSystem(t), this.systemToBatchIndex.set(t, n);
        return;
      }
    let i;
    switch (e.renderMode) {
      case K.Trail:
        i = new wd(e);
        break;
      case K.Mesh:
      case K.BillBoard:
      case K.VerticalBillBoard:
      case K.HorizontalBillBoard:
      case K.StretchedBillBoard:
        i = new Pd(e);
        break;
    }
    this.depthTexture && i.applyDepthTexture(this.depthTexture), i.addSystem(t), this.batches.push(i), this.systemToBatchIndex.set(t, this.batches.length - 1), this.add(i);
  }
  deleteSystem(t) {
    const e = this.systemToBatchIndex.get(t);
    e != null && (this.batches[e].removeSystem(t), this.systemToBatchIndex.delete(t));
  }
  setDepthTexture(t) {
    this.depthTexture = t;
    for (const e of this.batches)
      e.applyDepthTexture(t);
  }
  updateSystem(t) {
    this.deleteSystem(t), this.addSystem(t);
  }
  update(t) {
    this.systemToBatchIndex.forEach((e, i) => {
      i.update(t);
    });
    for (let e = 0; e < this.batches.length; e++)
      this.batches[e].update();
  }
}
const Ju = Mo;
vd();
console.log("%c Particle system powered by three.quarks. https://quarks.art/", "font-size: 14px; font-weight: bold;");
const ec = /* @__PURE__ */ Math.sqrt(5), Bd = (ec - 1) / 4, ct = (5 - ec) / 20, vs = (s) => Math.floor(s) | 0, Ks = /* @__PURE__ */ new Float64Array([
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0
]);
function Uu(s = Math.random) {
  const t = Ed(s), e = new Float64Array(t).map((r) => Ks[r % 32 * 4]), i = new Float64Array(t).map((r) => Ks[r % 32 * 4 + 1]), n = new Float64Array(t).map((r) => Ks[r % 32 * 4 + 2]), o = new Float64Array(t).map((r) => Ks[r % 32 * 4 + 3]);
  return function(c, l, a, d) {
    let h, u, p, m, b;
    const G = (c + l + a + d) * Bd, y = vs(c + G), Z = vs(l + G), f = vs(a + G), V = vs(d + G), X = (y + Z + f + V) * ct, R = y - X, x = Z - X, S = f - X, C = V - X, L = c - R, g = l - x, W = a - S, z = d - C;
    let v = 0, k = 0, N = 0, J = 0;
    L > g ? v++ : k++, L > W ? v++ : N++, L > z ? v++ : J++, g > W ? k++ : N++, g > z ? k++ : J++, W > z ? N++ : J++;
    const P = v >= 3 ? 1 : 0, D = k >= 3 ? 1 : 0, st = N >= 3 ? 1 : 0, et = J >= 3 ? 1 : 0, gt = v >= 2 ? 1 : 0, Lt = k >= 2 ? 1 : 0, nt = N >= 2 ? 1 : 0, mt = J >= 2 ? 1 : 0, it = v >= 1 ? 1 : 0, O = k >= 1 ? 1 : 0, me = N >= 1 ? 1 : 0, A = J >= 1 ? 1 : 0, Et = L - P + ct, ee = g - D + ct, Le = W - st + ct, Se = z - et + ct, We = L - gt + 2 * ct, Ce = g - Lt + 2 * ct, ge = W - nt + 2 * ct, ze = z - mt + 2 * ct, ve = L - it + 3 * ct, Ke = g - O + 3 * ct, Te = W - me + 3 * ct, ie = z - A + 3 * ct, se = L - 1 + 4 * ct, ne = g - 1 + 4 * ct, oe = W - 1 + 4 * ct, re = z - 1 + 4 * ct, Nt = y & 255, It = Z & 255, Jt = f & 255, Ut = V & 255;
    let F = 0.6 - L * L - g * g - W * W - z * z;
    if (F < 0)
      h = 0;
    else {
      const _ = Nt + t[It + t[Jt + t[Ut]]];
      F *= F, h = F * F * (e[_] * L + i[_] * g + n[_] * W + o[_] * z);
    }
    let pi = 0.6 - Et * Et - ee * ee - Le * Le - Se * Se;
    if (pi < 0)
      u = 0;
    else {
      const _ = Nt + P + t[It + D + t[Jt + st + t[Ut + et]]];
      pi *= pi, u = pi * pi * (e[_] * Et + i[_] * ee + n[_] * Le + o[_] * Se);
    }
    let mi = 0.6 - We * We - Ce * Ce - ge * ge - ze * ze;
    if (mi < 0)
      p = 0;
    else {
      const _ = Nt + gt + t[It + Lt + t[Jt + nt + t[Ut + mt]]];
      mi *= mi, p = mi * mi * (e[_] * We + i[_] * Ce + n[_] * ge + o[_] * ze);
    }
    let bi = 0.6 - ve * ve - Ke * Ke - Te * Te - ie * ie;
    if (bi < 0)
      m = 0;
    else {
      const _ = Nt + it + t[It + O + t[Jt + me + t[Ut + A]]];
      bi *= bi, m = bi * bi * (e[_] * ve + i[_] * Ke + n[_] * Te + o[_] * ie);
    }
    let yi = 0.6 - se * se - ne * ne - oe * oe - re * re;
    if (yi < 0)
      b = 0;
    else {
      const _ = Nt + 1 + t[It + 1 + t[Jt + 1 + t[Ut + 1]]];
      yi *= yi, b = yi * yi * (e[_] * se + i[_] * ne + n[_] * oe + o[_] * re);
    }
    return 27 * (h + u + p + m + b);
  };
}
function Ed(s) {
  const e = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++)
    e[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    const n = i + ~~(s() * (256 - i)), o = e[i];
    e[i] = e[n], e[n] = o;
  }
  for (let i = 256; i < 512; i++)
    e[i] = e[i - 256];
  return e;
}
class jd {
  /**
   * Creates a new ConstantBackoff.
   * @param backoff the backoff-time to return
   */
  constructor(t) {
    if (this._retries = 0, !Number.isInteger(t) || t < 0)
      throw new Error("Backoff must be a positive integer");
    this.backoff = t;
  }
  get retries() {
    return this._retries;
  }
  get current() {
    return this.backoff;
  }
  next() {
    return this._retries++, this.backoff;
  }
  reset() {
    this._retries = 0;
  }
}
class Od {
  /**
   * Creates a new ExponentialBackoff.
   * @param base the base of the exponentiation
   * @param expMax the maximum exponent, no bound if undefined
   */
  constructor(t, e) {
    if (this._retries = 0, !Number.isInteger(t) || t < 0)
      throw new Error("Base must be a positive integer or zero");
    if (e !== void 0 && (!Number.isInteger(e) || e < 0))
      throw new Error("ExpMax must be a undefined, a positive integer or zero");
    this.base = t, this.expMax = e, this.i = 0;
  }
  get retries() {
    return this._retries;
  }
  get current() {
    return this.base * Math.pow(2, this.i);
  }
  next() {
    return this._retries++, this.i = this.expMax === void 0 ? this.i + 1 : Math.min(this.i + 1, this.expMax), this.current;
  }
  reset() {
    this._retries = 0, this.i = 0;
  }
}
class _d {
  /**
   * Creates a new LinearBackoff.
   * @param initial the initial backoff-time in milliseconds
   * @param increment the amount to increment the backoff-time with every step (in milliseconds)
   * @param max the maximum backoff-time (in milliseconds), no bound if undefined
   */
  constructor(t, e, i) {
    if (this.i = 0, this._retries = 0, t < 0)
      throw new Error("Initial must be a positive number or zero");
    if (e < 0)
      throw new Error("Increment must be a positive number or zero");
    if (i !== void 0 && i < 0)
      throw new Error("Max must be undefined, a positive number or zero");
    if (i !== void 0 && i < t)
      throw new Error("Max must be undefined or greater than or equal to initial");
    this.initial = t, this.increment = e, this.max = i;
  }
  get retries() {
    return this._retries;
  }
  get current() {
    return this.max === void 0 ? this.initial + this.increment * this.i : Math.min(this.initial + this.increment * this.i, this.max);
  }
  next() {
    return this._retries++, this.i++, this.current;
  }
  reset() {
    this._retries = 0, this.i = 0;
  }
}
class Dd {
  constructor() {
    this.elements = [];
  }
  add(t) {
    this.elements.push(t);
  }
  clear() {
    this.elements.length = 0;
  }
  forEach(t) {
    this.elements.forEach(t);
  }
  length() {
    return this.elements.length;
  }
  isEmpty() {
    return this.elements.length === 0;
  }
  peek() {
    return this.elements[0];
  }
  read() {
    return this.elements.shift();
  }
}
class Ad {
  constructor(t) {
    if (!Number.isInteger(t) || t <= 0)
      throw new Error("Capacity must be a positive integer");
    this.elements = new Array(t + 1), this.head = 0, this.tail = 0;
  }
  add(t) {
    this.elements[this.head] = t, this.head = (this.head + 1) % this.elements.length, this.head === this.tail && (this.tail = (this.tail + 1) % this.elements.length);
  }
  clear() {
    this.head = 0, this.tail = 0;
  }
  forEach(t) {
    for (let e = this.tail; e !== this.head; e = (e + 1) % this.elements.length)
      t(this.elements[e]);
  }
  length() {
    return this.tail === this.head ? 0 : this.tail < this.head ? this.head - this.tail : this.elements.length - this.tail + this.head;
  }
  isEmpty() {
    return this.head === this.tail;
  }
  peek() {
    return this.isEmpty() ? void 0 : this.elements[this.tail];
  }
  read() {
    const t = this.peek();
    return t !== void 0 && (this.tail = (this.tail + 1) % this.elements.length), t;
  }
}
var B;
(function(s) {
  s.open = "open", s.close = "close", s.error = "error", s.message = "message", s.retry = "retry", s.reconnect = "reconnect";
})(B || (B = {}));
class ic {
  /**
   * Creates a new websocket.
   *
   * @param url to connect to.
   * @param protocols optional protocols to use.
   * @param options optional options to use.
   */
  constructor(t, e, i) {
    var n, o, r, c, l, a, d, h, u, p, m, b, G, y, Z;
    this._closedByUser = !1, this.handleOpenEvent = (f) => this.handleEvent(B.open, f), this.handleErrorEvent = (f) => this.handleEvent(B.error, f), this.handleCloseEvent = (f) => this.handleEvent(B.close, f), this.handleMessageEvent = (f) => this.handleEvent(B.message, f), this._url = t, this._protocols = e, this._options = {
      buffer: i == null ? void 0 : i.buffer,
      retry: {
        maxRetries: (n = i == null ? void 0 : i.retry) === null || n === void 0 ? void 0 : n.maxRetries,
        instantReconnect: (o = i == null ? void 0 : i.retry) === null || o === void 0 ? void 0 : o.instantReconnect,
        backoff: (r = i == null ? void 0 : i.retry) === null || r === void 0 ? void 0 : r.backoff
      },
      listeners: {
        open: [...(l = (c = i == null ? void 0 : i.listeners) === null || c === void 0 ? void 0 : c.open) !== null && l !== void 0 ? l : []],
        close: [...(d = (a = i == null ? void 0 : i.listeners) === null || a === void 0 ? void 0 : a.close) !== null && d !== void 0 ? d : []],
        error: [...(u = (h = i == null ? void 0 : i.listeners) === null || h === void 0 ? void 0 : h.error) !== null && u !== void 0 ? u : []],
        message: [...(m = (p = i == null ? void 0 : i.listeners) === null || p === void 0 ? void 0 : p.message) !== null && m !== void 0 ? m : []],
        retry: [...(G = (b = i == null ? void 0 : i.listeners) === null || b === void 0 ? void 0 : b.retry) !== null && G !== void 0 ? G : []],
        reconnect: [...(Z = (y = i == null ? void 0 : i.listeners) === null || y === void 0 ? void 0 : y.reconnect) !== null && Z !== void 0 ? Z : []]
      }
    }, this._underlyingWebsocket = this.tryConnect();
  }
  /**
   * Getter for the url.
   *
   * @return the url.
   */
  get url() {
    return this._url;
  }
  /**
   * Getter for the protocols.
   *
   * @return the protocols, or undefined if none were provided.
   */
  get protocols() {
    return this._protocols;
  }
  /**
   * Getter for the buffer.
   *
   * @return the buffer, or undefined if none was provided.
   */
  get buffer() {
    return this._options.buffer;
  }
  /**
   * Getter for the maxRetries.
   *
   * @return the maxRetries, or undefined if none was provided (no limit).
   */
  get maxRetries() {
    return this._options.retry.maxRetries;
  }
  /**
   * Getter for the instantReconnect.
   *
   * @return the instantReconnect, or undefined if none was provided.
   */
  get instantReconnect() {
    return this._options.retry.instantReconnect;
  }
  /**
   * Getter for the backoff.
   *
   * @return the backoff, or undefined if none was provided.
   */
  get backoff() {
    return this._options.retry.backoff;
  }
  /**
   * Whether the websocket was closed by the user. A websocket is closed by the user if the close().
   *
   * @return true if the websocket was closed by the user, false otherwise.
   */
  get closedByUser() {
    return this._closedByUser;
  }
  /**
   * Getter for the last 'open' event, e.g. the last time the websocket was connected.
   *
   * @return the last 'open' event, or undefined if the websocket was never connected.
   */
  get lastConnection() {
    return this._lastConnection;
  }
  /**
   * Getter for the underlying websocket. This can be used to access the browser's native websocket directly.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
   * @return the underlying websocket.
   */
  get underlyingWebsocket() {
    return this._underlyingWebsocket;
  }
  /**
   * Getter for the readyState of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
   * @return the readyState of the underlying websocket.
   */
  get readyState() {
    return this._underlyingWebsocket.readyState;
  }
  /**
   * Getter for the bufferedAmount of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount
   * @return the bufferedAmount of the underlying websocket.
   */
  get bufferedAmount() {
    return this._underlyingWebsocket.bufferedAmount;
  }
  /**
   * Getter for the extensions of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/extensions
   * @return the extensions of the underlying websocket.
   */
  get extensions() {
    return this._underlyingWebsocket.extensions;
  }
  /**
   * Getter for the binaryType of the underlying websocket.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/binaryType
   * @return the binaryType of the underlying websocket.
   */
  get binaryType() {
    return this._underlyingWebsocket.binaryType;
  }
  /**
   * Setter for the binaryType of the underlying websocket.
   *
   * @param value to set, 'blob' or 'arraybuffer'.
   */
  set binaryType(t) {
    this._underlyingWebsocket.binaryType = t;
  }
  /**
   * Sends data over the websocket.
   *
   * If the websocket is not connected and a buffer was provided on creation, the data will be added to the buffer.
   * If no buffer was provided or the websocket was closed by the user, the data will be dropped.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   * @param data to send.
   */
  send(t) {
    this.closedByUser || (this._underlyingWebsocket.readyState === this._underlyingWebsocket.OPEN ? this._underlyingWebsocket.send(t) : this.buffer !== void 0 && this.buffer.add(t));
  }
  /**
   * Close the websocket. No connection-retry will be attempted after this.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close
   * @param code optional close code.
   * @param reason optional close reason.
   */
  close(t, e) {
    this.cancelScheduledConnectionRetry(), this._closedByUser = !0, this._underlyingWebsocket.close(t, e);
  }
  /**
   * Adds an event listener for the given event-type.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   * @param type of the event to add the listener for.
   * @param listener to add.
   * @param options to use when adding the listener.
   */
  addEventListener(t, e, i) {
    this._options.listeners[t].push({ listener: e, options: i });
  }
  /**
   * Removes one or more event listener for the given event-type that match the given listener and options.
   *
   * @param type of the event to remove the listener for.
   * @param listener to remove.
   * @param options that were used when the listener was added.
   */
  removeEventListener(t, e, i) {
    const n = (o) => o.listener !== e || o.options !== i;
    this._options.listeners[t] = this._options.listeners[t].filter(n);
  }
  /**
   * Creates a new browser-native websocket and connects it to the given URL with the given protocols
   * and adds all event listeners to the browser-native websocket.
   *
   * @return the created browser-native websocket which is also stored in the '_underlyingWebsocket' property.
   */
  tryConnect() {
    return this._underlyingWebsocket = new WebSocket(this.url, this.protocols), this._underlyingWebsocket.addEventListener(B.open, this.handleOpenEvent), this._underlyingWebsocket.addEventListener(B.close, this.handleCloseEvent), this._underlyingWebsocket.addEventListener(B.error, this.handleErrorEvent), this._underlyingWebsocket.addEventListener(B.message, this.handleMessageEvent), this._underlyingWebsocket;
  }
  /**
   * Removes all event listeners from the browser-native websocket and closes it.
   */
  clearWebsocket() {
    this._underlyingWebsocket.removeEventListener(B.open, this.handleOpenEvent), this._underlyingWebsocket.removeEventListener(B.close, this.handleCloseEvent), this._underlyingWebsocket.removeEventListener(B.error, this.handleErrorEvent), this._underlyingWebsocket.removeEventListener(B.message, this.handleMessageEvent), this._underlyingWebsocket.close();
  }
  /**
   * Dispatch an event to all listeners of the given event-type.
   *
   * @param type of the event to dispatch.
   * @param event to dispatch.
   */
  dispatchEvent(t, e) {
    const i = this._options.listeners[t], n = [];
    i.forEach(({ listener: o, options: r }) => {
      o(this, e), (r === void 0 || r.once === void 0 || !r.once) && n.push({ listener: o, options: r });
    }), this._options.listeners[t] = n;
  }
  /**
   * Handles the given event by dispatching it to all listeners of the given event-type.
   *
   * @param type of the event to handle.
   * @param event to handle.
   */
  handleEvent(t, e) {
    switch (t) {
      case B.close:
        this.dispatchEvent(t, e), this.scheduleConnectionRetryIfNeeded();
        break;
      case B.open:
        if (this.backoff !== void 0 && this._lastConnection !== void 0) {
          const i = {
            retries: this.backoff.retries,
            lastConnection: new Date(this._lastConnection)
          }, n = new CustomEvent(B.reconnect, {
            detail: i
          });
          this.dispatchEvent(B.reconnect, n), this.backoff.reset();
        }
        this._lastConnection = /* @__PURE__ */ new Date(), this.dispatchEvent(t, e), this.sendBufferedData();
        break;
      case B.retry:
        this.dispatchEvent(t, e), this.clearWebsocket(), this.tryConnect();
        break;
      default:
        this.dispatchEvent(t, e);
        break;
    }
  }
  /**
   * Sends buffered data if there is a buffer defined.
   */
  sendBufferedData() {
    if (this.buffer !== void 0)
      for (let t = this.buffer.read(); t !== void 0; t = this.buffer.read())
        this.send(t);
  }
  /**
   * Schedules a connection-retry if there is a backoff defined and the websocket was not closed by the user.
   */
  scheduleConnectionRetryIfNeeded() {
    if (this.closedByUser || this.backoff === void 0)
      return;
    const t = (i) => {
      const n = new CustomEvent(B.retry, { detail: i });
      this.handleEvent(B.retry, n);
    }, e = {
      backoff: this._options.retry.instantReconnect === !0 ? 0 : this.backoff.next(),
      retries: this._options.retry.instantReconnect === !0 ? 0 : this.backoff.retries,
      lastConnection: this._lastConnection
    };
    (this._options.retry.maxRetries === void 0 || e.retries <= this._options.retry.maxRetries) && (this.retryTimeout = globalThis.setTimeout(() => t(e), e.backoff));
  }
  /**
   * Cancels the scheduled connection-retry, if there is one.
   */
  cancelScheduledConnectionRetry() {
    globalThis.clearTimeout(this.retryTimeout);
  }
}
class qd {
  /**
   * Creates a new WebsocketBuilder.
   *
   * @param url the url to connect to
   */
  constructor(t) {
    this._url = t;
  }
  /**
   * Getter for the url.
   *
   * @returns the url
   */
  get url() {
    return this._url;
  }
  /**
   * Adds protocols to the websocket. Subsequent calls to this method will override the previously set protocols.
   *
   * @param protocols the protocols to add
   */
  withProtocols(t) {
    return this._protocols = t, this;
  }
  /**
   * Getter for the protocols.
   *
   * @returns the protocols, undefined if no protocols have been set
   */
  get protocols() {
    return this._protocols;
  }
  /**
   * Sets the maximum number of retries before giving up. No limit if undefined.
   *
   * @param maxRetries the maximum number of retries before giving up
   */
  withMaxRetries(t) {
    var e;
    return this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (e = this._options) === null || e === void 0 ? void 0 : e.retry), { maxRetries: t }) }), this;
  }
  /**
   * Getter for the maximum number of retries before giving up.
   *
   * @returns the maximum number of retries before giving up, undefined if no maximum has been set
   */
  get maxRetries() {
    var t, e;
    return (e = (t = this._options) === null || t === void 0 ? void 0 : t.retry) === null || e === void 0 ? void 0 : e.maxRetries;
  }
  /**
   * Sets wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.
   *
   * @param instantReconnect wether to reconnect immediately after a connection has been lost
   */
  withInstantReconnect(t) {
    var e;
    return this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (e = this._options) === null || e === void 0 ? void 0 : e.retry), { instantReconnect: t }) }), this;
  }
  /**
   * Getter for wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.
   *
   * @returns wether to reconnect immediately after a connection has been lost, undefined if no value has been set
   */
  get instantReconnect() {
    var t, e;
    return (e = (t = this._options) === null || t === void 0 ? void 0 : t.retry) === null || e === void 0 ? void 0 : e.instantReconnect;
  }
  /**
   * Adds a backoff to the websocket. Subsequent calls to this method will override the previously set backoff.
   *
   * @param backoff the backoff to add
   */
  withBackoff(t) {
    var e;
    return this._options = Object.assign(Object.assign({}, this._options), { retry: Object.assign(Object.assign({}, (e = this._options) === null || e === void 0 ? void 0 : e.retry), { backoff: t }) }), this;
  }
  /**
   * Getter for the backoff.
   *
   * @returns the backoff, undefined if no backoff has been set
   */
  get backoff() {
    var t, e;
    return (e = (t = this._options) === null || t === void 0 ? void 0 : t.retry) === null || e === void 0 ? void 0 : e.backoff;
  }
  /**
   * Adds a buffer to the websocket. Subsequent calls to this method will override the previously set buffer.
   *
   * @param buffer the buffer to add
   */
  withBuffer(t) {
    return this._options = Object.assign(Object.assign({}, this._options), { buffer: t }), this;
  }
  /**
   * Getter for the buffer.
   *
   * @returns the buffer, undefined if no buffer has been set
   */
  get buffer() {
    var t;
    return (t = this._options) === null || t === void 0 ? void 0 : t.buffer;
  }
  /**
   * Adds an 'open' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onOpen(t, e) {
    return this.addListener(B.open, t, e), this;
  }
  /**
   * Adds an 'close' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onClose(t, e) {
    return this.addListener(B.close, t, e), this;
  }
  /**
   * Adds an 'error' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onError(t, e) {
    return this.addListener(B.error, t, e), this;
  }
  /**
   * Adds an 'message' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onMessage(t, e) {
    return this.addListener(B.message, t, e), this;
  }
  /**
   * Adds an 'retry' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onRetry(t, e) {
    return this.addListener(B.retry, t, e), this;
  }
  /**
   * Adds an 'reconnect' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
   * called in the order they were added.
   *
   * @param listener the listener to add
   * @param options the listener options
   */
  onReconnect(t, e) {
    return this.addListener(B.reconnect, t, e), this;
  }
  /**
   * Builds the websocket.
   *
   * @return a new websocket, with the set options
   */
  build() {
    return new ic(this._url, this._protocols, this._options);
  }
  /**
   * Adds an event listener to the options.
   *
   * @param event the event to add the listener to
   * @param listener the listener to add
   * @param options the listener options
   */
  addListener(t, e, i) {
    var n, o, r, c, l, a, d, h, u, p, m, b, G, y, Z, f, V, X, R, x, S;
    return this._options = Object.assign(Object.assign({}, this._options), { listeners: {
      open: (r = (o = (n = this._options) === null || n === void 0 ? void 0 : n.listeners) === null || o === void 0 ? void 0 : o.open) !== null && r !== void 0 ? r : [],
      close: (a = (l = (c = this._options) === null || c === void 0 ? void 0 : c.listeners) === null || l === void 0 ? void 0 : l.close) !== null && a !== void 0 ? a : [],
      error: (u = (h = (d = this._options) === null || d === void 0 ? void 0 : d.listeners) === null || h === void 0 ? void 0 : h.error) !== null && u !== void 0 ? u : [],
      message: (b = (m = (p = this._options) === null || p === void 0 ? void 0 : p.listeners) === null || m === void 0 ? void 0 : m.message) !== null && b !== void 0 ? b : [],
      retry: (Z = (y = (G = this._options) === null || G === void 0 ? void 0 : G.listeners) === null || y === void 0 ? void 0 : y.retry) !== null && Z !== void 0 ? Z : [],
      reconnect: (X = (V = (f = this._options) === null || f === void 0 ? void 0 : f.listeners) === null || V === void 0 ? void 0 : V.reconnect) !== null && X !== void 0 ? X : [],
      [t]: [
        ...(S = (x = (R = this._options) === null || R === void 0 ? void 0 : R.listeners) === null || x === void 0 ? void 0 : x[t]) !== null && S !== void 0 ? S : [],
        { listener: e, options: i }
      ]
    } }), this;
  }
}
const Pu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArrayQueue: Dd,
  ConstantBackoff: jd,
  ExponentialBackoff: Od,
  LinearBackoff: _d,
  RingQueue: Ad,
  Websocket: ic,
  WebsocketBuilder: qd,
  get WebsocketEvent() {
    return B;
  }
}, Symbol.toStringTag, { value: "Module" })), Yo = 0, sc = 1, nc = 2, $d = 0, th = 1, po = 2, en = 1.25, mo = 1, Re = 6 * 4 + 4 + 4, Xn = 65535, eh = Math.pow(2, -24), Yn = Symbol("SKIP_GENERATION");
function oc(s) {
  return s.index ? s.index.count : s.attributes.position.count;
}
function ui(s) {
  return oc(s) / 3;
}
function rc(s, t = ArrayBuffer) {
  return s > 65535 ? new Uint32Array(new t(4 * s)) : new Uint16Array(new t(2 * s));
}
function ih(s, t) {
  if (!s.index) {
    const e = s.attributes.position.count, i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, n = rc(e, i);
    s.setIndex(new Gt(n, 1));
    for (let o = 0; o < e; o++)
      n[o] = o;
  }
}
function lc(s, t) {
  const e = ui(s), i = t || s.drawRange, n = i.start / 3, o = (i.start + i.count) / 3, r = Math.max(0, n), c = Math.min(e, o) - r;
  return [{
    offset: Math.floor(r),
    count: Math.floor(c)
  }];
}
function cc(s, t) {
  if (!s.groups || !s.groups.length)
    return lc(s, t);
  const e = [], i = /* @__PURE__ */ new Set(), n = t || s.drawRange, o = n.start / 3, r = (n.start + n.count) / 3;
  for (const l of s.groups) {
    const a = l.start / 3, d = (l.start + l.count) / 3;
    i.add(Math.max(o, a)), i.add(Math.min(r, d));
  }
  const c = Array.from(i.values()).sort((l, a) => l - a);
  for (let l = 0; l < c.length - 1; l++) {
    const a = c[l], d = c[l + 1];
    e.push({
      offset: Math.floor(a),
      count: Math.floor(d - a)
    });
  }
  return e;
}
function sh(s, t) {
  const e = ui(s), i = cc(s, t).sort((r, c) => r.offset - c.offset), n = i[i.length - 1];
  n.count = Math.min(e - n.offset, n.count);
  let o = 0;
  return i.forEach(({ count: r }) => o += r), e !== o;
}
function kn(s, t, e, i, n) {
  let o = 1 / 0, r = 1 / 0, c = 1 / 0, l = -1 / 0, a = -1 / 0, d = -1 / 0, h = 1 / 0, u = 1 / 0, p = 1 / 0, m = -1 / 0, b = -1 / 0, G = -1 / 0;
  for (let y = t * 6, Z = (t + e) * 6; y < Z; y += 6) {
    const f = s[y + 0], V = s[y + 1], X = f - V, R = f + V;
    X < o && (o = X), R > l && (l = R), f < h && (h = f), f > m && (m = f);
    const x = s[y + 2], S = s[y + 3], C = x - S, L = x + S;
    C < r && (r = C), L > a && (a = L), x < u && (u = x), x > b && (b = x);
    const g = s[y + 4], W = s[y + 5], z = g - W, v = g + W;
    z < c && (c = z), v > d && (d = v), g < p && (p = g), g > G && (G = g);
  }
  i[0] = o, i[1] = r, i[2] = c, i[3] = l, i[4] = a, i[5] = d, n[0] = h, n[1] = u, n[2] = p, n[3] = m, n[4] = b, n[5] = G;
}
function nh(s, t = null, e = null, i = null) {
  const n = s.attributes.position, o = s.index ? s.index.array : null, r = ui(s), c = n.normalized;
  let l;
  t === null ? (l = new Float32Array(r * 6), e = 0, i = r) : (l = t, e = e || 0, i = i || r);
  const a = n.array, d = n.offset || 0;
  let h = 3;
  n.isInterleavedBufferAttribute && (h = n.data.stride);
  const u = ["getX", "getY", "getZ"];
  for (let p = e; p < e + i; p++) {
    const m = p * 3, b = p * 6;
    let G = m + 0, y = m + 1, Z = m + 2;
    o && (G = o[G], y = o[y], Z = o[Z]), c || (G = G * h + d, y = y * h + d, Z = Z * h + d);
    for (let f = 0; f < 3; f++) {
      let V, X, R;
      c ? (V = n[u[f]](G), X = n[u[f]](y), R = n[u[f]](Z)) : (V = a[G + f], X = a[y + f], R = a[Z + f]);
      let x = V;
      X < x && (x = X), R < x && (x = R);
      let S = V;
      X > S && (S = X), R > S && (S = R);
      const C = (S - x) / 2, L = f * 2;
      l[b + L + 0] = x + C, l[b + L + 1] = C + (Math.abs(x) + C) * eh;
    }
  }
  return l;
}
function E(s, t, e) {
  return e.min.x = t[s], e.min.y = t[s + 1], e.min.z = t[s + 2], e.max.x = t[s + 3], e.max.y = t[s + 4], e.max.z = t[s + 5], e;
}
function Vr(s) {
  let t = -1, e = -1 / 0;
  for (let i = 0; i < 3; i++) {
    const n = s[i + 3] - s[i];
    n > e && (e = n, t = i);
  }
  return t;
}
function Rr(s, t) {
  t.set(s);
}
function xr(s, t, e) {
  let i, n;
  for (let o = 0; o < 3; o++) {
    const r = o + 3;
    i = s[o], n = t[o], e[o] = i < n ? i : n, i = s[r], n = t[r], e[r] = i > n ? i : n;
  }
}
function Ts(s, t, e) {
  for (let i = 0; i < 3; i++) {
    const n = t[s + 2 * i], o = t[s + 2 * i + 1], r = n - o, c = n + o;
    r < e[i] && (e[i] = r), c > e[i + 3] && (e[i + 3] = c);
  }
}
function fi(s) {
  const t = s[3] - s[0], e = s[4] - s[1], i = s[5] - s[2];
  return 2 * (t * e + e * i + i * t);
}
const le = 32, oh = (s, t) => s.candidate - t.candidate, Ge = new Array(le).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
})), Ms = new Float32Array(6);
function rh(s, t, e, i, n, o) {
  let r = -1, c = 0;
  if (o === Yo)
    r = Vr(t), r !== -1 && (c = (t[r] + t[r + 3]) / 2);
  else if (o === sc)
    r = Vr(s), r !== -1 && (c = lh(e, i, n, r));
  else if (o === nc) {
    const l = fi(s);
    let a = en * n;
    const d = i * 6, h = (i + n) * 6;
    for (let u = 0; u < 3; u++) {
      const p = t[u], G = (t[u + 3] - p) / le;
      if (n < le / 4) {
        const y = [...Ge];
        y.length = n;
        let Z = 0;
        for (let V = d; V < h; V += 6, Z++) {
          const X = y[Z];
          X.candidate = e[V + 2 * u], X.count = 0;
          const {
            bounds: R,
            leftCacheBounds: x,
            rightCacheBounds: S
          } = X;
          for (let C = 0; C < 3; C++)
            S[C] = 1 / 0, S[C + 3] = -1 / 0, x[C] = 1 / 0, x[C + 3] = -1 / 0, R[C] = 1 / 0, R[C + 3] = -1 / 0;
          Ts(V, e, R);
        }
        y.sort(oh);
        let f = n;
        for (let V = 0; V < f; V++) {
          const X = y[V];
          for (; V + 1 < f && y[V + 1].candidate === X.candidate; )
            y.splice(V + 1, 1), f--;
        }
        for (let V = d; V < h; V += 6) {
          const X = e[V + 2 * u];
          for (let R = 0; R < f; R++) {
            const x = y[R];
            X >= x.candidate ? Ts(V, e, x.rightCacheBounds) : (Ts(V, e, x.leftCacheBounds), x.count++);
          }
        }
        for (let V = 0; V < f; V++) {
          const X = y[V], R = X.count, x = n - X.count, S = X.leftCacheBounds, C = X.rightCacheBounds;
          let L = 0;
          R !== 0 && (L = fi(S) / l);
          let g = 0;
          x !== 0 && (g = fi(C) / l);
          const W = mo + en * (L * R + g * x);
          W < a && (r = u, a = W, c = X.candidate);
        }
      } else {
        for (let f = 0; f < le; f++) {
          const V = Ge[f];
          V.count = 0, V.candidate = p + G + f * G;
          const X = V.bounds;
          for (let R = 0; R < 3; R++)
            X[R] = 1 / 0, X[R + 3] = -1 / 0;
        }
        for (let f = d; f < h; f += 6) {
          let R = ~~((e[f + 2 * u] - p) / G);
          R >= le && (R = le - 1);
          const x = Ge[R];
          x.count++, Ts(f, e, x.bounds);
        }
        const y = Ge[le - 1];
        Rr(y.bounds, y.rightCacheBounds);
        for (let f = le - 2; f >= 0; f--) {
          const V = Ge[f], X = Ge[f + 1];
          xr(V.bounds, X.rightCacheBounds, V.rightCacheBounds);
        }
        let Z = 0;
        for (let f = 0; f < le - 1; f++) {
          const V = Ge[f], X = V.count, R = V.bounds, S = Ge[f + 1].rightCacheBounds;
          X !== 0 && (Z === 0 ? Rr(R, Ms) : xr(R, Ms, Ms)), Z += X;
          let C = 0, L = 0;
          Z !== 0 && (C = fi(Ms) / l);
          const g = n - Z;
          g !== 0 && (L = fi(S) / l);
          const W = mo + en * (C * Z + L * g);
          W < a && (r = u, a = W, c = V.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);
  return { axis: r, pos: c };
}
function lh(s, t, e, i) {
  let n = 0;
  for (let o = t, r = t + e; o < r; o++)
    n += s[o * 6 + i * 2];
  return n / e;
}
class Hn {
  constructor() {
    this.boundingData = new Float32Array(6);
  }
}
function ch(s, t, e, i, n, o) {
  let r = i, c = i + n - 1;
  const l = o.pos, a = o.axis * 2;
  for (; ; ) {
    for (; r <= c && e[r * 6 + a] < l; )
      r++;
    for (; r <= c && e[c * 6 + a] >= l; )
      c--;
    if (r < c) {
      for (let d = 0; d < 3; d++) {
        let h = t[r * 3 + d];
        t[r * 3 + d] = t[c * 3 + d], t[c * 3 + d] = h;
      }
      for (let d = 0; d < 6; d++) {
        let h = e[r * 6 + d];
        e[r * 6 + d] = e[c * 6 + d], e[c * 6 + d] = h;
      }
      r++, c--;
    } else
      return r;
  }
}
function ah(s, t, e, i, n, o) {
  let r = i, c = i + n - 1;
  const l = o.pos, a = o.axis * 2;
  for (; ; ) {
    for (; r <= c && e[r * 6 + a] < l; )
      r++;
    for (; r <= c && e[c * 6 + a] >= l; )
      c--;
    if (r < c) {
      let d = s[r];
      s[r] = s[c], s[c] = d;
      for (let h = 0; h < 6; h++) {
        let u = e[r * 6 + h];
        e[r * 6 + h] = e[c * 6 + h], e[c * 6 + h] = u;
      }
      r++, c--;
    } else
      return r;
  }
}
function Vt(s, t) {
  return t[s + 15] === 65535;
}
function Wt(s, t) {
  return t[s + 6];
}
function vt(s, t) {
  return t[s + 14];
}
function Mt(s) {
  return s + 8;
}
function Kt(s, t) {
  return t[s + 6];
}
function ko(s, t) {
  return t[s + 7];
}
let ac, ki, sn, dc;
const dh = Math.pow(2, 32);
function bo(s) {
  return "count" in s ? 1 : 1 + bo(s.left) + bo(s.right);
}
function hh(s, t, e) {
  return ac = new Float32Array(e), ki = new Uint32Array(e), sn = new Uint16Array(e), dc = new Uint8Array(e), yo(s, t);
}
function yo(s, t) {
  const e = s / 4, i = s / 2, n = "count" in t, o = t.boundingData;
  for (let r = 0; r < 6; r++)
    ac[e + r] = o[r];
  if (n)
    if (t.buffer) {
      const r = t.buffer;
      dc.set(new Uint8Array(r), s);
      for (let c = s, l = s + r.byteLength; c < l; c += Re) {
        const a = c / 2;
        Vt(a, sn) || (ki[c / 4 + 6] += e);
      }
      return s + r.byteLength;
    } else {
      const r = t.offset, c = t.count;
      return ki[e + 6] = r, sn[i + 14] = c, sn[i + 15] = Xn, s + Re;
    }
  else {
    const r = t.left, c = t.right, l = t.splitAxis;
    let a;
    if (a = yo(s + Re, r), a / 4 > dh)
      throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
    return ki[e + 6] = a / 4, a = yo(a, c), ki[e + 7] = l, a;
  }
}
function uh(s, t) {
  const e = (s.index ? s.index.count : s.attributes.position.count) / 3, i = e > 2 ** 16, n = i ? 4 : 2, o = t ? new SharedArrayBuffer(e * n) : new ArrayBuffer(e * n), r = i ? new Uint32Array(o) : new Uint16Array(o);
  for (let c = 0, l = r.length; c < l; c++)
    r[c] = c;
  return r;
}
function ph(s, t, e, i, n) {
  const {
    maxDepth: o,
    verbose: r,
    maxLeafTris: c,
    strategy: l,
    onProgress: a,
    indirect: d
  } = n, h = s._indirectBuffer, u = s.geometry, p = u.index ? u.index.array : null, m = d ? ah : ch, b = ui(u), G = new Float32Array(6);
  let y = !1;
  const Z = new Hn();
  return kn(t, e, i, Z.boundingData, G), V(Z, e, i, G), Z;
  function f(X) {
    a && a(X / b);
  }
  function V(X, R, x, S = null, C = 0) {
    if (!y && C >= o && (y = !0, r && (console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`), console.warn(u))), x <= c || C >= o)
      return f(R + x), X.offset = R, X.count = x, X;
    const L = rh(X.boundingData, S, t, R, x, l);
    if (L.axis === -1)
      return f(R + x), X.offset = R, X.count = x, X;
    const g = m(h, p, t, R, x, L);
    if (g === R || g === R + x)
      f(R + x), X.offset = R, X.count = x;
    else {
      X.splitAxis = L.axis;
      const W = new Hn(), z = R, v = g - R;
      X.left = W, kn(t, z, v, W.boundingData, G), V(W, z, v, G, C + 1);
      const k = new Hn(), N = g, J = x - v;
      X.right = k, kn(t, N, J, k.boundingData, G), V(k, N, J, G, C + 1);
    }
    return X;
  }
}
function mh(s, t) {
  const e = s.geometry;
  t.indirect && (s._indirectBuffer = uh(e, t.useSharedArrayBuffer), sh(e, t.range) && !t.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), s._indirectBuffer || ih(e, t);
  const i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, n = nh(e), o = t.indirect ? lc(e, t.range) : cc(e, t.range);
  s._roots = o.map((r) => {
    const c = ph(s, n, r.offset, r.count, t), l = bo(c), a = new i(Re * l);
    return hh(0, c, a), a;
  });
}
class pe {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, e) {
    let i = 1 / 0, n = -1 / 0;
    for (let o = 0, r = t.length; o < r; o++) {
      const l = t[o][e];
      i = l < i ? l : i, n = l > n ? l : n;
    }
    this.min = i, this.max = n;
  }
  setFromPoints(t, e) {
    let i = 1 / 0, n = -1 / 0;
    for (let o = 0, r = e.length; o < r; o++) {
      const c = e[o], l = t.dot(c);
      i = l < i ? l : i, n = l > n ? l : n;
    }
    this.min = i, this.max = n;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
}
pe.prototype.setFromBox = function() {
  const s = new M();
  return function(e, i) {
    const n = i.min, o = i.max;
    let r = 1 / 0, c = -1 / 0;
    for (let l = 0; l <= 1; l++)
      for (let a = 0; a <= 1; a++)
        for (let d = 0; d <= 1; d++) {
          s.x = n.x * l + o.x * (1 - l), s.y = n.y * a + o.y * (1 - a), s.z = n.z * d + o.z * (1 - d);
          const h = e.dot(s);
          r = Math.min(h, r), c = Math.max(h, c);
        }
    this.min = r, this.max = c;
  };
}();
const bh = function() {
  const s = new M(), t = new M(), e = new M();
  return function(n, o, r) {
    const c = n.start, l = s, a = o.start, d = t;
    e.subVectors(c, a), s.subVectors(n.end, n.start), t.subVectors(o.end, o.start);
    const h = e.dot(d), u = d.dot(l), p = d.dot(d), m = e.dot(l), G = l.dot(l) * p - u * u;
    let y, Z;
    G !== 0 ? y = (h * u - m * p) / G : y = 0, Z = (h + y * u) / p, r.x = y, r.y = Z;
  };
}(), Ho = function() {
  const s = new qt(), t = new M(), e = new M();
  return function(n, o, r, c) {
    bh(n, o, s);
    let l = s.x, a = s.y;
    if (l >= 0 && l <= 1 && a >= 0 && a <= 1) {
      n.at(l, r), o.at(a, c);
      return;
    } else if (l >= 0 && l <= 1) {
      a < 0 ? o.at(0, c) : o.at(1, c), n.closestPointToPoint(c, !0, r);
      return;
    } else if (a >= 0 && a <= 1) {
      l < 0 ? n.at(0, r) : n.at(1, r), o.closestPointToPoint(r, !0, c);
      return;
    } else {
      let d;
      l < 0 ? d = n.start : d = n.end;
      let h;
      a < 0 ? h = o.start : h = o.end;
      const u = t, p = e;
      if (n.closestPointToPoint(h, !0, t), o.closestPointToPoint(d, !0, e), u.distanceToSquared(h) <= p.distanceToSquared(d)) {
        r.copy(u), c.copy(h);
        return;
      } else {
        r.copy(d), c.copy(p);
        return;
      }
    }
  };
}(), yh = function() {
  const s = new M(), t = new M(), e = new Dr(), i = new he();
  return function(o, r) {
    const { radius: c, center: l } = o, { a, b: d, c: h } = r;
    if (i.start = a, i.end = d, i.closestPointToPoint(l, !0, s).distanceTo(l) <= c || (i.start = a, i.end = h, i.closestPointToPoint(l, !0, s).distanceTo(l) <= c) || (i.start = d, i.end = h, i.closestPointToPoint(l, !0, s).distanceTo(l) <= c))
      return !0;
    const b = r.getPlane(e);
    if (Math.abs(b.distanceToPoint(l)) <= c) {
      const y = b.projectPoint(l, t);
      if (r.containsPoint(y))
        return !0;
    }
    return !1;
  };
}(), Gh = 1e-15;
function Nn(s) {
  return Math.abs(s) < Gh;
}
class Ht extends wt {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new M()), this.satBounds = new Array(4).fill().map(() => new pe()), this.points = [this.a, this.b, this.c], this.sphere = new Ar(), this.plane = new Dr(), this.needsUpdate = !0;
  }
  intersectsSphere(t) {
    return yh(t, this);
  }
  update() {
    const t = this.a, e = this.b, i = this.c, n = this.points, o = this.satAxes, r = this.satBounds, c = o[0], l = r[0];
    this.getNormal(c), l.setFromPoints(c, n);
    const a = o[1], d = r[1];
    a.subVectors(t, e), d.setFromPoints(a, n);
    const h = o[2], u = r[2];
    h.subVectors(e, i), u.setFromPoints(h, n);
    const p = o[3], m = r[3];
    p.subVectors(i, t), m.setFromPoints(p, n), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(c, t), this.needsUpdate = !1;
  }
}
Ht.prototype.closestPointToSegment = function() {
  const s = new M(), t = new M(), e = new he();
  return function(n, o = null, r = null) {
    const { start: c, end: l } = n, a = this.points;
    let d, h = 1 / 0;
    for (let u = 0; u < 3; u++) {
      const p = (u + 1) % 3;
      e.start.copy(a[u]), e.end.copy(a[p]), Ho(e, n, s, t), d = s.distanceToSquared(t), d < h && (h = d, o && o.copy(s), r && r.copy(t));
    }
    return this.closestPointToPoint(c, s), d = c.distanceToSquared(s), d < h && (h = d, o && o.copy(s), r && r.copy(c)), this.closestPointToPoint(l, s), d = l.distanceToSquared(s), d < h && (h = d, o && o.copy(s), r && r.copy(l)), Math.sqrt(h);
  };
}();
Ht.prototype.intersectsTriangle = function() {
  const s = new Ht(), t = new Array(3), e = new Array(3), i = new pe(), n = new pe(), o = new M(), r = new M(), c = new M(), l = new M(), a = new M(), d = new he(), h = new he(), u = new he(), p = new M();
  function m(b, G, y) {
    const Z = b.points;
    let f = 0, V = -1;
    for (let X = 0; X < 3; X++) {
      const { start: R, end: x } = d;
      R.copy(Z[X]), x.copy(Z[(X + 1) % 3]), d.delta(r);
      const S = Nn(G.distanceToPoint(R));
      if (Nn(G.normal.dot(r)) && S) {
        y.copy(d), f = 2;
        break;
      }
      const C = G.intersectLine(d, p);
      if (!C && S && p.copy(R), (C || S) && !Nn(p.distanceTo(x))) {
        if (f <= 1)
          (f === 1 ? y.start : y.end).copy(p), S && (V = f);
        else if (f >= 2) {
          (V === 1 ? y.start : y.end).copy(p), f = 2;
          break;
        }
        if (f++, f === 2 && V === -1)
          break;
      }
    }
    return f;
  }
  return function(G, y = null, Z = !1) {
    this.needsUpdate && this.update(), G.isExtendedTriangle ? G.needsUpdate && G.update() : (s.copy(G), s.update(), G = s);
    const f = this.plane, V = G.plane;
    if (Math.abs(f.normal.dot(V.normal)) > 1 - 1e-10) {
      const X = this.satBounds, R = this.satAxes;
      e[0] = G.a, e[1] = G.b, e[2] = G.c;
      for (let C = 0; C < 4; C++) {
        const L = X[C], g = R[C];
        if (i.setFromPoints(g, e), L.isSeparated(i))
          return !1;
      }
      const x = G.satBounds, S = G.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let C = 0; C < 4; C++) {
        const L = x[C], g = S[C];
        if (i.setFromPoints(g, t), L.isSeparated(i))
          return !1;
      }
      for (let C = 0; C < 4; C++) {
        const L = R[C];
        for (let g = 0; g < 4; g++) {
          const W = S[g];
          if (o.crossVectors(L, W), i.setFromPoints(o, t), n.setFromPoints(o, e), i.isSeparated(n))
            return !1;
        }
      }
      return y && (Z || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), y.start.set(0, 0, 0), y.end.set(0, 0, 0)), !0;
    } else {
      const X = m(this, V, h);
      if (X === 1 && G.containsPoint(h.end))
        return y && (y.start.copy(h.end), y.end.copy(h.end)), !0;
      if (X !== 2)
        return !1;
      const R = m(G, f, u);
      if (R === 1 && this.containsPoint(u.end))
        return y && (y.start.copy(u.end), y.end.copy(u.end)), !0;
      if (R !== 2)
        return !1;
      if (h.delta(c), u.delta(l), c.dot(l) < 0) {
        let z = u.start;
        u.start = u.end, u.end = z;
      }
      const x = h.start.dot(c), S = h.end.dot(c), C = u.start.dot(c), L = u.end.dot(c), g = S < C, W = x < L;
      return x !== L && C !== S && g === W ? !1 : (y && (a.subVectors(h.start, u.start), a.dot(c) > 0 ? y.start.copy(h.start) : y.start.copy(u.start), a.subVectors(h.end, u.end), a.dot(c) < 0 ? y.end.copy(h.end) : y.end.copy(u.end)), !0);
    }
  };
}();
Ht.prototype.distanceToPoint = function() {
  const s = new M();
  return function(e) {
    return this.closestPointToPoint(e, s), e.distanceTo(s);
  };
}();
Ht.prototype.distanceToTriangle = function() {
  const s = new M(), t = new M(), e = ["a", "b", "c"], i = new he(), n = new he();
  return function(r, c = null, l = null) {
    const a = c || l ? i : null;
    if (this.intersectsTriangle(r, a))
      return (c || l) && (c && a.getCenter(c), l && a.getCenter(l)), 0;
    let d = 1 / 0;
    for (let h = 0; h < 3; h++) {
      let u;
      const p = e[h], m = r[p];
      this.closestPointToPoint(m, s), u = m.distanceToSquared(s), u < d && (d = u, c && c.copy(s), l && l.copy(m));
      const b = this[p];
      r.closestPointToPoint(b, s), u = b.distanceToSquared(s), u < d && (d = u, c && c.copy(b), l && l.copy(s));
    }
    for (let h = 0; h < 3; h++) {
      const u = e[h], p = e[(h + 1) % 3];
      i.set(this[u], this[p]);
      for (let m = 0; m < 3; m++) {
        const b = e[m], G = e[(m + 1) % 3];
        n.set(r[b], r[G]), Ho(i, n, s, t);
        const y = s.distanceToSquared(t);
        y < d && (d = y, c && c.copy(s), l && l.copy(t));
      }
    }
    return Math.sqrt(d);
  };
}();
class Xt {
  constructor(t, e, i) {
    this.isOrientedBox = !0, this.min = new M(), this.max = new M(), this.matrix = new kt(), this.invMatrix = new kt(), this.points = new Array(8).fill().map(() => new M()), this.satAxes = new Array(3).fill().map(() => new M()), this.satBounds = new Array(3).fill().map(() => new pe()), this.alignedSatBounds = new Array(3).fill().map(() => new pe()), this.needsUpdate = !1, t && this.min.copy(t), e && this.max.copy(e), i && this.matrix.copy(i);
  }
  set(t, e, i) {
    this.min.copy(t), this.max.copy(e), this.matrix.copy(i), this.needsUpdate = !0;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = !0;
  }
}
Xt.prototype.update = function() {
  return function() {
    const t = this.matrix, e = this.min, i = this.max, n = this.points;
    for (let a = 0; a <= 1; a++)
      for (let d = 0; d <= 1; d++)
        for (let h = 0; h <= 1; h++) {
          const u = 1 * a | 2 * d | 4 * h, p = n[u];
          p.x = a ? i.x : e.x, p.y = d ? i.y : e.y, p.z = h ? i.z : e.z, p.applyMatrix4(t);
        }
    const o = this.satBounds, r = this.satAxes, c = n[0];
    for (let a = 0; a < 3; a++) {
      const d = r[a], h = o[a], u = 1 << a, p = n[u];
      d.subVectors(c, p), h.setFromPoints(d, n);
    }
    const l = this.alignedSatBounds;
    l[0].setFromPointsField(n, "x"), l[1].setFromPointsField(n, "y"), l[2].setFromPointsField(n, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
  };
}();
Xt.prototype.intersectsBox = function() {
  const s = new pe();
  return function(e) {
    this.needsUpdate && this.update();
    const i = e.min, n = e.max, o = this.satBounds, r = this.satAxes, c = this.alignedSatBounds;
    if (s.min = i.x, s.max = n.x, c[0].isSeparated(s) || (s.min = i.y, s.max = n.y, c[1].isSeparated(s)) || (s.min = i.z, s.max = n.z, c[2].isSeparated(s)))
      return !1;
    for (let l = 0; l < 3; l++) {
      const a = r[l], d = o[l];
      if (s.setFromBox(a, e), d.isSeparated(s))
        return !1;
    }
    return !0;
  };
}();
Xt.prototype.intersectsTriangle = function() {
  const s = new Ht(), t = new Array(3), e = new pe(), i = new pe(), n = new M();
  return function(r) {
    this.needsUpdate && this.update(), r.isExtendedTriangle ? r.needsUpdate && r.update() : (s.copy(r), s.update(), r = s);
    const c = this.satBounds, l = this.satAxes;
    t[0] = r.a, t[1] = r.b, t[2] = r.c;
    for (let u = 0; u < 3; u++) {
      const p = c[u], m = l[u];
      if (e.setFromPoints(m, t), p.isSeparated(e))
        return !1;
    }
    const a = r.satBounds, d = r.satAxes, h = this.points;
    for (let u = 0; u < 3; u++) {
      const p = a[u], m = d[u];
      if (e.setFromPoints(m, h), p.isSeparated(e))
        return !1;
    }
    for (let u = 0; u < 3; u++) {
      const p = l[u];
      for (let m = 0; m < 4; m++) {
        const b = d[m];
        if (n.crossVectors(p, b), e.setFromPoints(n, t), i.setFromPoints(n, h), e.isSeparated(i))
          return !1;
      }
    }
    return !0;
  };
}();
Xt.prototype.closestPointToPoint = function() {
  return function(t, e) {
    return this.needsUpdate && this.update(), e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), e;
  };
}();
Xt.prototype.distanceToPoint = function() {
  const s = new M();
  return function(e) {
    return this.closestPointToPoint(e, s), e.distanceTo(s);
  };
}();
Xt.prototype.distanceToBox = function() {
  const s = ["x", "y", "z"], t = new Array(12).fill().map(() => new he()), e = new Array(12).fill().map(() => new he()), i = new M(), n = new M();
  return function(r, c = 0, l = null, a = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(r))
      return (l || a) && (r.getCenter(n), this.closestPointToPoint(n, i), r.closestPointToPoint(i, n), l && l.copy(i), a && a.copy(n)), 0;
    const d = c * c, h = r.min, u = r.max, p = this.points;
    let m = 1 / 0;
    for (let G = 0; G < 8; G++) {
      const y = p[G];
      n.copy(y).clamp(h, u);
      const Z = y.distanceToSquared(n);
      if (Z < m && (m = Z, l && l.copy(y), a && a.copy(n), Z < d))
        return Math.sqrt(Z);
    }
    let b = 0;
    for (let G = 0; G < 3; G++)
      for (let y = 0; y <= 1; y++)
        for (let Z = 0; Z <= 1; Z++) {
          const f = (G + 1) % 3, V = (G + 2) % 3, X = y << f | Z << V, R = 1 << G | y << f | Z << V, x = p[X], S = p[R];
          t[b].set(x, S);
          const L = s[G], g = s[f], W = s[V], z = e[b], v = z.start, k = z.end;
          v[L] = h[L], v[g] = y ? h[g] : u[g], v[W] = Z ? h[W] : u[g], k[L] = u[L], k[g] = y ? h[g] : u[g], k[W] = Z ? h[W] : u[g], b++;
        }
    for (let G = 0; G <= 1; G++)
      for (let y = 0; y <= 1; y++)
        for (let Z = 0; Z <= 1; Z++) {
          n.x = G ? u.x : h.x, n.y = y ? u.y : h.y, n.z = Z ? u.z : h.z, this.closestPointToPoint(n, i);
          const f = n.distanceToSquared(i);
          if (f < m && (m = f, l && l.copy(i), a && a.copy(n), f < d))
            return Math.sqrt(f);
        }
    for (let G = 0; G < 12; G++) {
      const y = t[G];
      for (let Z = 0; Z < 12; Z++) {
        const f = e[Z];
        Ho(y, f, i, n);
        const V = i.distanceToSquared(n);
        if (V < m && (m = V, l && l.copy(i), a && a.copy(n), V < d))
          return Math.sqrt(V);
      }
    }
    return Math.sqrt(m);
  };
}();
class No {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
}
class Zh extends No {
  constructor() {
    super(() => new Ht());
  }
}
const Yt = /* @__PURE__ */ new Zh();
class Xh {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t = [];
    let e = null;
    this.setBuffer = (i) => {
      e && t.push(e), e = i, this.float32Array = new Float32Array(i), this.uint16Array = new Uint16Array(i), this.uint32Array = new Uint32Array(i);
    }, this.clearBuffer = () => {
      e = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, t.length !== 0 && this.setBuffer(t.pop());
    };
  }
}
const j = new Xh();
let Ve, ni;
const Oe = [], Ys = /* @__PURE__ */ new No(() => new Ct());
function fh(s, t, e, i, n, o) {
  Ve = Ys.getPrimitive(), ni = Ys.getPrimitive(), Oe.push(Ve, ni), j.setBuffer(s._roots[t]);
  const r = Go(0, s.geometry, e, i, n, o);
  j.clearBuffer(), Ys.releasePrimitive(Ve), Ys.releasePrimitive(ni), Oe.pop(), Oe.pop();
  const c = Oe.length;
  return c > 0 && (ni = Oe[c - 1], Ve = Oe[c - 2]), r;
}
function Go(s, t, e, i, n = null, o = 0, r = 0) {
  const { float32Array: c, uint16Array: l, uint32Array: a } = j;
  let d = s * 2;
  if (Vt(d, l)) {
    const u = Wt(s, a), p = vt(d, l);
    return E(s, c, Ve), i(u, p, !1, r, o + s, Ve);
  } else {
    let L = function(W) {
      const { uint16Array: z, uint32Array: v } = j;
      let k = W * 2;
      for (; !Vt(k, z); )
        W = Mt(W), k = W * 2;
      return Wt(W, v);
    }, g = function(W) {
      const { uint16Array: z, uint32Array: v } = j;
      let k = W * 2;
      for (; !Vt(k, z); )
        W = Kt(W, v), k = W * 2;
      return Wt(W, v) + vt(k, z);
    };
    const u = Mt(s), p = Kt(s, a);
    let m = u, b = p, G, y, Z, f;
    if (n && (Z = Ve, f = ni, E(m, c, Z), E(b, c, f), G = n(Z), y = n(f), y < G)) {
      m = p, b = u;
      const W = G;
      G = y, y = W, Z = f;
    }
    Z || (Z = Ve, E(m, c, Z));
    const V = Vt(m * 2, l), X = e(Z, V, G, r + 1, o + m);
    let R;
    if (X === po) {
      const W = L(m), v = g(m) - W;
      R = i(W, v, !0, r + 1, o + m, Z);
    } else
      R = X && Go(
        m,
        t,
        e,
        i,
        n,
        o,
        r + 1
      );
    if (R)
      return !0;
    f = ni, E(b, c, f);
    const x = Vt(b * 2, l), S = e(f, x, y, r + 1, o + b);
    let C;
    if (S === po) {
      const W = L(b), v = g(b) - W;
      C = i(W, v, !0, r + 1, o + b, f);
    } else
      C = S && Go(
        b,
        t,
        e,
        i,
        n,
        o,
        r + 1
      );
    return !!C;
  }
}
const Vi = /* @__PURE__ */ new M(), In = /* @__PURE__ */ new M();
function Vh(s, t, e = {}, i = 0, n = 1 / 0) {
  const o = i * i, r = n * n;
  let c = 1 / 0, l = null;
  if (s.shapecast(
    {
      boundsTraverseOrder: (d) => (Vi.copy(t).clamp(d.min, d.max), Vi.distanceToSquared(t)),
      intersectsBounds: (d, h, u) => u < c && u < r,
      intersectsTriangle: (d, h) => {
        d.closestPointToPoint(t, Vi);
        const u = t.distanceToSquared(Vi);
        return u < c && (In.copy(Vi), c = u, l = h), u < o;
      }
    }
  ), c === 1 / 0)
    return null;
  const a = Math.sqrt(c);
  return e.point ? e.point.copy(In) : e.point = In.clone(), e.distance = a, e.faceIndex = l, e;
}
const Rh = parseInt(qr) >= 169, He = /* @__PURE__ */ new M(), Ne = /* @__PURE__ */ new M(), Ie = /* @__PURE__ */ new M(), ks = /* @__PURE__ */ new qt(), Hs = /* @__PURE__ */ new qt(), Ns = /* @__PURE__ */ new qt(), Lr = /* @__PURE__ */ new M(), Sr = /* @__PURE__ */ new M(), Wr = /* @__PURE__ */ new M(), Ri = /* @__PURE__ */ new M();
function xh(s, t, e, i, n, o, r, c) {
  let l;
  if (o === Lc ? l = s.intersectTriangle(i, e, t, !0, n) : l = s.intersectTriangle(t, e, i, o !== jn, n), l === null)
    return null;
  const a = s.origin.distanceTo(n);
  return a < r || a > c ? null : {
    distance: a,
    point: n.clone()
  };
}
function Lh(s, t, e, i, n, o, r, c, l, a, d) {
  He.fromBufferAttribute(t, o), Ne.fromBufferAttribute(t, r), Ie.fromBufferAttribute(t, c);
  const h = xh(s, He, Ne, Ie, Ri, l, a, d);
  if (h) {
    const u = new M();
    wt.getBarycoord(Ri, He, Ne, Ie, u), i && (ks.fromBufferAttribute(i, o), Hs.fromBufferAttribute(i, r), Ns.fromBufferAttribute(i, c), h.uv = wt.getInterpolation(Ri, He, Ne, Ie, ks, Hs, Ns, new qt())), n && (ks.fromBufferAttribute(n, o), Hs.fromBufferAttribute(n, r), Ns.fromBufferAttribute(n, c), h.uv1 = wt.getInterpolation(Ri, He, Ne, Ie, ks, Hs, Ns, new qt())), e && (Lr.fromBufferAttribute(e, o), Sr.fromBufferAttribute(e, r), Wr.fromBufferAttribute(e, c), h.normal = wt.getInterpolation(Ri, He, Ne, Ie, Lr, Sr, Wr, new M()), h.normal.dot(s.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: o,
      b: r,
      c,
      normal: new M(),
      materialIndex: 0
    };
    wt.getNormal(He, Ne, Ie, p.normal), h.face = p, h.faceIndex = o, Rh && (h.barycoord = u);
  }
  return h;
}
function fn(s, t, e, i, n, o, r) {
  const c = i * 3;
  let l = c + 0, a = c + 1, d = c + 2;
  const h = s.index;
  s.index && (l = h.getX(l), a = h.getX(a), d = h.getX(d));
  const { position: u, normal: p, uv: m, uv1: b } = s.attributes, G = Lh(e, u, p, m, b, l, a, d, t, o, r);
  return G ? (G.faceIndex = i, n && n.push(G), G) : null;
}
function tt(s, t, e, i) {
  const n = s.a, o = s.b, r = s.c;
  let c = t, l = t + 1, a = t + 2;
  e && (c = e.getX(c), l = e.getX(l), a = e.getX(a)), n.x = i.getX(c), n.y = i.getY(c), n.z = i.getZ(c), o.x = i.getX(l), o.y = i.getY(l), o.z = i.getZ(l), r.x = i.getX(a), r.y = i.getY(a), r.z = i.getZ(a);
}
const xi = /* @__PURE__ */ new M(), Li = /* @__PURE__ */ new M(), Si = /* @__PURE__ */ new M(), Cr = /* @__PURE__ */ new qt(), gr = /* @__PURE__ */ new qt(), zr = /* @__PURE__ */ new qt();
function Sh(s, t, e, i) {
  const n = t.getIndex().array, o = t.getAttribute("position"), r = t.getAttribute("uv"), c = n[e * 3], l = n[e * 3 + 1], a = n[e * 3 + 2];
  xi.fromBufferAttribute(o, c), Li.fromBufferAttribute(o, l), Si.fromBufferAttribute(o, a);
  let d = 0;
  const h = t.groups, u = e * 3;
  for (let b = 0, G = h.length; b < G; b++) {
    const y = h[b], { start: Z, count: f } = y;
    if (u >= Z && u < Z + f) {
      d = y.materialIndex;
      break;
    }
  }
  const p = i && i.barycoord ? i.barycoord : new M();
  wt.getBarycoord(s, xi, Li, Si, p);
  let m = null;
  return r && (Cr.fromBufferAttribute(r, c), gr.fromBufferAttribute(r, l), zr.fromBufferAttribute(r, a), i && i.uv ? m = i.uv : m = new qt(), wt.getInterpolation(s, xi, Li, Si, Cr, gr, zr, m)), i ? (i.face || (i.face = {}), i.face.a = c, i.face.b = l, i.face.c = a, i.face.materialIndex = d, i.face.normal || (i.face.normal = new M()), wt.getNormal(xi, Li, Si, i.face.normal), m && (i.uv = m), i.barycoord = p, i) : {
    face: {
      a: c,
      b: l,
      c: a,
      materialIndex: d,
      normal: wt.getNormal(xi, Li, Si, new M())
    },
    uv: m,
    barycoord: p
  };
}
function Wh(s, t, e, i, n, o, r, c) {
  const { geometry: l, _indirectBuffer: a } = s;
  for (let d = i, h = i + n; d < h; d++)
    fn(l, t, e, d, o, r, c);
}
function Ch(s, t, e, i, n, o, r) {
  const { geometry: c, _indirectBuffer: l } = s;
  let a = 1 / 0, d = null;
  for (let h = i, u = i + n; h < u; h++) {
    let p;
    p = fn(c, t, e, h, null, o, r), p && p.distance < a && (d = p, a = p.distance);
  }
  return d;
}
function gh(s, t, e, i, n, o, r) {
  const { geometry: c } = e, { index: l } = c, a = c.attributes.position;
  for (let d = s, h = t + s; d < h; d++) {
    let u;
    if (u = d, tt(r, u * 3, l, a), r.needsUpdate = !0, i(r, u, n, o))
      return !0;
  }
  return !1;
}
function zh(s, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = s.geometry, i = e.index ? e.index.array : null, n = e.attributes.position;
  let o, r, c, l, a = 0;
  const d = s._roots;
  for (let u = 0, p = d.length; u < p; u++)
    o = d[u], r = new Uint32Array(o), c = new Uint16Array(o), l = new Float32Array(o), h(0, a), a += o.byteLength;
  function h(u, p, m = !1) {
    const b = u * 2;
    if (c[b + 15] === Xn) {
      const y = r[u + 6], Z = c[b + 14];
      let f = 1 / 0, V = 1 / 0, X = 1 / 0, R = -1 / 0, x = -1 / 0, S = -1 / 0;
      for (let C = 3 * y, L = 3 * (y + Z); C < L; C++) {
        let g = i[C];
        const W = n.getX(g), z = n.getY(g), v = n.getZ(g);
        W < f && (f = W), W > R && (R = W), z < V && (V = z), z > x && (x = z), v < X && (X = v), v > S && (S = v);
      }
      return l[u + 0] !== f || l[u + 1] !== V || l[u + 2] !== X || l[u + 3] !== R || l[u + 4] !== x || l[u + 5] !== S ? (l[u + 0] = f, l[u + 1] = V, l[u + 2] = X, l[u + 3] = R, l[u + 4] = x, l[u + 5] = S, !0) : !1;
    } else {
      const y = u + 8, Z = r[u + 6], f = y + p, V = Z + p;
      let X = m, R = !1, x = !1;
      t ? X || (R = t.has(f), x = t.has(V), X = !R && !x) : (R = !0, x = !0);
      const S = X || R, C = X || x;
      let L = !1;
      S && (L = h(y, p, X));
      let g = !1;
      C && (g = h(Z, p, X));
      const W = L || g;
      if (W)
        for (let z = 0; z < 3; z++) {
          const v = y + z, k = Z + z, N = l[v], J = l[v + 3], P = l[k], D = l[k + 3];
          l[u + z] = N < P ? N : P, l[u + z + 3] = J > D ? J : D;
        }
      return W;
    }
  }
}
function xe(s, t, e, i, n) {
  let o, r, c, l, a, d;
  const h = 1 / e.direction.x, u = 1 / e.direction.y, p = 1 / e.direction.z, m = e.origin.x, b = e.origin.y, G = e.origin.z;
  let y = t[s], Z = t[s + 3], f = t[s + 1], V = t[s + 3 + 1], X = t[s + 2], R = t[s + 3 + 2];
  return h >= 0 ? (o = (y - m) * h, r = (Z - m) * h) : (o = (Z - m) * h, r = (y - m) * h), u >= 0 ? (c = (f - b) * u, l = (V - b) * u) : (c = (V - b) * u, l = (f - b) * u), o > l || c > r || ((c > o || isNaN(o)) && (o = c), (l < r || isNaN(r)) && (r = l), p >= 0 ? (a = (X - G) * p, d = (R - G) * p) : (a = (R - G) * p, d = (X - G) * p), o > d || a > r) ? !1 : ((a > o || o !== o) && (o = a), (d < r || r !== r) && (r = d), o <= n && r >= i);
}
function vh(s, t, e, i, n, o, r, c) {
  const { geometry: l, _indirectBuffer: a } = s;
  for (let d = i, h = i + n; d < h; d++) {
    let u = a ? a[d] : d;
    fn(l, t, e, u, o, r, c);
  }
}
function Kh(s, t, e, i, n, o, r) {
  const { geometry: c, _indirectBuffer: l } = s;
  let a = 1 / 0, d = null;
  for (let h = i, u = i + n; h < u; h++) {
    let p;
    p = fn(c, t, e, l ? l[h] : h, null, o, r), p && p.distance < a && (d = p, a = p.distance);
  }
  return d;
}
function Th(s, t, e, i, n, o, r) {
  const { geometry: c } = e, { index: l } = c, a = c.attributes.position;
  for (let d = s, h = t + s; d < h; d++) {
    let u;
    if (u = e.resolveTriangleIndex(d), tt(r, u * 3, l, a), r.needsUpdate = !0, i(r, u, n, o))
      return !0;
  }
  return !1;
}
function Mh(s, t, e, i, n, o, r) {
  j.setBuffer(s._roots[t]), Zo(0, s, e, i, n, o, r), j.clearBuffer();
}
function Zo(s, t, e, i, n, o, r) {
  const { float32Array: c, uint16Array: l, uint32Array: a } = j, d = s * 2;
  if (Vt(d, l)) {
    const u = Wt(s, a), p = vt(d, l);
    Wh(t, e, i, u, p, n, o, r);
  } else {
    const u = Mt(s);
    xe(u, c, i, o, r) && Zo(u, t, e, i, n, o, r);
    const p = Kt(s, a);
    xe(p, c, i, o, r) && Zo(p, t, e, i, n, o, r);
  }
}
const Yh = ["x", "y", "z"];
function kh(s, t, e, i, n, o) {
  j.setBuffer(s._roots[t]);
  const r = Xo(0, s, e, i, n, o);
  return j.clearBuffer(), r;
}
function Xo(s, t, e, i, n, o) {
  const { float32Array: r, uint16Array: c, uint32Array: l } = j;
  let a = s * 2;
  if (Vt(a, c)) {
    const h = Wt(s, l), u = vt(a, c);
    return Ch(t, e, i, h, u, n, o);
  } else {
    const h = ko(s, l), u = Yh[h], m = i.direction[u] >= 0;
    let b, G;
    m ? (b = Mt(s), G = Kt(s, l)) : (b = Kt(s, l), G = Mt(s));
    const Z = xe(b, r, i, n, o) ? Xo(b, t, e, i, n, o) : null;
    if (Z) {
      const X = Z.point[u];
      if (m ? X <= r[G + h] : (
        // min bounding data
        X >= r[G + h + 3]
      ))
        return Z;
    }
    const V = xe(G, r, i, n, o) ? Xo(G, t, e, i, n, o) : null;
    return Z && V ? Z.distance <= V.distance ? Z : V : Z || V || null;
  }
}
const Is = /* @__PURE__ */ new Ct(), _e = /* @__PURE__ */ new Ht(), De = /* @__PURE__ */ new Ht(), Wi = /* @__PURE__ */ new kt(), vr = /* @__PURE__ */ new Xt(), Js = /* @__PURE__ */ new Xt();
function Hh(s, t, e, i) {
  j.setBuffer(s._roots[t]);
  const n = fo(0, s, e, i);
  return j.clearBuffer(), n;
}
function fo(s, t, e, i, n = null) {
  const { float32Array: o, uint16Array: r, uint32Array: c } = j;
  let l = s * 2;
  if (n === null && (e.boundingBox || e.computeBoundingBox(), vr.set(e.boundingBox.min, e.boundingBox.max, i), n = vr), Vt(l, r)) {
    const d = t.geometry, h = d.index, u = d.attributes.position, p = e.index, m = e.attributes.position, b = Wt(s, c), G = vt(l, r);
    if (Wi.copy(i).invert(), e.boundsTree)
      return E(s, o, Js), Js.matrix.copy(Wi), Js.needsUpdate = !0, e.boundsTree.shapecast({
        intersectsBounds: (Z) => Js.intersectsBox(Z),
        intersectsTriangle: (Z) => {
          Z.a.applyMatrix4(i), Z.b.applyMatrix4(i), Z.c.applyMatrix4(i), Z.needsUpdate = !0;
          for (let f = b * 3, V = (G + b) * 3; f < V; f += 3)
            if (tt(De, f, h, u), De.needsUpdate = !0, Z.intersectsTriangle(De))
              return !0;
          return !1;
        }
      });
    for (let y = b * 3, Z = (G + b) * 3; y < Z; y += 3) {
      tt(_e, y, h, u), _e.a.applyMatrix4(Wi), _e.b.applyMatrix4(Wi), _e.c.applyMatrix4(Wi), _e.needsUpdate = !0;
      for (let f = 0, V = p.count; f < V; f += 3)
        if (tt(De, f, p, m), De.needsUpdate = !0, _e.intersectsTriangle(De))
          return !0;
    }
  } else {
    const d = s + 8, h = c[s + 6];
    return E(d, o, Is), !!(n.intersectsBox(Is) && fo(d, t, e, i, n) || (E(h, o, Is), n.intersectsBox(Is) && fo(h, t, e, i, n)));
  }
}
const Us = /* @__PURE__ */ new kt(), Jn = /* @__PURE__ */ new Xt(), Ci = /* @__PURE__ */ new Xt(), Nh = /* @__PURE__ */ new M(), Ih = /* @__PURE__ */ new M(), Jh = /* @__PURE__ */ new M(), Uh = /* @__PURE__ */ new M();
function Ph(s, t, e, i = {}, n = {}, o = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), Jn.set(t.boundingBox.min, t.boundingBox.max, e), Jn.needsUpdate = !0;
  const c = s.geometry, l = c.attributes.position, a = c.index, d = t.attributes.position, h = t.index, u = Yt.getPrimitive(), p = Yt.getPrimitive();
  let m = Nh, b = Ih, G = null, y = null;
  n && (G = Jh, y = Uh);
  let Z = 1 / 0, f = null, V = null;
  return Us.copy(e).invert(), Ci.matrix.copy(Us), s.shapecast(
    {
      boundsTraverseOrder: (X) => Jn.distanceToBox(X),
      intersectsBounds: (X, R, x) => x < Z && x < r ? (R && (Ci.min.copy(X.min), Ci.max.copy(X.max), Ci.needsUpdate = !0), !0) : !1,
      intersectsRange: (X, R) => {
        if (t.boundsTree)
          return t.boundsTree.shapecast({
            boundsTraverseOrder: (S) => Ci.distanceToBox(S),
            intersectsBounds: (S, C, L) => L < Z && L < r,
            intersectsRange: (S, C) => {
              for (let L = S, g = S + C; L < g; L++) {
                tt(p, 3 * L, h, d), p.a.applyMatrix4(e), p.b.applyMatrix4(e), p.c.applyMatrix4(e), p.needsUpdate = !0;
                for (let W = X, z = X + R; W < z; W++) {
                  tt(u, 3 * W, a, l), u.needsUpdate = !0;
                  const v = u.distanceToTriangle(p, m, G);
                  if (v < Z && (b.copy(m), y && y.copy(G), Z = v, f = W, V = L), v < o)
                    return !0;
                }
              }
            }
          });
        {
          const x = ui(t);
          for (let S = 0, C = x; S < C; S++) {
            tt(p, 3 * S, h, d), p.a.applyMatrix4(e), p.b.applyMatrix4(e), p.c.applyMatrix4(e), p.needsUpdate = !0;
            for (let L = X, g = X + R; L < g; L++) {
              tt(u, 3 * L, a, l), u.needsUpdate = !0;
              const W = u.distanceToTriangle(p, m, G);
              if (W < Z && (b.copy(m), y && y.copy(G), Z = W, f = L, V = S), W < o)
                return !0;
            }
          }
        }
      }
    }
  ), Yt.releasePrimitive(u), Yt.releasePrimitive(p), Z === 1 / 0 ? null : (i.point ? i.point.copy(b) : i.point = b.clone(), i.distance = Z, i.faceIndex = f, n && (n.point ? n.point.copy(y) : n.point = y.clone(), n.point.applyMatrix4(Us), b.applyMatrix4(Us), n.distance = b.sub(n.point).length(), n.faceIndex = V), i);
}
function Fh(s, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = s.geometry, i = e.index ? e.index.array : null, n = e.attributes.position;
  let o, r, c, l, a = 0;
  const d = s._roots;
  for (let u = 0, p = d.length; u < p; u++)
    o = d[u], r = new Uint32Array(o), c = new Uint16Array(o), l = new Float32Array(o), h(0, a), a += o.byteLength;
  function h(u, p, m = !1) {
    const b = u * 2;
    if (c[b + 15] === Xn) {
      const y = r[u + 6], Z = c[b + 14];
      let f = 1 / 0, V = 1 / 0, X = 1 / 0, R = -1 / 0, x = -1 / 0, S = -1 / 0;
      for (let C = y, L = y + Z; C < L; C++) {
        const g = 3 * s.resolveTriangleIndex(C);
        for (let W = 0; W < 3; W++) {
          let z = g + W;
          z = i ? i[z] : z;
          const v = n.getX(z), k = n.getY(z), N = n.getZ(z);
          v < f && (f = v), v > R && (R = v), k < V && (V = k), k > x && (x = k), N < X && (X = N), N > S && (S = N);
        }
      }
      return l[u + 0] !== f || l[u + 1] !== V || l[u + 2] !== X || l[u + 3] !== R || l[u + 4] !== x || l[u + 5] !== S ? (l[u + 0] = f, l[u + 1] = V, l[u + 2] = X, l[u + 3] = R, l[u + 4] = x, l[u + 5] = S, !0) : !1;
    } else {
      const y = u + 8, Z = r[u + 6], f = y + p, V = Z + p;
      let X = m, R = !1, x = !1;
      t ? X || (R = t.has(f), x = t.has(V), X = !R && !x) : (R = !0, x = !0);
      const S = X || R, C = X || x;
      let L = !1;
      S && (L = h(y, p, X));
      let g = !1;
      C && (g = h(Z, p, X));
      const W = L || g;
      if (W)
        for (let z = 0; z < 3; z++) {
          const v = y + z, k = Z + z, N = l[v], J = l[v + 3], P = l[k], D = l[k + 3];
          l[u + z] = N < P ? N : P, l[u + z + 3] = J > D ? J : D;
        }
      return W;
    }
  }
}
function Qh(s, t, e, i, n, o, r) {
  j.setBuffer(s._roots[t]), Vo(0, s, e, i, n, o, r), j.clearBuffer();
}
function Vo(s, t, e, i, n, o, r) {
  const { float32Array: c, uint16Array: l, uint32Array: a } = j, d = s * 2;
  if (Vt(d, l)) {
    const u = Wt(s, a), p = vt(d, l);
    vh(t, e, i, u, p, n, o, r);
  } else {
    const u = Mt(s);
    xe(u, c, i, o, r) && Vo(u, t, e, i, n, o, r);
    const p = Kt(s, a);
    xe(p, c, i, o, r) && Vo(p, t, e, i, n, o, r);
  }
}
const wh = ["x", "y", "z"];
function Bh(s, t, e, i, n, o) {
  j.setBuffer(s._roots[t]);
  const r = Ro(0, s, e, i, n, o);
  return j.clearBuffer(), r;
}
function Ro(s, t, e, i, n, o) {
  const { float32Array: r, uint16Array: c, uint32Array: l } = j;
  let a = s * 2;
  if (Vt(a, c)) {
    const h = Wt(s, l), u = vt(a, c);
    return Kh(t, e, i, h, u, n, o);
  } else {
    const h = ko(s, l), u = wh[h], m = i.direction[u] >= 0;
    let b, G;
    m ? (b = Mt(s), G = Kt(s, l)) : (b = Kt(s, l), G = Mt(s));
    const Z = xe(b, r, i, n, o) ? Ro(b, t, e, i, n, o) : null;
    if (Z) {
      const X = Z.point[u];
      if (m ? X <= r[G + h] : (
        // min bounding data
        X >= r[G + h + 3]
      ))
        return Z;
    }
    const V = xe(G, r, i, n, o) ? Ro(G, t, e, i, n, o) : null;
    return Z && V ? Z.distance <= V.distance ? Z : V : Z || V || null;
  }
}
const Ps = /* @__PURE__ */ new Ct(), Ae = /* @__PURE__ */ new Ht(), qe = /* @__PURE__ */ new Ht(), gi = /* @__PURE__ */ new kt(), Kr = /* @__PURE__ */ new Xt(), Fs = /* @__PURE__ */ new Xt();
function Eh(s, t, e, i) {
  j.setBuffer(s._roots[t]);
  const n = xo(0, s, e, i);
  return j.clearBuffer(), n;
}
function xo(s, t, e, i, n = null) {
  const { float32Array: o, uint16Array: r, uint32Array: c } = j;
  let l = s * 2;
  if (n === null && (e.boundingBox || e.computeBoundingBox(), Kr.set(e.boundingBox.min, e.boundingBox.max, i), n = Kr), Vt(l, r)) {
    const d = t.geometry, h = d.index, u = d.attributes.position, p = e.index, m = e.attributes.position, b = Wt(s, c), G = vt(l, r);
    if (gi.copy(i).invert(), e.boundsTree)
      return E(s, o, Fs), Fs.matrix.copy(gi), Fs.needsUpdate = !0, e.boundsTree.shapecast({
        intersectsBounds: (Z) => Fs.intersectsBox(Z),
        intersectsTriangle: (Z) => {
          Z.a.applyMatrix4(i), Z.b.applyMatrix4(i), Z.c.applyMatrix4(i), Z.needsUpdate = !0;
          for (let f = b, V = G + b; f < V; f++)
            if (tt(qe, 3 * t.resolveTriangleIndex(f), h, u), qe.needsUpdate = !0, Z.intersectsTriangle(qe))
              return !0;
          return !1;
        }
      });
    for (let y = b, Z = G + b; y < Z; y++) {
      const f = t.resolveTriangleIndex(y);
      tt(Ae, 3 * f, h, u), Ae.a.applyMatrix4(gi), Ae.b.applyMatrix4(gi), Ae.c.applyMatrix4(gi), Ae.needsUpdate = !0;
      for (let V = 0, X = p.count; V < X; V += 3)
        if (tt(qe, V, p, m), qe.needsUpdate = !0, Ae.intersectsTriangle(qe))
          return !0;
    }
  } else {
    const d = s + 8, h = c[s + 6];
    return E(d, o, Ps), !!(n.intersectsBox(Ps) && xo(d, t, e, i, n) || (E(h, o, Ps), n.intersectsBox(Ps) && xo(h, t, e, i, n)));
  }
}
const Qs = /* @__PURE__ */ new kt(), Un = /* @__PURE__ */ new Xt(), zi = /* @__PURE__ */ new Xt(), jh = /* @__PURE__ */ new M(), Oh = /* @__PURE__ */ new M(), _h = /* @__PURE__ */ new M(), Dh = /* @__PURE__ */ new M();
function Ah(s, t, e, i = {}, n = {}, o = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), Un.set(t.boundingBox.min, t.boundingBox.max, e), Un.needsUpdate = !0;
  const c = s.geometry, l = c.attributes.position, a = c.index, d = t.attributes.position, h = t.index, u = Yt.getPrimitive(), p = Yt.getPrimitive();
  let m = jh, b = Oh, G = null, y = null;
  n && (G = _h, y = Dh);
  let Z = 1 / 0, f = null, V = null;
  return Qs.copy(e).invert(), zi.matrix.copy(Qs), s.shapecast(
    {
      boundsTraverseOrder: (X) => Un.distanceToBox(X),
      intersectsBounds: (X, R, x) => x < Z && x < r ? (R && (zi.min.copy(X.min), zi.max.copy(X.max), zi.needsUpdate = !0), !0) : !1,
      intersectsRange: (X, R) => {
        if (t.boundsTree) {
          const x = t.boundsTree;
          return x.shapecast({
            boundsTraverseOrder: (S) => zi.distanceToBox(S),
            intersectsBounds: (S, C, L) => L < Z && L < r,
            intersectsRange: (S, C) => {
              for (let L = S, g = S + C; L < g; L++) {
                const W = x.resolveTriangleIndex(L);
                tt(p, 3 * W, h, d), p.a.applyMatrix4(e), p.b.applyMatrix4(e), p.c.applyMatrix4(e), p.needsUpdate = !0;
                for (let z = X, v = X + R; z < v; z++) {
                  const k = s.resolveTriangleIndex(z);
                  tt(u, 3 * k, a, l), u.needsUpdate = !0;
                  const N = u.distanceToTriangle(p, m, G);
                  if (N < Z && (b.copy(m), y && y.copy(G), Z = N, f = z, V = L), N < o)
                    return !0;
                }
              }
            }
          });
        } else {
          const x = ui(t);
          for (let S = 0, C = x; S < C; S++) {
            tt(p, 3 * S, h, d), p.a.applyMatrix4(e), p.b.applyMatrix4(e), p.c.applyMatrix4(e), p.needsUpdate = !0;
            for (let L = X, g = X + R; L < g; L++) {
              const W = s.resolveTriangleIndex(L);
              tt(u, 3 * W, a, l), u.needsUpdate = !0;
              const z = u.distanceToTriangle(p, m, G);
              if (z < Z && (b.copy(m), y && y.copy(G), Z = z, f = L, V = S), z < o)
                return !0;
            }
          }
        }
      }
    }
  ), Yt.releasePrimitive(u), Yt.releasePrimitive(p), Z === 1 / 0 ? null : (i.point ? i.point.copy(b) : i.point = b.clone(), i.distance = Z, i.faceIndex = f, n && (n.point ? n.point.copy(y) : n.point = y.clone(), n.point.applyMatrix4(Qs), b.applyMatrix4(Qs), n.distance = b.sub(n.point).length(), n.faceIndex = V), i);
}
function hc() {
  return typeof SharedArrayBuffer < "u";
}
const Ui = new j.constructor(), pn = new j.constructor(), Xe = new No(() => new Ct()), $e = new Ct(), ti = new Ct(), Pn = new Ct(), Fn = new Ct();
let Qn = !1;
function qh(s, t, e, i) {
  if (Qn)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Qn = !0;
  const n = s._roots, o = t._roots;
  let r, c = 0, l = 0;
  const a = new kt().copy(e).invert();
  for (let d = 0, h = n.length; d < h; d++) {
    Ui.setBuffer(n[d]), l = 0;
    const u = Xe.getPrimitive();
    E(0, Ui.float32Array, u), u.applyMatrix4(a);
    for (let p = 0, m = o.length; p < m && (pn.setBuffer(o[p]), r = Ft(
      0,
      0,
      e,
      a,
      i,
      c,
      l,
      0,
      0,
      u
    ), pn.clearBuffer(), l += o[p].length, !r); p++)
      ;
    if (Xe.releasePrimitive(u), Ui.clearBuffer(), c += n[d].length, r)
      break;
  }
  return Qn = !1, r;
}
function Ft(s, t, e, i, n, o = 0, r = 0, c = 0, l = 0, a = null, d = !1) {
  let h, u;
  d ? (h = pn, u = Ui) : (h = Ui, u = pn);
  const p = h.float32Array, m = h.uint32Array, b = h.uint16Array, G = u.float32Array, y = u.uint32Array, Z = u.uint16Array, f = s * 2, V = t * 2, X = Vt(f, b), R = Vt(V, Z);
  let x = !1;
  if (R && X)
    d ? x = n(
      Wt(t, y),
      vt(t * 2, Z),
      Wt(s, m),
      vt(s * 2, b),
      l,
      r + t,
      c,
      o + s
    ) : x = n(
      Wt(s, m),
      vt(s * 2, b),
      Wt(t, y),
      vt(t * 2, Z),
      c,
      o + s,
      l,
      r + t
    );
  else if (R) {
    const S = Xe.getPrimitive();
    E(t, G, S), S.applyMatrix4(e);
    const C = Mt(s), L = Kt(s, m);
    E(C, p, $e), E(L, p, ti);
    const g = S.intersectsBox($e), W = S.intersectsBox(ti);
    x = g && Ft(
      t,
      C,
      i,
      e,
      n,
      r,
      o,
      l,
      c + 1,
      S,
      !d
    ) || W && Ft(
      t,
      L,
      i,
      e,
      n,
      r,
      o,
      l,
      c + 1,
      S,
      !d
    ), Xe.releasePrimitive(S);
  } else {
    const S = Mt(t), C = Kt(t, y);
    E(S, G, Pn), E(C, G, Fn);
    const L = a.intersectsBox(Pn), g = a.intersectsBox(Fn);
    if (L && g)
      x = Ft(
        s,
        S,
        e,
        i,
        n,
        o,
        r,
        c,
        l + 1,
        a,
        d
      ) || Ft(
        s,
        C,
        e,
        i,
        n,
        o,
        r,
        c,
        l + 1,
        a,
        d
      );
    else if (L)
      if (X)
        x = Ft(
          s,
          S,
          e,
          i,
          n,
          o,
          r,
          c,
          l + 1,
          a,
          d
        );
      else {
        const W = Xe.getPrimitive();
        W.copy(Pn).applyMatrix4(e);
        const z = Mt(s), v = Kt(s, m);
        E(z, p, $e), E(v, p, ti);
        const k = W.intersectsBox($e), N = W.intersectsBox(ti);
        x = k && Ft(
          S,
          z,
          i,
          e,
          n,
          r,
          o,
          l,
          c + 1,
          W,
          !d
        ) || N && Ft(
          S,
          v,
          i,
          e,
          n,
          r,
          o,
          l,
          c + 1,
          W,
          !d
        ), Xe.releasePrimitive(W);
      }
    else if (g)
      if (X)
        x = Ft(
          s,
          C,
          e,
          i,
          n,
          o,
          r,
          c,
          l + 1,
          a,
          d
        );
      else {
        const W = Xe.getPrimitive();
        W.copy(Fn).applyMatrix4(e);
        const z = Mt(s), v = Kt(s, m);
        E(z, p, $e), E(v, p, ti);
        const k = W.intersectsBox($e), N = W.intersectsBox(ti);
        x = k && Ft(
          C,
          z,
          i,
          e,
          n,
          r,
          o,
          l,
          c + 1,
          W,
          !d
        ) || N && Ft(
          C,
          v,
          i,
          e,
          n,
          r,
          o,
          l,
          c + 1,
          W,
          !d
        ), Xe.releasePrimitive(W);
      }
  }
  return x;
}
const ws = /* @__PURE__ */ new Xt(), Tr = /* @__PURE__ */ new Ct(), $h = {
  strategy: Yo,
  maxDepth: 40,
  maxLeafTris: 10,
  useSharedArrayBuffer: !1,
  setBoundingBox: !0,
  onProgress: null,
  indirect: !1,
  verbose: !0,
  range: null
};
class Ee {
  static serialize(t, e = {}) {
    e = {
      cloneBuffers: !0,
      ...e
    };
    const i = t.geometry, n = t._roots, o = t._indirectBuffer, r = i.getIndex();
    let c;
    return e.cloneBuffers ? c = {
      roots: n.map((l) => l.slice()),
      index: r ? r.array.slice() : null,
      indirectBuffer: o ? o.slice() : null
    } : c = {
      roots: n,
      index: r ? r.array : null,
      indirectBuffer: o
    }, c;
  }
  static deserialize(t, e, i = {}) {
    i = {
      setIndex: !0,
      indirect: !!t.indirectBuffer,
      ...i
    };
    const { index: n, roots: o, indirectBuffer: r } = t, c = new Ee(e, { ...i, [Yn]: !0 });
    if (c._roots = o, c._indirectBuffer = r || null, i.setIndex) {
      const l = e.getIndex();
      if (l === null) {
        const a = new Gt(t.index, 1, !1);
        e.setIndex(a);
      } else
        l.array !== n && (l.array.set(n), l.needsUpdate = !0);
    }
    return c;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t, e = {}) {
    if (t.isBufferGeometry) {
      if (t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (e = Object.assign({
      ...$h,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Yn]: !1
    }, e), e.useSharedArrayBuffer && !hc())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t, this._roots = null, this._indirectBuffer = null, e[Yn] || (mh(this, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new Ct()))), this.resolveTriangleIndex = e.indirect ? (i) => this._indirectBuffer[i] : (i) => i;
  }
  refit(t = null) {
    return (this.indirect ? Fh : zh)(this, t);
  }
  traverse(t, e = 0) {
    const i = this._roots[e], n = new Uint32Array(i), o = new Uint16Array(i);
    r(0);
    function r(c, l = 0) {
      const a = c * 2, d = o[a + 15] === Xn;
      if (d) {
        const h = n[c + 6], u = o[a + 14];
        t(l, d, new Float32Array(i, c * 4, 6), h, u);
      } else {
        const h = c + Re / 4, u = n[c + 6], p = n[c + 7];
        t(l, d, new Float32Array(i, c * 4, 6), p) || (r(h, l + 1), r(u, l + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(t, e = Jo, i = 0, n = 1 / 0) {
    const o = this._roots, r = this.geometry, c = [], l = e.isMaterial, a = Array.isArray(e), d = r.groups, h = l ? e.side : e, u = this.indirect ? Qh : Mh;
    for (let p = 0, m = o.length; p < m; p++) {
      const b = a ? e[d[p].materialIndex].side : h, G = c.length;
      if (u(this, p, b, t, c, i, n), a) {
        const y = d[p].materialIndex;
        for (let Z = G, f = c.length; Z < f; Z++)
          c[Z].face.materialIndex = y;
      }
    }
    return c;
  }
  raycastFirst(t, e = Jo, i = 0, n = 1 / 0) {
    const o = this._roots, r = this.geometry, c = e.isMaterial, l = Array.isArray(e);
    let a = null;
    const d = r.groups, h = c ? e.side : e, u = this.indirect ? Bh : kh;
    for (let p = 0, m = o.length; p < m; p++) {
      const b = l ? e[d[p].materialIndex].side : h, G = u(this, p, b, t, i, n);
      G != null && (a == null || G.distance < a.distance) && (a = G, l && (G.face.materialIndex = d[p].materialIndex));
    }
    return a;
  }
  intersectsGeometry(t, e) {
    let i = !1;
    const n = this._roots, o = this.indirect ? Eh : Hh;
    for (let r = 0, c = n.length; r < c && (i = o(this, r, t, e), !i); r++)
      ;
    return i;
  }
  shapecast(t) {
    const e = Yt.getPrimitive(), i = this.indirect ? Th : gh;
    let {
      boundsTraverseOrder: n,
      intersectsBounds: o,
      intersectsRange: r,
      intersectsTriangle: c
    } = t;
    if (r && c) {
      const h = r;
      r = (u, p, m, b, G) => h(u, p, m, b, G) ? !0 : i(u, p, this, c, m, b, e);
    } else
      r || (c ? r = (h, u, p, m) => i(h, u, this, c, p, m, e) : r = (h, u, p) => p);
    let l = !1, a = 0;
    const d = this._roots;
    for (let h = 0, u = d.length; h < u; h++) {
      const p = d[h];
      if (l = fh(this, h, o, r, n, a), l)
        break;
      a += p.byteLength;
    }
    return Yt.releasePrimitive(e), l;
  }
  bvhcast(t, e, i) {
    let {
      intersectsRanges: n,
      intersectsTriangles: o
    } = i;
    const r = Yt.getPrimitive(), c = this.geometry.index, l = this.geometry.attributes.position, a = this.indirect ? (m) => {
      const b = this.resolveTriangleIndex(m);
      tt(r, b * 3, c, l);
    } : (m) => {
      tt(r, m * 3, c, l);
    }, d = Yt.getPrimitive(), h = t.geometry.index, u = t.geometry.attributes.position, p = t.indirect ? (m) => {
      const b = t.resolveTriangleIndex(m);
      tt(d, b * 3, h, u);
    } : (m) => {
      tt(d, m * 3, h, u);
    };
    if (o) {
      const m = (b, G, y, Z, f, V, X, R) => {
        for (let x = y, S = y + Z; x < S; x++) {
          p(x), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
          for (let C = b, L = b + G; C < L; C++)
            if (a(C), r.needsUpdate = !0, o(r, d, C, x, f, V, X, R))
              return !0;
        }
        return !1;
      };
      if (n) {
        const b = n;
        n = function(G, y, Z, f, V, X, R, x) {
          return b(G, y, Z, f, V, X, R, x) ? !0 : m(G, y, Z, f, V, X, R, x);
        };
      } else
        n = m;
    }
    return qh(this, t, e, n);
  }
  /* Derived Cast Functions */
  intersectsBox(t, e) {
    return ws.set(t.min, t.max, e), ws.needsUpdate = !0, this.shapecast(
      {
        intersectsBounds: (i) => ws.intersectsBox(i),
        intersectsTriangle: (i) => ws.intersectsTriangle(i)
      }
    );
  }
  intersectsSphere(t) {
    return this.shapecast(
      {
        intersectsBounds: (e) => t.intersectsBox(e),
        intersectsTriangle: (e) => e.intersectsSphere(t)
      }
    );
  }
  closestPointToGeometry(t, e, i = {}, n = {}, o = 0, r = 1 / 0) {
    return (this.indirect ? Ah : Ph)(
      this,
      t,
      e,
      i,
      n,
      o,
      r
    );
  }
  closestPointToPoint(t, e = {}, i = 0, n = 1 / 0) {
    return Vh(
      this,
      t,
      e,
      i,
      n
    );
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((i) => {
      E(0, new Float32Array(i), Tr), t.union(Tr);
    }), t;
  }
}
const Mr = /* @__PURE__ */ new Ct(), Yr = /* @__PURE__ */ new kt();
class tu extends Lo {
  get isMesh() {
    return !this.displayEdges;
  }
  get isLineSegments() {
    return this.displayEdges;
  }
  get isLine() {
    return this.displayEdges;
  }
  getVertexPosition(...t) {
    return mn.prototype.getVertexPosition.call(this, ...t);
  }
  constructor(t, e, i = 10, n = 0) {
    super(), this.material = e, this.geometry = new oi(), this.name = "MeshBVHRootHelper", this.depth = i, this.displayParents = !1, this.bvh = t, this.displayEdges = !0, this._group = n;
  }
  raycast() {
  }
  update() {
    const t = this.geometry, e = this.bvh, i = this._group;
    if (t.dispose(), this.visible = !1, e) {
      const n = this.depth - 1, o = this.displayParents;
      let r = 0;
      e.traverse((u, p) => {
        if (u >= n || p)
          return r++, !0;
        o && r++;
      }, i);
      let c = 0;
      const l = new Float32Array(8 * 3 * r);
      e.traverse((u, p, m) => {
        const b = u >= n || p;
        if (b || o) {
          E(0, m, Mr);
          const { min: G, max: y } = Mr;
          for (let Z = -1; Z <= 1; Z += 2) {
            const f = Z < 0 ? G.x : y.x;
            for (let V = -1; V <= 1; V += 2) {
              const X = V < 0 ? G.y : y.y;
              for (let R = -1; R <= 1; R += 2) {
                const x = R < 0 ? G.z : y.z;
                l[c + 0] = f, l[c + 1] = X, l[c + 2] = x, c += 3;
              }
            }
          }
          return b;
        }
      }, i);
      let a, d;
      this.displayEdges ? d = new Uint8Array([
        // x axis
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7,
        // y axis
        0,
        2,
        1,
        3,
        4,
        6,
        5,
        7,
        // z axis
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ]) : d = new Uint8Array([
        // X-, X+
        0,
        1,
        2,
        2,
        1,
        3,
        4,
        6,
        5,
        6,
        7,
        5,
        // Y-, Y+
        1,
        4,
        5,
        0,
        4,
        1,
        2,
        3,
        6,
        3,
        7,
        6,
        // Z-, Z+
        0,
        2,
        4,
        2,
        6,
        4,
        1,
        5,
        3,
        3,
        5,
        7
      ]), l.length > 65535 ? a = new Uint32Array(d.length * r) : a = new Uint16Array(d.length * r);
      const h = d.length;
      for (let u = 0; u < r; u++) {
        const p = u * 8, m = u * h;
        for (let b = 0; b < h; b++)
          a[m + b] = p + d[b];
      }
      t.setIndex(
        new Gt(a, 1, !1)
      ), t.setAttribute(
        "position",
        new Gt(l, 3, !1)
      ), this.visible = !0;
    }
  }
}
class Io extends Sc {
  get color() {
    return this.edgeMaterial.color;
  }
  get opacity() {
    return this.edgeMaterial.opacity;
  }
  set opacity(t) {
    this.edgeMaterial.opacity = t, this.meshMaterial.opacity = t;
  }
  constructor(t = null, e = null, i = 10) {
    t instanceof Ee && (i = e || 10, e = t, t = null), typeof e == "number" && (i = e, e = null), super(), this.name = "MeshBVHHelper", this.depth = i, this.mesh = t, this.bvh = e, this.displayParents = !1, this.displayEdges = !0, this.objectIndex = 0, this._roots = [];
    const n = new Wc({
      color: 65416,
      transparent: !0,
      opacity: 0.3,
      depthWrite: !1
    }), o = new En({
      color: 65416,
      transparent: !0,
      opacity: 0.3,
      depthWrite: !1
    });
    o.color = n.color, this.edgeMaterial = n, this.meshMaterial = o, this.update();
  }
  update() {
    const t = this.mesh;
    let e = this.bvh || t.geometry.boundsTree || null;
    if (t.isBatchedMesh && t.boundsTrees && !e) {
      const n = t._drawInfo[this.objectIndex];
      n && (e = t.boundsTrees[n.geometryIndex] || e);
    }
    const i = e ? e._roots.length : 0;
    for (; this._roots.length > i; ) {
      const n = this._roots.pop();
      n.geometry.dispose(), this.remove(n);
    }
    for (let n = 0; n < i; n++) {
      const { depth: o, edgeMaterial: r, meshMaterial: c, displayParents: l, displayEdges: a } = this;
      if (n >= this._roots.length) {
        const h = new tu(e, r, o, n);
        this.add(h), this._roots.push(h);
      }
      const d = this._roots[n];
      d.bvh = e, d.depth = o, d.displayParents = l, d.displayEdges = a, d.material = a ? r : c, d.update();
    }
  }
  updateMatrixWorld(...t) {
    const e = this.mesh, i = this.parent;
    e !== null && (e.updateWorldMatrix(!0, !1), i ? this.matrix.copy(i.matrixWorld).invert().multiply(e.matrixWorld) : this.matrix.copy(e.matrixWorld), (e.isInstancedMesh || e.isBatchedMesh) && (e.getMatrixAt(this.objectIndex, Yr), this.matrix.multiply(Yr)), this.matrix.decompose(
      this.position,
      this.quaternion,
      this.scale
    )), super.updateMatrixWorld(...t);
  }
  copy(t) {
    this.depth = t.depth, this.mesh = t.mesh, this.bvh = t.bvh, this.opacity = t.opacity, this.color.copy(t.color);
  }
  clone() {
    return new Io(this.mesh, this.bvh, this.depth);
  }
  dispose() {
    this.edgeMaterial.dispose(), this.meshMaterial.dispose();
    const t = this.children;
    for (let e = 0, i = t.length; e < i; e++)
      t[e].geometry.dispose();
  }
}
const vi = /* @__PURE__ */ new Ct(), kr = /* @__PURE__ */ new Ct(), ei = /* @__PURE__ */ new M();
function Hr(s) {
  switch (typeof s) {
    case "number":
      return 8;
    case "string":
      return s.length * 2;
    case "boolean":
      return 4;
    default:
      return 0;
  }
}
function eu(s) {
  return /(Uint|Int|Float)(8|16|32)Array/.test(s.constructor.name);
}
function iu(s, t) {
  const e = {
    nodeCount: 0,
    leafNodeCount: 0,
    depth: {
      min: 1 / 0,
      max: -1 / 0
    },
    tris: {
      min: 1 / 0,
      max: -1 / 0
    },
    splits: [0, 0, 0],
    surfaceAreaScore: 0
  };
  return s.traverse((i, n, o, r, c) => {
    const l = o[3] - o[0], a = o[1 + 3] - o[1], d = o[2 + 3] - o[2], h = 2 * (l * a + a * d + d * l);
    e.nodeCount++, n ? (e.leafNodeCount++, e.depth.min = Math.min(i, e.depth.min), e.depth.max = Math.max(i, e.depth.max), e.tris.min = Math.min(c, e.tris.min), e.tris.max = Math.max(c, e.tris.max), e.surfaceAreaScore += h * en * c) : (e.splits[r]++, e.surfaceAreaScore += h * mo);
  }, t), e.tris.min === 1 / 0 && (e.tris.min = 0, e.tris.max = 0), e.depth.min === 1 / 0 && (e.depth.min = 0, e.depth.max = 0), e;
}
function su(s) {
  return s._roots.map((t, e) => iu(s, e));
}
function nu(s) {
  const t = /* @__PURE__ */ new Set(), e = [s];
  let i = 0;
  for (; e.length; ) {
    const n = e.pop();
    if (!t.has(n)) {
      t.add(n);
      for (let o in n) {
        if (!Object.hasOwn(n, o))
          continue;
        i += Hr(o);
        const r = n[o];
        r && (typeof r == "object" || typeof r == "function") ? eu(r) || hc() && r instanceof SharedArrayBuffer || r instanceof ArrayBuffer ? i += r.byteLength : e.push(r) : i += Hr(r);
      }
    }
  }
  return i;
}
function ou(s) {
  const t = s.geometry, e = [], i = t.index, n = t.getAttribute("position");
  let o = !0;
  return s.traverse((r, c, l, a, d) => {
    const h = {
      depth: r,
      isLeaf: c,
      boundingData: l,
      offset: a,
      count: d
    };
    e[r] = h, E(0, l, vi);
    const u = e[r - 1];
    if (c)
      for (let p = a, m = a + d; p < m; p++) {
        const b = s.resolveTriangleIndex(p);
        let G = 3 * b, y = 3 * b + 1, Z = 3 * b + 2;
        i && (G = i.getX(G), y = i.getX(y), Z = i.getX(Z));
        let f;
        ei.fromBufferAttribute(n, G), f = vi.containsPoint(ei), ei.fromBufferAttribute(n, y), f = f && vi.containsPoint(ei), ei.fromBufferAttribute(n, Z), f = f && vi.containsPoint(ei), console.assert(f, "Leaf bounds does not fully contain triangle."), o = o && f;
      }
    if (u) {
      E(0, l, kr);
      const p = kr.containsBox(vi);
      console.assert(p, "Parent bounds does not fully contain child."), o = o && p;
    }
  }), o;
}
function ru(s) {
  const t = [];
  return s.traverse((e, i, n, o, r) => {
    const c = {
      bounds: E(0, n, new Ct())
    };
    i ? (c.count = r, c.offset = o) : (c.left = null, c.right = null), t[e] = c;
    const l = t[e - 1];
    l && (l.left === null ? l.left = c : l.right = c);
  }), t[0];
}
function Nr(s, t, e) {
  return s === null ? null : (s.point.applyMatrix4(t.matrixWorld), s.distance = s.point.distanceTo(e.ray.origin), s.object = t, s);
}
const lu = parseInt(qr) >= 166, Bs = /* @__PURE__ */ new gc(), Ir = /* @__PURE__ */ new M(), Jr = /* @__PURE__ */ new kt(), cu = mn.prototype.raycast, au = Cc.prototype.raycast, Ur = /* @__PURE__ */ new M(), at = /* @__PURE__ */ new mn(), Es = [];
function du(s, t) {
  this.isBatchedMesh ? hu.call(this, s, t) : uu.call(this, s, t);
}
function hu(s, t) {
  if (this.boundsTrees) {
    const e = this.boundsTrees, i = this._drawInfo || this._instanceInfo, n = this._drawRanges || this._geometryInfo, o = this.matrixWorld;
    at.material = this.material, at.geometry = this.geometry;
    const r = at.geometry.boundsTree, c = at.geometry.drawRange;
    at.geometry.boundingSphere === null && (at.geometry.boundingSphere = new Ar());
    for (let l = 0, a = i.length; l < a; l++) {
      if (!this.getVisibleAt(l))
        continue;
      const d = i[l].geometryIndex;
      if (at.geometry.boundsTree = e[d], this.getMatrixAt(l, at.matrixWorld).premultiply(o), !at.geometry.boundsTree) {
        this.getBoundingBoxAt(d, at.geometry.boundingBox), this.getBoundingSphereAt(d, at.geometry.boundingSphere);
        const h = n[d];
        at.geometry.setDrawRange(h.start, h.count);
      }
      at.raycast(s, Es);
      for (let h = 0, u = Es.length; h < u; h++) {
        const p = Es[h];
        p.object = this, p.batchId = l, t.push(p);
      }
      Es.length = 0;
    }
    at.geometry.boundsTree = r, at.geometry.drawRange = c, at.material = null, at.geometry = null;
  } else
    au.call(this, s, t);
}
function uu(s, t) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    Jr.copy(this.matrixWorld).invert(), Bs.copy(s.ray).applyMatrix4(Jr), Ur.setFromMatrixScale(this.matrixWorld), Ir.copy(Bs.direction).multiply(Ur);
    const e = Ir.length(), i = s.near / e, n = s.far / e, o = this.geometry.boundsTree;
    if (s.firstHitOnly === !0) {
      const r = Nr(o.raycastFirst(Bs, this.material, i, n), this, s);
      r && t.push(r);
    } else {
      const r = o.raycast(Bs, this.material, i, n);
      for (let c = 0, l = r.length; c < l; c++) {
        const a = Nr(r[c], this, s);
        a && t.push(a);
      }
    }
  } else
    cu.call(this, s, t);
}
function pu(s = {}) {
  return this.boundsTree = new Ee(this, s), this.boundsTree;
}
function mu() {
  this.boundsTree = null;
}
function bu(s = -1, t = {}) {
  if (!lu)
    throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");
  t.indirect && console.warn('"Indirect" is set to false because it is not supported for BatchedMesh.'), t = {
    ...t,
    indirect: !1,
    range: null
  };
  const e = this._drawRanges || this._geometryInfo, i = this._geometryCount;
  this.boundsTrees || (this.boundsTrees = new Array(i).fill(null));
  const n = this.boundsTrees;
  for (; n.length < i; )
    n.push(null);
  if (s < 0) {
    for (let o = 0; o < i; o++)
      t.range = e[o], n[o] = new Ee(this.geometry, t);
    return n;
  } else
    return s < e.length && (t.range = e[s], n[s] = new Ee(this.geometry, t)), n[s] || null;
}
function yu(s = -1) {
  s < 0 ? this.boundsTrees.fill(null) : s < this.boundsTree.length && (this.boundsTrees[s] = null);
}
function Gu(s) {
  switch (s) {
    case 1:
      return "R";
    case 2:
      return "RG";
    case 3:
      return "RGBA";
    case 4:
      return "RGBA";
  }
  throw new Error();
}
function Zu(s) {
  switch (s) {
    case 1:
      return Tc;
    case 2:
      return Kc;
    case 3:
      return nn;
    case 4:
      return nn;
  }
}
function Pr(s) {
  switch (s) {
    case 1:
      return Mc;
    case 2:
      return $r;
    case 3:
      return Dn;
    case 4:
      return Dn;
  }
}
class Vn extends _n {
  constructor() {
    super(), this.minFilter = ii, this.magFilter = ii, this.generateMipmaps = !1, this.overrideItemSize = null, this._forcedType = null;
  }
  updateFrom(t) {
    const e = this.overrideItemSize, i = t.itemSize, n = t.count;
    if (e !== null) {
      if (i * n % e !== 0)
        throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");
      t.itemSize = e, t.count = n * i / e;
    }
    const o = t.itemSize, r = t.count, c = t.normalized, l = t.array.constructor, a = l.BYTES_PER_ELEMENT;
    let d = this._forcedType, h = o;
    if (d === null)
      switch (l) {
        case Float32Array:
          d = Ii;
          break;
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
          d = Ni;
          break;
        case Int8Array:
        case Int16Array:
        case Int32Array:
          d = Ds;
          break;
      }
    let u, p, m, b, G = Gu(o);
    switch (d) {
      case Ii:
        m = 1, p = Zu(o), c && a === 1 ? (b = l, G += "8", l === Uint8Array ? u = Uo : (u = Po, G += "_SNORM")) : (b = Float32Array, G += "32F", u = Ii);
        break;
      case Ds:
        G += a * 8 + "I", m = c ? Math.pow(2, l.BYTES_PER_ELEMENT * 8 - 1) : 1, p = Pr(o), a === 1 ? (b = Int8Array, u = Po) : a === 2 ? (b = Int16Array, u = vc) : (b = Int32Array, u = Ds);
        break;
      case Ni:
        G += a * 8 + "UI", m = c ? Math.pow(2, l.BYTES_PER_ELEMENT * 8 - 1) : 1, p = Pr(o), a === 1 ? (b = Uint8Array, u = Uo) : a === 2 ? (b = Uint16Array, u = zc) : (b = Uint32Array, u = Ni);
        break;
    }
    h === 3 && (p === nn || p === Dn) && (h = 4);
    const y = Math.ceil(Math.sqrt(r)) || 1, Z = h * y * y, f = new b(Z), V = t.normalized;
    t.normalized = !1;
    for (let X = 0; X < r; X++) {
      const R = h * X;
      f[R] = t.getX(X) / m, o >= 2 && (f[R + 1] = t.getY(X) / m), o >= 3 && (f[R + 2] = t.getZ(X) / m, h === 4 && (f[R + 3] = 1)), o >= 4 && (f[R + 3] = t.getW(X) / m);
    }
    t.normalized = V, this.internalFormat = G, this.format = p, this.type = u, this.image.width = y, this.image.height = y, this.image.data = f, this.needsUpdate = !0, this.dispose(), t.itemSize = i, t.count = n;
  }
}
class uc extends Vn {
  constructor() {
    super(), this._forcedType = Ni;
  }
}
class Xu extends Vn {
  constructor() {
    super(), this._forcedType = Ds;
  }
}
class pc extends Vn {
  constructor() {
    super(), this._forcedType = Ii;
  }
}
class fu {
  constructor() {
    this.index = new uc(), this.position = new pc(), this.bvhBounds = new _n(), this.bvhContents = new _n(), this._cachedIndexAttr = null, this.index.overrideItemSize = 3;
  }
  updateFrom(t) {
    const { geometry: e } = t;
    if (Ru(t, this.bvhBounds, this.bvhContents), this.position.updateFrom(e.attributes.position), t.indirect) {
      const i = t._indirectBuffer;
      if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== i.length)
        if (e.index)
          this._cachedIndexAttr = e.index.clone();
        else {
          const n = rc(oc(e));
          this._cachedIndexAttr = new Gt(n, 1, !1);
        }
      Vu(e, i, this._cachedIndexAttr), this.index.updateFrom(this._cachedIndexAttr);
    } else
      this.index.updateFrom(e.index);
  }
  dispose() {
    const { index: t, position: e, bvhBounds: i, bvhContents: n } = this;
    t && t.dispose(), e && e.dispose(), i && i.dispose(), n && n.dispose();
  }
}
function Vu(s, t, e) {
  const i = e.array, n = s.index ? s.index.array : null;
  for (let o = 0, r = t.length; o < r; o++) {
    const c = 3 * o, l = 3 * t[o];
    for (let a = 0; a < 3; a++)
      i[c + a] = n ? n[l + a] : l + a;
  }
}
function Ru(s, t, e) {
  const i = s._roots;
  if (i.length !== 1)
    throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");
  const n = i[0], o = new Uint16Array(n), r = new Uint32Array(n), c = new Float32Array(n), l = n.byteLength / Re, a = 2 * Math.ceil(Math.sqrt(l / 2)), d = new Float32Array(4 * a * a), h = Math.ceil(Math.sqrt(l)), u = new Uint32Array(2 * h * h);
  for (let p = 0; p < l; p++) {
    const m = p * Re / 4, b = m * 2, G = m;
    for (let y = 0; y < 3; y++)
      d[8 * p + 0 + y] = c[G + 0 + y], d[8 * p + 4 + y] = c[G + 3 + y];
    if (Vt(b, o)) {
      const y = vt(b, o), Z = Wt(m, r), f = 4294901760 | y;
      u[p * 2 + 0] = f, u[p * 2 + 1] = Z;
    } else {
      const y = 4 * Kt(m, r) / Re, Z = ko(m, r);
      u[p * 2 + 0] = Z, u[p * 2 + 1] = y;
    }
  }
  t.image.data = d, t.image.width = a, t.image.height = a, t.format = nn, t.type = Ii, t.internalFormat = "RGBA32F", t.minFilter = ii, t.magFilter = ii, t.generateMipmaps = !1, t.needsUpdate = !0, t.dispose(), e.image.data = u, e.image.width = h, e.image.height = h, e.format = $r, e.type = Ni, e.internalFormat = "RG32UI", e.minFilter = ii, e.magFilter = ii, e.generateMipmaps = !1, e.needsUpdate = !0, e.dispose();
}
const Je = /* @__PURE__ */ new M(), Ue = /* @__PURE__ */ new M(), Pe = /* @__PURE__ */ new M(), Fr = /* @__PURE__ */ new So(), js = /* @__PURE__ */ new M(), wn = /* @__PURE__ */ new M(), Qr = /* @__PURE__ */ new So(), wr = /* @__PURE__ */ new So(), Os = /* @__PURE__ */ new kt(), Br = /* @__PURE__ */ new kt();
function Ki(s, t) {
  if (!s && !t)
    return;
  const e = s.count === t.count, i = s.normalized === t.normalized, n = s.array.constructor === t.array.constructor, o = s.itemSize === t.itemSize;
  if (!e || !i || !n || !o)
    throw new Error();
}
function Hi(s, t = null) {
  const e = s.array.constructor, i = s.normalized, n = s.itemSize, o = t === null ? s.count : t;
  return new Gt(new e(n * o), n, i);
}
function mc(s, t, e = 0) {
  if (s.isInterleavedBufferAttribute) {
    const i = s.itemSize;
    for (let n = 0, o = s.count; n < o; n++) {
      const r = n + e;
      t.setX(r, s.getX(n)), i >= 2 && t.setY(r, s.getY(n)), i >= 3 && t.setZ(r, s.getZ(n)), i >= 4 && t.setW(r, s.getW(n));
    }
  } else {
    const i = t.array, n = i.constructor, o = i.BYTES_PER_ELEMENT * s.itemSize * e;
    new n(i.buffer, o, s.array.length).set(s.array);
  }
}
function xu(s, t, e) {
  const i = s.elements, n = t.elements;
  for (let o = 0, r = n.length; o < r; o++)
    i[o] += n[o] * e;
}
function Er(s, t, e) {
  const i = s.skeleton, n = s.geometry, o = i.bones, r = i.boneInverses;
  Qr.fromBufferAttribute(n.attributes.skinIndex, t), wr.fromBufferAttribute(n.attributes.skinWeight, t), Os.elements.fill(0);
  for (let c = 0; c < 4; c++) {
    const l = wr.getComponent(c);
    if (l !== 0) {
      const a = Qr.getComponent(c);
      Br.multiplyMatrices(o[a].matrixWorld, r[a]), xu(Os, Br, l);
    }
  }
  return Os.multiply(s.bindMatrix).premultiply(s.bindMatrixInverse), e.transformDirection(Os), e;
}
function Bn(s, t, e, i, n) {
  js.set(0, 0, 0);
  for (let o = 0, r = s.length; o < r; o++) {
    const c = t[o], l = s[o];
    c !== 0 && (wn.fromBufferAttribute(l, i), e ? js.addScaledVector(wn, c) : js.addScaledVector(wn.sub(n), c));
  }
  n.add(js);
}
function Lu(s, t = { useGroups: !1, updateIndex: !1, skipAttributes: [] }, e = new oi()) {
  const i = s[0].index !== null, { useGroups: n = !1, updateIndex: o = !1, skipAttributes: r = [] } = t, c = new Set(Object.keys(s[0].attributes)), l = {};
  let a = 0;
  e.clearGroups();
  for (let d = 0; d < s.length; ++d) {
    const h = s[d];
    let u = 0;
    if (i !== (h.index !== null))
      throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
    for (const p in h.attributes) {
      if (!c.has(p))
        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "' + p + '" attribute exists among all geometries, or in none of them.');
      l[p] === void 0 && (l[p] = []), l[p].push(h.attributes[p]), u++;
    }
    if (u !== c.size)
      throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");
    if (n) {
      let p;
      if (i)
        p = h.index.count;
      else if (h.attributes.position !== void 0)
        p = h.attributes.position.count;
      else
        throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");
      e.addGroup(a, p, d), a += p;
    }
  }
  if (i) {
    let d = !1;
    if (!e.index) {
      let h = 0;
      for (let u = 0; u < s.length; ++u)
        h += s[u].index.count;
      e.setIndex(new Gt(new Uint32Array(h), 1, !1)), d = !0;
    }
    if (o || d) {
      const h = e.index;
      let u = 0, p = 0;
      for (let m = 0; m < s.length; ++m) {
        const b = s[m], G = b.index;
        if (r[m] !== !0)
          for (let y = 0; y < G.count; ++y)
            h.setX(u, G.getX(y) + p), u++;
        p += b.attributes.position.count;
      }
    }
  }
  for (const d in l) {
    const h = l[d];
    if (!(d in e.attributes)) {
      let m = 0;
      for (const b in h)
        m += h[b].count;
      e.setAttribute(d, Hi(l[d][0], m));
    }
    const u = e.attributes[d];
    let p = 0;
    for (let m = 0, b = h.length; m < b; m++) {
      const G = h[m];
      r[m] !== !0 && mc(G, u, p), p += G.count;
    }
  }
  return e;
}
function Su(s, t) {
  if (s === null || t === null)
    return s === t;
  if (s.length !== t.length)
    return !1;
  for (let e = 0, i = s.length; e < i; e++)
    if (s[e] !== t[e])
      return !1;
  return !0;
}
function Wu(s) {
  const { index: t, attributes: e } = s;
  if (t)
    for (let i = 0, n = t.count; i < n; i += 3) {
      const o = t.getX(i), r = t.getX(i + 2);
      t.setX(i, r), t.setX(i + 2, o);
    }
  else
    for (const i in e) {
      const n = e[i], o = n.itemSize;
      for (let r = 0, c = n.count; r < c; r += 3)
        for (let l = 0; l < o; l++) {
          const a = n.getComponent(r, l), d = n.getComponent(r + 2, l);
          n.setComponent(r, l, d), n.setComponent(r + 2, l, a);
        }
    }
  return s;
}
class Cu {
  constructor(t) {
    this.matrixWorld = new kt(), this.geometryHash = null, this.boneMatrices = null, this.primitiveCount = -1, this.mesh = t, this.update();
  }
  update() {
    const t = this.mesh, e = t.geometry, i = t.skeleton, n = (e.index ? e.index.count : e.attributes.position.count) / 3;
    if (this.matrixWorld.copy(t.matrixWorld), this.geometryHash = e.attributes.position.version, this.primitiveCount = n, i) {
      i.boneTexture || i.computeBoneTexture(), i.update();
      const o = i.boneMatrices;
      !this.boneMatrices || this.boneMatrices.length !== o.length ? this.boneMatrices = o.slice() : this.boneMatrices.set(o);
    } else
      this.boneMatrices = null;
  }
  didChange() {
    const t = this.mesh, e = t.geometry, i = (e.index ? e.index.count : e.attributes.position.count) / 3;
    return !(this.matrixWorld.equals(t.matrixWorld) && this.geometryHash === e.attributes.position.version && Su(t.skeleton && t.skeleton.boneMatrices || null, this.boneMatrices) && this.primitiveCount === i);
  }
}
class gu {
  constructor(t) {
    Array.isArray(t) || (t = [t]);
    const e = [];
    t.forEach((i) => {
      i.traverseVisible((n) => {
        n.isMesh && e.push(n);
      });
    }), this.meshes = e, this.useGroups = !0, this.applyWorldTransforms = !0, this.attributes = ["position", "normal", "color", "tangent", "uv", "uv2"], this._intermediateGeometry = new Array(e.length).fill().map(() => new oi()), this._diffMap = /* @__PURE__ */ new WeakMap();
  }
  getMaterials() {
    const t = [];
    return this.meshes.forEach((e) => {
      Array.isArray(e.material) ? t.push(...e.material) : t.push(e.material);
    }), t;
  }
  generate(t = new oi()) {
    let e = [];
    const { meshes: i, useGroups: n, _intermediateGeometry: o, _diffMap: r } = this;
    for (let c = 0, l = i.length; c < l; c++) {
      const a = i[c], d = o[c], h = r.get(a);
      !h || h.didChange(a) ? (this._convertToStaticGeometry(a, d), e.push(!1), h ? h.update() : r.set(a, new Cu(a))) : e.push(!0);
    }
    if (o.length === 0) {
      t.setIndex(null);
      const c = t.attributes;
      for (const l in c)
        t.deleteAttribute(l);
      for (const l in this.attributes)
        t.setAttribute(this.attributes[l], new Gt(new Float32Array(0), 4, !1));
    } else
      Lu(o, { useGroups: n, skipAttributes: e }, t);
    for (const c in t.attributes)
      t.attributes[c].needsUpdate = !0;
    return t;
  }
  _convertToStaticGeometry(t, e = new oi()) {
    const i = t.geometry, n = this.applyWorldTransforms, o = this.attributes.includes("normal"), r = this.attributes.includes("tangent"), c = i.attributes, l = e.attributes;
    !e.index && i.index && (e.index = i.index.clone()), l.position || e.setAttribute("position", Hi(c.position)), o && !l.normal && c.normal && e.setAttribute("normal", Hi(c.normal)), r && !l.tangent && c.tangent && e.setAttribute("tangent", Hi(c.tangent)), Ki(i.index, e.index), Ki(c.position, l.position), o && Ki(c.normal, l.normal), r && Ki(c.tangent, l.tangent);
    const a = c.position, d = o ? c.normal : null, h = r ? c.tangent : null, u = i.morphAttributes.position, p = i.morphAttributes.normal, m = i.morphAttributes.tangent, b = i.morphTargetsRelative, G = t.morphTargetInfluences, y = new Yc();
    y.getNormalMatrix(t.matrixWorld), i.index && e.index.array.set(i.index.array);
    for (let Z = 0, f = c.position.count; Z < f; Z++)
      Je.fromBufferAttribute(a, Z), d && Ue.fromBufferAttribute(d, Z), h && (Fr.fromBufferAttribute(h, Z), Pe.fromBufferAttribute(h, Z)), G && (u && Bn(u, G, b, Z, Je), p && Bn(p, G, b, Z, Ue), m && Bn(m, G, b, Z, Pe)), t.isSkinnedMesh && (t.applyBoneTransform(Z, Je), d && Er(t, Z, Ue), h && Er(t, Z, Pe)), n && Je.applyMatrix4(t.matrixWorld), l.position.setXYZ(Z, Je.x, Je.y, Je.z), d && (n && Ue.applyNormalMatrix(y), l.normal.setXYZ(Z, Ue.x, Ue.y, Ue.z)), h && (n && Pe.transformDirection(t.matrixWorld), l.tangent.setXYZW(Z, Pe.x, Pe.y, Pe.z, Fr.w));
    for (const Z in this.attributes) {
      const f = this.attributes[Z];
      f === "position" || f === "tangent" || f === "normal" || !(f in c) || (l[f] || e.setAttribute(f, Hi(c[f])), Ki(c[f], l[f]), mc(c[f], l[f]));
    }
    return t.matrixWorld.determinant() < 0 && Wu(e), e;
  }
}
const bc = (
  /* glsl */
  `

// A stack of uint32 indices can can store the indices for
// a perfectly balanced tree with a depth up to 31. Lower stack
// depth gets higher performance.
//
// However not all trees are balanced. Best value to set this to
// is the trees max depth.
#ifndef BVH_STACK_DEPTH
#define BVH_STACK_DEPTH 60
#endif

#ifndef INFINITY
#define INFINITY 1e20
#endif

// Utilities
uvec4 uTexelFetch1D( usampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

ivec4 iTexelFetch1D( isampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 texelFetch1D( sampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {

	return
		barycoord.x * texelFetch1D( tex, faceIndices.x ) +
		barycoord.y * texelFetch1D( tex, faceIndices.y ) +
		barycoord.z * texelFetch1D( tex, faceIndices.z );

}

void ndcToCameraRay(
	vec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,
	out vec3 rayOrigin, out vec3 rayDirection
) {

	// get camera look direction and near plane for camera clipping
	vec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );
	vec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );
	float near = abs( nearVector.z / nearVector.w );

	// get the camera direction and position from camera matrices
	vec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );
	direction /= direction.w;
	direction = cameraWorld * direction - origin;

	// slide the origin along the ray until it sits at the near clip plane position
	origin.xyz += direction.xyz * near / dot( direction, lookDirection );

	rayOrigin = origin.xyz;
	rayDirection = direction.xyz;

}
`
), yc = (
  /* glsl */
  `

float dot2( vec3 v ) {

	return dot( v, v );

}

// https://www.shadertoy.com/view/ttfGWl
vec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {

    vec3 v10 = v1 - v0;
    vec3 v21 = v2 - v1;
    vec3 v02 = v0 - v2;

	vec3 p0 = p - v0;
	vec3 p1 = p - v1;
	vec3 p2 = p - v2;

    vec3 nor = cross( v10, v02 );

    // method 2, in barycentric space
    vec3  q = cross( nor, p0 );
    float d = 1.0 / dot2( nor );
    float u = d * dot( q, v02 );
    float v = d * dot( q, v10 );
    float w = 1.0 - u - v;

	if( u < 0.0 ) {

		w = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );
		u = 0.0;
		v = 1.0 - w;

	} else if( v < 0.0 ) {

		u = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );
		v = 0.0;
		w = 1.0 - u;

	} else if( w < 0.0 ) {

		v = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );
		w = 0.0;
		u = 1.0-v;

	}

	barycoord = vec3( u, v, w );
    return u * v1 + v * v2 + w * v0;

}

float distanceToTriangles(
	// geometry info and triangle range
	sampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,

	// point and cut off range
	vec3 point, float closestDistanceSquared,

	// outputs
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint
) {

	bool found = false;
	vec3 localBarycoord;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;
		vec3 a = texelFetch1D( positionAttr, indices.x ).rgb;
		vec3 b = texelFetch1D( positionAttr, indices.y ).rgb;
		vec3 c = texelFetch1D( positionAttr, indices.z ).rgb;

		// get the closest point and barycoord
		vec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );
		vec3 delta = point - closestPoint;
		float sqDist = dot2( delta );
		if ( sqDist < closestDistanceSquared ) {

			// set the output results
			closestDistanceSquared = sqDist;
			faceIndices = uvec4( indices.xyz, i );
			faceNormal = normalize( cross( a - b, b - c ) );
			barycoord = localBarycoord;
			outPoint = closestPoint;
			side = sign( dot( faceNormal, delta ) );

		}

	}

	return closestDistanceSquared;

}

float distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {

	vec3 clampedPoint = clamp( point, boundsMin, boundsMax );
	vec3 delta = point - clampedPoint;
	return dot( delta, delta );

}

float distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {

	uint cni2 = currNodeIndex * 2u;
	vec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;
	vec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;
	return distanceSqToBounds( point, boundsMin, boundsMax );

}

// use a macro to hide the fact that we need to expand the struct into separate fields
#define	bvhClosestPointToPoint(		bvh,		point, faceIndices, faceNormal, barycoord, side, outPoint	)	_bvhClosestPointToPoint(		bvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,		point, faceIndices, faceNormal, barycoord, side, outPoint	)

float _bvhClosestPointToPoint(
	// bvh info
	sampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,

	// point to check
	vec3 point,

	// output variables
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout vec3 outPoint
 ) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ BVH_STACK_DEPTH ];
	stack[ 0 ] = 0u;

	float closestDistanceSquared = pow( 100000.0, 2.0 );
	bool found = false;
	while ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );
		if ( boundsHitDistance > closestDistanceSquared ) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );
		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;
			closestDistanceSquared = distanceToTriangles(
				bvh_position, bvh_index, offset, count, point, closestDistanceSquared,

				// outputs
				faceIndices, faceNormal, barycoord, side, outPoint
			);

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;
			bool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;
			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return sqrt( closestDistanceSquared );

}
`
), Gc = (
  /* glsl */
  `

#ifndef TRI_INTERSECT_EPSILON
#define TRI_INTERSECT_EPSILON 1e-5
#endif

// Raycasting
bool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {

	// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/
	// https://tavianator.com/2011/ray_box.html
	vec3 invDir = 1.0 / rayDirection;

	// find intersection distances for each plane
	vec3 tMinPlane = invDir * ( boundsMin - rayOrigin );
	vec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );

	// get the min and max distances from each intersection
	vec3 tMinHit = min( tMaxPlane, tMinPlane );
	vec3 tMaxHit = max( tMaxPlane, tMinPlane );

	// get the furthest hit distance
	vec2 t = max( tMinHit.xx, tMinHit.yz );
	float t0 = max( t.x, t.y );

	// get the minimum hit distance
	t = min( tMaxHit.xx, tMaxHit.yz );
	float t1 = min( t.x, t.y );

	// set distance to 0.0 if the ray starts inside the box
	dist = max( t0, 0.0 );

	return t1 >= dist;

}

bool intersectsTriangle(
	vec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,
	out vec3 barycoord, out vec3 norm, out float dist, out float side
) {

	// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d
	vec3 edge1 = b - a;
	vec3 edge2 = c - a;
	norm = cross( edge1, edge2 );

	float det = - dot( rayDirection, norm );
	float invdet = 1.0 / det;

	vec3 AO = rayOrigin - a;
	vec3 DAO = cross( AO, rayDirection );

	vec4 uvt;
	uvt.x = dot( edge2, DAO ) * invdet;
	uvt.y = - dot( edge1, DAO ) * invdet;
	uvt.z = dot( AO, norm ) * invdet;
	uvt.w = 1.0 - uvt.x - uvt.y;

	// set the hit information
	barycoord = uvt.wxy; // arranged in A, B, C order
	dist = uvt.z;
	side = sign( det );
	norm = side * normalize( norm );

	// add an epsilon to avoid misses between triangles
	uvt += vec4( TRI_INTERSECT_EPSILON );

	return all( greaterThanEqual( uvt, vec4( 0.0 ) ) );

}

bool intersectTriangles(
	// geometry info and triangle range
	sampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// outputs
	inout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	bool found = false;
	vec3 localBarycoord, localNormal;
	float localDist, localSide;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;
		vec3 a = texelFetch1D( positionAttr, indices.x ).rgb;
		vec3 b = texelFetch1D( positionAttr, indices.y ).rgb;
		vec3 c = texelFetch1D( positionAttr, indices.z ).rgb;

		if (
			intersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )
			&& localDist < minDistance
		) {

			found = true;
			minDistance = localDist;

			faceIndices = uvec4( indices.xyz, i );
			faceNormal = localNormal;

			side = localSide;
			barycoord = localBarycoord;
			dist = localDist;

		}

	}

	return found;

}

bool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {

	uint cni2 = currNodeIndex * 2u;
	vec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;
	vec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;
	return intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );

}

// use a macro to hide the fact that we need to expand the struct into separate fields
#define	bvhIntersectFirstHit(		bvh,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)	_bvhIntersectFirstHit(		bvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)

bool _bvhIntersectFirstHit(
	// bvh info
	sampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// output variables split into separate variables due to output precision
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ BVH_STACK_DEPTH ];
	stack[ 0 ] = 0u;

	float triangleDistance = INFINITY;
	bool found = false;
	while ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance;
		if (
			! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )
			|| boundsHitDistance > triangleDistance
		) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );

		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;

			found = intersectTriangles(
				bvh_position, bvh_index, offset, count,
				rayOrigin, rayDirection, triangleDistance,
				faceIndices, faceNormal, barycoord, side, dist
			) || found;

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;

			bool leftToRight = rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;

			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return found;

}
`
), Zc = (
  /* glsl */
  `
struct BVH {

	usampler2D index;
	sampler2D position;

	sampler2D bvhBounds;
	usampler2D bvhContents;

};
`
), zu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bvh_distance_functions: yc,
  bvh_ray_functions: Gc,
  bvh_struct_definitions: Zc,
  common_functions: bc
}, Symbol.toStringTag, { value: "Module" })), vu = Zc, Ku = yc, Tu = `
	${bc}
	${Gc}
`, Fu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AVERAGE: sc,
  BVHShaderGLSL: zu,
  CENTER: Yo,
  CONTAINED: po,
  ExtendedTriangle: Ht,
  FloatVertexAttributeTexture: pc,
  INTERSECTED: th,
  IntVertexAttributeTexture: Xu,
  MeshBVH: Ee,
  MeshBVHHelper: Io,
  MeshBVHUniformStruct: fu,
  NOT_INTERSECTED: $d,
  OrientedBox: Xt,
  SAH: nc,
  StaticGeometryGenerator: gu,
  UIntVertexAttributeTexture: uc,
  VertexAttributeTexture: Vn,
  acceleratedRaycast: du,
  computeBatchedBoundsTree: bu,
  computeBoundsTree: pu,
  disposeBatchedBoundsTree: yu,
  disposeBoundsTree: mu,
  estimateMemoryInBytes: nu,
  getBVHExtremes: su,
  getJSONStructure: ru,
  getTriangleHitPointInfo: Sh,
  shaderDistanceFunction: Ku,
  shaderIntersectFunction: Tu,
  shaderStructs: vu,
  validateBounds: ou
}, Symbol.toStringTag, { value: "Module" }));
class Qu {
  constructor(t) {
    this.name = "WorkerBase", this.running = !1, this.worker = t, this.worker.onerror = (e) => {
      throw e.message ? new Error(`${this.name}: Could not create Web Worker with error "${e.message}"`) : new Error(`${this.name}: Could not create Web Worker.`);
    };
  }
  runTask() {
  }
  generate(...t) {
    if (this.running)
      throw new Error("GenerateMeshBVHWorker: Already running job.");
    if (this.worker === null)
      throw new Error("GenerateMeshBVHWorker: Worker has been disposed.");
    this.running = !0;
    const e = this.runTask(this.worker, ...t);
    return e.finally(() => {
      this.running = !1;
    }), e;
  }
  dispose() {
    this.worker.terminate(), this.worker = null;
  }
}
const Xc = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBBbj10eXBlb2YgZG9jdW1lbnQ8InUiP2RvY3VtZW50LmN1cnJlbnRTY3JpcHQ6bnVsbDsvKioKICogQGxpY2Vuc2UKICogQ29weXJpZ2h0IDIwMTAtMjAyNCBUaHJlZS5qcyBBdXRob3JzCiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQKICovY29uc3QgWGU9IjE2OSIsVmk9MCxVaT0xLEVvPTIsTW49MCxraT0zMDAsQ289MzAxLEZvPTMwMixIaT0xZTMsX3M9MTAwMSxxaT0xMDAyLHpzPTEwMDMsJGk9MTAwNixHaT0xMDA4LFJvPTEwMDksQm89MTAxMyxXaT0xMDE0LElvPTEwMTUsdm89MTAxNixQbz0xMDIwLExvPTEwMjMsU249MTAyNixYaT0xMDI3LFlpPTAsT289MSxicz0iIiwkdD0ic3JnYiIsRXM9InNyZ2ItbGluZWFyIixEbz0iZGlzcGxheS1wMyIsWmk9ImRpc3BsYXktcDMtbGluZWFyIixfbj0ibGluZWFyIixKaT0ic3JnYiIsamk9InJlYzcwOSIsUWk9InAzIixDcz0zNTA0NCxZZT0yZTMsem49MjAwMTtjbGFzcyBaZXthZGRFdmVudExpc3RlbmVyKHQsZSl7dGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwJiYodGhpcy5fbGlzdGVuZXJzPXt9KTtjb25zdCBzPXRoaXMuX2xpc3RlbmVycztzW3RdPT09dm9pZCAwJiYoc1t0XT1bXSksc1t0XS5pbmRleE9mKGUpPT09LTEmJnNbdF0ucHVzaChlKX1oYXNFdmVudExpc3RlbmVyKHQsZSl7aWYodGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwKXJldHVybiExO2NvbnN0IHM9dGhpcy5fbGlzdGVuZXJzO3JldHVybiBzW3RdIT09dm9pZCAwJiZzW3RdLmluZGV4T2YoZSkhPT0tMX1yZW1vdmVFdmVudExpc3RlbmVyKHQsZSl7aWYodGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwKXJldHVybjtjb25zdCBuPXRoaXMuX2xpc3RlbmVyc1t0XTtpZihuIT09dm9pZCAwKXtjb25zdCBpPW4uaW5kZXhPZihlKTtpIT09LTEmJm4uc3BsaWNlKGksMSl9fWRpc3BhdGNoRXZlbnQodCl7aWYodGhpcy5fbGlzdGVuZXJzPT09dm9pZCAwKXJldHVybjtjb25zdCBzPXRoaXMuX2xpc3RlbmVyc1t0LnR5cGVdO2lmKHMhPT12b2lkIDApe3QudGFyZ2V0PXRoaXM7Y29uc3Qgbj1zLnNsaWNlKDApO2ZvcihsZXQgaT0wLG89bi5sZW5ndGg7aTxvO2krKyluW2ldLmNhbGwodGhpcyx0KTt0LnRhcmdldD1udWxsfX19Y29uc3Qgb3Q9WyIwMCIsIjAxIiwiMDIiLCIwMyIsIjA0IiwiMDUiLCIwNiIsIjA3IiwiMDgiLCIwOSIsIjBhIiwiMGIiLCIwYyIsIjBkIiwiMGUiLCIwZiIsIjEwIiwiMTEiLCIxMiIsIjEzIiwiMTQiLCIxNSIsIjE2IiwiMTciLCIxOCIsIjE5IiwiMWEiLCIxYiIsIjFjIiwiMWQiLCIxZSIsIjFmIiwiMjAiLCIyMSIsIjIyIiwiMjMiLCIyNCIsIjI1IiwiMjYiLCIyNyIsIjI4IiwiMjkiLCIyYSIsIjJiIiwiMmMiLCIyZCIsIjJlIiwiMmYiLCIzMCIsIjMxIiwiMzIiLCIzMyIsIjM0IiwiMzUiLCIzNiIsIjM3IiwiMzgiLCIzOSIsIjNhIiwiM2IiLCIzYyIsIjNkIiwiM2UiLCIzZiIsIjQwIiwiNDEiLCI0MiIsIjQzIiwiNDQiLCI0NSIsIjQ2IiwiNDciLCI0OCIsIjQ5IiwiNGEiLCI0YiIsIjRjIiwiNGQiLCI0ZSIsIjRmIiwiNTAiLCI1MSIsIjUyIiwiNTMiLCI1NCIsIjU1IiwiNTYiLCI1NyIsIjU4IiwiNTkiLCI1YSIsIjViIiwiNWMiLCI1ZCIsIjVlIiwiNWYiLCI2MCIsIjYxIiwiNjIiLCI2MyIsIjY0IiwiNjUiLCI2NiIsIjY3IiwiNjgiLCI2OSIsIjZhIiwiNmIiLCI2YyIsIjZkIiwiNmUiLCI2ZiIsIjcwIiwiNzEiLCI3MiIsIjczIiwiNzQiLCI3NSIsIjc2IiwiNzciLCI3OCIsIjc5IiwiN2EiLCI3YiIsIjdjIiwiN2QiLCI3ZSIsIjdmIiwiODAiLCI4MSIsIjgyIiwiODMiLCI4NCIsIjg1IiwiODYiLCI4NyIsIjg4IiwiODkiLCI4YSIsIjhiIiwiOGMiLCI4ZCIsIjhlIiwiOGYiLCI5MCIsIjkxIiwiOTIiLCI5MyIsIjk0IiwiOTUiLCI5NiIsIjk3IiwiOTgiLCI5OSIsIjlhIiwiOWIiLCI5YyIsIjlkIiwiOWUiLCI5ZiIsImEwIiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsImE2IiwiYTciLCJhOCIsImE5IiwiYWEiLCJhYiIsImFjIiwiYWQiLCJhZSIsImFmIiwiYjAiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiYjkiLCJiYSIsImJiIiwiYmMiLCJiZCIsImJlIiwiYmYiLCJjMCIsImMxIiwiYzIiLCJjMyIsImM0IiwiYzUiLCJjNiIsImM3IiwiYzgiLCJjOSIsImNhIiwiY2IiLCJjYyIsImNkIiwiY2UiLCJjZiIsImQwIiwiZDEiLCJkMiIsImQzIiwiZDQiLCJkNSIsImQ2IiwiZDciLCJkOCIsImQ5IiwiZGEiLCJkYiIsImRjIiwiZGQiLCJkZSIsImRmIiwiZTAiLCJlMSIsImUyIiwiZTMiLCJlNCIsImU1IiwiZTYiLCJlNyIsImU4IiwiZTkiLCJlYSIsImViIiwiZWMiLCJlZCIsImVlIiwiZWYiLCJmMCIsImYxIiwiZjIiLCJmMyIsImY0IiwiZjUiLCJmNiIsImY3IiwiZjgiLCJmOSIsImZhIiwiZmIiLCJmYyIsImZkIiwiZmUiLCJmZiJdO2xldCBLaT0xMjM0NTY3O2NvbnN0IHRyPU1hdGguUEkvMTgwLGVyPTE4MC9NYXRoLlBJO2Z1bmN0aW9uIEt0KCl7Y29uc3Qgcj1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTV8MCx0PU1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NXwwLGU9TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk1fDAscz1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTV8MDtyZXR1cm4ob3RbciYyNTVdK290W3I+PjgmMjU1XStvdFtyPj4xNiYyNTVdK290W3I+PjI0JjI1NV0rIi0iK290W3QmMjU1XStvdFt0Pj44JjI1NV0rIi0iK290W3Q+PjE2JjE1fDY0XStvdFt0Pj4yNCYyNTVdKyItIitvdFtlJjYzfDEyOF0rb3RbZT4+OCYyNTVdKyItIitvdFtlPj4xNiYyNTVdK290W2U+PjI0JjI1NV0rb3RbcyYyNTVdK290W3M+PjgmMjU1XStvdFtzPj4xNiYyNTVdK290W3M+PjI0JjI1NV0pLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gYXQocix0LGUpe3JldHVybiBNYXRoLm1heCh0LE1hdGgubWluKGUscikpfWZ1bmN0aW9uIGJuKHIsdCl7cmV0dXJuKHIldCt0KSV0fWZ1bmN0aW9uIFZvKHIsdCxlLHMsbil7cmV0dXJuIHMrKHItdCkqKG4tcykvKGUtdCl9ZnVuY3Rpb24gVW8ocix0LGUpe3JldHVybiByIT09dD8oZS1yKS8odC1yKTowfWZ1bmN0aW9uIEplKHIsdCxlKXtyZXR1cm4oMS1lKSpyK2UqdH1mdW5jdGlvbiBrbyhyLHQsZSxzKXtyZXR1cm4gSmUocix0LDEtTWF0aC5leHAoLWUqcykpfWZ1bmN0aW9uIEhvKHIsdD0xKXtyZXR1cm4gdC1NYXRoLmFicyhibihyLHQqMiktdCl9ZnVuY3Rpb24gcW8ocix0LGUpe3JldHVybiByPD10PzA6cj49ZT8xOihyPShyLXQpLyhlLXQpLHIqciooMy0yKnIpKX1mdW5jdGlvbiAkbyhyLHQsZSl7cmV0dXJuIHI8PXQ/MDpyPj1lPzE6KHI9KHItdCkvKGUtdCkscipyKnIqKHIqKHIqNi0xNSkrMTApKX1mdW5jdGlvbiBHbyhyLHQpe3JldHVybiByK01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoodC1yKzEpKX1mdW5jdGlvbiBXbyhyLHQpe3JldHVybiByK01hdGgucmFuZG9tKCkqKHQtcil9ZnVuY3Rpb24gWG8ocil7cmV0dXJuIHIqKC41LU1hdGgucmFuZG9tKCkpfWZ1bmN0aW9uIFlvKHIpe3IhPT12b2lkIDAmJihLaT1yKTtsZXQgdD1LaSs9MTgzMTU2NTgxMztyZXR1cm4gdD1NYXRoLmltdWwodF50Pj4+MTUsdHwxKSx0Xj10K01hdGguaW11bCh0XnQ+Pj43LHR8NjEpLCgodF50Pj4+MTQpPj4+MCkvNDI5NDk2NzI5Nn1mdW5jdGlvbiBabyhyKXtyZXR1cm4gcip0cn1mdW5jdGlvbiBKbyhyKXtyZXR1cm4gciplcn1mdW5jdGlvbiBqbyhyKXtyZXR1cm4ociZyLTEpPT09MCYmciE9PTB9ZnVuY3Rpb24gUW8ocil7cmV0dXJuIE1hdGgucG93KDIsTWF0aC5jZWlsKE1hdGgubG9nKHIpL01hdGguTE4yKSl9ZnVuY3Rpb24gS28ocil7cmV0dXJuIE1hdGgucG93KDIsTWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMikpfWZ1bmN0aW9uIHRhKHIsdCxlLHMsbil7Y29uc3QgaT1NYXRoLmNvcyxvPU1hdGguc2luLGE9aShlLzIpLGM9byhlLzIpLHU9aSgodCtzKS8yKSxoPW8oKHQrcykvMiksbD1pKCh0LXMpLzIpLGQ9bygodC1zKS8yKSxmPWkoKHMtdCkvMikscD1vKChzLXQpLzIpO3N3aXRjaChuKXtjYXNlIlhZWCI6ci5zZXQoYSpoLGMqbCxjKmQsYSp1KTticmVhaztjYXNlIllaWSI6ci5zZXQoYypkLGEqaCxjKmwsYSp1KTticmVhaztjYXNlIlpYWiI6ci5zZXQoYypsLGMqZCxhKmgsYSp1KTticmVhaztjYXNlIlhaWCI6ci5zZXQoYSpoLGMqcCxjKmYsYSp1KTticmVhaztjYXNlIllYWSI6ci5zZXQoYypmLGEqaCxjKnAsYSp1KTticmVhaztjYXNlIlpZWiI6ci5zZXQoYypwLGMqZixhKmgsYSp1KTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuTWF0aFV0aWxzOiAuc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrbil9fWZ1bmN0aW9uIEV0KHIsdCl7c3dpdGNoKHQuY29uc3RydWN0b3Ipe2Nhc2UgRmxvYXQzMkFycmF5OnJldHVybiByO2Nhc2UgVWludDMyQXJyYXk6cmV0dXJuIHIvNDI5NDk2NzI5NTtjYXNlIFVpbnQxNkFycmF5OnJldHVybiByLzY1NTM1O2Nhc2UgVWludDhBcnJheTpyZXR1cm4gci8yNTU7Y2FzZSBJbnQzMkFycmF5OnJldHVybiBNYXRoLm1heChyLzIxNDc0ODM2NDcsLTEpO2Nhc2UgSW50MTZBcnJheTpyZXR1cm4gTWF0aC5tYXgoci8zMjc2NywtMSk7Y2FzZSBJbnQ4QXJyYXk6cmV0dXJuIE1hdGgubWF4KHIvMTI3LC0xKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb21wb25lbnQgdHlwZS4iKX19ZnVuY3Rpb24gJChyLHQpe3N3aXRjaCh0LmNvbnN0cnVjdG9yKXtjYXNlIEZsb2F0MzJBcnJheTpyZXR1cm4gcjtjYXNlIFVpbnQzMkFycmF5OnJldHVybiBNYXRoLnJvdW5kKHIqNDI5NDk2NzI5NSk7Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChyKjY1NTM1KTtjYXNlIFVpbnQ4QXJyYXk6cmV0dXJuIE1hdGgucm91bmQocioyNTUpO2Nhc2UgSW50MzJBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChyKjIxNDc0ODM2NDcpO2Nhc2UgSW50MTZBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChyKjMyNzY3KTtjYXNlIEludDhBcnJheTpyZXR1cm4gTWF0aC5yb3VuZChyKjEyNyk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29tcG9uZW50IHR5cGUuIil9fWNvbnN0IGVhPXtERUcyUkFEOnRyLFJBRDJERUc6ZXIsZ2VuZXJhdGVVVUlEOkt0LGNsYW1wOmF0LGV1Y2xpZGVhbk1vZHVsbzpibixtYXBMaW5lYXI6Vm8saW52ZXJzZUxlcnA6VW8sbGVycDpKZSxkYW1wOmtvLHBpbmdwb25nOkhvLHNtb290aHN0ZXA6cW8sc21vb3RoZXJzdGVwOiRvLHJhbmRJbnQ6R28scmFuZEZsb2F0OldvLHJhbmRGbG9hdFNwcmVhZDpYbyxzZWVkZWRSYW5kb206WW8sZGVnVG9SYWQ6Wm8scmFkVG9EZWc6Sm8saXNQb3dlck9mVHdvOmpvLGNlaWxQb3dlck9mVHdvOlFvLGZsb29yUG93ZXJPZlR3bzpLbyxzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOnRhLG5vcm1hbGl6ZTokLGRlbm9ybWFsaXplOkV0fTtjbGFzcyBKe2NvbnN0cnVjdG9yKHQ9MCxlPTApe0oucHJvdG90eXBlLmlzVmVjdG9yMj0hMCx0aGlzLng9dCx0aGlzLnk9ZX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy54fXNldCB3aWR0aCh0KXt0aGlzLng9dH1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXMueX1zZXQgaGVpZ2h0KHQpe3RoaXMueT10fXNldCh0LGUpe3JldHVybiB0aGlzLng9dCx0aGlzLnk9ZSx0aGlzfXNldFNjYWxhcih0KXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PXQsdGhpc31zZXRYKHQpe3JldHVybiB0aGlzLng9dCx0aGlzfXNldFkodCl7cmV0dXJuIHRoaXMueT10LHRoaXN9c2V0Q29tcG9uZW50KHQsZSl7c3dpdGNoKHQpe2Nhc2UgMDp0aGlzLng9ZTticmVhaztjYXNlIDE6dGhpcy55PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIit0KX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQodCl7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrdCl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnkpfWNvcHkodCl7cmV0dXJuIHRoaXMueD10LngsdGhpcy55PXQueSx0aGlzfWFkZCh0KXtyZXR1cm4gdGhpcy54Kz10LngsdGhpcy55Kz10LnksdGhpc31hZGRTY2FsYXIodCl7cmV0dXJuIHRoaXMueCs9dCx0aGlzLnkrPXQsdGhpc31hZGRWZWN0b3JzKHQsZSl7cmV0dXJuIHRoaXMueD10LngrZS54LHRoaXMueT10LnkrZS55LHRoaXN9YWRkU2NhbGVkVmVjdG9yKHQsZSl7cmV0dXJuIHRoaXMueCs9dC54KmUsdGhpcy55Kz10LnkqZSx0aGlzfXN1Yih0KXtyZXR1cm4gdGhpcy54LT10LngsdGhpcy55LT10LnksdGhpc31zdWJTY2FsYXIodCl7cmV0dXJuIHRoaXMueC09dCx0aGlzLnktPXQsdGhpc31zdWJWZWN0b3JzKHQsZSl7cmV0dXJuIHRoaXMueD10LngtZS54LHRoaXMueT10LnktZS55LHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIHRoaXMueCo9dC54LHRoaXMueSo9dC55LHRoaXN9bXVsdGlwbHlTY2FsYXIodCl7cmV0dXJuIHRoaXMueCo9dCx0aGlzLnkqPXQsdGhpc31kaXZpZGUodCl7cmV0dXJuIHRoaXMueC89dC54LHRoaXMueS89dC55LHRoaXN9ZGl2aWRlU2NhbGFyKHQpe3JldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEvdCl9YXBwbHlNYXRyaXgzKHQpe2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LG49dC5lbGVtZW50cztyZXR1cm4gdGhpcy54PW5bMF0qZStuWzNdKnMrbls2XSx0aGlzLnk9blsxXSplK25bNF0qcytuWzddLHRoaXN9bWluKHQpe3JldHVybiB0aGlzLng9TWF0aC5taW4odGhpcy54LHQueCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0LnkpLHRoaXN9bWF4KHQpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodGhpcy54LHQueCksdGhpcy55PU1hdGgubWF4KHRoaXMueSx0LnkpLHRoaXN9Y2xhbXAodCxlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHQueCxNYXRoLm1pbihlLngsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KHQueSxNYXRoLm1pbihlLnksdGhpcy55KSksdGhpc31jbGFtcFNjYWxhcih0LGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueCkpLHRoaXMueT1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy55KSksdGhpc31jbGFtcExlbmd0aCh0LGUpe2NvbnN0IHM9dGhpcy5sZW5ndGgoKTtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoc3x8MSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgodCxNYXRoLm1pbihlLHMpKSl9Zmxvb3IoKXtyZXR1cm4gdGhpcy54PU1hdGguZmxvb3IodGhpcy54KSx0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXN9cm91bmQoKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PU1hdGgudHJ1bmModGhpcy54KSx0aGlzLnk9TWF0aC50cnVuYyh0aGlzLnkpLHRoaXN9bmVnYXRlKCl7cmV0dXJuIHRoaXMueD0tdGhpcy54LHRoaXMueT0tdGhpcy55LHRoaXN9ZG90KHQpe3JldHVybiB0aGlzLngqdC54K3RoaXMueSp0Lnl9Y3Jvc3ModCl7cmV0dXJuIHRoaXMueCp0LnktdGhpcy55KnQueH1sZW5ndGhTcSgpe3JldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnl9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkpfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSl9bm9ybWFsaXplKCl7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCl8fDEpfWFuZ2xlKCl7cmV0dXJuIE1hdGguYXRhbjIoLXRoaXMueSwtdGhpcy54KStNYXRoLlBJfWFuZ2xlVG8odCl7Y29uc3QgZT1NYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpKnQubGVuZ3RoU3EoKSk7aWYoZT09PTApcmV0dXJuIE1hdGguUEkvMjtjb25zdCBzPXRoaXMuZG90KHQpL2U7cmV0dXJuIE1hdGguYWNvcyhhdChzLC0xLDEpKX1kaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh0KSl9ZGlzdGFuY2VUb1NxdWFyZWQodCl7Y29uc3QgZT10aGlzLngtdC54LHM9dGhpcy55LXQueTtyZXR1cm4gZSplK3Mqc31tYW5oYXR0YW5EaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLmFicyh0aGlzLngtdC54KStNYXRoLmFicyh0aGlzLnktdC55KX1zZXRMZW5ndGgodCl7cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCl9bGVycCh0LGUpe3JldHVybiB0aGlzLngrPSh0LngtdGhpcy54KSplLHRoaXMueSs9KHQueS10aGlzLnkpKmUsdGhpc31sZXJwVmVjdG9ycyh0LGUscyl7cmV0dXJuIHRoaXMueD10LngrKGUueC10LngpKnMsdGhpcy55PXQueSsoZS55LXQueSkqcyx0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC54PT09dGhpcy54JiZ0Lnk9PT10aGlzLnl9ZnJvbUFycmF5KHQsZT0wKXtyZXR1cm4gdGhpcy54PXRbZV0sdGhpcy55PXRbZSsxXSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMueCx0W2UrMV09dGhpcy55LHR9ZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpe3JldHVybiB0aGlzLng9dC5nZXRYKGUpLHRoaXMueT10LmdldFkoZSksdGhpc31yb3RhdGVBcm91bmQodCxlKXtjb25zdCBzPU1hdGguY29zKGUpLG49TWF0aC5zaW4oZSksaT10aGlzLngtdC54LG89dGhpcy55LXQueTtyZXR1cm4gdGhpcy54PWkqcy1vKm4rdC54LHRoaXMueT1pKm4rbypzK3QueSx0aGlzfXJhbmRvbSgpe3JldHVybiB0aGlzLng9TWF0aC5yYW5kb20oKSx0aGlzLnk9TWF0aC5yYW5kb20oKSx0aGlzfSpbU3ltYm9sLml0ZXJhdG9yXSgpe3lpZWxkIHRoaXMueCx5aWVsZCB0aGlzLnl9fWNsYXNzIEN0e2NvbnN0cnVjdG9yKHQsZSxzLG4saSxvLGEsYyx1KXtDdC5wcm90b3R5cGUuaXNNYXRyaXgzPSEwLHRoaXMuZWxlbWVudHM9WzEsMCwwLDAsMSwwLDAsMCwxXSx0IT09dm9pZCAwJiZ0aGlzLnNldCh0LGUscyxuLGksbyxhLGMsdSl9c2V0KHQsZSxzLG4saSxvLGEsYyx1KXtjb25zdCBoPXRoaXMuZWxlbWVudHM7cmV0dXJuIGhbMF09dCxoWzFdPW4saFsyXT1hLGhbM109ZSxoWzRdPWksaFs1XT1jLGhbNl09cyxoWzddPW8saFs4XT11LHRoaXN9aWRlbnRpdHkoKXtyZXR1cm4gdGhpcy5zZXQoMSwwLDAsMCwxLDAsMCwwLDEpLHRoaXN9Y29weSh0KXtjb25zdCBlPXRoaXMuZWxlbWVudHMscz10LmVsZW1lbnRzO3JldHVybiBlWzBdPXNbMF0sZVsxXT1zWzFdLGVbMl09c1syXSxlWzNdPXNbM10sZVs0XT1zWzRdLGVbNV09c1s1XSxlWzZdPXNbNl0sZVs3XT1zWzddLGVbOF09c1s4XSx0aGlzfWV4dHJhY3RCYXNpcyh0LGUscyl7cmV0dXJuIHQuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywwKSxlLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsMSkscy5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLDIpLHRoaXN9c2V0RnJvbU1hdHJpeDQodCl7Y29uc3QgZT10LmVsZW1lbnRzO3JldHVybiB0aGlzLnNldChlWzBdLGVbNF0sZVs4XSxlWzFdLGVbNV0sZVs5XSxlWzJdLGVbNl0sZVsxMF0pLHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLHQpfXByZW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModCx0aGlzKX1tdWx0aXBseU1hdHJpY2VzKHQsZSl7Y29uc3Qgcz10LmVsZW1lbnRzLG49ZS5lbGVtZW50cyxpPXRoaXMuZWxlbWVudHMsbz1zWzBdLGE9c1szXSxjPXNbNl0sdT1zWzFdLGg9c1s0XSxsPXNbN10sZD1zWzJdLGY9c1s1XSxwPXNbOF0sbT1uWzBdLGc9blszXSx5PW5bNl0sVD1uWzFdLHc9bls0XSxNPW5bN10sTj1uWzJdLF89bls1XSxTPW5bOF07cmV0dXJuIGlbMF09byptK2EqVCtjKk4saVszXT1vKmcrYSp3K2MqXyxpWzZdPW8qeSthKk0rYypTLGlbMV09dSptK2gqVCtsKk4saVs0XT11KmcraCp3K2wqXyxpWzddPXUqeStoKk0rbCpTLGlbMl09ZCptK2YqVCtwKk4saVs1XT1kKmcrZip3K3AqXyxpWzhdPWQqeStmKk0rcCpTLHRoaXN9bXVsdGlwbHlTY2FsYXIodCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzO3JldHVybiBlWzBdKj10LGVbM10qPXQsZVs2XSo9dCxlWzFdKj10LGVbNF0qPXQsZVs3XSo9dCxlWzJdKj10LGVbNV0qPXQsZVs4XSo9dCx0aGlzfWRldGVybWluYW50KCl7Y29uc3QgdD10aGlzLmVsZW1lbnRzLGU9dFswXSxzPXRbMV0sbj10WzJdLGk9dFszXSxvPXRbNF0sYT10WzVdLGM9dFs2XSx1PXRbN10saD10WzhdO3JldHVybiBlKm8qaC1lKmEqdS1zKmkqaCtzKmEqYytuKmkqdS1uKm8qY31pbnZlcnQoKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsZT10WzBdLHM9dFsxXSxuPXRbMl0saT10WzNdLG89dFs0XSxhPXRbNV0sYz10WzZdLHU9dFs3XSxoPXRbOF0sbD1oKm8tYSp1LGQ9YSpjLWgqaSxmPXUqaS1vKmMscD1lKmwrcypkK24qZjtpZihwPT09MClyZXR1cm4gdGhpcy5zZXQoMCwwLDAsMCwwLDAsMCwwLDApO2NvbnN0IG09MS9wO3JldHVybiB0WzBdPWwqbSx0WzFdPShuKnUtaCpzKSptLHRbMl09KGEqcy1uKm8pKm0sdFszXT1kKm0sdFs0XT0oaCplLW4qYykqbSx0WzVdPShuKmktYSplKSptLHRbNl09ZiptLHRbN109KHMqYy11KmUpKm0sdFs4XT0obyplLXMqaSkqbSx0aGlzfXRyYW5zcG9zZSgpe2xldCB0O2NvbnN0IGU9dGhpcy5lbGVtZW50cztyZXR1cm4gdD1lWzFdLGVbMV09ZVszXSxlWzNdPXQsdD1lWzJdLGVbMl09ZVs2XSxlWzZdPXQsdD1lWzVdLGVbNV09ZVs3XSxlWzddPXQsdGhpc31nZXROb3JtYWxNYXRyaXgodCl7cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQodCkuaW52ZXJ0KCkudHJhbnNwb3NlKCl9dHJhbnNwb3NlSW50b0FycmF5KHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cztyZXR1cm4gdFswXT1lWzBdLHRbMV09ZVszXSx0WzJdPWVbNl0sdFszXT1lWzFdLHRbNF09ZVs0XSx0WzVdPWVbN10sdFs2XT1lWzJdLHRbN109ZVs1XSx0WzhdPWVbOF0sdGhpc31zZXRVdlRyYW5zZm9ybSh0LGUscyxuLGksbyxhKXtjb25zdCBjPU1hdGguY29zKGkpLHU9TWF0aC5zaW4oaSk7cmV0dXJuIHRoaXMuc2V0KHMqYyxzKnUsLXMqKGMqbyt1KmEpK28rdCwtbip1LG4qYywtbiooLXUqbytjKmEpK2ErZSwwLDAsMSksdGhpc31zY2FsZSh0LGUpe3JldHVybiB0aGlzLnByZW11bHRpcGx5KEVuLm1ha2VTY2FsZSh0LGUpKSx0aGlzfXJvdGF0ZSh0KXtyZXR1cm4gdGhpcy5wcmVtdWx0aXBseShFbi5tYWtlUm90YXRpb24oLXQpKSx0aGlzfXRyYW5zbGF0ZSh0LGUpe3JldHVybiB0aGlzLnByZW11bHRpcGx5KEVuLm1ha2VUcmFuc2xhdGlvbih0LGUpKSx0aGlzfW1ha2VUcmFuc2xhdGlvbih0LGUpe3JldHVybiB0LmlzVmVjdG9yMj90aGlzLnNldCgxLDAsdC54LDAsMSx0LnksMCwwLDEpOnRoaXMuc2V0KDEsMCx0LDAsMSxlLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvbih0KXtjb25zdCBlPU1hdGguY29zKHQpLHM9TWF0aC5zaW4odCk7cmV0dXJuIHRoaXMuc2V0KGUsLXMsMCxzLGUsMCwwLDAsMSksdGhpc31tYWtlU2NhbGUodCxlKXtyZXR1cm4gdGhpcy5zZXQodCwwLDAsMCxlLDAsMCwwLDEpLHRoaXN9ZXF1YWxzKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxzPXQuZWxlbWVudHM7Zm9yKGxldCBuPTA7bjw5O24rKylpZihlW25dIT09c1tuXSlyZXR1cm4hMTtyZXR1cm4hMH1mcm9tQXJyYXkodCxlPTApe2ZvcihsZXQgcz0wO3M8OTtzKyspdGhpcy5lbGVtZW50c1tzXT10W3MrZV07cmV0dXJuIHRoaXN9dG9BcnJheSh0PVtdLGU9MCl7Y29uc3Qgcz10aGlzLmVsZW1lbnRzO3JldHVybiB0W2VdPXNbMF0sdFtlKzFdPXNbMV0sdFtlKzJdPXNbMl0sdFtlKzNdPXNbM10sdFtlKzRdPXNbNF0sdFtlKzVdPXNbNV0sdFtlKzZdPXNbNl0sdFtlKzddPXNbN10sdFtlKzhdPXNbOF0sdH1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKX19Y29uc3QgRW49bmV3IEN0O2Z1bmN0aW9uIHNhKHIpe2ZvcihsZXQgdD1yLmxlbmd0aC0xO3Q+PTA7LS10KWlmKHJbdF0+PTY1NTM1KXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIHNyKHIpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiLHIpfWNvbnN0IG5yPW5ldyBDdCgpLnNldCguODIyNDYyMSwuMTc3NTM4LDAsLjAzMzE5NDEsLjk2NjgwNTgsMCwuMDE3MDgyNywuMDcyMzk3NCwuOTEwNTE5OSksaXI9bmV3IEN0KCkuc2V0KDEuMjI0OTQwMSwtLjIyNDk0MDQsMCwtLjA0MjA1NjksMS4wNDIwNTcxLDAsLS4wMTk2Mzc2LC0uMDc4NjM2MSwxLjA5ODI3MzUpLGplPXtbRXNdOnt0cmFuc2ZlcjpfbixwcmltYXJpZXM6amksbHVtaW5hbmNlQ29lZmZpY2llbnRzOlsuMjEyNiwuNzE1MiwuMDcyMl0sdG9SZWZlcmVuY2U6cj0+cixmcm9tUmVmZXJlbmNlOnI9PnJ9LFskdF06e3RyYW5zZmVyOkppLHByaW1hcmllczpqaSxsdW1pbmFuY2VDb2VmZmljaWVudHM6Wy4yMTI2LC43MTUyLC4wNzIyXSx0b1JlZmVyZW5jZTpyPT5yLmNvbnZlcnRTUkdCVG9MaW5lYXIoKSxmcm9tUmVmZXJlbmNlOnI9PnIuY29udmVydExpbmVhclRvU1JHQigpfSxbWmldOnt0cmFuc2ZlcjpfbixwcmltYXJpZXM6UWksbHVtaW5hbmNlQ29lZmZpY2llbnRzOlsuMjI4OSwuNjkxNywuMDc5M10sdG9SZWZlcmVuY2U6cj0+ci5hcHBseU1hdHJpeDMoaXIpLGZyb21SZWZlcmVuY2U6cj0+ci5hcHBseU1hdHJpeDMobnIpfSxbRG9dOnt0cmFuc2ZlcjpKaSxwcmltYXJpZXM6UWksbHVtaW5hbmNlQ29lZmZpY2llbnRzOlsuMjI4OSwuNjkxNywuMDc5M10sdG9SZWZlcmVuY2U6cj0+ci5jb252ZXJ0U1JHQlRvTGluZWFyKCkuYXBwbHlNYXRyaXgzKGlyKSxmcm9tUmVmZXJlbmNlOnI9PnIuYXBwbHlNYXRyaXgzKG5yKS5jb252ZXJ0TGluZWFyVG9TUkdCKCl9fSxuYT1uZXcgU2V0KFtFcyxaaV0pLG10PXtlbmFibGVkOiEwLF93b3JraW5nQ29sb3JTcGFjZTpFcyxnZXQgd29ya2luZ0NvbG9yU3BhY2UoKXtyZXR1cm4gdGhpcy5fd29ya2luZ0NvbG9yU3BhY2V9LHNldCB3b3JraW5nQ29sb3JTcGFjZShyKXtpZighbmEuaGFzKHIpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgd29ya2luZyBjb2xvciBzcGFjZSwgIiR7cn0iLmApO3RoaXMuX3dvcmtpbmdDb2xvclNwYWNlPXJ9LGNvbnZlcnQ6ZnVuY3Rpb24ocix0LGUpe2lmKHRoaXMuZW5hYmxlZD09PSExfHx0PT09ZXx8IXR8fCFlKXJldHVybiByO2NvbnN0IHM9amVbdF0udG9SZWZlcmVuY2Usbj1qZVtlXS5mcm9tUmVmZXJlbmNlO3JldHVybiBuKHMocikpfSxmcm9tV29ya2luZ0NvbG9yU3BhY2U6ZnVuY3Rpb24ocix0KXtyZXR1cm4gdGhpcy5jb252ZXJ0KHIsdGhpcy5fd29ya2luZ0NvbG9yU3BhY2UsdCl9LHRvV29ya2luZ0NvbG9yU3BhY2U6ZnVuY3Rpb24ocix0KXtyZXR1cm4gdGhpcy5jb252ZXJ0KHIsdCx0aGlzLl93b3JraW5nQ29sb3JTcGFjZSl9LGdldFByaW1hcmllczpmdW5jdGlvbihyKXtyZXR1cm4gamVbcl0ucHJpbWFyaWVzfSxnZXRUcmFuc2ZlcjpmdW5jdGlvbihyKXtyZXR1cm4gcj09PWJzP19uOmplW3JdLnRyYW5zZmVyfSxnZXRMdW1pbmFuY2VDb2VmZmljaWVudHM6ZnVuY3Rpb24ocix0PXRoaXMuX3dvcmtpbmdDb2xvclNwYWNlKXtyZXR1cm4gci5mcm9tQXJyYXkoamVbdF0ubHVtaW5hbmNlQ29lZmZpY2llbnRzKX19O2Z1bmN0aW9uIHhlKHIpe3JldHVybiByPC4wNDA0NT9yKi4wNzczOTkzODA4Ok1hdGgucG93KHIqLjk0Nzg2NzI5ODYrLjA1MjEzMjcwMTQsMi40KX1mdW5jdGlvbiBDbihyKXtyZXR1cm4gcjwuMDAzMTMwOD9yKjEyLjkyOjEuMDU1Kk1hdGgucG93KHIsLjQxNjY2KS0uMDU1fWxldCBUZTtjbGFzcyBpYXtzdGF0aWMgZ2V0RGF0YVVSTCh0KXtpZigvXmRhdGE6L2kudGVzdCh0LnNyYyl8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudD4idSIpcmV0dXJuIHQuc3JjO2xldCBlO2lmKHQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCllPXQ7ZWxzZXtUZT09PXZvaWQgMCYmKFRlPXNyKCJjYW52YXMiKSksVGUud2lkdGg9dC53aWR0aCxUZS5oZWlnaHQ9dC5oZWlnaHQ7Y29uc3Qgcz1UZS5nZXRDb250ZXh0KCIyZCIpO3QgaW5zdGFuY2VvZiBJbWFnZURhdGE/cy5wdXRJbWFnZURhdGEodCwwLDApOnMuZHJhd0ltYWdlKHQsMCwwLHQud2lkdGgsdC5oZWlnaHQpLGU9VGV9cmV0dXJuIGUud2lkdGg+MjA0OHx8ZS5oZWlnaHQ+MjA0OD8oY29uc29sZS53YXJuKCJUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMiLHQpLGUudG9EYXRhVVJMKCJpbWFnZS9qcGVnIiwuNikpOmUudG9EYXRhVVJMKCJpbWFnZS9wbmciKX1zdGF0aWMgc1JHQlRvTGluZWFyKHQpe2lmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PCJ1IiYmdCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDwidSImJnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dHlwZW9mIEltYWdlQml0bWFwPCJ1IiYmdCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXtjb25zdCBlPXNyKCJjYW52YXMiKTtlLndpZHRoPXQud2lkdGgsZS5oZWlnaHQ9dC5oZWlnaHQ7Y29uc3Qgcz1lLmdldENvbnRleHQoIjJkIik7cy5kcmF3SW1hZ2UodCwwLDAsdC53aWR0aCx0LmhlaWdodCk7Y29uc3Qgbj1zLmdldEltYWdlRGF0YSgwLDAsdC53aWR0aCx0LmhlaWdodCksaT1uLmRhdGE7Zm9yKGxldCBvPTA7bzxpLmxlbmd0aDtvKyspaVtvXT14ZShpW29dLzI1NSkqMjU1O3JldHVybiBzLnB1dEltYWdlRGF0YShuLDAsMCksZX1lbHNlIGlmKHQuZGF0YSl7Y29uc3QgZT10LmRhdGEuc2xpY2UoMCk7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fGUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheT9lW3NdPU1hdGguZmxvb3IoeGUoZVtzXS8yNTUpKjI1NSk6ZVtzXT14ZShlW3NdKTtyZXR1cm57ZGF0YTplLHdpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0fX1lbHNlIHJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkltYWdlVXRpbHMuc1JHQlRvTGluZWFyKCk6IFVuc3VwcG9ydGVkIGltYWdlIHR5cGUuIE5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gYXBwbGllZC4iKSx0fX1sZXQgcmE9MDtjbGFzcyBycntjb25zdHJ1Y3Rvcih0PW51bGwpe3RoaXMuaXNTb3VyY2U9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6cmErK30pLHRoaXMudXVpZD1LdCgpLHRoaXMuZGF0YT10LHRoaXMuZGF0YVJlYWR5PSEwLHRoaXMudmVyc2lvbj0wfXNldCBuZWVkc1VwZGF0ZSh0KXt0PT09ITAmJnRoaXMudmVyc2lvbisrfXRvSlNPTih0KXtjb25zdCBlPXQ9PT12b2lkIDB8fHR5cGVvZiB0PT0ic3RyaW5nIjtpZighZSYmdC5pbWFnZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gdC5pbWFnZXNbdGhpcy51dWlkXTtjb25zdCBzPXt1dWlkOnRoaXMudXVpZCx1cmw6IiJ9LG49dGhpcy5kYXRhO2lmKG4hPT1udWxsKXtsZXQgaTtpZihBcnJheS5pc0FycmF5KG4pKXtpPVtdO2ZvcihsZXQgbz0wLGE9bi5sZW5ndGg7bzxhO28rKyluW29dLmlzRGF0YVRleHR1cmU/aS5wdXNoKEZuKG5bb10uaW1hZ2UpKTppLnB1c2goRm4obltvXSkpfWVsc2UgaT1GbihuKTtzLnVybD1pfXJldHVybiBlfHwodC5pbWFnZXNbdGhpcy51dWlkXT1zKSxzfX1mdW5jdGlvbiBGbihyKXtyZXR1cm4gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8InUiJiZyIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PCJ1IiYmciBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHx0eXBlb2YgSW1hZ2VCaXRtYXA8InUiJiZyIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA/aWEuZ2V0RGF0YVVSTChyKTpyLmRhdGE/e2RhdGE6QXJyYXkuZnJvbShyLmRhdGEpLHdpZHRoOnIud2lkdGgsaGVpZ2h0OnIuaGVpZ2h0LHR5cGU6ci5kYXRhLmNvbnN0cnVjdG9yLm5hbWV9Oihjb25zb2xlLndhcm4oIlRIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4iKSx7fSl9bGV0IG9hPTA7Y2xhc3MgRHQgZXh0ZW5kcyBaZXtjb25zdHJ1Y3Rvcih0PUR0LkRFRkFVTFRfSU1BR0UsZT1EdC5ERUZBVUxUX01BUFBJTkcscz1fcyxuPV9zLGk9JGksbz1HaSxhPUxvLGM9Um8sdT1EdC5ERUZBVUxUX0FOSVNPVFJPUFksaD1icyl7c3VwZXIoKSx0aGlzLmlzVGV4dHVyZT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWQiLHt2YWx1ZTpvYSsrfSksdGhpcy51dWlkPUt0KCksdGhpcy5uYW1lPSIiLHRoaXMuc291cmNlPW5ldyBycih0KSx0aGlzLm1pcG1hcHM9W10sdGhpcy5tYXBwaW5nPWUsdGhpcy5jaGFubmVsPTAsdGhpcy53cmFwUz1zLHRoaXMud3JhcFQ9bix0aGlzLm1hZ0ZpbHRlcj1pLHRoaXMubWluRmlsdGVyPW8sdGhpcy5hbmlzb3Ryb3B5PXUsdGhpcy5mb3JtYXQ9YSx0aGlzLmludGVybmFsRm9ybWF0PW51bGwsdGhpcy50eXBlPWMsdGhpcy5vZmZzZXQ9bmV3IEooMCwwKSx0aGlzLnJlcGVhdD1uZXcgSigxLDEpLHRoaXMuY2VudGVyPW5ldyBKKDAsMCksdGhpcy5yb3RhdGlvbj0wLHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMCx0aGlzLm1hdHJpeD1uZXcgQ3QsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITAsdGhpcy5wcmVtdWx0aXBseUFscGhhPSExLHRoaXMuZmxpcFk9ITAsdGhpcy51bnBhY2tBbGlnbm1lbnQ9NCx0aGlzLmNvbG9yU3BhY2U9aCx0aGlzLnVzZXJEYXRhPXt9LHRoaXMudmVyc2lvbj0wLHRoaXMub25VcGRhdGU9bnVsbCx0aGlzLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMSx0aGlzLnBtcmVtVmVyc2lvbj0wfWdldCBpbWFnZSgpe3JldHVybiB0aGlzLnNvdXJjZS5kYXRhfXNldCBpbWFnZSh0PW51bGwpe3RoaXMuc291cmNlLmRhdGE9dH11cGRhdGVNYXRyaXgoKXt0aGlzLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSh0aGlzLm9mZnNldC54LHRoaXMub2Zmc2V0LnksdGhpcy5yZXBlYXQueCx0aGlzLnJlcGVhdC55LHRoaXMucm90YXRpb24sdGhpcy5jZW50ZXIueCx0aGlzLmNlbnRlci55KX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9Y29weSh0KXtyZXR1cm4gdGhpcy5uYW1lPXQubmFtZSx0aGlzLnNvdXJjZT10LnNvdXJjZSx0aGlzLm1pcG1hcHM9dC5taXBtYXBzLnNsaWNlKDApLHRoaXMubWFwcGluZz10Lm1hcHBpbmcsdGhpcy5jaGFubmVsPXQuY2hhbm5lbCx0aGlzLndyYXBTPXQud3JhcFMsdGhpcy53cmFwVD10LndyYXBULHRoaXMubWFnRmlsdGVyPXQubWFnRmlsdGVyLHRoaXMubWluRmlsdGVyPXQubWluRmlsdGVyLHRoaXMuYW5pc290cm9weT10LmFuaXNvdHJvcHksdGhpcy5mb3JtYXQ9dC5mb3JtYXQsdGhpcy5pbnRlcm5hbEZvcm1hdD10LmludGVybmFsRm9ybWF0LHRoaXMudHlwZT10LnR5cGUsdGhpcy5vZmZzZXQuY29weSh0Lm9mZnNldCksdGhpcy5yZXBlYXQuY29weSh0LnJlcGVhdCksdGhpcy5jZW50ZXIuY29weSh0LmNlbnRlciksdGhpcy5yb3RhdGlvbj10LnJvdGF0aW9uLHRoaXMubWF0cml4QXV0b1VwZGF0ZT10Lm1hdHJpeEF1dG9VcGRhdGUsdGhpcy5tYXRyaXguY29weSh0Lm1hdHJpeCksdGhpcy5nZW5lcmF0ZU1pcG1hcHM9dC5nZW5lcmF0ZU1pcG1hcHMsdGhpcy5wcmVtdWx0aXBseUFscGhhPXQucHJlbXVsdGlwbHlBbHBoYSx0aGlzLmZsaXBZPXQuZmxpcFksdGhpcy51bnBhY2tBbGlnbm1lbnQ9dC51bnBhY2tBbGlnbm1lbnQsdGhpcy5jb2xvclNwYWNlPXQuY29sb3JTcGFjZSx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodC51c2VyRGF0YSkpLHRoaXMubmVlZHNVcGRhdGU9ITAsdGhpc310b0pTT04odCl7Y29uc3QgZT10PT09dm9pZCAwfHx0eXBlb2YgdD09InN0cmluZyI7aWYoIWUmJnQudGV4dHVyZXNbdGhpcy51dWlkXSE9PXZvaWQgMClyZXR1cm4gdC50ZXh0dXJlc1t0aGlzLnV1aWRdO2NvbnN0IHM9e21ldGFkYXRhOnt2ZXJzaW9uOjQuNix0eXBlOiJUZXh0dXJlIixnZW5lcmF0b3I6IlRleHR1cmUudG9KU09OIn0sdXVpZDp0aGlzLnV1aWQsbmFtZTp0aGlzLm5hbWUsaW1hZ2U6dGhpcy5zb3VyY2UudG9KU09OKHQpLnV1aWQsbWFwcGluZzp0aGlzLm1hcHBpbmcsY2hhbm5lbDp0aGlzLmNoYW5uZWwscmVwZWF0Olt0aGlzLnJlcGVhdC54LHRoaXMucmVwZWF0LnldLG9mZnNldDpbdGhpcy5vZmZzZXQueCx0aGlzLm9mZnNldC55XSxjZW50ZXI6W3RoaXMuY2VudGVyLngsdGhpcy5jZW50ZXIueV0scm90YXRpb246dGhpcy5yb3RhdGlvbix3cmFwOlt0aGlzLndyYXBTLHRoaXMud3JhcFRdLGZvcm1hdDp0aGlzLmZvcm1hdCxpbnRlcm5hbEZvcm1hdDp0aGlzLmludGVybmFsRm9ybWF0LHR5cGU6dGhpcy50eXBlLGNvbG9yU3BhY2U6dGhpcy5jb2xvclNwYWNlLG1pbkZpbHRlcjp0aGlzLm1pbkZpbHRlcixtYWdGaWx0ZXI6dGhpcy5tYWdGaWx0ZXIsYW5pc290cm9weTp0aGlzLmFuaXNvdHJvcHksZmxpcFk6dGhpcy5mbGlwWSxnZW5lcmF0ZU1pcG1hcHM6dGhpcy5nZW5lcmF0ZU1pcG1hcHMscHJlbXVsdGlwbHlBbHBoYTp0aGlzLnByZW11bHRpcGx5QWxwaGEsdW5wYWNrQWxpZ25tZW50OnRoaXMudW5wYWNrQWxpZ25tZW50fTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoPjAmJihzLnVzZXJEYXRhPXRoaXMudXNlckRhdGEpLGV8fCh0LnRleHR1cmVzW3RoaXMudXVpZF09cyksc31kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNwb3NlIn0pfXRyYW5zZm9ybVV2KHQpe2lmKHRoaXMubWFwcGluZyE9PWtpKXJldHVybiB0O2lmKHQuYXBwbHlNYXRyaXgzKHRoaXMubWF0cml4KSx0Lng8MHx8dC54PjEpc3dpdGNoKHRoaXMud3JhcFMpe2Nhc2UgSGk6dC54PXQueC1NYXRoLmZsb29yKHQueCk7YnJlYWs7Y2FzZSBfczp0Lng9dC54PDA/MDoxO2JyZWFrO2Nhc2UgcWk6TWF0aC5hYnMoTWF0aC5mbG9vcih0LngpJTIpPT09MT90Lng9TWF0aC5jZWlsKHQueCktdC54OnQueD10LngtTWF0aC5mbG9vcih0LngpO2JyZWFrfWlmKHQueTwwfHx0Lnk+MSlzd2l0Y2godGhpcy53cmFwVCl7Y2FzZSBIaTp0Lnk9dC55LU1hdGguZmxvb3IodC55KTticmVhaztjYXNlIF9zOnQueT10Lnk8MD8wOjE7YnJlYWs7Y2FzZSBxaTpNYXRoLmFicyhNYXRoLmZsb29yKHQueSklMik9PT0xP3QueT1NYXRoLmNlaWwodC55KS10Lnk6dC55PXQueS1NYXRoLmZsb29yKHQueSk7YnJlYWt9cmV0dXJuIHRoaXMuZmxpcFkmJih0Lnk9MS10LnkpLHR9c2V0IG5lZWRzVXBkYXRlKHQpe3Q9PT0hMCYmKHRoaXMudmVyc2lvbisrLHRoaXMuc291cmNlLm5lZWRzVXBkYXRlPSEwKX1zZXQgbmVlZHNQTVJFTVVwZGF0ZSh0KXt0PT09ITAmJnRoaXMucG1yZW1WZXJzaW9uKyt9fUR0LkRFRkFVTFRfSU1BR0U9bnVsbCxEdC5ERUZBVUxUX01BUFBJTkc9a2ksRHQuREVGQVVMVF9BTklTT1RST1BZPTQ7Y2xhc3MgRnR7Y29uc3RydWN0b3IodD0wLGU9MCxzPTAsbj0xKXtGdC5wcm90b3R5cGUuaXNWZWN0b3I0PSEwLHRoaXMueD10LHRoaXMueT1lLHRoaXMuej1zLHRoaXMudz1ufWdldCB3aWR0aCgpe3JldHVybiB0aGlzLnp9c2V0IHdpZHRoKHQpe3RoaXMuej10fWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy53fXNldCBoZWlnaHQodCl7dGhpcy53PXR9c2V0KHQsZSxzLG4pe3JldHVybiB0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9cyx0aGlzLnc9bix0aGlzfXNldFNjYWxhcih0KXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PXQsdGhpcy56PXQsdGhpcy53PXQsdGhpc31zZXRYKHQpe3JldHVybiB0aGlzLng9dCx0aGlzfXNldFkodCl7cmV0dXJuIHRoaXMueT10LHRoaXN9c2V0Wih0KXtyZXR1cm4gdGhpcy56PXQsdGhpc31zZXRXKHQpe3JldHVybiB0aGlzLnc9dCx0aGlzfXNldENvbXBvbmVudCh0LGUpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy54PWU7YnJlYWs7Y2FzZSAxOnRoaXMueT1lO2JyZWFrO2Nhc2UgMjp0aGlzLno9ZTticmVhaztjYXNlIDM6dGhpcy53PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIit0KX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQodCl7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2Nhc2UgMzpyZXR1cm4gdGhpcy53O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrdCl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9Y29weSh0KXtyZXR1cm4gdGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LnosdGhpcy53PXQudyE9PXZvaWQgMD90Lnc6MSx0aGlzfWFkZCh0KXtyZXR1cm4gdGhpcy54Kz10LngsdGhpcy55Kz10LnksdGhpcy56Kz10LnosdGhpcy53Kz10LncsdGhpc31hZGRTY2FsYXIodCl7cmV0dXJuIHRoaXMueCs9dCx0aGlzLnkrPXQsdGhpcy56Kz10LHRoaXMudys9dCx0aGlzfWFkZFZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueCtlLngsdGhpcy55PXQueStlLnksdGhpcy56PXQueitlLnosdGhpcy53PXQudytlLncsdGhpc31hZGRTY2FsZWRWZWN0b3IodCxlKXtyZXR1cm4gdGhpcy54Kz10LngqZSx0aGlzLnkrPXQueSplLHRoaXMueis9dC56KmUsdGhpcy53Kz10LncqZSx0aGlzfXN1Yih0KXtyZXR1cm4gdGhpcy54LT10LngsdGhpcy55LT10LnksdGhpcy56LT10LnosdGhpcy53LT10LncsdGhpc31zdWJTY2FsYXIodCl7cmV0dXJuIHRoaXMueC09dCx0aGlzLnktPXQsdGhpcy56LT10LHRoaXMudy09dCx0aGlzfXN1YlZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueC1lLngsdGhpcy55PXQueS1lLnksdGhpcy56PXQuei1lLnosdGhpcy53PXQudy1lLncsdGhpc31tdWx0aXBseSh0KXtyZXR1cm4gdGhpcy54Kj10LngsdGhpcy55Kj10LnksdGhpcy56Kj10LnosdGhpcy53Kj10LncsdGhpc31tdWx0aXBseVNjYWxhcih0KXtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXQsdGhpcy53Kj10LHRoaXN9YXBwbHlNYXRyaXg0KHQpe2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LG49dGhpcy56LGk9dGhpcy53LG89dC5lbGVtZW50cztyZXR1cm4gdGhpcy54PW9bMF0qZStvWzRdKnMrb1s4XSpuK29bMTJdKmksdGhpcy55PW9bMV0qZStvWzVdKnMrb1s5XSpuK29bMTNdKmksdGhpcy56PW9bMl0qZStvWzZdKnMrb1sxMF0qbitvWzE0XSppLHRoaXMudz1vWzNdKmUrb1s3XSpzK29bMTFdKm4rb1sxNV0qaSx0aGlzfWRpdmlkZVNjYWxhcih0KXtyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxL3QpfXNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uKHQpe3RoaXMudz0yKk1hdGguYWNvcyh0LncpO2NvbnN0IGU9TWF0aC5zcXJ0KDEtdC53KnQudyk7cmV0dXJuIGU8MWUtND8odGhpcy54PTEsdGhpcy55PTAsdGhpcy56PTApOih0aGlzLng9dC54L2UsdGhpcy55PXQueS9lLHRoaXMuej10LnovZSksdGhpc31zZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXgodCl7bGV0IGUscyxuLGk7Y29uc3QgYz10LmVsZW1lbnRzLHU9Y1swXSxoPWNbNF0sbD1jWzhdLGQ9Y1sxXSxmPWNbNV0scD1jWzldLG09Y1syXSxnPWNbNl0seT1jWzEwXTtpZihNYXRoLmFicyhoLWQpPC4wMSYmTWF0aC5hYnMobC1tKTwuMDEmJk1hdGguYWJzKHAtZyk8LjAxKXtpZihNYXRoLmFicyhoK2QpPC4xJiZNYXRoLmFicyhsK20pPC4xJiZNYXRoLmFicyhwK2cpPC4xJiZNYXRoLmFicyh1K2YreS0zKTwuMSlyZXR1cm4gdGhpcy5zZXQoMSwwLDAsMCksdGhpcztlPU1hdGguUEk7Y29uc3Qgdz0odSsxKS8yLE09KGYrMSkvMixOPSh5KzEpLzIsXz0oaCtkKS80LFM9KGwrbSkvNCxFPShwK2cpLzQ7cmV0dXJuIHc+TSYmdz5OP3c8LjAxPyhzPTAsbj0uNzA3MTA2NzgxLGk9LjcwNzEwNjc4MSk6KHM9TWF0aC5zcXJ0KHcpLG49Xy9zLGk9Uy9zKTpNPk4/TTwuMDE/KHM9LjcwNzEwNjc4MSxuPTAsaT0uNzA3MTA2NzgxKToobj1NYXRoLnNxcnQoTSkscz1fL24saT1FL24pOk48LjAxPyhzPS43MDcxMDY3ODEsbj0uNzA3MTA2NzgxLGk9MCk6KGk9TWF0aC5zcXJ0KE4pLHM9Uy9pLG49RS9pKSx0aGlzLnNldChzLG4saSxlKSx0aGlzfWxldCBUPU1hdGguc3FydCgoZy1wKSooZy1wKSsobC1tKSoobC1tKSsoZC1oKSooZC1oKSk7cmV0dXJuIE1hdGguYWJzKFQpPC4wMDEmJihUPTEpLHRoaXMueD0oZy1wKS9ULHRoaXMueT0obC1tKS9ULHRoaXMuej0oZC1oKS9ULHRoaXMudz1NYXRoLmFjb3MoKHUrZit5LTEpLzIpLHRoaXN9c2V0RnJvbU1hdHJpeFBvc2l0aW9uKHQpe2NvbnN0IGU9dC5lbGVtZW50cztyZXR1cm4gdGhpcy54PWVbMTJdLHRoaXMueT1lWzEzXSx0aGlzLno9ZVsxNF0sdGhpcy53PWVbMTVdLHRoaXN9bWluKHQpe3JldHVybiB0aGlzLng9TWF0aC5taW4odGhpcy54LHQueCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0LnkpLHRoaXMuej1NYXRoLm1pbih0aGlzLnosdC56KSx0aGlzLnc9TWF0aC5taW4odGhpcy53LHQudyksdGhpc31tYXgodCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LHQueSksdGhpcy56PU1hdGgubWF4KHRoaXMueix0LnopLHRoaXMudz1NYXRoLm1heCh0aGlzLncsdC53KSx0aGlzfWNsYW1wKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LngsTWF0aC5taW4oZS54LHRoaXMueCkpLHRoaXMueT1NYXRoLm1heCh0LnksTWF0aC5taW4oZS55LHRoaXMueSkpLHRoaXMuej1NYXRoLm1heCh0LnosTWF0aC5taW4oZS56LHRoaXMueikpLHRoaXMudz1NYXRoLm1heCh0LncsTWF0aC5taW4oZS53LHRoaXMudykpLHRoaXN9Y2xhbXBTY2FsYXIodCxlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueSkpLHRoaXMuej1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy56KSksdGhpcy53PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLncpKSx0aGlzfWNsYW1wTGVuZ3RoKHQsZSl7Y29uc3Qgcz10aGlzLmxlbmd0aCgpO3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcihzfHwxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heCh0LE1hdGgubWluKGUscykpKX1mbG9vcigpe3JldHVybiB0aGlzLng9TWF0aC5mbG9vcih0aGlzLngpLHRoaXMueT1NYXRoLmZsb29yKHRoaXMueSksdGhpcy56PU1hdGguZmxvb3IodGhpcy56KSx0aGlzLnc9TWF0aC5mbG9vcih0aGlzLncpLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXMuej1NYXRoLmNlaWwodGhpcy56KSx0aGlzLnc9TWF0aC5jZWlsKHRoaXMudyksdGhpc31yb3VuZCgpe3JldHVybiB0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpLHRoaXMueT1NYXRoLnJvdW5kKHRoaXMueSksdGhpcy56PU1hdGgucm91bmQodGhpcy56KSx0aGlzLnc9TWF0aC5yb3VuZCh0aGlzLncpLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PU1hdGgudHJ1bmModGhpcy54KSx0aGlzLnk9TWF0aC50cnVuYyh0aGlzLnkpLHRoaXMuej1NYXRoLnRydW5jKHRoaXMueiksdGhpcy53PU1hdGgudHJ1bmModGhpcy53KSx0aGlzfW5lZ2F0ZSgpe3JldHVybiB0aGlzLng9LXRoaXMueCx0aGlzLnk9LXRoaXMueSx0aGlzLno9LXRoaXMueix0aGlzLnc9LXRoaXMudyx0aGlzfWRvdCh0KXtyZXR1cm4gdGhpcy54KnQueCt0aGlzLnkqdC55K3RoaXMueip0LnordGhpcy53KnQud31sZW5ndGhTcSgpe3JldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMueit0aGlzLncqdGhpcy53fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudyl9bWFuaGF0dGFuTGVuZ3RoKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueCkrTWF0aC5hYnModGhpcy55KStNYXRoLmFicyh0aGlzLnopK01hdGguYWJzKHRoaXMudyl9bm9ybWFsaXplKCl7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCl8fDEpfXNldExlbmd0aCh0KXtyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcih0KX1sZXJwKHQsZSl7cmV0dXJuIHRoaXMueCs9KHQueC10aGlzLngpKmUsdGhpcy55Kz0odC55LXRoaXMueSkqZSx0aGlzLnorPSh0LnotdGhpcy56KSplLHRoaXMudys9KHQudy10aGlzLncpKmUsdGhpc31sZXJwVmVjdG9ycyh0LGUscyl7cmV0dXJuIHRoaXMueD10LngrKGUueC10LngpKnMsdGhpcy55PXQueSsoZS55LXQueSkqcyx0aGlzLno9dC56KyhlLnotdC56KSpzLHRoaXMudz10LncrKGUudy10LncpKnMsdGhpc31lcXVhbHModCl7cmV0dXJuIHQueD09PXRoaXMueCYmdC55PT09dGhpcy55JiZ0Lno9PT10aGlzLnomJnQudz09PXRoaXMud31mcm9tQXJyYXkodCxlPTApe3JldHVybiB0aGlzLng9dFtlXSx0aGlzLnk9dFtlKzFdLHRoaXMuej10W2UrMl0sdGhpcy53PXRbZSszXSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMueCx0W2UrMV09dGhpcy55LHRbZSsyXT10aGlzLnosdFtlKzNdPXRoaXMudyx0fWZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKXtyZXR1cm4gdGhpcy54PXQuZ2V0WChlKSx0aGlzLnk9dC5nZXRZKGUpLHRoaXMuej10LmdldFooZSksdGhpcy53PXQuZ2V0VyhlKSx0aGlzfXJhbmRvbSgpe3JldHVybiB0aGlzLng9TWF0aC5yYW5kb20oKSx0aGlzLnk9TWF0aC5yYW5kb20oKSx0aGlzLno9TWF0aC5yYW5kb20oKSx0aGlzLnc9TWF0aC5yYW5kb20oKSx0aGlzfSpbU3ltYm9sLml0ZXJhdG9yXSgpe3lpZWxkIHRoaXMueCx5aWVsZCB0aGlzLnkseWllbGQgdGhpcy56LHlpZWxkIHRoaXMud319Y2xhc3Mgb3IgZXh0ZW5kcyBaZXtjb25zdHJ1Y3Rvcih0PTEsZT0xLHM9e30pe3N1cGVyKCksdGhpcy5pc1JlbmRlclRhcmdldD0hMCx0aGlzLndpZHRoPXQsdGhpcy5oZWlnaHQ9ZSx0aGlzLmRlcHRoPTEsdGhpcy5zY2lzc29yPW5ldyBGdCgwLDAsdCxlKSx0aGlzLnNjaXNzb3JUZXN0PSExLHRoaXMudmlld3BvcnQ9bmV3IEZ0KDAsMCx0LGUpO2NvbnN0IG49e3dpZHRoOnQsaGVpZ2h0OmUsZGVwdGg6MX07cz1PYmplY3QuYXNzaWduKHtnZW5lcmF0ZU1pcG1hcHM6ITEsaW50ZXJuYWxGb3JtYXQ6bnVsbCxtaW5GaWx0ZXI6JGksZGVwdGhCdWZmZXI6ITAsc3RlbmNpbEJ1ZmZlcjohMSxyZXNvbHZlRGVwdGhCdWZmZXI6ITAscmVzb2x2ZVN0ZW5jaWxCdWZmZXI6ITAsZGVwdGhUZXh0dXJlOm51bGwsc2FtcGxlczowLGNvdW50OjF9LHMpO2NvbnN0IGk9bmV3IER0KG4scy5tYXBwaW5nLHMud3JhcFMscy53cmFwVCxzLm1hZ0ZpbHRlcixzLm1pbkZpbHRlcixzLmZvcm1hdCxzLnR5cGUscy5hbmlzb3Ryb3B5LHMuY29sb3JTcGFjZSk7aS5mbGlwWT0hMSxpLmdlbmVyYXRlTWlwbWFwcz1zLmdlbmVyYXRlTWlwbWFwcyxpLmludGVybmFsRm9ybWF0PXMuaW50ZXJuYWxGb3JtYXQsdGhpcy50ZXh0dXJlcz1bXTtjb25zdCBvPXMuY291bnQ7Zm9yKGxldCBhPTA7YTxvO2ErKyl0aGlzLnRleHR1cmVzW2FdPWkuY2xvbmUoKSx0aGlzLnRleHR1cmVzW2FdLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMDt0aGlzLmRlcHRoQnVmZmVyPXMuZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPXMuc3RlbmNpbEJ1ZmZlcix0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlcj1zLnJlc29sdmVEZXB0aEJ1ZmZlcix0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyPXMucmVzb2x2ZVN0ZW5jaWxCdWZmZXIsdGhpcy5kZXB0aFRleHR1cmU9cy5kZXB0aFRleHR1cmUsdGhpcy5zYW1wbGVzPXMuc2FtcGxlc31nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzLnRleHR1cmVzWzBdfXNldCB0ZXh0dXJlKHQpe3RoaXMudGV4dHVyZXNbMF09dH1zZXRTaXplKHQsZSxzPTEpe2lmKHRoaXMud2lkdGghPT10fHx0aGlzLmhlaWdodCE9PWV8fHRoaXMuZGVwdGghPT1zKXt0aGlzLndpZHRoPXQsdGhpcy5oZWlnaHQ9ZSx0aGlzLmRlcHRoPXM7Zm9yKGxldCBuPTAsaT10aGlzLnRleHR1cmVzLmxlbmd0aDtuPGk7bisrKXRoaXMudGV4dHVyZXNbbl0uaW1hZ2Uud2lkdGg9dCx0aGlzLnRleHR1cmVzW25dLmltYWdlLmhlaWdodD1lLHRoaXMudGV4dHVyZXNbbl0uaW1hZ2UuZGVwdGg9czt0aGlzLmRpc3Bvc2UoKX10aGlzLnZpZXdwb3J0LnNldCgwLDAsdCxlKSx0aGlzLnNjaXNzb3Iuc2V0KDAsMCx0LGUpfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KHQpe3RoaXMud2lkdGg9dC53aWR0aCx0aGlzLmhlaWdodD10LmhlaWdodCx0aGlzLmRlcHRoPXQuZGVwdGgsdGhpcy5zY2lzc29yLmNvcHkodC5zY2lzc29yKSx0aGlzLnNjaXNzb3JUZXN0PXQuc2Npc3NvclRlc3QsdGhpcy52aWV3cG9ydC5jb3B5KHQudmlld3BvcnQpLHRoaXMudGV4dHVyZXMubGVuZ3RoPTA7Zm9yKGxldCBzPTAsbj10LnRleHR1cmVzLmxlbmd0aDtzPG47cysrKXRoaXMudGV4dHVyZXNbc109dC50ZXh0dXJlc1tzXS5jbG9uZSgpLHRoaXMudGV4dHVyZXNbc10uaXNSZW5kZXJUYXJnZXRUZXh0dXJlPSEwO2NvbnN0IGU9T2JqZWN0LmFzc2lnbih7fSx0LnRleHR1cmUuaW1hZ2UpO3JldHVybiB0aGlzLnRleHR1cmUuc291cmNlPW5ldyBycihlKSx0aGlzLmRlcHRoQnVmZmVyPXQuZGVwdGhCdWZmZXIsdGhpcy5zdGVuY2lsQnVmZmVyPXQuc3RlbmNpbEJ1ZmZlcix0aGlzLnJlc29sdmVEZXB0aEJ1ZmZlcj10LnJlc29sdmVEZXB0aEJ1ZmZlcix0aGlzLnJlc29sdmVTdGVuY2lsQnVmZmVyPXQucmVzb2x2ZVN0ZW5jaWxCdWZmZXIsdC5kZXB0aFRleHR1cmUhPT1udWxsJiYodGhpcy5kZXB0aFRleHR1cmU9dC5kZXB0aFRleHR1cmUuY2xvbmUoKSksdGhpcy5zYW1wbGVzPXQuc2FtcGxlcyx0aGlzfWRpc3Bvc2UoKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ImRpc3Bvc2UifSl9fWNsYXNzIFFle2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wLG49MSl7dGhpcy5pc1F1YXRlcm5pb249ITAsdGhpcy5feD10LHRoaXMuX3k9ZSx0aGlzLl96PXMsdGhpcy5fdz1ufXN0YXRpYyBzbGVycEZsYXQodCxlLHMsbixpLG8sYSl7bGV0IGM9c1tuKzBdLHU9c1tuKzFdLGg9c1tuKzJdLGw9c1tuKzNdO2NvbnN0IGQ9aVtvKzBdLGY9aVtvKzFdLHA9aVtvKzJdLG09aVtvKzNdO2lmKGE9PT0wKXt0W2UrMF09Yyx0W2UrMV09dSx0W2UrMl09aCx0W2UrM109bDtyZXR1cm59aWYoYT09PTEpe3RbZSswXT1kLHRbZSsxXT1mLHRbZSsyXT1wLHRbZSszXT1tO3JldHVybn1pZihsIT09bXx8YyE9PWR8fHUhPT1mfHxoIT09cCl7bGV0IGc9MS1hO2NvbnN0IHk9YypkK3UqZitoKnArbCptLFQ9eT49MD8xOi0xLHc9MS15Knk7aWYodz5OdW1iZXIuRVBTSUxPTil7Y29uc3QgTj1NYXRoLnNxcnQodyksXz1NYXRoLmF0YW4yKE4seSpUKTtnPU1hdGguc2luKGcqXykvTixhPU1hdGguc2luKGEqXykvTn1jb25zdCBNPWEqVDtpZihjPWMqZytkKk0sdT11KmcrZipNLGg9aCpnK3AqTSxsPWwqZyttKk0sZz09PTEtYSl7Y29uc3QgTj0xL01hdGguc3FydChjKmMrdSp1K2gqaCtsKmwpO2MqPU4sdSo9TixoKj1OLGwqPU59fXRbZV09Yyx0W2UrMV09dSx0W2UrMl09aCx0W2UrM109bH1zdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQodCxlLHMsbixpLG8pe2NvbnN0IGE9c1tuXSxjPXNbbisxXSx1PXNbbisyXSxoPXNbbiszXSxsPWlbb10sZD1pW28rMV0sZj1pW28rMl0scD1pW28rM107cmV0dXJuIHRbZV09YSpwK2gqbCtjKmYtdSpkLHRbZSsxXT1jKnAraCpkK3UqbC1hKmYsdFtlKzJdPXUqcCtoKmYrYSpkLWMqbCx0W2UrM109aCpwLWEqbC1jKmQtdSpmLHR9Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1zZXQgeCh0KXt0aGlzLl94PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCB5KCl7cmV0dXJuIHRoaXMuX3l9c2V0IHkodCl7dGhpcy5feT10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgeigpe3JldHVybiB0aGlzLl96fXNldCB6KHQpe3RoaXMuX3o9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHcoKXtyZXR1cm4gdGhpcy5fd31zZXQgdyh0KXt0aGlzLl93PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfXNldCh0LGUscyxuKXtyZXR1cm4gdGhpcy5feD10LHRoaXMuX3k9ZSx0aGlzLl96PXMsdGhpcy5fdz1uLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsdGhpcy5feSx0aGlzLl96LHRoaXMuX3cpfWNvcHkodCl7cmV0dXJuIHRoaXMuX3g9dC54LHRoaXMuX3k9dC55LHRoaXMuX3o9dC56LHRoaXMuX3c9dC53LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXNldEZyb21FdWxlcih0LGU9ITApe2NvbnN0IHM9dC5feCxuPXQuX3ksaT10Ll96LG89dC5fb3JkZXIsYT1NYXRoLmNvcyxjPU1hdGguc2luLHU9YShzLzIpLGg9YShuLzIpLGw9YShpLzIpLGQ9YyhzLzIpLGY9YyhuLzIpLHA9YyhpLzIpO3N3aXRjaChvKXtjYXNlIlhZWiI6dGhpcy5feD1kKmgqbCt1KmYqcCx0aGlzLl95PXUqZipsLWQqaCpwLHRoaXMuX3o9dSpoKnArZCpmKmwsdGhpcy5fdz11KmgqbC1kKmYqcDticmVhaztjYXNlIllYWiI6dGhpcy5feD1kKmgqbCt1KmYqcCx0aGlzLl95PXUqZipsLWQqaCpwLHRoaXMuX3o9dSpoKnAtZCpmKmwsdGhpcy5fdz11KmgqbCtkKmYqcDticmVhaztjYXNlIlpYWSI6dGhpcy5feD1kKmgqbC11KmYqcCx0aGlzLl95PXUqZipsK2QqaCpwLHRoaXMuX3o9dSpoKnArZCpmKmwsdGhpcy5fdz11KmgqbC1kKmYqcDticmVhaztjYXNlIlpZWCI6dGhpcy5feD1kKmgqbC11KmYqcCx0aGlzLl95PXUqZipsK2QqaCpwLHRoaXMuX3o9dSpoKnAtZCpmKmwsdGhpcy5fdz11KmgqbCtkKmYqcDticmVhaztjYXNlIllaWCI6dGhpcy5feD1kKmgqbCt1KmYqcCx0aGlzLl95PXUqZipsK2QqaCpwLHRoaXMuX3o9dSpoKnAtZCpmKmwsdGhpcy5fdz11KmgqbC1kKmYqcDticmVhaztjYXNlIlhaWSI6dGhpcy5feD1kKmgqbC11KmYqcCx0aGlzLl95PXUqZipsLWQqaCpwLHRoaXMuX3o9dSpoKnArZCpmKmwsdGhpcy5fdz11KmgqbCtkKmYqcDticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybigiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrbyl9cmV0dXJuIGU9PT0hMCYmdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbUF4aXNBbmdsZSh0LGUpe2NvbnN0IHM9ZS8yLG49TWF0aC5zaW4ocyk7cmV0dXJuIHRoaXMuX3g9dC54Km4sdGhpcy5feT10Lnkqbix0aGlzLl96PXQueipuLHRoaXMuX3c9TWF0aC5jb3MocyksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KHQpe2NvbnN0IGU9dC5lbGVtZW50cyxzPWVbMF0sbj1lWzRdLGk9ZVs4XSxvPWVbMV0sYT1lWzVdLGM9ZVs5XSx1PWVbMl0saD1lWzZdLGw9ZVsxMF0sZD1zK2ErbDtpZihkPjApe2NvbnN0IGY9LjUvTWF0aC5zcXJ0KGQrMSk7dGhpcy5fdz0uMjUvZix0aGlzLl94PShoLWMpKmYsdGhpcy5feT0oaS11KSpmLHRoaXMuX3o9KG8tbikqZn1lbHNlIGlmKHM+YSYmcz5sKXtjb25zdCBmPTIqTWF0aC5zcXJ0KDErcy1hLWwpO3RoaXMuX3c9KGgtYykvZix0aGlzLl94PS4yNSpmLHRoaXMuX3k9KG4rbykvZix0aGlzLl96PShpK3UpL2Z9ZWxzZSBpZihhPmwpe2NvbnN0IGY9MipNYXRoLnNxcnQoMSthLXMtbCk7dGhpcy5fdz0oaS11KS9mLHRoaXMuX3g9KG4rbykvZix0aGlzLl95PS4yNSpmLHRoaXMuX3o9KGMraCkvZn1lbHNle2NvbnN0IGY9MipNYXRoLnNxcnQoMStsLXMtYSk7dGhpcy5fdz0oby1uKS9mLHRoaXMuX3g9KGkrdSkvZix0aGlzLl95PShjK2gpL2YsdGhpcy5fej0uMjUqZn1yZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2V0RnJvbVVuaXRWZWN0b3JzKHQsZSl7bGV0IHM9dC5kb3QoZSkrMTtyZXR1cm4gczxOdW1iZXIuRVBTSUxPTj8ocz0wLE1hdGguYWJzKHQueCk+TWF0aC5hYnModC56KT8odGhpcy5feD0tdC55LHRoaXMuX3k9dC54LHRoaXMuX3o9MCx0aGlzLl93PXMpOih0aGlzLl94PTAsdGhpcy5feT0tdC56LHRoaXMuX3o9dC55LHRoaXMuX3c9cykpOih0aGlzLl94PXQueSplLnotdC56KmUueSx0aGlzLl95PXQueiplLngtdC54KmUueix0aGlzLl96PXQueCplLnktdC55KmUueCx0aGlzLl93PXMpLHRoaXMubm9ybWFsaXplKCl9YW5nbGVUbyh0KXtyZXR1cm4gMipNYXRoLmFjb3MoTWF0aC5hYnMoYXQodGhpcy5kb3QodCksLTEsMSkpKX1yb3RhdGVUb3dhcmRzKHQsZSl7Y29uc3Qgcz10aGlzLmFuZ2xlVG8odCk7aWYocz09PTApcmV0dXJuIHRoaXM7Y29uc3Qgbj1NYXRoLm1pbigxLGUvcyk7cmV0dXJuIHRoaXMuc2xlcnAodCxuKSx0aGlzfWlkZW50aXR5KCl7cmV0dXJuIHRoaXMuc2V0KDAsMCwwLDEpfWludmVydCgpe3JldHVybiB0aGlzLmNvbmp1Z2F0ZSgpfWNvbmp1Z2F0ZSgpe3JldHVybiB0aGlzLl94Kj0tMSx0aGlzLl95Kj0tMSx0aGlzLl96Kj0tMSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31kb3QodCl7cmV0dXJuIHRoaXMuX3gqdC5feCt0aGlzLl95KnQuX3krdGhpcy5feip0Ll96K3RoaXMuX3cqdC5fd31sZW5ndGhTcSgpe3JldHVybiB0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3d9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3cpfW5vcm1hbGl6ZSgpe2xldCB0PXRoaXMubGVuZ3RoKCk7cmV0dXJuIHQ9PT0wPyh0aGlzLl94PTAsdGhpcy5feT0wLHRoaXMuX3o9MCx0aGlzLl93PTEpOih0PTEvdCx0aGlzLl94PXRoaXMuX3gqdCx0aGlzLl95PXRoaXMuX3kqdCx0aGlzLl96PXRoaXMuX3oqdCx0aGlzLl93PXRoaXMuX3cqdCksdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLHQpfXByZW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnModCx0aGlzKX1tdWx0aXBseVF1YXRlcm5pb25zKHQsZSl7Y29uc3Qgcz10Ll94LG49dC5feSxpPXQuX3osbz10Ll93LGE9ZS5feCxjPWUuX3ksdT1lLl96LGg9ZS5fdztyZXR1cm4gdGhpcy5feD1zKmgrbyphK24qdS1pKmMsdGhpcy5feT1uKmgrbypjK2kqYS1zKnUsdGhpcy5fej1pKmgrbyp1K3MqYy1uKmEsdGhpcy5fdz1vKmgtcyphLW4qYy1pKnUsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLHRoaXN9c2xlcnAodCxlKXtpZihlPT09MClyZXR1cm4gdGhpcztpZihlPT09MSlyZXR1cm4gdGhpcy5jb3B5KHQpO2NvbnN0IHM9dGhpcy5feCxuPXRoaXMuX3ksaT10aGlzLl96LG89dGhpcy5fdztsZXQgYT1vKnQuX3crcyp0Ll94K24qdC5feStpKnQuX3o7aWYoYTwwPyh0aGlzLl93PS10Ll93LHRoaXMuX3g9LXQuX3gsdGhpcy5feT0tdC5feSx0aGlzLl96PS10Ll96LGE9LWEpOnRoaXMuY29weSh0KSxhPj0xKXJldHVybiB0aGlzLl93PW8sdGhpcy5feD1zLHRoaXMuX3k9bix0aGlzLl96PWksdGhpcztjb25zdCBjPTEtYSphO2lmKGM8PU51bWJlci5FUFNJTE9OKXtjb25zdCBmPTEtZTtyZXR1cm4gdGhpcy5fdz1mKm8rZSp0aGlzLl93LHRoaXMuX3g9ZipzK2UqdGhpcy5feCx0aGlzLl95PWYqbitlKnRoaXMuX3ksdGhpcy5fej1mKmkrZSp0aGlzLl96LHRoaXMubm9ybWFsaXplKCksdGhpc31jb25zdCB1PU1hdGguc3FydChjKSxoPU1hdGguYXRhbjIodSxhKSxsPU1hdGguc2luKCgxLWUpKmgpL3UsZD1NYXRoLnNpbihlKmgpL3U7cmV0dXJuIHRoaXMuX3c9bypsK3RoaXMuX3cqZCx0aGlzLl94PXMqbCt0aGlzLl94KmQsdGhpcy5feT1uKmwrdGhpcy5feSpkLHRoaXMuX3o9aSpsK3RoaXMuX3oqZCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zbGVycFF1YXRlcm5pb25zKHQsZSxzKXtyZXR1cm4gdGhpcy5jb3B5KHQpLnNsZXJwKGUscyl9cmFuZG9tKCl7Y29uc3QgdD0yKk1hdGguUEkqTWF0aC5yYW5kb20oKSxlPTIqTWF0aC5QSSpNYXRoLnJhbmRvbSgpLHM9TWF0aC5yYW5kb20oKSxuPU1hdGguc3FydCgxLXMpLGk9TWF0aC5zcXJ0KHMpO3JldHVybiB0aGlzLnNldChuKk1hdGguc2luKHQpLG4qTWF0aC5jb3ModCksaSpNYXRoLnNpbihlKSxpKk1hdGguY29zKGUpKX1lcXVhbHModCl7cmV0dXJuIHQuX3g9PT10aGlzLl94JiZ0Ll95PT09dGhpcy5feSYmdC5fej09PXRoaXMuX3omJnQuX3c9PT10aGlzLl93fWZyb21BcnJheSh0LGU9MCl7cmV0dXJuIHRoaXMuX3g9dFtlXSx0aGlzLl95PXRbZSsxXSx0aGlzLl96PXRbZSsyXSx0aGlzLl93PXRbZSszXSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0FycmF5KHQ9W10sZT0wKXtyZXR1cm4gdFtlXT10aGlzLl94LHRbZSsxXT10aGlzLl95LHRbZSsyXT10aGlzLl96LHRbZSszXT10aGlzLl93LHR9ZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUpe3JldHVybiB0aGlzLl94PXQuZ2V0WChlKSx0aGlzLl95PXQuZ2V0WShlKSx0aGlzLl96PXQuZ2V0WihlKSx0aGlzLl93PXQuZ2V0VyhlKSx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc310b0pTT04oKXtyZXR1cm4gdGhpcy50b0FycmF5KCl9X29uQ2hhbmdlKHQpe3JldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrPXQsdGhpc31fb25DaGFuZ2VDYWxsYmFjaygpe30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLl94LHlpZWxkIHRoaXMuX3kseWllbGQgdGhpcy5feix5aWVsZCB0aGlzLl93fX1jbGFzcyBBe2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wKXtBLnByb3RvdHlwZS5pc1ZlY3RvcjM9ITAsdGhpcy54PXQsdGhpcy55PWUsdGhpcy56PXN9c2V0KHQsZSxzKXtyZXR1cm4gcz09PXZvaWQgMCYmKHM9dGhpcy56KSx0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9cyx0aGlzfXNldFNjYWxhcih0KXtyZXR1cm4gdGhpcy54PXQsdGhpcy55PXQsdGhpcy56PXQsdGhpc31zZXRYKHQpe3JldHVybiB0aGlzLng9dCx0aGlzfXNldFkodCl7cmV0dXJuIHRoaXMueT10LHRoaXN9c2V0Wih0KXtyZXR1cm4gdGhpcy56PXQsdGhpc31zZXRDb21wb25lbnQodCxlKXtzd2l0Y2godCl7Y2FzZSAwOnRoaXMueD1lO2JyZWFrO2Nhc2UgMTp0aGlzLnk9ZTticmVhaztjYXNlIDI6dGhpcy56PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIit0KX1yZXR1cm4gdGhpc31nZXRDb21wb25lbnQodCl7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIrdCl9fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCx0aGlzLnksdGhpcy56KX1jb3B5KHQpe3JldHVybiB0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQueix0aGlzfWFkZCh0KXtyZXR1cm4gdGhpcy54Kz10LngsdGhpcy55Kz10LnksdGhpcy56Kz10LnosdGhpc31hZGRTY2FsYXIodCl7cmV0dXJuIHRoaXMueCs9dCx0aGlzLnkrPXQsdGhpcy56Kz10LHRoaXN9YWRkVmVjdG9ycyh0LGUpe3JldHVybiB0aGlzLng9dC54K2UueCx0aGlzLnk9dC55K2UueSx0aGlzLno9dC56K2Uueix0aGlzfWFkZFNjYWxlZFZlY3Rvcih0LGUpe3JldHVybiB0aGlzLngrPXQueCplLHRoaXMueSs9dC55KmUsdGhpcy56Kz10LnoqZSx0aGlzfXN1Yih0KXtyZXR1cm4gdGhpcy54LT10LngsdGhpcy55LT10LnksdGhpcy56LT10LnosdGhpc31zdWJTY2FsYXIodCl7cmV0dXJuIHRoaXMueC09dCx0aGlzLnktPXQsdGhpcy56LT10LHRoaXN9c3ViVmVjdG9ycyh0LGUpe3JldHVybiB0aGlzLng9dC54LWUueCx0aGlzLnk9dC55LWUueSx0aGlzLno9dC56LWUueix0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLngqPXQueCx0aGlzLnkqPXQueSx0aGlzLnoqPXQueix0aGlzfW11bHRpcGx5U2NhbGFyKHQpe3JldHVybiB0aGlzLngqPXQsdGhpcy55Kj10LHRoaXMueio9dCx0aGlzfW11bHRpcGx5VmVjdG9ycyh0LGUpe3JldHVybiB0aGlzLng9dC54KmUueCx0aGlzLnk9dC55KmUueSx0aGlzLno9dC56KmUueix0aGlzfWFwcGx5RXVsZXIodCl7cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKGFyLnNldEZyb21FdWxlcih0KSl9YXBwbHlBeGlzQW5nbGUodCxlKXtyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oYXIuc2V0RnJvbUF4aXNBbmdsZSh0LGUpKX1hcHBseU1hdHJpeDModCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksbj10aGlzLnosaT10LmVsZW1lbnRzO3JldHVybiB0aGlzLng9aVswXSplK2lbM10qcytpWzZdKm4sdGhpcy55PWlbMV0qZStpWzRdKnMraVs3XSpuLHRoaXMuej1pWzJdKmUraVs1XSpzK2lbOF0qbix0aGlzfWFwcGx5Tm9ybWFsTWF0cml4KHQpe3JldHVybiB0aGlzLmFwcGx5TWF0cml4Myh0KS5ub3JtYWxpemUoKX1hcHBseU1hdHJpeDQodCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksbj10aGlzLnosaT10LmVsZW1lbnRzLG89MS8oaVszXSplK2lbN10qcytpWzExXSpuK2lbMTVdKTtyZXR1cm4gdGhpcy54PShpWzBdKmUraVs0XSpzK2lbOF0qbitpWzEyXSkqbyx0aGlzLnk9KGlbMV0qZStpWzVdKnMraVs5XSpuK2lbMTNdKSpvLHRoaXMuej0oaVsyXSplK2lbNl0qcytpWzEwXSpuK2lbMTRdKSpvLHRoaXN9YXBwbHlRdWF0ZXJuaW9uKHQpe2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LG49dGhpcy56LGk9dC54LG89dC55LGE9dC56LGM9dC53LHU9MioobypuLWEqcyksaD0yKihhKmUtaSpuKSxsPTIqKGkqcy1vKmUpO3JldHVybiB0aGlzLng9ZStjKnUrbypsLWEqaCx0aGlzLnk9cytjKmgrYSp1LWkqbCx0aGlzLno9bitjKmwraSpoLW8qdSx0aGlzfXByb2plY3QodCl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGRJbnZlcnNlKS5hcHBseU1hdHJpeDQodC5wcm9qZWN0aW9uTWF0cml4KX11bnByb2plY3QodCl7cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KHQucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkKX10cmFuc2Zvcm1EaXJlY3Rpb24odCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksbj10aGlzLnosaT10LmVsZW1lbnRzO3JldHVybiB0aGlzLng9aVswXSplK2lbNF0qcytpWzhdKm4sdGhpcy55PWlbMV0qZStpWzVdKnMraVs5XSpuLHRoaXMuej1pWzJdKmUraVs2XSpzK2lbMTBdKm4sdGhpcy5ub3JtYWxpemUoKX1kaXZpZGUodCl7cmV0dXJuIHRoaXMueC89dC54LHRoaXMueS89dC55LHRoaXMuei89dC56LHRoaXN9ZGl2aWRlU2NhbGFyKHQpe3JldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEvdCl9bWluKHQpe3JldHVybiB0aGlzLng9TWF0aC5taW4odGhpcy54LHQueCksdGhpcy55PU1hdGgubWluKHRoaXMueSx0LnkpLHRoaXMuej1NYXRoLm1pbih0aGlzLnosdC56KSx0aGlzfW1heCh0KXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KHRoaXMueCx0LngpLHRoaXMueT1NYXRoLm1heCh0aGlzLnksdC55KSx0aGlzLno9TWF0aC5tYXgodGhpcy56LHQueiksdGhpc31jbGFtcCh0LGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgodC54LE1hdGgubWluKGUueCx0aGlzLngpKSx0aGlzLnk9TWF0aC5tYXgodC55LE1hdGgubWluKGUueSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgodC56LE1hdGgubWluKGUueix0aGlzLnopKSx0aGlzfWNsYW1wU2NhbGFyKHQsZSl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0LE1hdGgubWluKGUsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KHQsTWF0aC5taW4oZSx0aGlzLnkpKSx0aGlzLno9TWF0aC5tYXgodCxNYXRoLm1pbihlLHRoaXMueikpLHRoaXN9Y2xhbXBMZW5ndGgodCxlKXtjb25zdCBzPXRoaXMubGVuZ3RoKCk7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHN8fDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KHQsTWF0aC5taW4oZSxzKSkpfWZsb29yKCl7cmV0dXJuIHRoaXMueD1NYXRoLmZsb29yKHRoaXMueCksdGhpcy55PU1hdGguZmxvb3IodGhpcy55KSx0aGlzLno9TWF0aC5mbG9vcih0aGlzLnopLHRoaXN9Y2VpbCgpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXMuej1NYXRoLmNlaWwodGhpcy56KSx0aGlzfXJvdW5kKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueCksdGhpcy55PU1hdGgucm91bmQodGhpcy55KSx0aGlzLno9TWF0aC5yb3VuZCh0aGlzLnopLHRoaXN9cm91bmRUb1plcm8oKXtyZXR1cm4gdGhpcy54PU1hdGgudHJ1bmModGhpcy54KSx0aGlzLnk9TWF0aC50cnVuYyh0aGlzLnkpLHRoaXMuej1NYXRoLnRydW5jKHRoaXMueiksdGhpc31uZWdhdGUoKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpcy56PS10aGlzLnosdGhpc31kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueSt0aGlzLnoqdC56fWxlbmd0aFNxKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56fWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfW1hbmhhdHRhbkxlbmd0aCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KX1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9c2V0TGVuZ3RoKHQpe3JldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHQpfWxlcnAodCxlKXtyZXR1cm4gdGhpcy54Kz0odC54LXRoaXMueCkqZSx0aGlzLnkrPSh0LnktdGhpcy55KSplLHRoaXMueis9KHQuei10aGlzLnopKmUsdGhpc31sZXJwVmVjdG9ycyh0LGUscyl7cmV0dXJuIHRoaXMueD10LngrKGUueC10LngpKnMsdGhpcy55PXQueSsoZS55LXQueSkqcyx0aGlzLno9dC56KyhlLnotdC56KSpzLHRoaXN9Y3Jvc3ModCl7cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHRoaXMsdCl9Y3Jvc3NWZWN0b3JzKHQsZSl7Y29uc3Qgcz10Lngsbj10LnksaT10Lnosbz1lLngsYT1lLnksYz1lLno7cmV0dXJuIHRoaXMueD1uKmMtaSphLHRoaXMueT1pKm8tcypjLHRoaXMuej1zKmEtbipvLHRoaXN9cHJvamVjdE9uVmVjdG9yKHQpe2NvbnN0IGU9dC5sZW5ndGhTcSgpO2lmKGU9PT0wKXJldHVybiB0aGlzLnNldCgwLDAsMCk7Y29uc3Qgcz10LmRvdCh0aGlzKS9lO3JldHVybiB0aGlzLmNvcHkodCkubXVsdGlwbHlTY2FsYXIocyl9cHJvamVjdE9uUGxhbmUodCl7cmV0dXJuIFJuLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKHQpLHRoaXMuc3ViKFJuKX1yZWZsZWN0KHQpe3JldHVybiB0aGlzLnN1YihSbi5jb3B5KHQpLm11bHRpcGx5U2NhbGFyKDIqdGhpcy5kb3QodCkpKX1hbmdsZVRvKHQpe2NvbnN0IGU9TWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSp0Lmxlbmd0aFNxKCkpO2lmKGU9PT0wKXJldHVybiBNYXRoLlBJLzI7Y29uc3Qgcz10aGlzLmRvdCh0KS9lO3JldHVybiBNYXRoLmFjb3MoYXQocywtMSwxKSl9ZGlzdGFuY2VUbyh0KXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodCkpfWRpc3RhbmNlVG9TcXVhcmVkKHQpe2NvbnN0IGU9dGhpcy54LXQueCxzPXRoaXMueS10Lnksbj10aGlzLnotdC56O3JldHVybiBlKmUrcypzK24qbn1tYW5oYXR0YW5EaXN0YW5jZVRvKHQpe3JldHVybiBNYXRoLmFicyh0aGlzLngtdC54KStNYXRoLmFicyh0aGlzLnktdC55KStNYXRoLmFicyh0aGlzLnotdC56KX1zZXRGcm9tU3BoZXJpY2FsKHQpe3JldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHModC5yYWRpdXMsdC5waGksdC50aGV0YSl9c2V0RnJvbVNwaGVyaWNhbENvb3Jkcyh0LGUscyl7Y29uc3Qgbj1NYXRoLnNpbihlKSp0O3JldHVybiB0aGlzLng9bipNYXRoLnNpbihzKSx0aGlzLnk9TWF0aC5jb3MoZSkqdCx0aGlzLno9bipNYXRoLmNvcyhzKSx0aGlzfXNldEZyb21DeWxpbmRyaWNhbCh0KXtyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHModC5yYWRpdXMsdC50aGV0YSx0LnkpfXNldEZyb21DeWxpbmRyaWNhbENvb3Jkcyh0LGUscyl7cmV0dXJuIHRoaXMueD10Kk1hdGguc2luKGUpLHRoaXMueT1zLHRoaXMuej10Kk1hdGguY29zKGUpLHRoaXN9c2V0RnJvbU1hdHJpeFBvc2l0aW9uKHQpe2NvbnN0IGU9dC5lbGVtZW50cztyZXR1cm4gdGhpcy54PWVbMTJdLHRoaXMueT1lWzEzXSx0aGlzLno9ZVsxNF0sdGhpc31zZXRGcm9tTWF0cml4U2NhbGUodCl7Y29uc3QgZT10aGlzLnNldEZyb21NYXRyaXhDb2x1bW4odCwwKS5sZW5ndGgoKSxzPXRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LDEpLmxlbmd0aCgpLG49dGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHQsMikubGVuZ3RoKCk7cmV0dXJuIHRoaXMueD1lLHRoaXMueT1zLHRoaXMuej1uLHRoaXN9c2V0RnJvbU1hdHJpeENvbHVtbih0LGUpe3JldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLGUqNCl9c2V0RnJvbU1hdHJpeDNDb2x1bW4odCxlKXtyZXR1cm4gdGhpcy5mcm9tQXJyYXkodC5lbGVtZW50cyxlKjMpfXNldEZyb21FdWxlcih0KXtyZXR1cm4gdGhpcy54PXQuX3gsdGhpcy55PXQuX3ksdGhpcy56PXQuX3osdGhpc31zZXRGcm9tQ29sb3IodCl7cmV0dXJuIHRoaXMueD10LnIsdGhpcy55PXQuZyx0aGlzLno9dC5iLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0Lng9PT10aGlzLngmJnQueT09PXRoaXMueSYmdC56PT09dGhpcy56fWZyb21BcnJheSh0LGU9MCl7cmV0dXJuIHRoaXMueD10W2VdLHRoaXMueT10W2UrMV0sdGhpcy56PXRbZSsyXSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMueCx0W2UrMV09dGhpcy55LHRbZSsyXT10aGlzLnosdH1mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSl7cmV0dXJuIHRoaXMueD10LmdldFgoZSksdGhpcy55PXQuZ2V0WShlKSx0aGlzLno9dC5nZXRaKGUpLHRoaXN9cmFuZG9tKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJhbmRvbSgpLHRoaXMueT1NYXRoLnJhbmRvbSgpLHRoaXMuej1NYXRoLnJhbmRvbSgpLHRoaXN9cmFuZG9tRGlyZWN0aW9uKCl7Y29uc3QgdD1NYXRoLnJhbmRvbSgpKk1hdGguUEkqMixlPU1hdGgucmFuZG9tKCkqMi0xLHM9TWF0aC5zcXJ0KDEtZSplKTtyZXR1cm4gdGhpcy54PXMqTWF0aC5jb3ModCksdGhpcy55PWUsdGhpcy56PXMqTWF0aC5zaW4odCksdGhpc30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLngseWllbGQgdGhpcy55LHlpZWxkIHRoaXMuen19Y29uc3QgUm49bmV3IEEsYXI9bmV3IFFlO2NsYXNzIGh0e2NvbnN0cnVjdG9yKHQ9bmV3IEEoMS8wLDEvMCwxLzApLGU9bmV3IEEoLTEvMCwtMS8wLC0xLzApKXt0aGlzLmlzQm94Mz0hMCx0aGlzLm1pbj10LHRoaXMubWF4PWV9c2V0KHQsZSl7cmV0dXJuIHRoaXMubWluLmNvcHkodCksdGhpcy5tYXguY29weShlKSx0aGlzfXNldEZyb21BcnJheSh0KXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgZT0wLHM9dC5sZW5ndGg7ZTxzO2UrPTMpdGhpcy5leHBhbmRCeVBvaW50KFJ0LmZyb21BcnJheSh0LGUpKTtyZXR1cm4gdGhpc31zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHQpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCBlPTAscz10LmNvdW50O2U8cztlKyspdGhpcy5leHBhbmRCeVBvaW50KFJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKSk7cmV0dXJuIHRoaXN9c2V0RnJvbVBvaW50cyh0KXt0aGlzLm1ha2VFbXB0eSgpO2ZvcihsZXQgZT0wLHM9dC5sZW5ndGg7ZTxzO2UrKyl0aGlzLmV4cGFuZEJ5UG9pbnQodFtlXSk7cmV0dXJuIHRoaXN9c2V0RnJvbUNlbnRlckFuZFNpemUodCxlKXtjb25zdCBzPVJ0LmNvcHkoZSkubXVsdGlwbHlTY2FsYXIoLjUpO3JldHVybiB0aGlzLm1pbi5jb3B5KHQpLnN1YihzKSx0aGlzLm1heC5jb3B5KHQpLmFkZChzKSx0aGlzfXNldEZyb21PYmplY3QodCxlPSExKXtyZXR1cm4gdGhpcy5tYWtlRW1wdHkoKSx0aGlzLmV4cGFuZEJ5T2JqZWN0KHQsZSl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkodCl7cmV0dXJuIHRoaXMubWluLmNvcHkodC5taW4pLHRoaXMubWF4LmNvcHkodC5tYXgpLHRoaXN9bWFrZUVtcHR5KCl7cmV0dXJuIHRoaXMubWluLng9dGhpcy5taW4ueT10aGlzLm1pbi56PTEvMCx0aGlzLm1heC54PXRoaXMubWF4Lnk9dGhpcy5tYXguej0tMS8wLHRoaXN9aXNFbXB0eSgpe3JldHVybiB0aGlzLm1heC54PHRoaXMubWluLnh8fHRoaXMubWF4Lnk8dGhpcy5taW4ueXx8dGhpcy5tYXguejx0aGlzLm1pbi56fWdldENlbnRlcih0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dC5zZXQoMCwwLDApOnQuYWRkVmVjdG9ycyh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHlTY2FsYXIoLjUpfWdldFNpemUodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LnN1YlZlY3RvcnModGhpcy5tYXgsdGhpcy5taW4pfWV4cGFuZEJ5UG9pbnQodCl7cmV0dXJuIHRoaXMubWluLm1pbih0KSx0aGlzLm1heC5tYXgodCksdGhpc31leHBhbmRCeVZlY3Rvcih0KXtyZXR1cm4gdGhpcy5taW4uc3ViKHQpLHRoaXMubWF4LmFkZCh0KSx0aGlzfWV4cGFuZEJ5U2NhbGFyKHQpe3JldHVybiB0aGlzLm1pbi5hZGRTY2FsYXIoLXQpLHRoaXMubWF4LmFkZFNjYWxhcih0KSx0aGlzfWV4cGFuZEJ5T2JqZWN0KHQsZT0hMSl7dC51cGRhdGVXb3JsZE1hdHJpeCghMSwhMSk7Y29uc3Qgcz10Lmdlb21ldHJ5O2lmKHMhPT12b2lkIDApe2NvbnN0IGk9cy5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7aWYoZT09PSEwJiZpIT09dm9pZCAwJiZ0LmlzSW5zdGFuY2VkTWVzaCE9PSEwKWZvcihsZXQgbz0wLGE9aS5jb3VudDtvPGE7bysrKXQuaXNNZXNoPT09ITA/dC5nZXRWZXJ0ZXhQb3NpdGlvbihvLFJ0KTpSdC5mcm9tQnVmZmVyQXR0cmlidXRlKGksbyksUnQuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLHRoaXMuZXhwYW5kQnlQb2ludChSdCk7ZWxzZSB0LmJvdW5kaW5nQm94IT09dm9pZCAwPyh0LmJvdW5kaW5nQm94PT09bnVsbCYmdC5jb21wdXRlQm91bmRpbmdCb3goKSxGcy5jb3B5KHQuYm91bmRpbmdCb3gpKToocy5ib3VuZGluZ0JveD09PW51bGwmJnMuY29tcHV0ZUJvdW5kaW5nQm94KCksRnMuY29weShzLmJvdW5kaW5nQm94KSksRnMuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLHRoaXMudW5pb24oRnMpfWNvbnN0IG49dC5jaGlsZHJlbjtmb3IobGV0IGk9MCxvPW4ubGVuZ3RoO2k8bztpKyspdGhpcy5leHBhbmRCeU9iamVjdChuW2ldLGUpO3JldHVybiB0aGlzfWNvbnRhaW5zUG9pbnQodCl7cmV0dXJuIHQueD49dGhpcy5taW4ueCYmdC54PD10aGlzLm1heC54JiZ0Lnk+PXRoaXMubWluLnkmJnQueTw9dGhpcy5tYXgueSYmdC56Pj10aGlzLm1pbi56JiZ0Lno8PXRoaXMubWF4Lnp9Y29udGFpbnNCb3godCl7cmV0dXJuIHRoaXMubWluLng8PXQubWluLngmJnQubWF4Lng8PXRoaXMubWF4LngmJnRoaXMubWluLnk8PXQubWluLnkmJnQubWF4Lnk8PXRoaXMubWF4LnkmJnRoaXMubWluLno8PXQubWluLnomJnQubWF4Lno8PXRoaXMubWF4Lnp9Z2V0UGFyYW1ldGVyKHQsZSl7cmV0dXJuIGUuc2V0KCh0LngtdGhpcy5taW4ueCkvKHRoaXMubWF4LngtdGhpcy5taW4ueCksKHQueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSwodC56LXRoaXMubWluLnopLyh0aGlzLm1heC56LXRoaXMubWluLnopKX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiB0Lm1heC54Pj10aGlzLm1pbi54JiZ0Lm1pbi54PD10aGlzLm1heC54JiZ0Lm1heC55Pj10aGlzLm1pbi55JiZ0Lm1pbi55PD10aGlzLm1heC55JiZ0Lm1heC56Pj10aGlzLm1pbi56JiZ0Lm1pbi56PD10aGlzLm1heC56fWludGVyc2VjdHNTcGhlcmUodCl7cmV0dXJuIHRoaXMuY2xhbXBQb2ludCh0LmNlbnRlcixSdCksUnQuZGlzdGFuY2VUb1NxdWFyZWQodC5jZW50ZXIpPD10LnJhZGl1cyp0LnJhZGl1c31pbnRlcnNlY3RzUGxhbmUodCl7bGV0IGUscztyZXR1cm4gdC5ub3JtYWwueD4wPyhlPXQubm9ybWFsLngqdGhpcy5taW4ueCxzPXQubm9ybWFsLngqdGhpcy5tYXgueCk6KGU9dC5ub3JtYWwueCp0aGlzLm1heC54LHM9dC5ub3JtYWwueCp0aGlzLm1pbi54KSx0Lm5vcm1hbC55PjA/KGUrPXQubm9ybWFsLnkqdGhpcy5taW4ueSxzKz10Lm5vcm1hbC55KnRoaXMubWF4LnkpOihlKz10Lm5vcm1hbC55KnRoaXMubWF4Lnkscys9dC5ub3JtYWwueSp0aGlzLm1pbi55KSx0Lm5vcm1hbC56PjA/KGUrPXQubm9ybWFsLnoqdGhpcy5taW4ueixzKz10Lm5vcm1hbC56KnRoaXMubWF4LnopOihlKz10Lm5vcm1hbC56KnRoaXMubWF4Lnoscys9dC5ub3JtYWwueip0aGlzLm1pbi56KSxlPD0tdC5jb25zdGFudCYmcz49LXQuY29uc3RhbnR9aW50ZXJzZWN0c1RyaWFuZ2xlKHQpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiExO3RoaXMuZ2V0Q2VudGVyKEtlKSxScy5zdWJWZWN0b3JzKHRoaXMubWF4LEtlKSxOZS5zdWJWZWN0b3JzKHQuYSxLZSksd2Uuc3ViVmVjdG9ycyh0LmIsS2UpLEFlLnN1YlZlY3RvcnModC5jLEtlKSx0ZS5zdWJWZWN0b3JzKHdlLE5lKSxlZS5zdWJWZWN0b3JzKEFlLHdlKSx1ZS5zdWJWZWN0b3JzKE5lLEFlKTtsZXQgZT1bMCwtdGUueix0ZS55LDAsLWVlLnosZWUueSwwLC11ZS56LHVlLnksdGUueiwwLC10ZS54LGVlLnosMCwtZWUueCx1ZS56LDAsLXVlLngsLXRlLnksdGUueCwwLC1lZS55LGVlLngsMCwtdWUueSx1ZS54LDBdO3JldHVybiFCbihlLE5lLHdlLEFlLFJzKXx8KGU9WzEsMCwwLDAsMSwwLDAsMCwxXSwhQm4oZSxOZSx3ZSxBZSxScykpPyExOihCcy5jcm9zc1ZlY3RvcnModGUsZWUpLGU9W0JzLngsQnMueSxCcy56XSxCbihlLE5lLHdlLEFlLFJzKSl9Y2xhbXBQb2ludCh0LGUpe3JldHVybiBlLmNvcHkodCkuY2xhbXAodGhpcy5taW4sdGhpcy5tYXgpfWRpc3RhbmNlVG9Qb2ludCh0KXtyZXR1cm4gdGhpcy5jbGFtcFBvaW50KHQsUnQpLmRpc3RhbmNlVG8odCl9Z2V0Qm91bmRpbmdTcGhlcmUodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3QubWFrZUVtcHR5KCk6KHRoaXMuZ2V0Q2VudGVyKHQuY2VudGVyKSx0LnJhZGl1cz10aGlzLmdldFNpemUoUnQpLmxlbmd0aCgpKi41KSx0fWludGVyc2VjdCh0KXtyZXR1cm4gdGhpcy5taW4ubWF4KHQubWluKSx0aGlzLm1heC5taW4odC5tYXgpLHRoaXMuaXNFbXB0eSgpJiZ0aGlzLm1ha2VFbXB0eSgpLHRoaXN9dW5pb24odCl7cmV0dXJuIHRoaXMubWluLm1pbih0Lm1pbiksdGhpcy5tYXgubWF4KHQubWF4KSx0aGlzfWFwcGx5TWF0cml4NCh0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dGhpczooR3RbMF0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQodCksR3RbMV0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQodCksR3RbMl0uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQodCksR3RbM10uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQodCksR3RbNF0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQodCksR3RbNV0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQodCksR3RbNl0uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQodCksR3RbN10uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQodCksdGhpcy5zZXRGcm9tUG9pbnRzKEd0KSx0aGlzKX10cmFuc2xhdGUodCl7cmV0dXJuIHRoaXMubWluLmFkZCh0KSx0aGlzLm1heC5hZGQodCksdGhpc31lcXVhbHModCl7cmV0dXJuIHQubWluLmVxdWFscyh0aGlzLm1pbikmJnQubWF4LmVxdWFscyh0aGlzLm1heCl9fWNvbnN0IEd0PVtuZXcgQSxuZXcgQSxuZXcgQSxuZXcgQSxuZXcgQSxuZXcgQSxuZXcgQSxuZXcgQV0sUnQ9bmV3IEEsRnM9bmV3IGh0LE5lPW5ldyBBLHdlPW5ldyBBLEFlPW5ldyBBLHRlPW5ldyBBLGVlPW5ldyBBLHVlPW5ldyBBLEtlPW5ldyBBLFJzPW5ldyBBLEJzPW5ldyBBLGxlPW5ldyBBO2Z1bmN0aW9uIEJuKHIsdCxlLHMsbil7Zm9yKGxldCBpPTAsbz1yLmxlbmd0aC0zO2k8PW87aSs9Myl7bGUuZnJvbUFycmF5KHIsaSk7Y29uc3QgYT1uLngqTWF0aC5hYnMobGUueCkrbi55Kk1hdGguYWJzKGxlLnkpK24ueipNYXRoLmFicyhsZS56KSxjPXQuZG90KGxlKSx1PWUuZG90KGxlKSxoPXMuZG90KGxlKTtpZihNYXRoLm1heCgtTWF0aC5tYXgoYyx1LGgpLE1hdGgubWluKGMsdSxoKSk+YSlyZXR1cm4hMX1yZXR1cm4hMH1jb25zdCBhYT1uZXcgaHQsdHM9bmV3IEEsSW49bmV3IEE7Y2xhc3MgY3J7Y29uc3RydWN0b3IodD1uZXcgQSxlPS0xKXt0aGlzLmlzU3BoZXJlPSEwLHRoaXMuY2VudGVyPXQsdGhpcy5yYWRpdXM9ZX1zZXQodCxlKXtyZXR1cm4gdGhpcy5jZW50ZXIuY29weSh0KSx0aGlzLnJhZGl1cz1lLHRoaXN9c2V0RnJvbVBvaW50cyh0LGUpe2NvbnN0IHM9dGhpcy5jZW50ZXI7ZSE9PXZvaWQgMD9zLmNvcHkoZSk6YWEuc2V0RnJvbVBvaW50cyh0KS5nZXRDZW50ZXIocyk7bGV0IG49MDtmb3IobGV0IGk9MCxvPXQubGVuZ3RoO2k8bztpKyspbj1NYXRoLm1heChuLHMuZGlzdGFuY2VUb1NxdWFyZWQodFtpXSkpO3JldHVybiB0aGlzLnJhZGl1cz1NYXRoLnNxcnQobiksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLmNlbnRlci5jb3B5KHQuY2VudGVyKSx0aGlzLnJhZGl1cz10LnJhZGl1cyx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5yYWRpdXM8MH1tYWtlRW1wdHkoKXtyZXR1cm4gdGhpcy5jZW50ZXIuc2V0KDAsMCwwKSx0aGlzLnJhZGl1cz0tMSx0aGlzfWNvbnRhaW5zUG9pbnQodCl7cmV0dXJuIHQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpPD10aGlzLnJhZGl1cyp0aGlzLnJhZGl1c31kaXN0YW5jZVRvUG9pbnQodCl7cmV0dXJuIHQuZGlzdGFuY2VUbyh0aGlzLmNlbnRlciktdGhpcy5yYWRpdXN9aW50ZXJzZWN0c1NwaGVyZSh0KXtjb25zdCBlPXRoaXMucmFkaXVzK3QucmFkaXVzO3JldHVybiB0LmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcik8PWUqZX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiB0LmludGVyc2VjdHNTcGhlcmUodGhpcyl9aW50ZXJzZWN0c1BsYW5lKHQpe3JldHVybiBNYXRoLmFicyh0LmRpc3RhbmNlVG9Qb2ludCh0aGlzLmNlbnRlcikpPD10aGlzLnJhZGl1c31jbGFtcFBvaW50KHQsZSl7Y29uc3Qgcz10aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0KTtyZXR1cm4gZS5jb3B5KHQpLHM+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMmJihlLnN1Yih0aGlzLmNlbnRlcikubm9ybWFsaXplKCksZS5tdWx0aXBseVNjYWxhcih0aGlzLnJhZGl1cykuYWRkKHRoaXMuY2VudGVyKSksZX1nZXRCb3VuZGluZ0JveCh0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/KHQubWFrZUVtcHR5KCksdCk6KHQuc2V0KHRoaXMuY2VudGVyLHRoaXMuY2VudGVyKSx0LmV4cGFuZEJ5U2NhbGFyKHRoaXMucmFkaXVzKSx0KX1hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCh0KSx0aGlzLnJhZGl1cz10aGlzLnJhZGl1cyp0LmdldE1heFNjYWxlT25BeGlzKCksdGhpc310cmFuc2xhdGUodCl7cmV0dXJuIHRoaXMuY2VudGVyLmFkZCh0KSx0aGlzfWV4cGFuZEJ5UG9pbnQodCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuY2VudGVyLmNvcHkodCksdGhpcy5yYWRpdXM9MCx0aGlzO3RzLnN1YlZlY3RvcnModCx0aGlzLmNlbnRlcik7Y29uc3QgZT10cy5sZW5ndGhTcSgpO2lmKGU+dGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMpe2NvbnN0IHM9TWF0aC5zcXJ0KGUpLG49KHMtdGhpcy5yYWRpdXMpKi41O3RoaXMuY2VudGVyLmFkZFNjYWxlZFZlY3Rvcih0cyxuL3MpLHRoaXMucmFkaXVzKz1ufXJldHVybiB0aGlzfXVuaW9uKHQpe3JldHVybiB0LmlzRW1wdHkoKT90aGlzOnRoaXMuaXNFbXB0eSgpPyh0aGlzLmNvcHkodCksdGhpcyk6KHRoaXMuY2VudGVyLmVxdWFscyh0LmNlbnRlcik9PT0hMD90aGlzLnJhZGl1cz1NYXRoLm1heCh0aGlzLnJhZGl1cyx0LnJhZGl1cyk6KEluLnN1YlZlY3RvcnModC5jZW50ZXIsdGhpcy5jZW50ZXIpLnNldExlbmd0aCh0LnJhZGl1cyksdGhpcy5leHBhbmRCeVBvaW50KHRzLmNvcHkodC5jZW50ZXIpLmFkZChJbikpLHRoaXMuZXhwYW5kQnlQb2ludCh0cy5jb3B5KHQuY2VudGVyKS5zdWIoSW4pKSksdGhpcyl9ZXF1YWxzKHQpe3JldHVybiB0LmNlbnRlci5lcXVhbHModGhpcy5jZW50ZXIpJiZ0LnJhZGl1cz09PXRoaXMucmFkaXVzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX19Y2xhc3MgbnR7Y29uc3RydWN0b3IodCxlLHMsbixpLG8sYSxjLHUsaCxsLGQsZixwLG0sZyl7bnQucHJvdG90eXBlLmlzTWF0cml4ND0hMCx0aGlzLmVsZW1lbnRzPVsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXSx0IT09dm9pZCAwJiZ0aGlzLnNldCh0LGUscyxuLGksbyxhLGMsdSxoLGwsZCxmLHAsbSxnKX1zZXQodCxlLHMsbixpLG8sYSxjLHUsaCxsLGQsZixwLG0sZyl7Y29uc3QgeT10aGlzLmVsZW1lbnRzO3JldHVybiB5WzBdPXQseVs0XT1lLHlbOF09cyx5WzEyXT1uLHlbMV09aSx5WzVdPW8seVs5XT1hLHlbMTNdPWMseVsyXT11LHlbNl09aCx5WzEwXT1sLHlbMTRdPWQseVszXT1mLHlbN109cCx5WzExXT1tLHlbMTVdPWcsdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLnNldCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyBudCgpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKX1jb3B5KHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxzPXQuZWxlbWVudHM7cmV0dXJuIGVbMF09c1swXSxlWzFdPXNbMV0sZVsyXT1zWzJdLGVbM109c1szXSxlWzRdPXNbNF0sZVs1XT1zWzVdLGVbNl09c1s2XSxlWzddPXNbN10sZVs4XT1zWzhdLGVbOV09c1s5XSxlWzEwXT1zWzEwXSxlWzExXT1zWzExXSxlWzEyXT1zWzEyXSxlWzEzXT1zWzEzXSxlWzE0XT1zWzE0XSxlWzE1XT1zWzE1XSx0aGlzfWNvcHlQb3NpdGlvbih0KXtjb25zdCBlPXRoaXMuZWxlbWVudHMscz10LmVsZW1lbnRzO3JldHVybiBlWzEyXT1zWzEyXSxlWzEzXT1zWzEzXSxlWzE0XT1zWzE0XSx0aGlzfXNldEZyb21NYXRyaXgzKHQpe2NvbnN0IGU9dC5lbGVtZW50cztyZXR1cm4gdGhpcy5zZXQoZVswXSxlWzNdLGVbNl0sMCxlWzFdLGVbNF0sZVs3XSwwLGVbMl0sZVs1XSxlWzhdLDAsMCwwLDAsMSksdGhpc31leHRyYWN0QmFzaXModCxlLHMpe3JldHVybiB0LnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywwKSxlLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywxKSxzLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywyKSx0aGlzfW1ha2VCYXNpcyh0LGUscyl7cmV0dXJuIHRoaXMuc2V0KHQueCxlLngscy54LDAsdC55LGUueSxzLnksMCx0LnosZS56LHMueiwwLDAsMCwwLDEpLHRoaXN9ZXh0cmFjdFJvdGF0aW9uKHQpe2NvbnN0IGU9dGhpcy5lbGVtZW50cyxzPXQuZWxlbWVudHMsbj0xL01lLnNldEZyb21NYXRyaXhDb2x1bW4odCwwKS5sZW5ndGgoKSxpPTEvTWUuc2V0RnJvbU1hdHJpeENvbHVtbih0LDEpLmxlbmd0aCgpLG89MS9NZS5zZXRGcm9tTWF0cml4Q29sdW1uKHQsMikubGVuZ3RoKCk7cmV0dXJuIGVbMF09c1swXSpuLGVbMV09c1sxXSpuLGVbMl09c1syXSpuLGVbM109MCxlWzRdPXNbNF0qaSxlWzVdPXNbNV0qaSxlWzZdPXNbNl0qaSxlWzddPTAsZVs4XT1zWzhdKm8sZVs5XT1zWzldKm8sZVsxMF09c1sxMF0qbyxlWzExXT0wLGVbMTJdPTAsZVsxM109MCxlWzE0XT0wLGVbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tRXVsZXIodCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLHM9dC54LG49dC55LGk9dC56LG89TWF0aC5jb3MocyksYT1NYXRoLnNpbihzKSxjPU1hdGguY29zKG4pLHU9TWF0aC5zaW4obiksaD1NYXRoLmNvcyhpKSxsPU1hdGguc2luKGkpO2lmKHQub3JkZXI9PT0iWFlaIil7Y29uc3QgZD1vKmgsZj1vKmwscD1hKmgsbT1hKmw7ZVswXT1jKmgsZVs0XT0tYypsLGVbOF09dSxlWzFdPWYrcCp1LGVbNV09ZC1tKnUsZVs5XT0tYSpjLGVbMl09bS1kKnUsZVs2XT1wK2YqdSxlWzEwXT1vKmN9ZWxzZSBpZih0Lm9yZGVyPT09IllYWiIpe2NvbnN0IGQ9YypoLGY9YypsLHA9dSpoLG09dSpsO2VbMF09ZCttKmEsZVs0XT1wKmEtZixlWzhdPW8qdSxlWzFdPW8qbCxlWzVdPW8qaCxlWzldPS1hLGVbMl09ZiphLXAsZVs2XT1tK2QqYSxlWzEwXT1vKmN9ZWxzZSBpZih0Lm9yZGVyPT09IlpYWSIpe2NvbnN0IGQ9YypoLGY9YypsLHA9dSpoLG09dSpsO2VbMF09ZC1tKmEsZVs0XT0tbypsLGVbOF09cCtmKmEsZVsxXT1mK3AqYSxlWzVdPW8qaCxlWzldPW0tZCphLGVbMl09LW8qdSxlWzZdPWEsZVsxMF09bypjfWVsc2UgaWYodC5vcmRlcj09PSJaWVgiKXtjb25zdCBkPW8qaCxmPW8qbCxwPWEqaCxtPWEqbDtlWzBdPWMqaCxlWzRdPXAqdS1mLGVbOF09ZCp1K20sZVsxXT1jKmwsZVs1XT1tKnUrZCxlWzldPWYqdS1wLGVbMl09LXUsZVs2XT1hKmMsZVsxMF09bypjfWVsc2UgaWYodC5vcmRlcj09PSJZWlgiKXtjb25zdCBkPW8qYyxmPW8qdSxwPWEqYyxtPWEqdTtlWzBdPWMqaCxlWzRdPW0tZCpsLGVbOF09cCpsK2YsZVsxXT1sLGVbNV09bypoLGVbOV09LWEqaCxlWzJdPS11KmgsZVs2XT1mKmwrcCxlWzEwXT1kLW0qbH1lbHNlIGlmKHQub3JkZXI9PT0iWFpZIil7Y29uc3QgZD1vKmMsZj1vKnUscD1hKmMsbT1hKnU7ZVswXT1jKmgsZVs0XT0tbCxlWzhdPXUqaCxlWzFdPWQqbCttLGVbNV09bypoLGVbOV09ZipsLXAsZVsyXT1wKmwtZixlWzZdPWEqaCxlWzEwXT1tKmwrZH1yZXR1cm4gZVszXT0wLGVbN109MCxlWzExXT0wLGVbMTJdPTAsZVsxM109MCxlWzE0XT0wLGVbMTVdPTEsdGhpc31tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbih0KXtyZXR1cm4gdGhpcy5jb21wb3NlKGNhLHQsaGEpfWxvb2tBdCh0LGUscyl7Y29uc3Qgbj10aGlzLmVsZW1lbnRzO3JldHVybiB5dC5zdWJWZWN0b3JzKHQsZSkseXQubGVuZ3RoU3EoKT09PTAmJih5dC56PTEpLHl0Lm5vcm1hbGl6ZSgpLHNlLmNyb3NzVmVjdG9ycyhzLHl0KSxzZS5sZW5ndGhTcSgpPT09MCYmKE1hdGguYWJzKHMueik9PT0xP3l0LngrPTFlLTQ6eXQueis9MWUtNCx5dC5ub3JtYWxpemUoKSxzZS5jcm9zc1ZlY3RvcnMocyx5dCkpLHNlLm5vcm1hbGl6ZSgpLElzLmNyb3NzVmVjdG9ycyh5dCxzZSksblswXT1zZS54LG5bNF09SXMueCxuWzhdPXl0LngsblsxXT1zZS55LG5bNV09SXMueSxuWzldPXl0LnksblsyXT1zZS56LG5bNl09SXMueixuWzEwXT15dC56LHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLHQpfXByZW11bHRpcGx5KHQpe3JldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModCx0aGlzKX1tdWx0aXBseU1hdHJpY2VzKHQsZSl7Y29uc3Qgcz10LmVsZW1lbnRzLG49ZS5lbGVtZW50cyxpPXRoaXMuZWxlbWVudHMsbz1zWzBdLGE9c1s0XSxjPXNbOF0sdT1zWzEyXSxoPXNbMV0sbD1zWzVdLGQ9c1s5XSxmPXNbMTNdLHA9c1syXSxtPXNbNl0sZz1zWzEwXSx5PXNbMTRdLFQ9c1szXSx3PXNbN10sTT1zWzExXSxOPXNbMTVdLF89blswXSxTPW5bNF0sRT1uWzhdLEY9blsxMl0sUj1uWzFdLEk9bls1XSxCPW5bOV0sUD1uWzEzXSxMPW5bMl0sVj1uWzZdLEc9blsxMF0sTnQ9blsxNF0sSHQ9blszXSxxdD1uWzddLE5uPW5bMTFdLHduPW5bMTVdO3JldHVybiBpWzBdPW8qXythKlIrYypMK3UqSHQsaVs0XT1vKlMrYSpJK2MqVit1KnF0LGlbOF09bypFK2EqQitjKkcrdSpObixpWzEyXT1vKkYrYSpQK2MqTnQrdSp3bixpWzFdPWgqXytsKlIrZCpMK2YqSHQsaVs1XT1oKlMrbCpJK2QqVitmKnF0LGlbOV09aCpFK2wqQitkKkcrZipObixpWzEzXT1oKkYrbCpQK2QqTnQrZip3bixpWzJdPXAqXyttKlIrZypMK3kqSHQsaVs2XT1wKlMrbSpJK2cqVit5KnF0LGlbMTBdPXAqRSttKkIrZypHK3kqTm4saVsxNF09cCpGK20qUCtnKk50K3kqd24saVszXT1UKl8rdypSK00qTCtOKkh0LGlbN109VCpTK3cqSStNKlYrTipxdCxpWzExXT1UKkUrdypCK00qRytOKk5uLGlbMTVdPVQqRit3KlArTSpOdCtOKnduLHRoaXN9bXVsdGlwbHlTY2FsYXIodCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzO3JldHVybiBlWzBdKj10LGVbNF0qPXQsZVs4XSo9dCxlWzEyXSo9dCxlWzFdKj10LGVbNV0qPXQsZVs5XSo9dCxlWzEzXSo9dCxlWzJdKj10LGVbNl0qPXQsZVsxMF0qPXQsZVsxNF0qPXQsZVszXSo9dCxlWzddKj10LGVbMTFdKj10LGVbMTVdKj10LHRoaXN9ZGV0ZXJtaW5hbnQoKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsZT10WzBdLHM9dFs0XSxuPXRbOF0saT10WzEyXSxvPXRbMV0sYT10WzVdLGM9dFs5XSx1PXRbMTNdLGg9dFsyXSxsPXRbNl0sZD10WzEwXSxmPXRbMTRdLHA9dFszXSxtPXRbN10sZz10WzExXSx5PXRbMTVdO3JldHVybiBwKigraSpjKmwtbip1KmwtaSphKmQrcyp1KmQrbiphKmYtcypjKmYpK20qKCtlKmMqZi1lKnUqZCtpKm8qZC1uKm8qZituKnUqaC1pKmMqaCkrZyooK2UqdSpsLWUqYSpmLWkqbypsK3MqbypmK2kqYSpoLXMqdSpoKSt5KigtbiphKmgtZSpjKmwrZSphKmQrbipvKmwtcypvKmQrcypjKmgpfXRyYW5zcG9zZSgpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cztsZXQgZTtyZXR1cm4gZT10WzFdLHRbMV09dFs0XSx0WzRdPWUsZT10WzJdLHRbMl09dFs4XSx0WzhdPWUsZT10WzZdLHRbNl09dFs5XSx0WzldPWUsZT10WzNdLHRbM109dFsxMl0sdFsxMl09ZSxlPXRbN10sdFs3XT10WzEzXSx0WzEzXT1lLGU9dFsxMV0sdFsxMV09dFsxNF0sdFsxNF09ZSx0aGlzfXNldFBvc2l0aW9uKHQsZSxzKXtjb25zdCBuPXRoaXMuZWxlbWVudHM7cmV0dXJuIHQuaXNWZWN0b3IzPyhuWzEyXT10LngsblsxM109dC55LG5bMTRdPXQueik6KG5bMTJdPXQsblsxM109ZSxuWzE0XT1zKSx0aGlzfWludmVydCgpe2NvbnN0IHQ9dGhpcy5lbGVtZW50cyxlPXRbMF0scz10WzFdLG49dFsyXSxpPXRbM10sbz10WzRdLGE9dFs1XSxjPXRbNl0sdT10WzddLGg9dFs4XSxsPXRbOV0sZD10WzEwXSxmPXRbMTFdLHA9dFsxMl0sbT10WzEzXSxnPXRbMTRdLHk9dFsxNV0sVD1sKmcqdS1tKmQqdSttKmMqZi1hKmcqZi1sKmMqeSthKmQqeSx3PXAqZCp1LWgqZyp1LXAqYypmK28qZypmK2gqYyp5LW8qZCp5LE09aCptKnUtcCpsKnUrcCphKmYtbyptKmYtaCphKnkrbypsKnksTj1wKmwqYy1oKm0qYy1wKmEqZCtvKm0qZCtoKmEqZy1vKmwqZyxfPWUqVCtzKncrbipNK2kqTjtpZihfPT09MClyZXR1cm4gdGhpcy5zZXQoMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCk7Y29uc3QgUz0xL187cmV0dXJuIHRbMF09VCpTLHRbMV09KG0qZCppLWwqZyppLW0qbipmK3MqZypmK2wqbip5LXMqZCp5KSpTLHRbMl09KGEqZyppLW0qYyppK20qbip1LXMqZyp1LWEqbip5K3MqYyp5KSpTLHRbM109KGwqYyppLWEqZCppLWwqbip1K3MqZCp1K2EqbipmLXMqYypmKSpTLHRbNF09dypTLHRbNV09KGgqZyppLXAqZCppK3AqbipmLWUqZypmLWgqbip5K2UqZCp5KSpTLHRbNl09KHAqYyppLW8qZyppLXAqbip1K2UqZyp1K28qbip5LWUqYyp5KSpTLHRbN109KG8qZCppLWgqYyppK2gqbip1LWUqZCp1LW8qbipmK2UqYypmKSpTLHRbOF09TSpTLHRbOV09KHAqbCppLWgqbSppLXAqcypmK2UqbSpmK2gqcyp5LWUqbCp5KSpTLHRbMTBdPShvKm0qaS1wKmEqaStwKnMqdS1lKm0qdS1vKnMqeStlKmEqeSkqUyx0WzExXT0oaCphKmktbypsKmktaCpzKnUrZSpsKnUrbypzKmYtZSphKmYpKlMsdFsxMl09TipTLHRbMTNdPShoKm0qbi1wKmwqbitwKnMqZC1lKm0qZC1oKnMqZytlKmwqZykqUyx0WzE0XT0ocCphKm4tbyptKm4tcCpzKmMrZSptKmMrbypzKmctZSphKmcpKlMsdFsxNV09KG8qbCpuLWgqYSpuK2gqcypjLWUqbCpjLW8qcypkK2UqYSpkKSpTLHRoaXN9c2NhbGUodCl7Y29uc3QgZT10aGlzLmVsZW1lbnRzLHM9dC54LG49dC55LGk9dC56O3JldHVybiBlWzBdKj1zLGVbNF0qPW4sZVs4XSo9aSxlWzFdKj1zLGVbNV0qPW4sZVs5XSo9aSxlWzJdKj1zLGVbNl0qPW4sZVsxMF0qPWksZVszXSo9cyxlWzddKj1uLGVbMTFdKj1pLHRoaXN9Z2V0TWF4U2NhbGVPbkF4aXMoKXtjb25zdCB0PXRoaXMuZWxlbWVudHMsZT10WzBdKnRbMF0rdFsxXSp0WzFdK3RbMl0qdFsyXSxzPXRbNF0qdFs0XSt0WzVdKnRbNV0rdFs2XSp0WzZdLG49dFs4XSp0WzhdK3RbOV0qdFs5XSt0WzEwXSp0WzEwXTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KGUscyxuKSl9bWFrZVRyYW5zbGF0aW9uKHQsZSxzKXtyZXR1cm4gdC5pc1ZlY3RvcjM/dGhpcy5zZXQoMSwwLDAsdC54LDAsMSwwLHQueSwwLDAsMSx0LnosMCwwLDAsMSk6dGhpcy5zZXQoMSwwLDAsdCwwLDEsMCxlLDAsMCwxLHMsMCwwLDAsMSksdGhpc31tYWtlUm90YXRpb25YKHQpe2NvbnN0IGU9TWF0aC5jb3ModCkscz1NYXRoLnNpbih0KTtyZXR1cm4gdGhpcy5zZXQoMSwwLDAsMCwwLGUsLXMsMCwwLHMsZSwwLDAsMCwwLDEpLHRoaXN9bWFrZVJvdGF0aW9uWSh0KXtjb25zdCBlPU1hdGguY29zKHQpLHM9TWF0aC5zaW4odCk7cmV0dXJuIHRoaXMuc2V0KGUsMCxzLDAsMCwxLDAsMCwtcywwLGUsMCwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvbloodCl7Y29uc3QgZT1NYXRoLmNvcyh0KSxzPU1hdGguc2luKHQpO3JldHVybiB0aGlzLnNldChlLC1zLDAsMCxzLGUsMCwwLDAsMCwxLDAsMCwwLDAsMSksdGhpc31tYWtlUm90YXRpb25BeGlzKHQsZSl7Y29uc3Qgcz1NYXRoLmNvcyhlKSxuPU1hdGguc2luKGUpLGk9MS1zLG89dC54LGE9dC55LGM9dC56LHU9aSpvLGg9aSphO3JldHVybiB0aGlzLnNldCh1Km8rcyx1KmEtbipjLHUqYytuKmEsMCx1KmErbipjLGgqYStzLGgqYy1uKm8sMCx1KmMtbiphLGgqYytuKm8saSpjKmMrcywwLDAsMCwwLDEpLHRoaXN9bWFrZVNjYWxlKHQsZSxzKXtyZXR1cm4gdGhpcy5zZXQodCwwLDAsMCwwLGUsMCwwLDAsMCxzLDAsMCwwLDAsMSksdGhpc31tYWtlU2hlYXIodCxlLHMsbixpLG8pe3JldHVybiB0aGlzLnNldCgxLHMsaSwwLHQsMSxvLDAsZSxuLDEsMCwwLDAsMCwxKSx0aGlzfWNvbXBvc2UodCxlLHMpe2NvbnN0IG49dGhpcy5lbGVtZW50cyxpPWUuX3gsbz1lLl95LGE9ZS5feixjPWUuX3csdT1pK2ksaD1vK28sbD1hK2EsZD1pKnUsZj1pKmgscD1pKmwsbT1vKmgsZz1vKmwseT1hKmwsVD1jKnUsdz1jKmgsTT1jKmwsTj1zLngsXz1zLnksUz1zLno7cmV0dXJuIG5bMF09KDEtKG0reSkpKk4sblsxXT0oZitNKSpOLG5bMl09KHAtdykqTixuWzNdPTAsbls0XT0oZi1NKSpfLG5bNV09KDEtKGQreSkpKl8sbls2XT0oZytUKSpfLG5bN109MCxuWzhdPShwK3cpKlMsbls5XT0oZy1UKSpTLG5bMTBdPSgxLShkK20pKSpTLG5bMTFdPTAsblsxMl09dC54LG5bMTNdPXQueSxuWzE0XT10LnosblsxNV09MSx0aGlzfWRlY29tcG9zZSh0LGUscyl7Y29uc3Qgbj10aGlzLmVsZW1lbnRzO2xldCBpPU1lLnNldChuWzBdLG5bMV0sblsyXSkubGVuZ3RoKCk7Y29uc3Qgbz1NZS5zZXQobls0XSxuWzVdLG5bNl0pLmxlbmd0aCgpLGE9TWUuc2V0KG5bOF0sbls5XSxuWzEwXSkubGVuZ3RoKCk7dGhpcy5kZXRlcm1pbmFudCgpPDAmJihpPS1pKSx0Lng9blsxMl0sdC55PW5bMTNdLHQuej1uWzE0XSxCdC5jb3B5KHRoaXMpO2NvbnN0IHU9MS9pLGg9MS9vLGw9MS9hO3JldHVybiBCdC5lbGVtZW50c1swXSo9dSxCdC5lbGVtZW50c1sxXSo9dSxCdC5lbGVtZW50c1syXSo9dSxCdC5lbGVtZW50c1s0XSo9aCxCdC5lbGVtZW50c1s1XSo9aCxCdC5lbGVtZW50c1s2XSo9aCxCdC5lbGVtZW50c1s4XSo9bCxCdC5lbGVtZW50c1s5XSo9bCxCdC5lbGVtZW50c1sxMF0qPWwsZS5zZXRGcm9tUm90YXRpb25NYXRyaXgoQnQpLHMueD1pLHMueT1vLHMuej1hLHRoaXN9bWFrZVBlcnNwZWN0aXZlKHQsZSxzLG4saSxvLGE9WWUpe2NvbnN0IGM9dGhpcy5lbGVtZW50cyx1PTIqaS8oZS10KSxoPTIqaS8ocy1uKSxsPShlK3QpLyhlLXQpLGQ9KHMrbikvKHMtbik7bGV0IGYscDtpZihhPT09WWUpZj0tKG8raSkvKG8taSkscD0tMipvKmkvKG8taSk7ZWxzZSBpZihhPT09em4pZj0tby8oby1pKSxwPS1vKmkvKG8taSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLk1hdHJpeDQubWFrZVBlcnNwZWN0aXZlKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIrYSk7cmV0dXJuIGNbMF09dSxjWzRdPTAsY1s4XT1sLGNbMTJdPTAsY1sxXT0wLGNbNV09aCxjWzldPWQsY1sxM109MCxjWzJdPTAsY1s2XT0wLGNbMTBdPWYsY1sxNF09cCxjWzNdPTAsY1s3XT0wLGNbMTFdPS0xLGNbMTVdPTAsdGhpc31tYWtlT3J0aG9ncmFwaGljKHQsZSxzLG4saSxvLGE9WWUpe2NvbnN0IGM9dGhpcy5lbGVtZW50cyx1PTEvKGUtdCksaD0xLyhzLW4pLGw9MS8oby1pKSxkPShlK3QpKnUsZj0ocytuKSpoO2xldCBwLG07aWYoYT09PVllKXA9KG8raSkqbCxtPS0yKmw7ZWxzZSBpZihhPT09em4pcD1pKmwsbT0tMSpsO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5NYXRyaXg0Lm1ha2VPcnRob2dyYXBoaWMoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogIithKTtyZXR1cm4gY1swXT0yKnUsY1s0XT0wLGNbOF09MCxjWzEyXT0tZCxjWzFdPTAsY1s1XT0yKmgsY1s5XT0wLGNbMTNdPS1mLGNbMl09MCxjWzZdPTAsY1sxMF09bSxjWzE0XT0tcCxjWzNdPTAsY1s3XT0wLGNbMTFdPTAsY1sxNV09MSx0aGlzfWVxdWFscyh0KXtjb25zdCBlPXRoaXMuZWxlbWVudHMscz10LmVsZW1lbnRzO2ZvcihsZXQgbj0wO248MTY7bisrKWlmKGVbbl0hPT1zW25dKXJldHVybiExO3JldHVybiEwfWZyb21BcnJheSh0LGU9MCl7Zm9yKGxldCBzPTA7czwxNjtzKyspdGhpcy5lbGVtZW50c1tzXT10W3MrZV07cmV0dXJuIHRoaXN9dG9BcnJheSh0PVtdLGU9MCl7Y29uc3Qgcz10aGlzLmVsZW1lbnRzO3JldHVybiB0W2VdPXNbMF0sdFtlKzFdPXNbMV0sdFtlKzJdPXNbMl0sdFtlKzNdPXNbM10sdFtlKzRdPXNbNF0sdFtlKzVdPXNbNV0sdFtlKzZdPXNbNl0sdFtlKzddPXNbN10sdFtlKzhdPXNbOF0sdFtlKzldPXNbOV0sdFtlKzEwXT1zWzEwXSx0W2UrMTFdPXNbMTFdLHRbZSsxMl09c1sxMl0sdFtlKzEzXT1zWzEzXSx0W2UrMTRdPXNbMTRdLHRbZSsxNV09c1sxNV0sdH19Y29uc3QgTWU9bmV3IEEsQnQ9bmV3IG50LGNhPW5ldyBBKDAsMCwwKSxoYT1uZXcgQSgxLDEsMSksc2U9bmV3IEEsSXM9bmV3IEEseXQ9bmV3IEEsaHI9bmV3IG50LHVyPW5ldyBRZTtjbGFzcyB2c3tjb25zdHJ1Y3Rvcih0PTAsZT0wLHM9MCxuPXZzLkRFRkFVTFRfT1JERVIpe3RoaXMuaXNFdWxlcj0hMCx0aGlzLl94PXQsdGhpcy5feT1lLHRoaXMuX3o9cyx0aGlzLl9vcmRlcj1ufWdldCB4KCl7cmV0dXJuIHRoaXMuX3h9c2V0IHgodCl7dGhpcy5feD10LHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKX1nZXQgeSgpe3JldHVybiB0aGlzLl95fXNldCB5KHQpe3RoaXMuX3k9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9Z2V0IHooKXtyZXR1cm4gdGhpcy5fen1zZXQgeih0KXt0aGlzLl96PXQsdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpfWdldCBvcmRlcigpe3JldHVybiB0aGlzLl9vcmRlcn1zZXQgb3JkZXIodCl7dGhpcy5fb3JkZXI9dCx0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCl9c2V0KHQsZSxzLG49dGhpcy5fb3JkZXIpe3JldHVybiB0aGlzLl94PXQsdGhpcy5feT1lLHRoaXMuX3o9cyx0aGlzLl9vcmRlcj1uLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsdGhpcy5feSx0aGlzLl96LHRoaXMuX29yZGVyKX1jb3B5KHQpe3JldHVybiB0aGlzLl94PXQuX3gsdGhpcy5feT10Ll95LHRoaXMuX3o9dC5feix0aGlzLl9vcmRlcj10Ll9vcmRlcix0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zZXRGcm9tUm90YXRpb25NYXRyaXgodCxlPXRoaXMuX29yZGVyLHM9ITApe2NvbnN0IG49dC5lbGVtZW50cyxpPW5bMF0sbz1uWzRdLGE9bls4XSxjPW5bMV0sdT1uWzVdLGg9bls5XSxsPW5bMl0sZD1uWzZdLGY9blsxMF07c3dpdGNoKGUpe2Nhc2UiWFlaIjp0aGlzLl95PU1hdGguYXNpbihhdChhLC0xLDEpKSxNYXRoLmFicyhhKTwuOTk5OTk5OT8odGhpcy5feD1NYXRoLmF0YW4yKC1oLGYpLHRoaXMuX3o9TWF0aC5hdGFuMigtbyxpKSk6KHRoaXMuX3g9TWF0aC5hdGFuMihkLHUpLHRoaXMuX3o9MCk7YnJlYWs7Y2FzZSJZWFoiOnRoaXMuX3g9TWF0aC5hc2luKC1hdChoLC0xLDEpKSxNYXRoLmFicyhoKTwuOTk5OTk5OT8odGhpcy5feT1NYXRoLmF0YW4yKGEsZiksdGhpcy5fej1NYXRoLmF0YW4yKGMsdSkpOih0aGlzLl95PU1hdGguYXRhbjIoLWwsaSksdGhpcy5fej0wKTticmVhaztjYXNlIlpYWSI6dGhpcy5feD1NYXRoLmFzaW4oYXQoZCwtMSwxKSksTWF0aC5hYnMoZCk8Ljk5OTk5OTk/KHRoaXMuX3k9TWF0aC5hdGFuMigtbCxmKSx0aGlzLl96PU1hdGguYXRhbjIoLW8sdSkpOih0aGlzLl95PTAsdGhpcy5fej1NYXRoLmF0YW4yKGMsaSkpO2JyZWFrO2Nhc2UiWllYIjp0aGlzLl95PU1hdGguYXNpbigtYXQobCwtMSwxKSksTWF0aC5hYnMobCk8Ljk5OTk5OTk/KHRoaXMuX3g9TWF0aC5hdGFuMihkLGYpLHRoaXMuX3o9TWF0aC5hdGFuMihjLGkpKToodGhpcy5feD0wLHRoaXMuX3o9TWF0aC5hdGFuMigtbyx1KSk7YnJlYWs7Y2FzZSJZWlgiOnRoaXMuX3o9TWF0aC5hc2luKGF0KGMsLTEsMSkpLE1hdGguYWJzKGMpPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIoLWgsdSksdGhpcy5feT1NYXRoLmF0YW4yKC1sLGkpKToodGhpcy5feD0wLHRoaXMuX3k9TWF0aC5hdGFuMihhLGYpKTticmVhaztjYXNlIlhaWSI6dGhpcy5fej1NYXRoLmFzaW4oLWF0KG8sLTEsMSkpLE1hdGguYWJzKG8pPC45OTk5OTk5Pyh0aGlzLl94PU1hdGguYXRhbjIoZCx1KSx0aGlzLl95PU1hdGguYXRhbjIoYSxpKSk6KHRoaXMuX3g9TWF0aC5hdGFuMigtaCxmKSx0aGlzLl95PTApO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKCJUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIrZSl9cmV0dXJuIHRoaXMuX29yZGVyPWUscz09PSEwJiZ0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksdGhpc31zZXRGcm9tUXVhdGVybmlvbih0LGUscyl7cmV0dXJuIGhyLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpLHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KGhyLGUscyl9c2V0RnJvbVZlY3RvcjModCxlPXRoaXMuX29yZGVyKXtyZXR1cm4gdGhpcy5zZXQodC54LHQueSx0LnosZSl9cmVvcmRlcih0KXtyZXR1cm4gdXIuc2V0RnJvbUV1bGVyKHRoaXMpLHRoaXMuc2V0RnJvbVF1YXRlcm5pb24odXIsdCl9ZXF1YWxzKHQpe3JldHVybiB0Ll94PT09dGhpcy5feCYmdC5feT09PXRoaXMuX3kmJnQuX3o9PT10aGlzLl96JiZ0Ll9vcmRlcj09PXRoaXMuX29yZGVyfWZyb21BcnJheSh0KXtyZXR1cm4gdGhpcy5feD10WzBdLHRoaXMuX3k9dFsxXSx0aGlzLl96PXRbMl0sdFszXSE9PXZvaWQgMCYmKHRoaXMuX29yZGVyPXRbM10pLHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSx0aGlzfXRvQXJyYXkodD1bXSxlPTApe3JldHVybiB0W2VdPXRoaXMuX3gsdFtlKzFdPXRoaXMuX3ksdFtlKzJdPXRoaXMuX3osdFtlKzNdPXRoaXMuX29yZGVyLHR9X29uQ2hhbmdlKHQpe3JldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrPXQsdGhpc31fb25DaGFuZ2VDYWxsYmFjaygpe30qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLl94LHlpZWxkIHRoaXMuX3kseWllbGQgdGhpcy5feix5aWVsZCB0aGlzLl9vcmRlcn19dnMuREVGQVVMVF9PUkRFUj0iWFlaIjtjbGFzcyB1YXtjb25zdHJ1Y3Rvcigpe3RoaXMubWFzaz0xfXNldCh0KXt0aGlzLm1hc2s9KDE8PHR8MCk+Pj4wfWVuYWJsZSh0KXt0aGlzLm1hc2t8PTE8PHR8MH1lbmFibGVBbGwoKXt0aGlzLm1hc2s9LTF9dG9nZ2xlKHQpe3RoaXMubWFza149MTw8dHwwfWRpc2FibGUodCl7dGhpcy5tYXNrJj1+KDE8PHR8MCl9ZGlzYWJsZUFsbCgpe3RoaXMubWFzaz0wfXRlc3QodCl7cmV0dXJuKHRoaXMubWFzayZ0Lm1hc2spIT09MH1pc0VuYWJsZWQodCl7cmV0dXJuKHRoaXMubWFzayYoMTw8dHwwKSkhPT0wfX1sZXQgbGE9MDtjb25zdCBscj1uZXcgQSxTZT1uZXcgUWUsV3Q9bmV3IG50LFBzPW5ldyBBLGVzPW5ldyBBLGRhPW5ldyBBLGZhPW5ldyBRZSxkcj1uZXcgQSgxLDAsMCksZnI9bmV3IEEoMCwxLDApLHByPW5ldyBBKDAsMCwxKSxtcj17dHlwZToiYWRkZWQifSxwYT17dHlwZToicmVtb3ZlZCJ9LF9lPXt0eXBlOiJjaGlsZGFkZGVkIixjaGlsZDpudWxsfSx2bj17dHlwZToiY2hpbGRyZW1vdmVkIixjaGlsZDpudWxsfTtjbGFzcyBuZSBleHRlbmRzIFple2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmlzT2JqZWN0M0Q9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6bGErK30pLHRoaXMudXVpZD1LdCgpLHRoaXMubmFtZT0iIix0aGlzLnR5cGU9Ik9iamVjdDNEIix0aGlzLnBhcmVudD1udWxsLHRoaXMuY2hpbGRyZW49W10sdGhpcy51cD1uZS5ERUZBVUxUX1VQLmNsb25lKCk7Y29uc3QgdD1uZXcgQSxlPW5ldyB2cyxzPW5ldyBRZSxuPW5ldyBBKDEsMSwxKTtmdW5jdGlvbiBpKCl7cy5zZXRGcm9tRXVsZXIoZSwhMSl9ZnVuY3Rpb24gbygpe2Uuc2V0RnJvbVF1YXRlcm5pb24ocyx2b2lkIDAsITEpfWUuX29uQ2hhbmdlKGkpLHMuX29uQ2hhbmdlKG8pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMse3Bvc2l0aW9uOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTp0fSxyb3RhdGlvbjp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZX0scXVhdGVybmlvbjp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6c30sc2NhbGU6e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOm59LG1vZGVsVmlld01hdHJpeDp7dmFsdWU6bmV3IG50fSxub3JtYWxNYXRyaXg6e3ZhbHVlOm5ldyBDdH19KSx0aGlzLm1hdHJpeD1uZXcgbnQsdGhpcy5tYXRyaXhXb3JsZD1uZXcgbnQsdGhpcy5tYXRyaXhBdXRvVXBkYXRlPW5lLkRFRkFVTFRfTUFUUklYX0FVVE9fVVBEQVRFLHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlPW5lLkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMSx0aGlzLmxheWVycz1uZXcgdWEsdGhpcy52aXNpYmxlPSEwLHRoaXMuY2FzdFNoYWRvdz0hMSx0aGlzLnJlY2VpdmVTaGFkb3c9ITEsdGhpcy5mcnVzdHVtQ3VsbGVkPSEwLHRoaXMucmVuZGVyT3JkZXI9MCx0aGlzLmFuaW1hdGlvbnM9W10sdGhpcy51c2VyRGF0YT17fX1vbkJlZm9yZVNoYWRvdygpe31vbkFmdGVyU2hhZG93KCl7fW9uQmVmb3JlUmVuZGVyKCl7fW9uQWZ0ZXJSZW5kZXIoKXt9YXBwbHlNYXRyaXg0KHQpe3RoaXMubWF0cml4QXV0b1VwZGF0ZSYmdGhpcy51cGRhdGVNYXRyaXgoKSx0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSh0KSx0aGlzLm1hdHJpeC5kZWNvbXBvc2UodGhpcy5wb3NpdGlvbix0aGlzLnF1YXRlcm5pb24sdGhpcy5zY2FsZSl9YXBwbHlRdWF0ZXJuaW9uKHQpe3JldHVybiB0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkodCksdGhpc31zZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUodCxlKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSh0LGUpfXNldFJvdGF0aW9uRnJvbUV1bGVyKHQpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIodCwhMCl9c2V0Um90YXRpb25Gcm9tTWF0cml4KHQpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgodCl9c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0KXt0aGlzLnF1YXRlcm5pb24uY29weSh0KX1yb3RhdGVPbkF4aXModCxlKXtyZXR1cm4gU2Uuc2V0RnJvbUF4aXNBbmdsZSh0LGUpLHRoaXMucXVhdGVybmlvbi5tdWx0aXBseShTZSksdGhpc31yb3RhdGVPbldvcmxkQXhpcyh0LGUpe3JldHVybiBTZS5zZXRGcm9tQXhpc0FuZ2xlKHQsZSksdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KFNlKSx0aGlzfXJvdGF0ZVgodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKGRyLHQpfXJvdGF0ZVkodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKGZyLHQpfXJvdGF0ZVoodCl7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKHByLHQpfXRyYW5zbGF0ZU9uQXhpcyh0LGUpe3JldHVybiBsci5jb3B5KHQpLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pLHRoaXMucG9zaXRpb24uYWRkKGxyLm11bHRpcGx5U2NhbGFyKGUpKSx0aGlzfXRyYW5zbGF0ZVgodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKGRyLHQpfXRyYW5zbGF0ZVkodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKGZyLHQpfXRyYW5zbGF0ZVoodCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKHByLHQpfWxvY2FsVG9Xb3JsZCh0KXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdC5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCl9d29ybGRUb0xvY2FsKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSx0LmFwcGx5TWF0cml4NChXdC5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpKX1sb29rQXQodCxlLHMpe3QuaXNWZWN0b3IzP1BzLmNvcHkodCk6UHMuc2V0KHQsZSxzKTtjb25zdCBuPXRoaXMucGFyZW50O3RoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLGVzLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKSx0aGlzLmlzQ2FtZXJhfHx0aGlzLmlzTGlnaHQ/V3QubG9va0F0KGVzLFBzLHRoaXMudXApOld0Lmxvb2tBdChQcyxlcyx0aGlzLnVwKSx0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KFd0KSxuJiYoV3QuZXh0cmFjdFJvdGF0aW9uKG4ubWF0cml4V29ybGQpLFNlLnNldEZyb21Sb3RhdGlvbk1hdHJpeChXdCksdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KFNlLmludmVydCgpKSl9YWRkKHQpe2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKGxldCBlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0aGlzLmFkZChhcmd1bWVudHNbZV0pO3JldHVybiB0aGlzfXJldHVybiB0PT09dGhpcz8oY29uc29sZS5lcnJvcigiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuIix0KSx0aGlzKToodCYmdC5pc09iamVjdDNEPyh0LnJlbW92ZUZyb21QYXJlbnQoKSx0LnBhcmVudD10aGlzLHRoaXMuY2hpbGRyZW4ucHVzaCh0KSx0LmRpc3BhdGNoRXZlbnQobXIpLF9lLmNoaWxkPXQsdGhpcy5kaXNwYXRjaEV2ZW50KF9lKSxfZS5jaGlsZD1udWxsKTpjb25zb2xlLmVycm9yKCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuIix0KSx0aGlzKX1yZW1vdmUodCl7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IobGV0IHM9MDtzPGFyZ3VtZW50cy5sZW5ndGg7cysrKXRoaXMucmVtb3ZlKGFyZ3VtZW50c1tzXSk7cmV0dXJuIHRoaXN9Y29uc3QgZT10aGlzLmNoaWxkcmVuLmluZGV4T2YodCk7cmV0dXJuIGUhPT0tMSYmKHQucGFyZW50PW51bGwsdGhpcy5jaGlsZHJlbi5zcGxpY2UoZSwxKSx0LmRpc3BhdGNoRXZlbnQocGEpLHZuLmNoaWxkPXQsdGhpcy5kaXNwYXRjaEV2ZW50KHZuKSx2bi5jaGlsZD1udWxsKSx0aGlzfXJlbW92ZUZyb21QYXJlbnQoKXtjb25zdCB0PXRoaXMucGFyZW50O3JldHVybiB0IT09bnVsbCYmdC5yZW1vdmUodGhpcyksdGhpc31jbGVhcigpe3JldHVybiB0aGlzLnJlbW92ZSguLi50aGlzLmNoaWxkcmVuKX1hdHRhY2godCl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLFd0LmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCksdC5wYXJlbnQhPT1udWxsJiYodC5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLFd0Lm11bHRpcGx5KHQucGFyZW50Lm1hdHJpeFdvcmxkKSksdC5hcHBseU1hdHJpeDQoV3QpLHQucmVtb3ZlRnJvbVBhcmVudCgpLHQucGFyZW50PXRoaXMsdGhpcy5jaGlsZHJlbi5wdXNoKHQpLHQudXBkYXRlV29ybGRNYXRyaXgoITEsITApLHQuZGlzcGF0Y2hFdmVudChtciksX2UuY2hpbGQ9dCx0aGlzLmRpc3BhdGNoRXZlbnQoX2UpLF9lLmNoaWxkPW51bGwsdGhpc31nZXRPYmplY3RCeUlkKHQpe3JldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoImlkIix0KX1nZXRPYmplY3RCeU5hbWUodCl7cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgibmFtZSIsdCl9Z2V0T2JqZWN0QnlQcm9wZXJ0eSh0LGUpe2lmKHRoaXNbdF09PT1lKXJldHVybiB0aGlzO2ZvcihsZXQgcz0wLG49dGhpcy5jaGlsZHJlbi5sZW5ndGg7czxuO3MrKyl7Y29uc3Qgbz10aGlzLmNoaWxkcmVuW3NdLmdldE9iamVjdEJ5UHJvcGVydHkodCxlKTtpZihvIT09dm9pZCAwKXJldHVybiBvfX1nZXRPYmplY3RzQnlQcm9wZXJ0eSh0LGUscz1bXSl7dGhpc1t0XT09PWUmJnMucHVzaCh0aGlzKTtjb25zdCBuPXRoaXMuY2hpbGRyZW47Zm9yKGxldCBpPTAsbz1uLmxlbmd0aDtpPG87aSsrKW5baV0uZ2V0T2JqZWN0c0J5UHJvcGVydHkodCxlLHMpO3JldHVybiBzfWdldFdvcmxkUG9zaXRpb24odCl7cmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpLHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpfWdldFdvcmxkUXVhdGVybmlvbih0KXtyZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoZXMsdCxkYSksdH1nZXRXb3JsZFNjYWxlKHQpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSx0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShlcyxmYSx0KSx0fWdldFdvcmxkRGlyZWN0aW9uKHQpe3RoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsITEpO2NvbnN0IGU9dGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50cztyZXR1cm4gdC5zZXQoZVs4XSxlWzldLGVbMTBdKS5ub3JtYWxpemUoKX1yYXljYXN0KCl7fXRyYXZlcnNlKHQpe3QodGhpcyk7Y29uc3QgZT10aGlzLmNoaWxkcmVuO2ZvcihsZXQgcz0wLG49ZS5sZW5ndGg7czxuO3MrKyllW3NdLnRyYXZlcnNlKHQpfXRyYXZlcnNlVmlzaWJsZSh0KXtpZih0aGlzLnZpc2libGU9PT0hMSlyZXR1cm47dCh0aGlzKTtjb25zdCBlPXRoaXMuY2hpbGRyZW47Zm9yKGxldCBzPTAsbj1lLmxlbmd0aDtzPG47cysrKWVbc10udHJhdmVyc2VWaXNpYmxlKHQpfXRyYXZlcnNlQW5jZXN0b3JzKHQpe2NvbnN0IGU9dGhpcy5wYXJlbnQ7ZSE9PW51bGwmJih0KGUpLGUudHJhdmVyc2VBbmNlc3RvcnModCkpfXVwZGF0ZU1hdHJpeCgpe3RoaXMubWF0cml4LmNvbXBvc2UodGhpcy5wb3NpdGlvbix0aGlzLnF1YXRlcm5pb24sdGhpcy5zY2FsZSksdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwfXVwZGF0ZU1hdHJpeFdvcmxkKHQpe3RoaXMubWF0cml4QXV0b1VwZGF0ZSYmdGhpcy51cGRhdGVNYXRyaXgoKSwodGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlfHx0KSYmKHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlPT09ITAmJih0aGlzLnBhcmVudD09PW51bGw/dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTp0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpKSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITEsdD0hMCk7Y29uc3QgZT10aGlzLmNoaWxkcmVuO2ZvcihsZXQgcz0wLG49ZS5sZW5ndGg7czxuO3MrKyllW3NdLnVwZGF0ZU1hdHJpeFdvcmxkKHQpfXVwZGF0ZVdvcmxkTWF0cml4KHQsZSl7Y29uc3Qgcz10aGlzLnBhcmVudDtpZih0PT09ITAmJnMhPT1udWxsJiZzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCksdGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGU9PT0hMCYmKHRoaXMucGFyZW50PT09bnVsbD90aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpOnRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCx0aGlzLm1hdHJpeCkpLGU9PT0hMCl7Y29uc3Qgbj10aGlzLmNoaWxkcmVuO2ZvcihsZXQgaT0wLG89bi5sZW5ndGg7aTxvO2krKyluW2ldLnVwZGF0ZVdvcmxkTWF0cml4KCExLCEwKX19dG9KU09OKHQpe2NvbnN0IGU9dD09PXZvaWQgMHx8dHlwZW9mIHQ9PSJzdHJpbmciLHM9e307ZSYmKHQ9e2dlb21ldHJpZXM6e30sbWF0ZXJpYWxzOnt9LHRleHR1cmVzOnt9LGltYWdlczp7fSxzaGFwZXM6e30sc2tlbGV0b25zOnt9LGFuaW1hdGlvbnM6e30sbm9kZXM6e319LHMubWV0YWRhdGE9e3ZlcnNpb246NC42LHR5cGU6Ik9iamVjdCIsZ2VuZXJhdG9yOiJPYmplY3QzRC50b0pTT04ifSk7Y29uc3Qgbj17fTtuLnV1aWQ9dGhpcy51dWlkLG4udHlwZT10aGlzLnR5cGUsdGhpcy5uYW1lIT09IiImJihuLm5hbWU9dGhpcy5uYW1lKSx0aGlzLmNhc3RTaGFkb3c9PT0hMCYmKG4uY2FzdFNoYWRvdz0hMCksdGhpcy5yZWNlaXZlU2hhZG93PT09ITAmJihuLnJlY2VpdmVTaGFkb3c9ITApLHRoaXMudmlzaWJsZT09PSExJiYobi52aXNpYmxlPSExKSx0aGlzLmZydXN0dW1DdWxsZWQ9PT0hMSYmKG4uZnJ1c3R1bUN1bGxlZD0hMSksdGhpcy5yZW5kZXJPcmRlciE9PTAmJihuLnJlbmRlck9yZGVyPXRoaXMucmVuZGVyT3JkZXIpLE9iamVjdC5rZXlzKHRoaXMudXNlckRhdGEpLmxlbmd0aD4wJiYobi51c2VyRGF0YT10aGlzLnVzZXJEYXRhKSxuLmxheWVycz10aGlzLmxheWVycy5tYXNrLG4ubWF0cml4PXRoaXMubWF0cml4LnRvQXJyYXkoKSxuLnVwPXRoaXMudXAudG9BcnJheSgpLHRoaXMubWF0cml4QXV0b1VwZGF0ZT09PSExJiYobi5tYXRyaXhBdXRvVXBkYXRlPSExKSx0aGlzLmlzSW5zdGFuY2VkTWVzaCYmKG4udHlwZT0iSW5zdGFuY2VkTWVzaCIsbi5jb3VudD10aGlzLmNvdW50LG4uaW5zdGFuY2VNYXRyaXg9dGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKSx0aGlzLmluc3RhbmNlQ29sb3IhPT1udWxsJiYobi5pbnN0YW5jZUNvbG9yPXRoaXMuaW5zdGFuY2VDb2xvci50b0pTT04oKSkpLHRoaXMuaXNCYXRjaGVkTWVzaCYmKG4udHlwZT0iQmF0Y2hlZE1lc2giLG4ucGVyT2JqZWN0RnJ1c3R1bUN1bGxlZD10aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQsbi5zb3J0T2JqZWN0cz10aGlzLnNvcnRPYmplY3RzLG4uZHJhd1Jhbmdlcz10aGlzLl9kcmF3UmFuZ2VzLG4ucmVzZXJ2ZWRSYW5nZXM9dGhpcy5fcmVzZXJ2ZWRSYW5nZXMsbi52aXNpYmlsaXR5PXRoaXMuX3Zpc2liaWxpdHksbi5hY3RpdmU9dGhpcy5fYWN0aXZlLG4uYm91bmRzPXRoaXMuX2JvdW5kcy5tYXAoYT0+KHtib3hJbml0aWFsaXplZDphLmJveEluaXRpYWxpemVkLGJveE1pbjphLmJveC5taW4udG9BcnJheSgpLGJveE1heDphLmJveC5tYXgudG9BcnJheSgpLHNwaGVyZUluaXRpYWxpemVkOmEuc3BoZXJlSW5pdGlhbGl6ZWQsc3BoZXJlUmFkaXVzOmEuc3BoZXJlLnJhZGl1cyxzcGhlcmVDZW50ZXI6YS5zcGhlcmUuY2VudGVyLnRvQXJyYXkoKX0pKSxuLm1heEluc3RhbmNlQ291bnQ9dGhpcy5fbWF4SW5zdGFuY2VDb3VudCxuLm1heFZlcnRleENvdW50PXRoaXMuX21heFZlcnRleENvdW50LG4ubWF4SW5kZXhDb3VudD10aGlzLl9tYXhJbmRleENvdW50LG4uZ2VvbWV0cnlJbml0aWFsaXplZD10aGlzLl9nZW9tZXRyeUluaXRpYWxpemVkLG4uZ2VvbWV0cnlDb3VudD10aGlzLl9nZW9tZXRyeUNvdW50LG4ubWF0cmljZXNUZXh0dXJlPXRoaXMuX21hdHJpY2VzVGV4dHVyZS50b0pTT04odCksdGhpcy5fY29sb3JzVGV4dHVyZSE9PW51bGwmJihuLmNvbG9yc1RleHR1cmU9dGhpcy5fY29sb3JzVGV4dHVyZS50b0pTT04odCkpLHRoaXMuYm91bmRpbmdTcGhlcmUhPT1udWxsJiYobi5ib3VuZGluZ1NwaGVyZT17Y2VudGVyOm4uYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxyYWRpdXM6bi5ib3VuZGluZ1NwaGVyZS5yYWRpdXN9KSx0aGlzLmJvdW5kaW5nQm94IT09bnVsbCYmKG4uYm91bmRpbmdCb3g9e21pbjpuLmJvdW5kaW5nQm94Lm1pbi50b0FycmF5KCksbWF4Om4uYm91bmRpbmdCb3gubWF4LnRvQXJyYXkoKX0pKTtmdW5jdGlvbiBpKGEsYyl7cmV0dXJuIGFbYy51dWlkXT09PXZvaWQgMCYmKGFbYy51dWlkXT1jLnRvSlNPTih0KSksYy51dWlkfWlmKHRoaXMuaXNTY2VuZSl0aGlzLmJhY2tncm91bmQmJih0aGlzLmJhY2tncm91bmQuaXNDb2xvcj9uLmJhY2tncm91bmQ9dGhpcy5iYWNrZ3JvdW5kLnRvSlNPTigpOnRoaXMuYmFja2dyb3VuZC5pc1RleHR1cmUmJihuLmJhY2tncm91bmQ9dGhpcy5iYWNrZ3JvdW5kLnRvSlNPTih0KS51dWlkKSksdGhpcy5lbnZpcm9ubWVudCYmdGhpcy5lbnZpcm9ubWVudC5pc1RleHR1cmUmJnRoaXMuZW52aXJvbm1lbnQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlIT09ITAmJihuLmVudmlyb25tZW50PXRoaXMuZW52aXJvbm1lbnQudG9KU09OKHQpLnV1aWQpO2Vsc2UgaWYodGhpcy5pc01lc2h8fHRoaXMuaXNMaW5lfHx0aGlzLmlzUG9pbnRzKXtuLmdlb21ldHJ5PWkodC5nZW9tZXRyaWVzLHRoaXMuZ2VvbWV0cnkpO2NvbnN0IGE9dGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO2lmKGEhPT12b2lkIDAmJmEuc2hhcGVzIT09dm9pZCAwKXtjb25zdCBjPWEuc2hhcGVzO2lmKEFycmF5LmlzQXJyYXkoYykpZm9yKGxldCB1PTAsaD1jLmxlbmd0aDt1PGg7dSsrKXtjb25zdCBsPWNbdV07aSh0LnNoYXBlcyxsKX1lbHNlIGkodC5zaGFwZXMsYyl9fWlmKHRoaXMuaXNTa2lubmVkTWVzaCYmKG4uYmluZE1vZGU9dGhpcy5iaW5kTW9kZSxuLmJpbmRNYXRyaXg9dGhpcy5iaW5kTWF0cml4LnRvQXJyYXkoKSx0aGlzLnNrZWxldG9uIT09dm9pZCAwJiYoaSh0LnNrZWxldG9ucyx0aGlzLnNrZWxldG9uKSxuLnNrZWxldG9uPXRoaXMuc2tlbGV0b24udXVpZCkpLHRoaXMubWF0ZXJpYWwhPT12b2lkIDApaWYoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSl7Y29uc3QgYT1bXTtmb3IobGV0IGM9MCx1PXRoaXMubWF0ZXJpYWwubGVuZ3RoO2M8dTtjKyspYS5wdXNoKGkodC5tYXRlcmlhbHMsdGhpcy5tYXRlcmlhbFtjXSkpO24ubWF0ZXJpYWw9YX1lbHNlIG4ubWF0ZXJpYWw9aSh0Lm1hdGVyaWFscyx0aGlzLm1hdGVyaWFsKTtpZih0aGlzLmNoaWxkcmVuLmxlbmd0aD4wKXtuLmNoaWxkcmVuPVtdO2ZvcihsZXQgYT0wO2E8dGhpcy5jaGlsZHJlbi5sZW5ndGg7YSsrKW4uY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2FdLnRvSlNPTih0KS5vYmplY3QpfWlmKHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg+MCl7bi5hbmltYXRpb25zPVtdO2ZvcihsZXQgYT0wO2E8dGhpcy5hbmltYXRpb25zLmxlbmd0aDthKyspe2NvbnN0IGM9dGhpcy5hbmltYXRpb25zW2FdO24uYW5pbWF0aW9ucy5wdXNoKGkodC5hbmltYXRpb25zLGMpKX19aWYoZSl7Y29uc3QgYT1vKHQuZ2VvbWV0cmllcyksYz1vKHQubWF0ZXJpYWxzKSx1PW8odC50ZXh0dXJlcyksaD1vKHQuaW1hZ2VzKSxsPW8odC5zaGFwZXMpLGQ9byh0LnNrZWxldG9ucyksZj1vKHQuYW5pbWF0aW9ucykscD1vKHQubm9kZXMpO2EubGVuZ3RoPjAmJihzLmdlb21ldHJpZXM9YSksYy5sZW5ndGg+MCYmKHMubWF0ZXJpYWxzPWMpLHUubGVuZ3RoPjAmJihzLnRleHR1cmVzPXUpLGgubGVuZ3RoPjAmJihzLmltYWdlcz1oKSxsLmxlbmd0aD4wJiYocy5zaGFwZXM9bCksZC5sZW5ndGg+MCYmKHMuc2tlbGV0b25zPWQpLGYubGVuZ3RoPjAmJihzLmFuaW1hdGlvbnM9ZikscC5sZW5ndGg+MCYmKHMubm9kZXM9cCl9cmV0dXJuIHMub2JqZWN0PW4scztmdW5jdGlvbiBvKGEpe2NvbnN0IGM9W107Zm9yKGNvbnN0IHUgaW4gYSl7Y29uc3QgaD1hW3VdO2RlbGV0ZSBoLm1ldGFkYXRhLGMucHVzaChoKX1yZXR1cm4gY319Y2xvbmUodCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzLHQpfWNvcHkodCxlPSEwKXtpZih0aGlzLm5hbWU9dC5uYW1lLHRoaXMudXAuY29weSh0LnVwKSx0aGlzLnBvc2l0aW9uLmNvcHkodC5wb3NpdGlvbiksdGhpcy5yb3RhdGlvbi5vcmRlcj10LnJvdGF0aW9uLm9yZGVyLHRoaXMucXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbiksdGhpcy5zY2FsZS5jb3B5KHQuc2NhbGUpLHRoaXMubWF0cml4LmNvcHkodC5tYXRyaXgpLHRoaXMubWF0cml4V29ybGQuY29weSh0Lm1hdHJpeFdvcmxkKSx0aGlzLm1hdHJpeEF1dG9VcGRhdGU9dC5tYXRyaXhBdXRvVXBkYXRlLHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlPXQubWF0cml4V29ybGRBdXRvVXBkYXRlLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT10Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUsdGhpcy5sYXllcnMubWFzaz10LmxheWVycy5tYXNrLHRoaXMudmlzaWJsZT10LnZpc2libGUsdGhpcy5jYXN0U2hhZG93PXQuY2FzdFNoYWRvdyx0aGlzLnJlY2VpdmVTaGFkb3c9dC5yZWNlaXZlU2hhZG93LHRoaXMuZnJ1c3R1bUN1bGxlZD10LmZydXN0dW1DdWxsZWQsdGhpcy5yZW5kZXJPcmRlcj10LnJlbmRlck9yZGVyLHRoaXMuYW5pbWF0aW9ucz10LmFuaW1hdGlvbnMuc2xpY2UoKSx0aGlzLnVzZXJEYXRhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodC51c2VyRGF0YSkpLGU9PT0hMClmb3IobGV0IHM9MDtzPHQuY2hpbGRyZW4ubGVuZ3RoO3MrKyl7Y29uc3Qgbj10LmNoaWxkcmVuW3NdO3RoaXMuYWRkKG4uY2xvbmUoKSl9cmV0dXJuIHRoaXN9fW5lLkRFRkFVTFRfVVA9bmV3IEEoMCwxLDApLG5lLkRFRkFVTFRfTUFUUklYX0FVVE9fVVBEQVRFPSEwLG5lLkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFPSEwO2NvbnN0IEl0PW5ldyBBLFh0PW5ldyBBLFBuPW5ldyBBLFl0PW5ldyBBLHplPW5ldyBBLGJlPW5ldyBBLHlyPW5ldyBBLExuPW5ldyBBLE9uPW5ldyBBLERuPW5ldyBBLFZuPW5ldyBGdCxVbj1uZXcgRnQsa249bmV3IEZ0O2NsYXNzIHd0e2NvbnN0cnVjdG9yKHQ9bmV3IEEsZT1uZXcgQSxzPW5ldyBBKXt0aGlzLmE9dCx0aGlzLmI9ZSx0aGlzLmM9c31zdGF0aWMgZ2V0Tm9ybWFsKHQsZSxzLG4pe24uc3ViVmVjdG9ycyhzLGUpLEl0LnN1YlZlY3RvcnModCxlKSxuLmNyb3NzKEl0KTtjb25zdCBpPW4ubGVuZ3RoU3EoKTtyZXR1cm4gaT4wP24ubXVsdGlwbHlTY2FsYXIoMS9NYXRoLnNxcnQoaSkpOm4uc2V0KDAsMCwwKX1zdGF0aWMgZ2V0QmFyeWNvb3JkKHQsZSxzLG4saSl7SXQuc3ViVmVjdG9ycyhuLGUpLFh0LnN1YlZlY3RvcnMocyxlKSxQbi5zdWJWZWN0b3JzKHQsZSk7Y29uc3Qgbz1JdC5kb3QoSXQpLGE9SXQuZG90KFh0KSxjPUl0LmRvdChQbiksdT1YdC5kb3QoWHQpLGg9WHQuZG90KFBuKSxsPW8qdS1hKmE7aWYobD09PTApcmV0dXJuIGkuc2V0KDAsMCwwKSxudWxsO2NvbnN0IGQ9MS9sLGY9KHUqYy1hKmgpKmQscD0obypoLWEqYykqZDtyZXR1cm4gaS5zZXQoMS1mLXAscCxmKX1zdGF0aWMgY29udGFpbnNQb2ludCh0LGUscyxuKXtyZXR1cm4gdGhpcy5nZXRCYXJ5Y29vcmQodCxlLHMsbixZdCk9PT1udWxsPyExOll0Lng+PTAmJll0Lnk+PTAmJll0LngrWXQueTw9MX1zdGF0aWMgZ2V0SW50ZXJwb2xhdGlvbih0LGUscyxuLGksbyxhLGMpe3JldHVybiB0aGlzLmdldEJhcnljb29yZCh0LGUscyxuLFl0KT09PW51bGw/KGMueD0wLGMueT0wLCJ6ImluIGMmJihjLno9MCksInciaW4gYyYmKGMudz0wKSxudWxsKTooYy5zZXRTY2FsYXIoMCksYy5hZGRTY2FsZWRWZWN0b3IoaSxZdC54KSxjLmFkZFNjYWxlZFZlY3RvcihvLFl0LnkpLGMuYWRkU2NhbGVkVmVjdG9yKGEsWXQueiksYyl9c3RhdGljIGdldEludGVycG9sYXRlZEF0dHJpYnV0ZSh0LGUscyxuLGksbyl7cmV0dXJuIFZuLnNldFNjYWxhcigwKSxVbi5zZXRTY2FsYXIoMCksa24uc2V0U2NhbGFyKDApLFZuLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKSxVbi5mcm9tQnVmZmVyQXR0cmlidXRlKHQscyksa24uZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LG4pLG8uc2V0U2NhbGFyKDApLG8uYWRkU2NhbGVkVmVjdG9yKFZuLGkueCksby5hZGRTY2FsZWRWZWN0b3IoVW4saS55KSxvLmFkZFNjYWxlZFZlY3RvcihrbixpLnopLG99c3RhdGljIGlzRnJvbnRGYWNpbmcodCxlLHMsbil7cmV0dXJuIEl0LnN1YlZlY3RvcnMocyxlKSxYdC5zdWJWZWN0b3JzKHQsZSksSXQuY3Jvc3MoWHQpLmRvdChuKTwwfXNldCh0LGUscyl7cmV0dXJuIHRoaXMuYS5jb3B5KHQpLHRoaXMuYi5jb3B5KGUpLHRoaXMuYy5jb3B5KHMpLHRoaXN9c2V0RnJvbVBvaW50c0FuZEluZGljZXModCxlLHMsbil7cmV0dXJuIHRoaXMuYS5jb3B5KHRbZV0pLHRoaXMuYi5jb3B5KHRbc10pLHRoaXMuYy5jb3B5KHRbbl0pLHRoaXN9c2V0RnJvbUF0dHJpYnV0ZUFuZEluZGljZXModCxlLHMsbil7cmV0dXJuIHRoaXMuYS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSksdGhpcy5iLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxzKSx0aGlzLmMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LG4pLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfWNvcHkodCl7cmV0dXJuIHRoaXMuYS5jb3B5KHQuYSksdGhpcy5iLmNvcHkodC5iKSx0aGlzLmMuY29weSh0LmMpLHRoaXN9Z2V0QXJlYSgpe3JldHVybiBJdC5zdWJWZWN0b3JzKHRoaXMuYyx0aGlzLmIpLFh0LnN1YlZlY3RvcnModGhpcy5hLHRoaXMuYiksSXQuY3Jvc3MoWHQpLmxlbmd0aCgpKi41fWdldE1pZHBvaW50KHQpe3JldHVybiB0LmFkZFZlY3RvcnModGhpcy5hLHRoaXMuYikuYWRkKHRoaXMuYykubXVsdGlwbHlTY2FsYXIoMS8zKX1nZXROb3JtYWwodCl7cmV0dXJuIHd0LmdldE5vcm1hbCh0aGlzLmEsdGhpcy5iLHRoaXMuYyx0KX1nZXRQbGFuZSh0KXtyZXR1cm4gdC5zZXRGcm9tQ29wbGFuYXJQb2ludHModGhpcy5hLHRoaXMuYix0aGlzLmMpfWdldEJhcnljb29yZCh0LGUpe3JldHVybiB3dC5nZXRCYXJ5Y29vcmQodCx0aGlzLmEsdGhpcy5iLHRoaXMuYyxlKX1nZXRJbnRlcnBvbGF0aW9uKHQsZSxzLG4saSl7cmV0dXJuIHd0LmdldEludGVycG9sYXRpb24odCx0aGlzLmEsdGhpcy5iLHRoaXMuYyxlLHMsbixpKX1jb250YWluc1BvaW50KHQpe3JldHVybiB3dC5jb250YWluc1BvaW50KHQsdGhpcy5hLHRoaXMuYix0aGlzLmMpfWlzRnJvbnRGYWNpbmcodCl7cmV0dXJuIHd0LmlzRnJvbnRGYWNpbmcodGhpcy5hLHRoaXMuYix0aGlzLmMsdCl9aW50ZXJzZWN0c0JveCh0KXtyZXR1cm4gdC5pbnRlcnNlY3RzVHJpYW5nbGUodGhpcyl9Y2xvc2VzdFBvaW50VG9Qb2ludCh0LGUpe2NvbnN0IHM9dGhpcy5hLG49dGhpcy5iLGk9dGhpcy5jO2xldCBvLGE7emUuc3ViVmVjdG9ycyhuLHMpLGJlLnN1YlZlY3RvcnMoaSxzKSxMbi5zdWJWZWN0b3JzKHQscyk7Y29uc3QgYz16ZS5kb3QoTG4pLHU9YmUuZG90KExuKTtpZihjPD0wJiZ1PD0wKXJldHVybiBlLmNvcHkocyk7T24uc3ViVmVjdG9ycyh0LG4pO2NvbnN0IGg9emUuZG90KE9uKSxsPWJlLmRvdChPbik7aWYoaD49MCYmbDw9aClyZXR1cm4gZS5jb3B5KG4pO2NvbnN0IGQ9YypsLWgqdTtpZihkPD0wJiZjPj0wJiZoPD0wKXJldHVybiBvPWMvKGMtaCksZS5jb3B5KHMpLmFkZFNjYWxlZFZlY3Rvcih6ZSxvKTtEbi5zdWJWZWN0b3JzKHQsaSk7Y29uc3QgZj16ZS5kb3QoRG4pLHA9YmUuZG90KERuKTtpZihwPj0wJiZmPD1wKXJldHVybiBlLmNvcHkoaSk7Y29uc3QgbT1mKnUtYypwO2lmKG08PTAmJnU+PTAmJnA8PTApcmV0dXJuIGE9dS8odS1wKSxlLmNvcHkocykuYWRkU2NhbGVkVmVjdG9yKGJlLGEpO2NvbnN0IGc9aCpwLWYqbDtpZihnPD0wJiZsLWg+PTAmJmYtcD49MClyZXR1cm4geXIuc3ViVmVjdG9ycyhpLG4pLGE9KGwtaCkvKGwtaCsoZi1wKSksZS5jb3B5KG4pLmFkZFNjYWxlZFZlY3Rvcih5cixhKTtjb25zdCB5PTEvKGcrbStkKTtyZXR1cm4gbz1tKnksYT1kKnksZS5jb3B5KHMpLmFkZFNjYWxlZFZlY3Rvcih6ZSxvKS5hZGRTY2FsZWRWZWN0b3IoYmUsYSl9ZXF1YWxzKHQpe3JldHVybiB0LmEuZXF1YWxzKHRoaXMuYSkmJnQuYi5lcXVhbHModGhpcy5iKSYmdC5jLmVxdWFscyh0aGlzLmMpfX1jb25zdCBncj17YWxpY2VibHVlOjE1NzkyMzgzLGFudGlxdWV3aGl0ZToxNjQ0NDM3NSxhcXVhOjY1NTM1LGFxdWFtYXJpbmU6ODM4ODU2NCxhenVyZToxNTc5NDE3NSxiZWlnZToxNjExOTI2MCxiaXNxdWU6MTY3NzAyNDQsYmxhY2s6MCxibGFuY2hlZGFsbW9uZDoxNjc3MjA0NSxibHVlOjI1NSxibHVldmlvbGV0OjkwNTUyMDIsYnJvd246MTA4MjQyMzQsYnVybHl3b29kOjE0NTk2MjMxLGNhZGV0Ymx1ZTo2MjY2NTI4LGNoYXJ0cmV1c2U6ODM4ODM1MixjaG9jb2xhdGU6MTM3ODk0NzAsY29yYWw6MTY3NDQyNzIsY29ybmZsb3dlcmJsdWU6NjU5MTk4MSxjb3Juc2lsazoxNjc3NTM4OCxjcmltc29uOjE0NDIzMTAwLGN5YW46NjU1MzUsZGFya2JsdWU6MTM5LGRhcmtjeWFuOjM1NzIzLGRhcmtnb2xkZW5yb2Q6MTIwOTI5MzksZGFya2dyYXk6MTExMTkwMTcsZGFya2dyZWVuOjI1NjAwLGRhcmtncmV5OjExMTE5MDE3LGRhcmtraGFraToxMjQzMzI1OSxkYXJrbWFnZW50YTo5MTA5NjQzLGRhcmtvbGl2ZWdyZWVuOjU1OTc5OTksZGFya29yYW5nZToxNjc0NzUyMCxkYXJrb3JjaGlkOjEwMDQwMDEyLGRhcmtyZWQ6OTEwOTUwNCxkYXJrc2FsbW9uOjE1MzA4NDEwLGRhcmtzZWFncmVlbjo5NDE5OTE5LGRhcmtzbGF0ZWJsdWU6NDczNDM0NyxkYXJrc2xhdGVncmF5OjMxMDA0OTUsZGFya3NsYXRlZ3JleTozMTAwNDk1LGRhcmt0dXJxdW9pc2U6NTI5NDUsZGFya3Zpb2xldDo5Njk5NTM5LGRlZXBwaW5rOjE2NzE2OTQ3LGRlZXBza3libHVlOjQ5MTUxLGRpbWdyYXk6NjkwODI2NSxkaW1ncmV5OjY5MDgyNjUsZG9kZ2VyYmx1ZToyMDAzMTk5LGZpcmVicmljazoxMTY3NDE0NixmbG9yYWx3aGl0ZToxNjc3NTkyMCxmb3Jlc3RncmVlbjoyMjYzODQyLGZ1Y2hzaWE6MTY3MTE5MzUsZ2FpbnNib3JvOjE0NDc0NDYwLGdob3N0d2hpdGU6MTYzMTY2NzEsZ29sZDoxNjc2NjcyMCxnb2xkZW5yb2Q6MTQzMjkxMjAsZ3JheTo4NDIxNTA0LGdyZWVuOjMyNzY4LGdyZWVueWVsbG93OjExNDAzMDU1LGdyZXk6ODQyMTUwNCxob25leWRldzoxNTc5NDE2MCxob3RwaW5rOjE2NzM4NzQwLGluZGlhbnJlZDoxMzQ1ODUyNCxpbmRpZ286NDkxNTMzMCxpdm9yeToxNjc3NzIwMCxraGFraToxNTc4NzY2MCxsYXZlbmRlcjoxNTEzMjQxMCxsYXZlbmRlcmJsdXNoOjE2NzczMzY1LGxhd25ncmVlbjo4MTkwOTc2LGxlbW9uY2hpZmZvbjoxNjc3NTg4NSxsaWdodGJsdWU6MTEzOTMyNTQsbGlnaHRjb3JhbDoxNTc2MTUzNixsaWdodGN5YW46MTQ3NDU1OTksbGlnaHRnb2xkZW5yb2R5ZWxsb3c6MTY0NDgyMTAsbGlnaHRncmF5OjEzODgyMzIzLGxpZ2h0Z3JlZW46OTQ5ODI1NixsaWdodGdyZXk6MTM4ODIzMjMsbGlnaHRwaW5rOjE2NzU4NDY1LGxpZ2h0c2FsbW9uOjE2NzUyNzYyLGxpZ2h0c2VhZ3JlZW46MjE0Mjg5MCxsaWdodHNreWJsdWU6ODkwMDM0NixsaWdodHNsYXRlZ3JheTo3ODMzNzUzLGxpZ2h0c2xhdGVncmV5Ojc4MzM3NTMsbGlnaHRzdGVlbGJsdWU6MTE1ODQ3MzQsbGlnaHR5ZWxsb3c6MTY3NzcxODQsbGltZTo2NTI4MCxsaW1lZ3JlZW46MzMyOTMzMCxsaW5lbjoxNjQ0NTY3MCxtYWdlbnRhOjE2NzExOTM1LG1hcm9vbjo4Mzg4NjA4LG1lZGl1bWFxdWFtYXJpbmU6NjczNzMyMixtZWRpdW1ibHVlOjIwNSxtZWRpdW1vcmNoaWQ6MTIyMTE2NjcsbWVkaXVtcHVycGxlOjk2NjI2ODMsbWVkaXVtc2VhZ3JlZW46Mzk3ODA5NyxtZWRpdW1zbGF0ZWJsdWU6ODA4Nzc5MCxtZWRpdW1zcHJpbmdncmVlbjo2NDE1NCxtZWRpdW10dXJxdW9pc2U6NDc3MjMwMCxtZWRpdW12aW9sZXRyZWQ6MTMwNDcxNzMsbWlkbmlnaHRibHVlOjE2NDQ5MTIsbWludGNyZWFtOjE2MTIxODUwLG1pc3R5cm9zZToxNjc3MDI3Myxtb2NjYXNpbjoxNjc3MDIyOSxuYXZham93aGl0ZToxNjc2ODY4NSxuYXZ5OjEyOCxvbGRsYWNlOjE2NjQzNTU4LG9saXZlOjg0MjEzNzYsb2xpdmVkcmFiOjcwNDg3Mzksb3JhbmdlOjE2NzUzOTIwLG9yYW5nZXJlZDoxNjcyOTM0NCxvcmNoaWQ6MTQzMTU3MzQscGFsZWdvbGRlbnJvZDoxNTY1NzEzMCxwYWxlZ3JlZW46MTAwMjU4ODAscGFsZXR1cnF1b2lzZToxMTUyOTk2NixwYWxldmlvbGV0cmVkOjE0MzgxMjAzLHBhcGF5YXdoaXA6MTY3NzMwNzcscGVhY2hwdWZmOjE2NzY3NjczLHBlcnU6MTM0Njg5OTEscGluazoxNjc2MTAzNSxwbHVtOjE0NTI0NjM3LHBvd2RlcmJsdWU6MTE1OTE5MTAscHVycGxlOjgzODg3MzYscmViZWNjYXB1cnBsZTo2Njk3ODgxLHJlZDoxNjcxMTY4MCxyb3N5YnJvd246MTIzNTc1MTkscm95YWxibHVlOjQyODY5NDUsc2FkZGxlYnJvd246OTEyNzE4NyxzYWxtb246MTY0MTY4ODIsc2FuZHlicm93bjoxNjAzMjg2NCxzZWFncmVlbjozMDUwMzI3LHNlYXNoZWxsOjE2Nzc0NjM4LHNpZW5uYToxMDUwNjc5NyxzaWx2ZXI6MTI2MzIyNTYsc2t5Ymx1ZTo4OTAwMzMxLHNsYXRlYmx1ZTo2OTcwMDYxLHNsYXRlZ3JheTo3MzcyOTQ0LHNsYXRlZ3JleTo3MzcyOTQ0LHNub3c6MTY3NzU5MzAsc3ByaW5nZ3JlZW46NjU0MDcsc3RlZWxibHVlOjQ2MjA5ODAsdGFuOjEzODA4NzgwLHRlYWw6MzI4OTYsdGhpc3RsZToxNDIwNDg4OCx0b21hdG86MTY3MzcwOTUsdHVycXVvaXNlOjQyNTE4NTYsdmlvbGV0OjE1NjMxMDg2LHdoZWF0OjE2MTEzMzMxLHdoaXRlOjE2Nzc3MjE1LHdoaXRlc21va2U6MTYxMTkyODUseWVsbG93OjE2Nzc2OTYwLHllbGxvd2dyZWVuOjEwMTQ1MDc0fSxpZT17aDowLHM6MCxsOjB9LExzPXtoOjAsczowLGw6MH07ZnVuY3Rpb24gSG4ocix0LGUpe3JldHVybiBlPDAmJihlKz0xKSxlPjEmJihlLT0xKSxlPDEvNj9yKyh0LXIpKjYqZTplPDEvMj90OmU8Mi8zP3IrKHQtcikqNiooMi8zLWUpOnJ9Y2xhc3MgcW57Y29uc3RydWN0b3IodCxlLHMpe3JldHVybiB0aGlzLmlzQ29sb3I9ITAsdGhpcy5yPTEsdGhpcy5nPTEsdGhpcy5iPTEsdGhpcy5zZXQodCxlLHMpfXNldCh0LGUscyl7aWYoZT09PXZvaWQgMCYmcz09PXZvaWQgMCl7Y29uc3Qgbj10O24mJm4uaXNDb2xvcj90aGlzLmNvcHkobik6dHlwZW9mIG49PSJudW1iZXIiP3RoaXMuc2V0SGV4KG4pOnR5cGVvZiBuPT0ic3RyaW5nIiYmdGhpcy5zZXRTdHlsZShuKX1lbHNlIHRoaXMuc2V0UkdCKHQsZSxzKTtyZXR1cm4gdGhpc31zZXRTY2FsYXIodCl7cmV0dXJuIHRoaXMucj10LHRoaXMuZz10LHRoaXMuYj10LHRoaXN9c2V0SGV4KHQsZT0kdCl7cmV0dXJuIHQ9TWF0aC5mbG9vcih0KSx0aGlzLnI9KHQ+PjE2JjI1NSkvMjU1LHRoaXMuZz0odD4+OCYyNTUpLzI1NSx0aGlzLmI9KHQmMjU1KS8yNTUsbXQudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLGUpLHRoaXN9c2V0UkdCKHQsZSxzLG49bXQud29ya2luZ0NvbG9yU3BhY2Upe3JldHVybiB0aGlzLnI9dCx0aGlzLmc9ZSx0aGlzLmI9cyxtdC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsbiksdGhpc31zZXRIU0wodCxlLHMsbj1tdC53b3JraW5nQ29sb3JTcGFjZSl7aWYodD1ibih0LDEpLGU9YXQoZSwwLDEpLHM9YXQocywwLDEpLGU9PT0wKXRoaXMucj10aGlzLmc9dGhpcy5iPXM7ZWxzZXtjb25zdCBpPXM8PS41P3MqKDErZSk6cytlLXMqZSxvPTIqcy1pO3RoaXMucj1IbihvLGksdCsxLzMpLHRoaXMuZz1IbihvLGksdCksdGhpcy5iPUhuKG8saSx0LTEvMyl9cmV0dXJuIG10LnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcyxuKSx0aGlzfXNldFN0eWxlKHQsZT0kdCl7ZnVuY3Rpb24gcyhpKXtpIT09dm9pZCAwJiZwYXJzZUZsb2F0KGkpPDEmJmNvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAiK3QrIiB3aWxsIGJlIGlnbm9yZWQuIil9bGV0IG47aWYobj0vXihcdyspXCgoW15cKV0qKVwpLy5leGVjKHQpKXtsZXQgaTtjb25zdCBvPW5bMV0sYT1uWzJdO3N3aXRjaChvKXtjYXNlInJnYiI6Y2FzZSJyZ2JhIjppZihpPS9eXHMqKFxkKylccyosXHMqKFxkKylccyosXHMqKFxkKylccyooPzosXHMqKFxkKlwuP1xkKylccyopPyQvLmV4ZWMoYSkpcmV0dXJuIHMoaVs0XSksdGhpcy5zZXRSR0IoTWF0aC5taW4oMjU1LHBhcnNlSW50KGlbMV0sMTApKS8yNTUsTWF0aC5taW4oMjU1LHBhcnNlSW50KGlbMl0sMTApKS8yNTUsTWF0aC5taW4oMjU1LHBhcnNlSW50KGlbM10sMTApKS8yNTUsZSk7aWYoaT0vXlxzKihcZCspXCVccyosXHMqKFxkKylcJVxzKixccyooXGQrKVwlXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKGEpKXJldHVybiBzKGlbNF0pLHRoaXMuc2V0UkdCKE1hdGgubWluKDEwMCxwYXJzZUludChpWzFdLDEwKSkvMTAwLE1hdGgubWluKDEwMCxwYXJzZUludChpWzJdLDEwKSkvMTAwLE1hdGgubWluKDEwMCxwYXJzZUludChpWzNdLDEwKSkvMTAwLGUpO2JyZWFrO2Nhc2UiaHNsIjpjYXNlImhzbGEiOmlmKGk9L15ccyooXGQqXC4/XGQrKVxzKixccyooXGQqXC4/XGQrKVwlXHMqLFxzKihcZCpcLj9cZCspXCVccyooPzosXHMqKFxkKlwuP1xkKylccyopPyQvLmV4ZWMoYSkpcmV0dXJuIHMoaVs0XSksdGhpcy5zZXRIU0wocGFyc2VGbG9hdChpWzFdKS8zNjAscGFyc2VGbG9hdChpWzJdKS8xMDAscGFyc2VGbG9hdChpWzNdKS8xMDAsZSk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yIG1vZGVsICIrdCl9fWVsc2UgaWYobj0vXlwjKFtBLUZhLWZcZF0rKSQvLmV4ZWModCkpe2NvbnN0IGk9blsxXSxvPWkubGVuZ3RoO2lmKG89PT0zKXJldHVybiB0aGlzLnNldFJHQihwYXJzZUludChpLmNoYXJBdCgwKSwxNikvMTUscGFyc2VJbnQoaS5jaGFyQXQoMSksMTYpLzE1LHBhcnNlSW50KGkuY2hhckF0KDIpLDE2KS8xNSxlKTtpZihvPT09NilyZXR1cm4gdGhpcy5zZXRIZXgocGFyc2VJbnQoaSwxNiksZSk7Y29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogSW52YWxpZCBoZXggY29sb3IgIit0KX1lbHNlIGlmKHQmJnQubGVuZ3RoPjApcmV0dXJuIHRoaXMuc2V0Q29sb3JOYW1lKHQsZSk7cmV0dXJuIHRoaXN9c2V0Q29sb3JOYW1lKHQsZT0kdCl7Y29uc3Qgcz1nclt0LnRvTG93ZXJDYXNlKCldO3JldHVybiBzIT09dm9pZCAwP3RoaXMuc2V0SGV4KHMsZSk6Y29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAiK3QpLHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5yLHRoaXMuZyx0aGlzLmIpfWNvcHkodCl7cmV0dXJuIHRoaXMucj10LnIsdGhpcy5nPXQuZyx0aGlzLmI9dC5iLHRoaXN9Y29weVNSR0JUb0xpbmVhcih0KXtyZXR1cm4gdGhpcy5yPXhlKHQuciksdGhpcy5nPXhlKHQuZyksdGhpcy5iPXhlKHQuYiksdGhpc31jb3B5TGluZWFyVG9TUkdCKHQpe3JldHVybiB0aGlzLnI9Q24odC5yKSx0aGlzLmc9Q24odC5nKSx0aGlzLmI9Q24odC5iKSx0aGlzfWNvbnZlcnRTUkdCVG9MaW5lYXIoKXtyZXR1cm4gdGhpcy5jb3B5U1JHQlRvTGluZWFyKHRoaXMpLHRoaXN9Y29udmVydExpbmVhclRvU1JHQigpe3JldHVybiB0aGlzLmNvcHlMaW5lYXJUb1NSR0IodGhpcyksdGhpc31nZXRIZXgodD0kdCl7cmV0dXJuIG10LmZyb21Xb3JraW5nQ29sb3JTcGFjZShjdC5jb3B5KHRoaXMpLHQpLE1hdGgucm91bmQoYXQoY3QucioyNTUsMCwyNTUpKSo2NTUzNitNYXRoLnJvdW5kKGF0KGN0LmcqMjU1LDAsMjU1KSkqMjU2K01hdGgucm91bmQoYXQoY3QuYioyNTUsMCwyNTUpKX1nZXRIZXhTdHJpbmcodD0kdCl7cmV0dXJuKCIwMDAwMDAiK3RoaXMuZ2V0SGV4KHQpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpfWdldEhTTCh0LGU9bXQud29ya2luZ0NvbG9yU3BhY2Upe210LmZyb21Xb3JraW5nQ29sb3JTcGFjZShjdC5jb3B5KHRoaXMpLGUpO2NvbnN0IHM9Y3QucixuPWN0LmcsaT1jdC5iLG89TWF0aC5tYXgocyxuLGkpLGE9TWF0aC5taW4ocyxuLGkpO2xldCBjLHU7Y29uc3QgaD0oYStvKS8yO2lmKGE9PT1vKWM9MCx1PTA7ZWxzZXtjb25zdCBsPW8tYTtzd2l0Y2godT1oPD0uNT9sLyhvK2EpOmwvKDItby1hKSxvKXtjYXNlIHM6Yz0obi1pKS9sKyhuPGk/NjowKTticmVhaztjYXNlIG46Yz0oaS1zKS9sKzI7YnJlYWs7Y2FzZSBpOmM9KHMtbikvbCs0O2JyZWFrfWMvPTZ9cmV0dXJuIHQuaD1jLHQucz11LHQubD1oLHR9Z2V0UkdCKHQsZT1tdC53b3JraW5nQ29sb3JTcGFjZSl7cmV0dXJuIG10LmZyb21Xb3JraW5nQ29sb3JTcGFjZShjdC5jb3B5KHRoaXMpLGUpLHQucj1jdC5yLHQuZz1jdC5nLHQuYj1jdC5iLHR9Z2V0U3R5bGUodD0kdCl7bXQuZnJvbVdvcmtpbmdDb2xvclNwYWNlKGN0LmNvcHkodGhpcyksdCk7Y29uc3QgZT1jdC5yLHM9Y3QuZyxuPWN0LmI7cmV0dXJuIHQhPT0kdD9gY29sb3IoJHt0fSAke2UudG9GaXhlZCgzKX0gJHtzLnRvRml4ZWQoMyl9ICR7bi50b0ZpeGVkKDMpfSlgOmByZ2IoJHtNYXRoLnJvdW5kKGUqMjU1KX0sJHtNYXRoLnJvdW5kKHMqMjU1KX0sJHtNYXRoLnJvdW5kKG4qMjU1KX0pYH1vZmZzZXRIU0wodCxlLHMpe3JldHVybiB0aGlzLmdldEhTTChpZSksdGhpcy5zZXRIU0woaWUuaCt0LGllLnMrZSxpZS5sK3MpfWFkZCh0KXtyZXR1cm4gdGhpcy5yKz10LnIsdGhpcy5nKz10LmcsdGhpcy5iKz10LmIsdGhpc31hZGRDb2xvcnModCxlKXtyZXR1cm4gdGhpcy5yPXQucitlLnIsdGhpcy5nPXQuZytlLmcsdGhpcy5iPXQuYitlLmIsdGhpc31hZGRTY2FsYXIodCl7cmV0dXJuIHRoaXMucis9dCx0aGlzLmcrPXQsdGhpcy5iKz10LHRoaXN9c3ViKHQpe3JldHVybiB0aGlzLnI9TWF0aC5tYXgoMCx0aGlzLnItdC5yKSx0aGlzLmc9TWF0aC5tYXgoMCx0aGlzLmctdC5nKSx0aGlzLmI9TWF0aC5tYXgoMCx0aGlzLmItdC5iKSx0aGlzfW11bHRpcGx5KHQpe3JldHVybiB0aGlzLnIqPXQucix0aGlzLmcqPXQuZyx0aGlzLmIqPXQuYix0aGlzfW11bHRpcGx5U2NhbGFyKHQpe3JldHVybiB0aGlzLnIqPXQsdGhpcy5nKj10LHRoaXMuYio9dCx0aGlzfWxlcnAodCxlKXtyZXR1cm4gdGhpcy5yKz0odC5yLXRoaXMucikqZSx0aGlzLmcrPSh0LmctdGhpcy5nKSplLHRoaXMuYis9KHQuYi10aGlzLmIpKmUsdGhpc31sZXJwQ29sb3JzKHQsZSxzKXtyZXR1cm4gdGhpcy5yPXQucisoZS5yLXQucikqcyx0aGlzLmc9dC5nKyhlLmctdC5nKSpzLHRoaXMuYj10LmIrKGUuYi10LmIpKnMsdGhpc31sZXJwSFNMKHQsZSl7dGhpcy5nZXRIU0woaWUpLHQuZ2V0SFNMKExzKTtjb25zdCBzPUplKGllLmgsTHMuaCxlKSxuPUplKGllLnMsTHMucyxlKSxpPUplKGllLmwsTHMubCxlKTtyZXR1cm4gdGhpcy5zZXRIU0wocyxuLGkpLHRoaXN9c2V0RnJvbVZlY3RvcjModCl7cmV0dXJuIHRoaXMucj10LngsdGhpcy5nPXQueSx0aGlzLmI9dC56LHRoaXN9YXBwbHlNYXRyaXgzKHQpe2NvbnN0IGU9dGhpcy5yLHM9dGhpcy5nLG49dGhpcy5iLGk9dC5lbGVtZW50cztyZXR1cm4gdGhpcy5yPWlbMF0qZStpWzNdKnMraVs2XSpuLHRoaXMuZz1pWzFdKmUraVs0XSpzK2lbN10qbix0aGlzLmI9aVsyXSplK2lbNV0qcytpWzhdKm4sdGhpc31lcXVhbHModCl7cmV0dXJuIHQucj09PXRoaXMuciYmdC5nPT09dGhpcy5nJiZ0LmI9PT10aGlzLmJ9ZnJvbUFycmF5KHQsZT0wKXtyZXR1cm4gdGhpcy5yPXRbZV0sdGhpcy5nPXRbZSsxXSx0aGlzLmI9dFtlKzJdLHRoaXN9dG9BcnJheSh0PVtdLGU9MCl7cmV0dXJuIHRbZV09dGhpcy5yLHRbZSsxXT10aGlzLmcsdFtlKzJdPXRoaXMuYix0fWZyb21CdWZmZXJBdHRyaWJ1dGUodCxlKXtyZXR1cm4gdGhpcy5yPXQuZ2V0WChlKSx0aGlzLmc9dC5nZXRZKGUpLHRoaXMuYj10LmdldFooZSksdGhpc310b0pTT04oKXtyZXR1cm4gdGhpcy5nZXRIZXgoKX0qW1N5bWJvbC5pdGVyYXRvcl0oKXt5aWVsZCB0aGlzLnIseWllbGQgdGhpcy5nLHlpZWxkIHRoaXMuYn19Y29uc3QgY3Q9bmV3IHFuO3FuLk5BTUVTPWdyO2NvbnN0IGo9bmV3IEEsT3M9bmV3IEo7Y2xhc3MgdnR7Y29uc3RydWN0b3IodCxlLHM9ITEpe2lmKEFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigiVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4iKTt0aGlzLmlzQnVmZmVyQXR0cmlidXRlPSEwLHRoaXMubmFtZT0iIix0aGlzLmFycmF5PXQsdGhpcy5pdGVtU2l6ZT1lLHRoaXMuY291bnQ9dCE9PXZvaWQgMD90Lmxlbmd0aC9lOjAsdGhpcy5ub3JtYWxpemVkPXMsdGhpcy51c2FnZT1Dcyx0aGlzLnVwZGF0ZVJhbmdlcz1bXSx0aGlzLmdwdVR5cGU9SW8sdGhpcy52ZXJzaW9uPTB9b25VcGxvYWRDYWxsYmFjaygpe31zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiZ0aGlzLnZlcnNpb24rK31zZXRVc2FnZSh0KXtyZXR1cm4gdGhpcy51c2FnZT10LHRoaXN9YWRkVXBkYXRlUmFuZ2UodCxlKXt0aGlzLnVwZGF0ZVJhbmdlcy5wdXNoKHtzdGFydDp0LGNvdW50OmV9KX1jbGVhclVwZGF0ZVJhbmdlcygpe3RoaXMudXBkYXRlUmFuZ2VzLmxlbmd0aD0wfWNvcHkodCl7cmV0dXJuIHRoaXMubmFtZT10Lm5hbWUsdGhpcy5hcnJheT1uZXcgdC5hcnJheS5jb25zdHJ1Y3Rvcih0LmFycmF5KSx0aGlzLml0ZW1TaXplPXQuaXRlbVNpemUsdGhpcy5jb3VudD10LmNvdW50LHRoaXMubm9ybWFsaXplZD10Lm5vcm1hbGl6ZWQsdGhpcy51c2FnZT10LnVzYWdlLHRoaXMuZ3B1VHlwZT10LmdwdVR5cGUsdGhpc31jb3B5QXQodCxlLHMpe3QqPXRoaXMuaXRlbVNpemUscyo9ZS5pdGVtU2l6ZTtmb3IobGV0IG49MCxpPXRoaXMuaXRlbVNpemU7bjxpO24rKyl0aGlzLmFycmF5W3Qrbl09ZS5hcnJheVtzK25dO3JldHVybiB0aGlzfWNvcHlBcnJheSh0KXtyZXR1cm4gdGhpcy5hcnJheS5zZXQodCksdGhpc31hcHBseU1hdHJpeDModCl7aWYodGhpcy5pdGVtU2l6ZT09PTIpZm9yKGxldCBlPTAscz10aGlzLmNvdW50O2U8cztlKyspT3MuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLE9zLmFwcGx5TWF0cml4Myh0KSx0aGlzLnNldFhZKGUsT3MueCxPcy55KTtlbHNlIGlmKHRoaXMuaXRlbVNpemU9PT0zKWZvcihsZXQgZT0wLHM9dGhpcy5jb3VudDtlPHM7ZSsrKWouZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLGouYXBwbHlNYXRyaXgzKHQpLHRoaXMuc2V0WFlaKGUsai54LGoueSxqLnopO3JldHVybiB0aGlzfWFwcGx5TWF0cml4NCh0KXtmb3IobGV0IGU9MCxzPXRoaXMuY291bnQ7ZTxzO2UrKylqLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyxlKSxqLmFwcGx5TWF0cml4NCh0KSx0aGlzLnNldFhZWihlLGoueCxqLnksai56KTtyZXR1cm4gdGhpc31hcHBseU5vcm1hbE1hdHJpeCh0KXtmb3IobGV0IGU9MCxzPXRoaXMuY291bnQ7ZTxzO2UrKylqLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyxlKSxqLmFwcGx5Tm9ybWFsTWF0cml4KHQpLHRoaXMuc2V0WFlaKGUsai54LGoueSxqLnopO3JldHVybiB0aGlzfXRyYW5zZm9ybURpcmVjdGlvbih0KXtmb3IobGV0IGU9MCxzPXRoaXMuY291bnQ7ZTxzO2UrKylqLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyxlKSxqLnRyYW5zZm9ybURpcmVjdGlvbih0KSx0aGlzLnNldFhZWihlLGoueCxqLnksai56KTtyZXR1cm4gdGhpc31zZXQodCxlPTApe3JldHVybiB0aGlzLmFycmF5LnNldCh0LGUpLHRoaXN9Z2V0Q29tcG9uZW50KHQsZSl7bGV0IHM9dGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrZV07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHM9RXQocyx0aGlzLmFycmF5KSksc31zZXRDb21wb25lbnQodCxlLHMpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihzPSQocyx0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrZV09cyx0aGlzfWdldFgodCl7bGV0IGU9dGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemVdO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPUV0KGUsdGhpcy5hcnJheSkpLGV9c2V0WCh0LGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPSQoZSx0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemVdPWUsdGhpc31nZXRZKHQpe2xldCBlPXRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplKzFdO3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPUV0KGUsdGhpcy5hcnJheSkpLGV9c2V0WSh0LGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPSQoZSx0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrMV09ZSx0aGlzfWdldFoodCl7bGV0IGU9dGhpcy5hcnJheVt0KnRoaXMuaXRlbVNpemUrMl07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9RXQoZSx0aGlzLmFycmF5KSksZX1zZXRaKHQsZSl7cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9JChlLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSsyXT1lLHRoaXN9Z2V0Vyh0KXtsZXQgZT10aGlzLmFycmF5W3QqdGhpcy5pdGVtU2l6ZSszXTtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT1FdChlLHRoaXMuYXJyYXkpKSxlfXNldFcodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT0kKGUsdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCp0aGlzLml0ZW1TaXplKzNdPWUsdGhpc31zZXRYWSh0LGUscyl7cmV0dXJuIHQqPXRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkJiYoZT0kKGUsdGhpcy5hcnJheSkscz0kKHMsdGhpcy5hcnJheSkpLHRoaXMuYXJyYXlbdCswXT1lLHRoaXMuYXJyYXlbdCsxXT1zLHRoaXN9c2V0WFlaKHQsZSxzLG4pe3JldHVybiB0Kj10aGlzLml0ZW1TaXplLHRoaXMubm9ybWFsaXplZCYmKGU9JChlLHRoaXMuYXJyYXkpLHM9JChzLHRoaXMuYXJyYXkpLG49JChuLHRoaXMuYXJyYXkpKSx0aGlzLmFycmF5W3QrMF09ZSx0aGlzLmFycmF5W3QrMV09cyx0aGlzLmFycmF5W3QrMl09bix0aGlzfXNldFhZWlcodCxlLHMsbixpKXtyZXR1cm4gdCo9dGhpcy5pdGVtU2l6ZSx0aGlzLm5vcm1hbGl6ZWQmJihlPSQoZSx0aGlzLmFycmF5KSxzPSQocyx0aGlzLmFycmF5KSxuPSQobix0aGlzLmFycmF5KSxpPSQoaSx0aGlzLmFycmF5KSksdGhpcy5hcnJheVt0KzBdPWUsdGhpcy5hcnJheVt0KzFdPXMsdGhpcy5hcnJheVt0KzJdPW4sdGhpcy5hcnJheVt0KzNdPWksdGhpc31vblVwbG9hZCh0KXtyZXR1cm4gdGhpcy5vblVwbG9hZENhbGxiYWNrPXQsdGhpc31jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmFycmF5LHRoaXMuaXRlbVNpemUpLmNvcHkodGhpcyl9dG9KU09OKCl7Y29uc3QgdD17aXRlbVNpemU6dGhpcy5pdGVtU2l6ZSx0eXBlOnRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxhcnJheTpBcnJheS5mcm9tKHRoaXMuYXJyYXkpLG5vcm1hbGl6ZWQ6dGhpcy5ub3JtYWxpemVkfTtyZXR1cm4gdGhpcy5uYW1lIT09IiImJih0Lm5hbWU9dGhpcy5uYW1lKSx0aGlzLnVzYWdlIT09Q3MmJih0LnVzYWdlPXRoaXMudXNhZ2UpLHR9fWNsYXNzIG1hIGV4dGVuZHMgdnR7Y29uc3RydWN0b3IodCxlLHMpe3N1cGVyKG5ldyBVaW50MTZBcnJheSh0KSxlLHMpfX1jbGFzcyB5YSBleHRlbmRzIHZ0e2NvbnN0cnVjdG9yKHQsZSxzKXtzdXBlcihuZXcgVWludDMyQXJyYXkodCksZSxzKX19Y2xhc3MgZ2EgZXh0ZW5kcyB2dHtjb25zdHJ1Y3Rvcih0LGUscyl7c3VwZXIobmV3IEZsb2F0MzJBcnJheSh0KSxlLHMpfX1sZXQgeGE9MDtjb25zdCBBdD1uZXcgbnQsJG49bmV3IG5lLEVlPW5ldyBBLGd0PW5ldyBodCxzcz1uZXcgaHQsaXQ9bmV3IEE7Y2xhc3MgR24gZXh0ZW5kcyBaZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pc0J1ZmZlckdlb21ldHJ5PSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZCIse3ZhbHVlOnhhKyt9KSx0aGlzLnV1aWQ9S3QoKSx0aGlzLm5hbWU9IiIsdGhpcy50eXBlPSJCdWZmZXJHZW9tZXRyeSIsdGhpcy5pbmRleD1udWxsLHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLm1vcnBoQXR0cmlidXRlcz17fSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPSExLHRoaXMuZ3JvdXBzPVtdLHRoaXMuYm91bmRpbmdCb3g9bnVsbCx0aGlzLmJvdW5kaW5nU3BoZXJlPW51bGwsdGhpcy5kcmF3UmFuZ2U9e3N0YXJ0OjAsY291bnQ6MS8wfSx0aGlzLnVzZXJEYXRhPXt9fWdldEluZGV4KCl7cmV0dXJuIHRoaXMuaW5kZXh9c2V0SW5kZXgodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dGhpcy5pbmRleD1uZXcoc2EodCk/eWE6bWEpKHQsMSk6dGhpcy5pbmRleD10LHRoaXN9Z2V0QXR0cmlidXRlKHQpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbdF19c2V0QXR0cmlidXRlKHQsZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1t0XT1lLHRoaXN9ZGVsZXRlQXR0cmlidXRlKHQpe3JldHVybiBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW3RdLHRoaXN9aGFzQXR0cmlidXRlKHQpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXNbdF0hPT12b2lkIDB9YWRkR3JvdXAodCxlLHM9MCl7dGhpcy5ncm91cHMucHVzaCh7c3RhcnQ6dCxjb3VudDplLG1hdGVyaWFsSW5kZXg6c30pfWNsZWFyR3JvdXBzKCl7dGhpcy5ncm91cHM9W119c2V0RHJhd1JhbmdlKHQsZSl7dGhpcy5kcmF3UmFuZ2Uuc3RhcnQ9dCx0aGlzLmRyYXdSYW5nZS5jb3VudD1lfWFwcGx5TWF0cml4NCh0KXtjb25zdCBlPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtlIT09dm9pZCAwJiYoZS5hcHBseU1hdHJpeDQodCksZS5uZWVkc1VwZGF0ZT0hMCk7Y29uc3Qgcz10aGlzLmF0dHJpYnV0ZXMubm9ybWFsO2lmKHMhPT12b2lkIDApe2NvbnN0IGk9bmV3IEN0KCkuZ2V0Tm9ybWFsTWF0cml4KHQpO3MuYXBwbHlOb3JtYWxNYXRyaXgoaSkscy5uZWVkc1VwZGF0ZT0hMH1jb25zdCBuPXRoaXMuYXR0cmlidXRlcy50YW5nZW50O3JldHVybiBuIT09dm9pZCAwJiYobi50cmFuc2Zvcm1EaXJlY3Rpb24odCksbi5uZWVkc1VwZGF0ZT0hMCksdGhpcy5ib3VuZGluZ0JveCE9PW51bGwmJnRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5ib3VuZGluZ1NwaGVyZSE9PW51bGwmJnRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksdGhpc31hcHBseVF1YXRlcm5pb24odCl7cmV0dXJuIEF0Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHQpLHRoaXMuYXBwbHlNYXRyaXg0KEF0KSx0aGlzfXJvdGF0ZVgodCl7cmV0dXJuIEF0Lm1ha2VSb3RhdGlvblgodCksdGhpcy5hcHBseU1hdHJpeDQoQXQpLHRoaXN9cm90YXRlWSh0KXtyZXR1cm4gQXQubWFrZVJvdGF0aW9uWSh0KSx0aGlzLmFwcGx5TWF0cml4NChBdCksdGhpc31yb3RhdGVaKHQpe3JldHVybiBBdC5tYWtlUm90YXRpb25aKHQpLHRoaXMuYXBwbHlNYXRyaXg0KEF0KSx0aGlzfXRyYW5zbGF0ZSh0LGUscyl7cmV0dXJuIEF0Lm1ha2VUcmFuc2xhdGlvbih0LGUscyksdGhpcy5hcHBseU1hdHJpeDQoQXQpLHRoaXN9c2NhbGUodCxlLHMpe3JldHVybiBBdC5tYWtlU2NhbGUodCxlLHMpLHRoaXMuYXBwbHlNYXRyaXg0KEF0KSx0aGlzfWxvb2tBdCh0KXtyZXR1cm4gJG4ubG9va0F0KHQpLCRuLnVwZGF0ZU1hdHJpeCgpLHRoaXMuYXBwbHlNYXRyaXg0KCRuLm1hdHJpeCksdGhpc31jZW50ZXIoKXtyZXR1cm4gdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcihFZSkubmVnYXRlKCksdGhpcy50cmFuc2xhdGUoRWUueCxFZS55LEVlLnopLHRoaXN9c2V0RnJvbVBvaW50cyh0KXtjb25zdCBlPVtdO2ZvcihsZXQgcz0wLG49dC5sZW5ndGg7czxuO3MrKyl7Y29uc3QgaT10W3NdO2UucHVzaChpLngsaS55LGkuenx8MCl9cmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlKCJwb3NpdGlvbiIsbmV3IGdhKGUsMykpLHRoaXN9Y29tcHV0ZUJvdW5kaW5nQm94KCl7dGhpcy5ib3VuZGluZ0JveD09PW51bGwmJih0aGlzLmJvdW5kaW5nQm94PW5ldyBodCk7Y29uc3QgdD10aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24sZT10aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtpZih0JiZ0LmlzR0xCdWZmZXJBdHRyaWJ1dGUpe2NvbnNvbGUuZXJyb3IoIlRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBib3guIix0aGlzKSx0aGlzLmJvdW5kaW5nQm94LnNldChuZXcgQSgtMS8wLC0xLzAsLTEvMCksbmV3IEEoMS8wLDEvMCwxLzApKTtyZXR1cm59aWYodCE9PXZvaWQgMCl7aWYodGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHQpLGUpZm9yKGxldCBzPTAsbj1lLmxlbmd0aDtzPG47cysrKXtjb25zdCBpPWVbc107Z3Quc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShpKSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPyhpdC5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWluLGd0Lm1pbiksdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KGl0KSxpdC5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWF4LGd0Lm1heCksdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KGl0KSk6KHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChndC5taW4pLHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChndC5tYXgpKX19ZWxzZSB0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpOyhpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi54KXx8aXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueSl8fGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnopKSYmY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgInBvc2l0aW9uIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLHRoaXMpfWNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpe3RoaXMuYm91bmRpbmdTcGhlcmU9PT1udWxsJiYodGhpcy5ib3VuZGluZ1NwaGVyZT1uZXcgY3IpO2NvbnN0IHQ9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLGU9dGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247aWYodCYmdC5pc0dMQnVmZmVyQXR0cmlidXRlKXtjb25zb2xlLmVycm9yKCJUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgc3BoZXJlLiIsdGhpcyksdGhpcy5ib3VuZGluZ1NwaGVyZS5zZXQobmV3IEEsMS8wKTtyZXR1cm59aWYodCl7Y29uc3Qgcz10aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtpZihndC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHQpLGUpZm9yKGxldCBpPTAsbz1lLmxlbmd0aDtpPG87aSsrKXtjb25zdCBhPWVbaV07c3Muc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShhKSx0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPyhpdC5hZGRWZWN0b3JzKGd0Lm1pbixzcy5taW4pLGd0LmV4cGFuZEJ5UG9pbnQoaXQpLGl0LmFkZFZlY3RvcnMoZ3QubWF4LHNzLm1heCksZ3QuZXhwYW5kQnlQb2ludChpdCkpOihndC5leHBhbmRCeVBvaW50KHNzLm1pbiksZ3QuZXhwYW5kQnlQb2ludChzcy5tYXgpKX1ndC5nZXRDZW50ZXIocyk7bGV0IG49MDtmb3IobGV0IGk9MCxvPXQuY291bnQ7aTxvO2krKylpdC5mcm9tQnVmZmVyQXR0cmlidXRlKHQsaSksbj1NYXRoLm1heChuLHMuZGlzdGFuY2VUb1NxdWFyZWQoaXQpKTtpZihlKWZvcihsZXQgaT0wLG89ZS5sZW5ndGg7aTxvO2krKyl7Y29uc3QgYT1lW2ldLGM9dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtmb3IobGV0IHU9MCxoPWEuY291bnQ7dTxoO3UrKylpdC5mcm9tQnVmZmVyQXR0cmlidXRlKGEsdSksYyYmKEVlLmZyb21CdWZmZXJBdHRyaWJ1dGUodCx1KSxpdC5hZGQoRWUpKSxuPU1hdGgubWF4KG4scy5kaXN0YW5jZVRvU3F1YXJlZChpdCkpfXRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzPU1hdGguc3FydChuKSxpc05hTih0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cykmJmNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgInBvc2l0aW9uIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLHRoaXMpfX1jb21wdXRlVGFuZ2VudHMoKXtjb25zdCB0PXRoaXMuaW5kZXgsZT10aGlzLmF0dHJpYnV0ZXM7aWYodD09PW51bGx8fGUucG9zaXRpb249PT12b2lkIDB8fGUubm9ybWFsPT09dm9pZCAwfHxlLnV2PT09dm9pZCAwKXtjb25zb2xlLmVycm9yKCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGZhaWxlZC4gTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1dikiKTtyZXR1cm59Y29uc3Qgcz1lLnBvc2l0aW9uLG49ZS5ub3JtYWwsaT1lLnV2O3RoaXMuaGFzQXR0cmlidXRlKCJ0YW5nZW50Iik9PT0hMSYmdGhpcy5zZXRBdHRyaWJ1dGUoInRhbmdlbnQiLG5ldyB2dChuZXcgRmxvYXQzMkFycmF5KDQqcy5jb3VudCksNCkpO2NvbnN0IG89dGhpcy5nZXRBdHRyaWJ1dGUoInRhbmdlbnQiKSxhPVtdLGM9W107Zm9yKGxldCBFPTA7RTxzLmNvdW50O0UrKylhW0VdPW5ldyBBLGNbRV09bmV3IEE7Y29uc3QgdT1uZXcgQSxoPW5ldyBBLGw9bmV3IEEsZD1uZXcgSixmPW5ldyBKLHA9bmV3IEosbT1uZXcgQSxnPW5ldyBBO2Z1bmN0aW9uIHkoRSxGLFIpe3UuZnJvbUJ1ZmZlckF0dHJpYnV0ZShzLEUpLGguZnJvbUJ1ZmZlckF0dHJpYnV0ZShzLEYpLGwuZnJvbUJ1ZmZlckF0dHJpYnV0ZShzLFIpLGQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLEUpLGYuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLEYpLHAuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLFIpLGguc3ViKHUpLGwuc3ViKHUpLGYuc3ViKGQpLHAuc3ViKGQpO2NvbnN0IEk9MS8oZi54KnAueS1wLngqZi55KTtpc0Zpbml0ZShJKSYmKG0uY29weShoKS5tdWx0aXBseVNjYWxhcihwLnkpLmFkZFNjYWxlZFZlY3RvcihsLC1mLnkpLm11bHRpcGx5U2NhbGFyKEkpLGcuY29weShsKS5tdWx0aXBseVNjYWxhcihmLngpLmFkZFNjYWxlZFZlY3RvcihoLC1wLngpLm11bHRpcGx5U2NhbGFyKEkpLGFbRV0uYWRkKG0pLGFbRl0uYWRkKG0pLGFbUl0uYWRkKG0pLGNbRV0uYWRkKGcpLGNbRl0uYWRkKGcpLGNbUl0uYWRkKGcpKX1sZXQgVD10aGlzLmdyb3VwcztULmxlbmd0aD09PTAmJihUPVt7c3RhcnQ6MCxjb3VudDp0LmNvdW50fV0pO2ZvcihsZXQgRT0wLEY9VC5sZW5ndGg7RTxGOysrRSl7Y29uc3QgUj1UW0VdLEk9Ui5zdGFydCxCPVIuY291bnQ7Zm9yKGxldCBQPUksTD1JK0I7UDxMO1ArPTMpeSh0LmdldFgoUCswKSx0LmdldFgoUCsxKSx0LmdldFgoUCsyKSl9Y29uc3Qgdz1uZXcgQSxNPW5ldyBBLE49bmV3IEEsXz1uZXcgQTtmdW5jdGlvbiBTKEUpe04uZnJvbUJ1ZmZlckF0dHJpYnV0ZShuLEUpLF8uY29weShOKTtjb25zdCBGPWFbRV07dy5jb3B5KEYpLHcuc3ViKE4ubXVsdGlwbHlTY2FsYXIoTi5kb3QoRikpKS5ub3JtYWxpemUoKSxNLmNyb3NzVmVjdG9ycyhfLEYpO2NvbnN0IEk9TS5kb3QoY1tFXSk8MD8tMToxO28uc2V0WFlaVyhFLHcueCx3Lnksdy56LEkpfWZvcihsZXQgRT0wLEY9VC5sZW5ndGg7RTxGOysrRSl7Y29uc3QgUj1UW0VdLEk9Ui5zdGFydCxCPVIuY291bnQ7Zm9yKGxldCBQPUksTD1JK0I7UDxMO1ArPTMpUyh0LmdldFgoUCswKSksUyh0LmdldFgoUCsxKSksUyh0LmdldFgoUCsyKSl9fWNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCl7Y29uc3QgdD10aGlzLmluZGV4LGU9dGhpcy5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7aWYoZSE9PXZvaWQgMCl7bGV0IHM9dGhpcy5nZXRBdHRyaWJ1dGUoIm5vcm1hbCIpO2lmKHM9PT12b2lkIDApcz1uZXcgdnQobmV3IEZsb2F0MzJBcnJheShlLmNvdW50KjMpLDMpLHRoaXMuc2V0QXR0cmlidXRlKCJub3JtYWwiLHMpO2Vsc2UgZm9yKGxldCBkPTAsZj1zLmNvdW50O2Q8ZjtkKyspcy5zZXRYWVooZCwwLDAsMCk7Y29uc3Qgbj1uZXcgQSxpPW5ldyBBLG89bmV3IEEsYT1uZXcgQSxjPW5ldyBBLHU9bmV3IEEsaD1uZXcgQSxsPW5ldyBBO2lmKHQpZm9yKGxldCBkPTAsZj10LmNvdW50O2Q8ZjtkKz0zKXtjb25zdCBwPXQuZ2V0WChkKzApLG09dC5nZXRYKGQrMSksZz10LmdldFgoZCsyKTtuLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxwKSxpLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxtKSxvLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxnKSxoLnN1YlZlY3RvcnMobyxpKSxsLnN1YlZlY3RvcnMobixpKSxoLmNyb3NzKGwpLGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShzLHApLGMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShzLG0pLHUuZnJvbUJ1ZmZlckF0dHJpYnV0ZShzLGcpLGEuYWRkKGgpLGMuYWRkKGgpLHUuYWRkKGgpLHMuc2V0WFlaKHAsYS54LGEueSxhLnopLHMuc2V0WFlaKG0sYy54LGMueSxjLnopLHMuc2V0WFlaKGcsdS54LHUueSx1LnopfWVsc2UgZm9yKGxldCBkPTAsZj1lLmNvdW50O2Q8ZjtkKz0zKW4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLGQrMCksaS5mcm9tQnVmZmVyQXR0cmlidXRlKGUsZCsxKSxvLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxkKzIpLGguc3ViVmVjdG9ycyhvLGkpLGwuc3ViVmVjdG9ycyhuLGkpLGguY3Jvc3MobCkscy5zZXRYWVooZCswLGgueCxoLnksaC56KSxzLnNldFhZWihkKzEsaC54LGgueSxoLnopLHMuc2V0WFlaKGQrMixoLngsaC55LGgueik7dGhpcy5ub3JtYWxpemVOb3JtYWxzKCkscy5uZWVkc1VwZGF0ZT0hMH19bm9ybWFsaXplTm9ybWFscygpe2NvbnN0IHQ9dGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtmb3IobGV0IGU9MCxzPXQuY291bnQ7ZTxzO2UrKylpdC5mcm9tQnVmZmVyQXR0cmlidXRlKHQsZSksaXQubm9ybWFsaXplKCksdC5zZXRYWVooZSxpdC54LGl0LnksaXQueil9dG9Ob25JbmRleGVkKCl7ZnVuY3Rpb24gdChhLGMpe2NvbnN0IHU9YS5hcnJheSxoPWEuaXRlbVNpemUsbD1hLm5vcm1hbGl6ZWQsZD1uZXcgdS5jb25zdHJ1Y3RvcihjLmxlbmd0aCpoKTtsZXQgZj0wLHA9MDtmb3IobGV0IG09MCxnPWMubGVuZ3RoO208ZzttKyspe2EuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT9mPWNbbV0qYS5kYXRhLnN0cmlkZSthLm9mZnNldDpmPWNbbV0qaDtmb3IobGV0IHk9MDt5PGg7eSsrKWRbcCsrXT11W2YrK119cmV0dXJuIG5ldyB2dChkLGgsbCl9aWYodGhpcy5pbmRleD09PW51bGwpcmV0dXJuIGNvbnNvbGUud2FybigiVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEJ1ZmZlckdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuIiksdGhpcztjb25zdCBlPW5ldyBHbixzPXRoaXMuaW5kZXguYXJyYXksbj10aGlzLmF0dHJpYnV0ZXM7Zm9yKGNvbnN0IGEgaW4gbil7Y29uc3QgYz1uW2FdLHU9dChjLHMpO2Uuc2V0QXR0cmlidXRlKGEsdSl9Y29uc3QgaT10aGlzLm1vcnBoQXR0cmlidXRlcztmb3IoY29uc3QgYSBpbiBpKXtjb25zdCBjPVtdLHU9aVthXTtmb3IobGV0IGg9MCxsPXUubGVuZ3RoO2g8bDtoKyspe2NvbnN0IGQ9dVtoXSxmPXQoZCxzKTtjLnB1c2goZil9ZS5tb3JwaEF0dHJpYnV0ZXNbYV09Y31lLm1vcnBoVGFyZ2V0c1JlbGF0aXZlPXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7Y29uc3Qgbz10aGlzLmdyb3Vwcztmb3IobGV0IGE9MCxjPW8ubGVuZ3RoO2E8YzthKyspe2NvbnN0IHU9b1thXTtlLmFkZEdyb3VwKHUuc3RhcnQsdS5jb3VudCx1Lm1hdGVyaWFsSW5kZXgpfXJldHVybiBlfXRvSlNPTigpe2NvbnN0IHQ9e21ldGFkYXRhOnt2ZXJzaW9uOjQuNix0eXBlOiJCdWZmZXJHZW9tZXRyeSIsZ2VuZXJhdG9yOiJCdWZmZXJHZW9tZXRyeS50b0pTT04ifX07aWYodC51dWlkPXRoaXMudXVpZCx0LnR5cGU9dGhpcy50eXBlLHRoaXMubmFtZSE9PSIiJiYodC5uYW1lPXRoaXMubmFtZSksT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoPjAmJih0LnVzZXJEYXRhPXRoaXMudXNlckRhdGEpLHRoaXMucGFyYW1ldGVycyE9PXZvaWQgMCl7Y29uc3QgYz10aGlzLnBhcmFtZXRlcnM7Zm9yKGNvbnN0IHUgaW4gYyljW3VdIT09dm9pZCAwJiYodFt1XT1jW3VdKTtyZXR1cm4gdH10LmRhdGE9e2F0dHJpYnV0ZXM6e319O2NvbnN0IGU9dGhpcy5pbmRleDtlIT09bnVsbCYmKHQuZGF0YS5pbmRleD17dHlwZTplLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsYXJyYXk6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5hcnJheSl9KTtjb25zdCBzPXRoaXMuYXR0cmlidXRlcztmb3IoY29uc3QgYyBpbiBzKXtjb25zdCB1PXNbY107dC5kYXRhLmF0dHJpYnV0ZXNbY109dS50b0pTT04odC5kYXRhKX1jb25zdCBuPXt9O2xldCBpPSExO2Zvcihjb25zdCBjIGluIHRoaXMubW9ycGhBdHRyaWJ1dGVzKXtjb25zdCB1PXRoaXMubW9ycGhBdHRyaWJ1dGVzW2NdLGg9W107Zm9yKGxldCBsPTAsZD11Lmxlbmd0aDtsPGQ7bCsrKXtjb25zdCBmPXVbbF07aC5wdXNoKGYudG9KU09OKHQuZGF0YSkpfWgubGVuZ3RoPjAmJihuW2NdPWgsaT0hMCl9aSYmKHQuZGF0YS5tb3JwaEF0dHJpYnV0ZXM9bix0LmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmU9dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSk7Y29uc3Qgbz10aGlzLmdyb3VwcztvLmxlbmd0aD4wJiYodC5kYXRhLmdyb3Vwcz1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKSk7Y29uc3QgYT10aGlzLmJvdW5kaW5nU3BoZXJlO3JldHVybiBhIT09bnVsbCYmKHQuZGF0YS5ib3VuZGluZ1NwaGVyZT17Y2VudGVyOmEuY2VudGVyLnRvQXJyYXkoKSxyYWRpdXM6YS5yYWRpdXN9KSx0fWNsb25lKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKX1jb3B5KHQpe3RoaXMuaW5kZXg9bnVsbCx0aGlzLmF0dHJpYnV0ZXM9e30sdGhpcy5tb3JwaEF0dHJpYnV0ZXM9e30sdGhpcy5ncm91cHM9W10sdGhpcy5ib3VuZGluZ0JveD1udWxsLHRoaXMuYm91bmRpbmdTcGhlcmU9bnVsbDtjb25zdCBlPXt9O3RoaXMubmFtZT10Lm5hbWU7Y29uc3Qgcz10LmluZGV4O3MhPT1udWxsJiZ0aGlzLnNldEluZGV4KHMuY2xvbmUoZSkpO2NvbnN0IG49dC5hdHRyaWJ1dGVzO2Zvcihjb25zdCB1IGluIG4pe2NvbnN0IGg9blt1XTt0aGlzLnNldEF0dHJpYnV0ZSh1LGguY2xvbmUoZSkpfWNvbnN0IGk9dC5tb3JwaEF0dHJpYnV0ZXM7Zm9yKGNvbnN0IHUgaW4gaSl7Y29uc3QgaD1bXSxsPWlbdV07Zm9yKGxldCBkPTAsZj1sLmxlbmd0aDtkPGY7ZCsrKWgucHVzaChsW2RdLmNsb25lKGUpKTt0aGlzLm1vcnBoQXR0cmlidXRlc1t1XT1ofXRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU9dC5tb3JwaFRhcmdldHNSZWxhdGl2ZTtjb25zdCBvPXQuZ3JvdXBzO2ZvcihsZXQgdT0wLGg9by5sZW5ndGg7dTxoO3UrKyl7Y29uc3QgbD1vW3VdO3RoaXMuYWRkR3JvdXAobC5zdGFydCxsLmNvdW50LGwubWF0ZXJpYWxJbmRleCl9Y29uc3QgYT10LmJvdW5kaW5nQm94O2EhPT1udWxsJiYodGhpcy5ib3VuZGluZ0JveD1hLmNsb25lKCkpO2NvbnN0IGM9dC5ib3VuZGluZ1NwaGVyZTtyZXR1cm4gYyE9PW51bGwmJih0aGlzLmJvdW5kaW5nU3BoZXJlPWMuY2xvbmUoKSksdGhpcy5kcmF3UmFuZ2Uuc3RhcnQ9dC5kcmF3UmFuZ2Uuc3RhcnQsdGhpcy5kcmF3UmFuZ2UuY291bnQ9dC5kcmF3UmFuZ2UuY291bnQsdGhpcy51c2VyRGF0YT10LnVzZXJEYXRhLHRoaXN9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzcG9zZSJ9KX19Y29uc3QgV249bmV3IEEsVGE9bmV3IEEsTmE9bmV3IEN0O2NsYXNzIFhue2NvbnN0cnVjdG9yKHQ9bmV3IEEoMSwwLDApLGU9MCl7dGhpcy5pc1BsYW5lPSEwLHRoaXMubm9ybWFsPXQsdGhpcy5jb25zdGFudD1lfXNldCh0LGUpe3JldHVybiB0aGlzLm5vcm1hbC5jb3B5KHQpLHRoaXMuY29uc3RhbnQ9ZSx0aGlzfXNldENvbXBvbmVudHModCxlLHMsbil7cmV0dXJuIHRoaXMubm9ybWFsLnNldCh0LGUscyksdGhpcy5jb25zdGFudD1uLHRoaXN9c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWwuY29weSh0KSx0aGlzLmNvbnN0YW50PS1lLmRvdCh0aGlzLm5vcm1hbCksdGhpc31zZXRGcm9tQ29wbGFuYXJQb2ludHModCxlLHMpe2NvbnN0IG49V24uc3ViVmVjdG9ycyhzLGUpLmNyb3NzKFRhLnN1YlZlY3RvcnModCxlKSkubm9ybWFsaXplKCk7cmV0dXJuIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQobix0KSx0aGlzfWNvcHkodCl7cmV0dXJuIHRoaXMubm9ybWFsLmNvcHkodC5ub3JtYWwpLHRoaXMuY29uc3RhbnQ9dC5jb25zdGFudCx0aGlzfW5vcm1hbGl6ZSgpe2NvbnN0IHQ9MS90aGlzLm5vcm1hbC5sZW5ndGgoKTtyZXR1cm4gdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIodCksdGhpcy5jb25zdGFudCo9dCx0aGlzfW5lZ2F0ZSgpe3JldHVybiB0aGlzLmNvbnN0YW50Kj0tMSx0aGlzLm5vcm1hbC5uZWdhdGUoKSx0aGlzfWRpc3RhbmNlVG9Qb2ludCh0KXtyZXR1cm4gdGhpcy5ub3JtYWwuZG90KHQpK3RoaXMuY29uc3RhbnR9ZGlzdGFuY2VUb1NwaGVyZSh0KXtyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQodC5jZW50ZXIpLXQucmFkaXVzfXByb2plY3RQb2ludCh0LGUpe3JldHVybiBlLmNvcHkodCkuYWRkU2NhbGVkVmVjdG9yKHRoaXMubm9ybWFsLC10aGlzLmRpc3RhbmNlVG9Qb2ludCh0KSl9aW50ZXJzZWN0TGluZSh0LGUpe2NvbnN0IHM9dC5kZWx0YShXbiksbj10aGlzLm5vcm1hbC5kb3Qocyk7aWYobj09PTApcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KHQuc3RhcnQpPT09MD9lLmNvcHkodC5zdGFydCk6bnVsbDtjb25zdCBpPS0odC5zdGFydC5kb3QodGhpcy5ub3JtYWwpK3RoaXMuY29uc3RhbnQpL247cmV0dXJuIGk8MHx8aT4xP251bGw6ZS5jb3B5KHQuc3RhcnQpLmFkZFNjYWxlZFZlY3RvcihzLGkpfWludGVyc2VjdHNMaW5lKHQpe2NvbnN0IGU9dGhpcy5kaXN0YW5jZVRvUG9pbnQodC5zdGFydCkscz10aGlzLmRpc3RhbmNlVG9Qb2ludCh0LmVuZCk7cmV0dXJuIGU8MCYmcz4wfHxzPDAmJmU+MH1pbnRlcnNlY3RzQm94KHQpe3JldHVybiB0LmludGVyc2VjdHNQbGFuZSh0aGlzKX1pbnRlcnNlY3RzU3BoZXJlKHQpe3JldHVybiB0LmludGVyc2VjdHNQbGFuZSh0aGlzKX1jb3BsYW5hclBvaW50KHQpe3JldHVybiB0LmNvcHkodGhpcy5ub3JtYWwpLm11bHRpcGx5U2NhbGFyKC10aGlzLmNvbnN0YW50KX1hcHBseU1hdHJpeDQodCxlKXtjb25zdCBzPWV8fE5hLmdldE5vcm1hbE1hdHJpeCh0KSxuPXRoaXMuY29wbGFuYXJQb2ludChXbikuYXBwbHlNYXRyaXg0KHQpLGk9dGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKHMpLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzLmNvbnN0YW50PS1uLmRvdChpKSx0aGlzfXRyYW5zbGF0ZSh0KXtyZXR1cm4gdGhpcy5jb25zdGFudC09dC5kb3QodGhpcy5ub3JtYWwpLHRoaXN9ZXF1YWxzKHQpe3JldHVybiB0Lm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpJiZ0LmNvbnN0YW50PT09dGhpcy5jb25zdGFudH1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyl9fWNsYXNzIHhyIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IodCxlLHMsbixpLG8sYSxjLHUsaD1Tbil7aWYoaCE9PVNuJiZoIT09WGkpdGhyb3cgbmV3IEVycm9yKCJEZXB0aFRleHR1cmUgZm9ybWF0IG11c3QgYmUgZWl0aGVyIFRIUkVFLkRlcHRoRm9ybWF0IG9yIFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdCIpO3M9PT12b2lkIDAmJmg9PT1TbiYmKHM9V2kpLHM9PT12b2lkIDAmJmg9PT1YaSYmKHM9UG8pLHN1cGVyKG51bGwsbixpLG8sYSxjLGgscyx1KSx0aGlzLmlzRGVwdGhUZXh0dXJlPSEwLHRoaXMuaW1hZ2U9e3dpZHRoOnQsaGVpZ2h0OmV9LHRoaXMubWFnRmlsdGVyPWEhPT12b2lkIDA/YTp6cyx0aGlzLm1pbkZpbHRlcj1jIT09dm9pZCAwP2M6enMsdGhpcy5mbGlwWT0hMSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmNvbXBhcmVGdW5jdGlvbj1udWxsfWNvcHkodCl7cmV0dXJuIHN1cGVyLmNvcHkodCksdGhpcy5jb21wYXJlRnVuY3Rpb249dC5jb21wYXJlRnVuY3Rpb24sdGhpc310b0pTT04odCl7Y29uc3QgZT1zdXBlci50b0pTT04odCk7cmV0dXJuIHRoaXMuY29tcGFyZUZ1bmN0aW9uIT09bnVsbCYmKGUuY29tcGFyZUZ1bmN0aW9uPXRoaXMuY29tcGFyZUZ1bmN0aW9uKSxlfX1jbGFzcyB3YXtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuaXNJbnRlcmxlYXZlZEJ1ZmZlcj0hMCx0aGlzLmFycmF5PXQsdGhpcy5zdHJpZGU9ZSx0aGlzLmNvdW50PXQhPT12b2lkIDA/dC5sZW5ndGgvZTowLHRoaXMudXNhZ2U9Q3MsdGhpcy51cGRhdGVSYW5nZXM9W10sdGhpcy52ZXJzaW9uPTAsdGhpcy51dWlkPUt0KCl9b25VcGxvYWRDYWxsYmFjaygpe31zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiZ0aGlzLnZlcnNpb24rK31zZXRVc2FnZSh0KXtyZXR1cm4gdGhpcy51c2FnZT10LHRoaXN9YWRkVXBkYXRlUmFuZ2UodCxlKXt0aGlzLnVwZGF0ZVJhbmdlcy5wdXNoKHtzdGFydDp0LGNvdW50OmV9KX1jbGVhclVwZGF0ZVJhbmdlcygpe3RoaXMudXBkYXRlUmFuZ2VzLmxlbmd0aD0wfWNvcHkodCl7cmV0dXJuIHRoaXMuYXJyYXk9bmV3IHQuYXJyYXkuY29uc3RydWN0b3IodC5hcnJheSksdGhpcy5jb3VudD10LmNvdW50LHRoaXMuc3RyaWRlPXQuc3RyaWRlLHRoaXMudXNhZ2U9dC51c2FnZSx0aGlzfWNvcHlBdCh0LGUscyl7dCo9dGhpcy5zdHJpZGUscyo9ZS5zdHJpZGU7Zm9yKGxldCBuPTAsaT10aGlzLnN0cmlkZTtuPGk7bisrKXRoaXMuYXJyYXlbdCtuXT1lLmFycmF5W3Mrbl07cmV0dXJuIHRoaXN9c2V0KHQsZT0wKXtyZXR1cm4gdGhpcy5hcnJheS5zZXQodCxlKSx0aGlzfWNsb25lKHQpe3QuYXJyYXlCdWZmZXJzPT09dm9pZCAwJiYodC5hcnJheUJ1ZmZlcnM9e30pLHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkPT09dm9pZCAwJiYodGhpcy5hcnJheS5idWZmZXIuX3V1aWQ9S3QoKSksdC5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdPT09dm9pZCAwJiYodC5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdPXRoaXMuYXJyYXkuc2xpY2UoMCkuYnVmZmVyKTtjb25zdCBlPW5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKHQuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSkscz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihlLHRoaXMuc3RyaWRlKTtyZXR1cm4gcy5zZXRVc2FnZSh0aGlzLnVzYWdlKSxzfW9uVXBsb2FkKHQpe3JldHVybiB0aGlzLm9uVXBsb2FkQ2FsbGJhY2s9dCx0aGlzfXRvSlNPTih0KXtyZXR1cm4gdC5hcnJheUJ1ZmZlcnM9PT12b2lkIDAmJih0LmFycmF5QnVmZmVycz17fSksdGhpcy5hcnJheS5idWZmZXIuX3V1aWQ9PT12b2lkIDAmJih0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZD1LdCgpKSx0LmFycmF5QnVmZmVyc1t0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZF09PT12b2lkIDAmJih0LmFycmF5QnVmZmVyc1t0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZF09QXJyYXkuZnJvbShuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheS5idWZmZXIpKSkse3V1aWQ6dGhpcy51dWlkLGJ1ZmZlcjp0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCx0eXBlOnRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxzdHJpZGU6dGhpcy5zdHJpZGV9fX1jb25zdCB1dD1uZXcgQTtjbGFzcyBZbntjb25zdHJ1Y3Rvcih0LGUscyxuPSExKXt0aGlzLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU9ITAsdGhpcy5uYW1lPSIiLHRoaXMuZGF0YT10LHRoaXMuaXRlbVNpemU9ZSx0aGlzLm9mZnNldD1zLHRoaXMubm9ybWFsaXplZD1ufWdldCBjb3VudCgpe3JldHVybiB0aGlzLmRhdGEuY291bnR9Z2V0IGFycmF5KCl7cmV0dXJuIHRoaXMuZGF0YS5hcnJheX1zZXQgbmVlZHNVcGRhdGUodCl7dGhpcy5kYXRhLm5lZWRzVXBkYXRlPXR9YXBwbHlNYXRyaXg0KHQpe2ZvcihsZXQgZT0wLHM9dGhpcy5kYXRhLmNvdW50O2U8cztlKyspdXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLGUpLHV0LmFwcGx5TWF0cml4NCh0KSx0aGlzLnNldFhZWihlLHV0LngsdXQueSx1dC56KTtyZXR1cm4gdGhpc31hcHBseU5vcm1hbE1hdHJpeCh0KXtmb3IobGV0IGU9MCxzPXRoaXMuY291bnQ7ZTxzO2UrKyl1dC5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsZSksdXQuYXBwbHlOb3JtYWxNYXRyaXgodCksdGhpcy5zZXRYWVooZSx1dC54LHV0LnksdXQueik7cmV0dXJuIHRoaXN9dHJhbnNmb3JtRGlyZWN0aW9uKHQpe2ZvcihsZXQgZT0wLHM9dGhpcy5jb3VudDtlPHM7ZSsrKXV0LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcyxlKSx1dC50cmFuc2Zvcm1EaXJlY3Rpb24odCksdGhpcy5zZXRYWVooZSx1dC54LHV0LnksdXQueik7cmV0dXJuIHRoaXN9Z2V0Q29tcG9uZW50KHQsZSl7bGV0IHM9dGhpcy5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrZV07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKHM9RXQocyx0aGlzLmFycmF5KSksc31zZXRDb21wb25lbnQodCxlLHMpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihzPSQocyx0aGlzLmFycmF5KSksdGhpcy5kYXRhLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldCtlXT1zLHRoaXN9c2V0WCh0LGUpe3JldHVybiB0aGlzLm5vcm1hbGl6ZWQmJihlPSQoZSx0aGlzLmFycmF5KSksdGhpcy5kYXRhLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldF09ZSx0aGlzfXNldFkodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT0kKGUsdGhpcy5hcnJheSkpLHRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrMV09ZSx0aGlzfXNldFoodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT0kKGUsdGhpcy5hcnJheSkpLHRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrMl09ZSx0aGlzfXNldFcodCxlKXtyZXR1cm4gdGhpcy5ub3JtYWxpemVkJiYoZT0kKGUsdGhpcy5hcnJheSkpLHRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrM109ZSx0aGlzfWdldFgodCl7bGV0IGU9dGhpcy5kYXRhLmFycmF5W3QqdGhpcy5kYXRhLnN0cmlkZSt0aGlzLm9mZnNldF07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9RXQoZSx0aGlzLmFycmF5KSksZX1nZXRZKHQpe2xldCBlPXRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrMV07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9RXQoZSx0aGlzLmFycmF5KSksZX1nZXRaKHQpe2xldCBlPXRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrMl07cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9RXQoZSx0aGlzLmFycmF5KSksZX1nZXRXKHQpe2xldCBlPXRoaXMuZGF0YS5hcnJheVt0KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQrM107cmV0dXJuIHRoaXMubm9ybWFsaXplZCYmKGU9RXQoZSx0aGlzLmFycmF5KSksZX1zZXRYWSh0LGUscyl7cmV0dXJuIHQ9dCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0LHRoaXMubm9ybWFsaXplZCYmKGU9JChlLHRoaXMuYXJyYXkpLHM9JChzLHRoaXMuYXJyYXkpKSx0aGlzLmRhdGEuYXJyYXlbdCswXT1lLHRoaXMuZGF0YS5hcnJheVt0KzFdPXMsdGhpc31zZXRYWVoodCxlLHMsbil7cmV0dXJuIHQ9dCp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0LHRoaXMubm9ybWFsaXplZCYmKGU9JChlLHRoaXMuYXJyYXkpLHM9JChzLHRoaXMuYXJyYXkpLG49JChuLHRoaXMuYXJyYXkpKSx0aGlzLmRhdGEuYXJyYXlbdCswXT1lLHRoaXMuZGF0YS5hcnJheVt0KzFdPXMsdGhpcy5kYXRhLmFycmF5W3QrMl09bix0aGlzfXNldFhZWlcodCxlLHMsbixpKXtyZXR1cm4gdD10KnRoaXMuZGF0YS5zdHJpZGUrdGhpcy5vZmZzZXQsdGhpcy5ub3JtYWxpemVkJiYoZT0kKGUsdGhpcy5hcnJheSkscz0kKHMsdGhpcy5hcnJheSksbj0kKG4sdGhpcy5hcnJheSksaT0kKGksdGhpcy5hcnJheSkpLHRoaXMuZGF0YS5hcnJheVt0KzBdPWUsdGhpcy5kYXRhLmFycmF5W3QrMV09cyx0aGlzLmRhdGEuYXJyYXlbdCsyXT1uLHRoaXMuZGF0YS5hcnJheVt0KzNdPWksdGhpc31jbG9uZSh0KXtpZih0PT09dm9pZCAwKXtjb25zb2xlLmxvZygiVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuY2xvbmUoKTogQ2xvbmluZyBhbiBpbnRlcmxlYXZlZCBidWZmZXIgYXR0cmlidXRlIHdpbGwgZGUtaW50ZXJsZWF2ZSBidWZmZXIgZGF0YS4iKTtjb25zdCBlPVtdO2ZvcihsZXQgcz0wO3M8dGhpcy5jb3VudDtzKyspe2NvbnN0IG49cyp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0O2ZvcihsZXQgaT0wO2k8dGhpcy5pdGVtU2l6ZTtpKyspZS5wdXNoKHRoaXMuZGF0YS5hcnJheVtuK2ldKX1yZXR1cm4gbmV3IHZ0KG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKGUpLHRoaXMuaXRlbVNpemUsdGhpcy5ub3JtYWxpemVkKX1lbHNlIHJldHVybiB0LmludGVybGVhdmVkQnVmZmVycz09PXZvaWQgMCYmKHQuaW50ZXJsZWF2ZWRCdWZmZXJzPXt9KSx0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF09PT12b2lkIDAmJih0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF09dGhpcy5kYXRhLmNsb25lKHQpKSxuZXcgWW4odC5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdLHRoaXMuaXRlbVNpemUsdGhpcy5vZmZzZXQsdGhpcy5ub3JtYWxpemVkKX10b0pTT04odCl7aWYodD09PXZvaWQgMCl7Y29uc29sZS5sb2coIlRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnRvSlNPTigpOiBTZXJpYWxpemluZyBhbiBpbnRlcmxlYXZlZCBidWZmZXIgYXR0cmlidXRlIHdpbGwgZGUtaW50ZXJsZWF2ZSBidWZmZXIgZGF0YS4iKTtjb25zdCBlPVtdO2ZvcihsZXQgcz0wO3M8dGhpcy5jb3VudDtzKyspe2NvbnN0IG49cyp0aGlzLmRhdGEuc3RyaWRlK3RoaXMub2Zmc2V0O2ZvcihsZXQgaT0wO2k8dGhpcy5pdGVtU2l6ZTtpKyspZS5wdXNoKHRoaXMuZGF0YS5hcnJheVtuK2ldKX1yZXR1cm57aXRlbVNpemU6dGhpcy5pdGVtU2l6ZSx0eXBlOnRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxhcnJheTplLG5vcm1hbGl6ZWQ6dGhpcy5ub3JtYWxpemVkfX1lbHNlIHJldHVybiB0LmludGVybGVhdmVkQnVmZmVycz09PXZvaWQgMCYmKHQuaW50ZXJsZWF2ZWRCdWZmZXJzPXt9KSx0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF09PT12b2lkIDAmJih0LmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF09dGhpcy5kYXRhLnRvSlNPTih0KSkse2lzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6ITAsaXRlbVNpemU6dGhpcy5pdGVtU2l6ZSxkYXRhOnRoaXMuZGF0YS51dWlkLG9mZnNldDp0aGlzLm9mZnNldCxub3JtYWxpemVkOnRoaXMubm9ybWFsaXplZH19fWNsYXNzIEFhIGV4dGVuZHMgRHR7Y29uc3RydWN0b3IodCxlKXtzdXBlcih7d2lkdGg6dCxoZWlnaHQ6ZX0pLHRoaXMuaXNGcmFtZWJ1ZmZlclRleHR1cmU9ITAsdGhpcy5tYWdGaWx0ZXI9enMsdGhpcy5taW5GaWx0ZXI9enMsdGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITEsdGhpcy5uZWVkc1VwZGF0ZT0hMH19Y29uc3QgVHI9bmV3IEEsRHM9bmV3IEE7Y2xhc3MgWnR7Y29uc3RydWN0b3IodD1uZXcgQSxlPW5ldyBBKXt0aGlzLnN0YXJ0PXQsdGhpcy5lbmQ9ZX1zZXQodCxlKXtyZXR1cm4gdGhpcy5zdGFydC5jb3B5KHQpLHRoaXMuZW5kLmNvcHkoZSksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLnN0YXJ0LmNvcHkodC5zdGFydCksdGhpcy5lbmQuY29weSh0LmVuZCksdGhpc31nZXRDZW50ZXIodCl7cmV0dXJuIHQuYWRkVmVjdG9ycyh0aGlzLnN0YXJ0LHRoaXMuZW5kKS5tdWx0aXBseVNjYWxhciguNSl9ZGVsdGEodCl7cmV0dXJuIHQuc3ViVmVjdG9ycyh0aGlzLmVuZCx0aGlzLnN0YXJ0KX1kaXN0YW5jZVNxKCl7cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5lbmQpfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyh0aGlzLmVuZCl9YXQodCxlKXtyZXR1cm4gdGhpcy5kZWx0YShlKS5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy5zdGFydCl9Y2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcih0LGUpe1RyLnN1YlZlY3RvcnModCx0aGlzLnN0YXJ0KSxEcy5zdWJWZWN0b3JzKHRoaXMuZW5kLHRoaXMuc3RhcnQpO2NvbnN0IHM9RHMuZG90KERzKTtsZXQgaT1Ecy5kb3QoVHIpL3M7cmV0dXJuIGUmJihpPWF0KGksMCwxKSksaX1jbG9zZXN0UG9pbnRUb1BvaW50KHQsZSxzKXtjb25zdCBuPXRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcih0LGUpO3JldHVybiB0aGlzLmRlbHRhKHMpLm11bHRpcGx5U2NhbGFyKG4pLmFkZCh0aGlzLnN0YXJ0KX1hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KHQpLHRoaXMuZW5kLmFwcGx5TWF0cml4NCh0KSx0aGlzfWVxdWFscyh0KXtyZXR1cm4gdC5zdGFydC5lcXVhbHModGhpcy5zdGFydCkmJnQuZW5kLmVxdWFscyh0aGlzLmVuZCl9Y2xvbmUoKXtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpfX1mdW5jdGlvbiBabihyLHQ9MCl7bGV0IGU9MzczNTkyODU1OV50LHM9MTEwMzU0Nzk5MV50O2lmKHIgaW5zdGFuY2VvZiBBcnJheSlmb3IobGV0IG49MCxpO248ci5sZW5ndGg7bisrKWk9cltuXSxlPU1hdGguaW11bChlXmksMjY1NDQzNTc2MSkscz1NYXRoLmltdWwoc15pLDE1OTczMzQ2NzcpO2Vsc2UgZm9yKGxldCBuPTAsaTtuPHIubGVuZ3RoO24rKylpPXIuY2hhckNvZGVBdChuKSxlPU1hdGguaW11bChlXmksMjY1NDQzNTc2MSkscz1NYXRoLmltdWwoc15pLDE1OTczMzQ2NzcpO3JldHVybiBlPU1hdGguaW11bChlXmU+Pj4xNiwyMjQ2ODIyNTA3KSxlXj1NYXRoLmltdWwoc15zPj4+MTMsMzI2NjQ4OTkwOSkscz1NYXRoLmltdWwoc15zPj4+MTYsMjI0NjgyMjUwNyksc149TWF0aC5pbXVsKGVeZT4+PjEzLDMyNjY0ODk5MDkpLDQyOTQ5NjcyOTYqKDIwOTcxNTEmcykrKGU+Pj4wKX1jb25zdCBNYT0oLi4ucik9PlpuKHIpO2Z1bmN0aW9uIFNhKHIsdD0hMSl7Y29uc3QgZT1bXTtyLmlzTm9kZT09PSEwJiYoZS5wdXNoKHIuaWQpLHI9ci5nZXRTZWxmKCkpO2Zvcihjb25zdHtwcm9wZXJ0eTpzLGNoaWxkTm9kZTpufW9mIEpuKHIpKWUucHVzaChlLFpuKHMuc2xpY2UoMCwtNCkpLG4uZ2V0Q2FjaGVLZXkodCkpO3JldHVybiBabihlKX1mdW5jdGlvbipKbihyLHQ9ITEpe2Zvcihjb25zdCBlIGluIHIpe2lmKGUuc3RhcnRzV2l0aCgiXyIpPT09ITApY29udGludWU7Y29uc3Qgcz1yW2VdO2lmKEFycmF5LmlzQXJyYXkocyk9PT0hMClmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKyl7Y29uc3QgaT1zW25dO2kmJihpLmlzTm9kZT09PSEwfHx0JiZ0eXBlb2YgaS50b0pTT049PSJmdW5jdGlvbiIpJiYoeWllbGR7cHJvcGVydHk6ZSxpbmRleDpuLGNoaWxkTm9kZTppfSl9ZWxzZSBpZihzJiZzLmlzTm9kZT09PSEwKXlpZWxke3Byb3BlcnR5OmUsY2hpbGROb2RlOnN9O2Vsc2UgaWYodHlwZW9mIHM9PSJvYmplY3QiKWZvcihjb25zdCBuIGluIHMpe2NvbnN0IGk9c1tuXTtpJiYoaS5pc05vZGU9PT0hMHx8dCYmdHlwZW9mIGkudG9KU09OPT0iZnVuY3Rpb24iKSYmKHlpZWxke3Byb3BlcnR5OmUsaW5kZXg6bixjaGlsZE5vZGU6aX0pfX19ZnVuY3Rpb24gVnMocil7aWYocj09bnVsbClyZXR1cm4gbnVsbDtjb25zdCB0PXR5cGVvZiByO3JldHVybiByLmlzTm9kZT09PSEwPyJub2RlIjp0PT09Im51bWJlciI/ImZsb2F0Ijp0PT09ImJvb2xlYW4iPyJib29sIjp0PT09InN0cmluZyI/InN0cmluZyI6dD09PSJmdW5jdGlvbiI/InNoYWRlciI6ci5pc1ZlY3RvcjI9PT0hMD8idmVjMiI6ci5pc1ZlY3RvcjM9PT0hMD8idmVjMyI6ci5pc1ZlY3RvcjQ9PT0hMD8idmVjNCI6ci5pc01hdHJpeDM9PT0hMD8ibWF0MyI6ci5pc01hdHJpeDQ9PT0hMD8ibWF0NCI6ci5pc0NvbG9yPT09ITA/ImNvbG9yIjpyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/IkFycmF5QnVmZmVyIjpudWxsfWZ1bmN0aW9uIE5yKHIsLi4udCl7Y29uc3QgZT1yP3Iuc2xpY2UoLTQpOnZvaWQgMDtyZXR1cm4gdC5sZW5ndGg9PT0xJiYoZT09PSJ2ZWMyIj90PVt0WzBdLHRbMF1dOmU9PT0idmVjMyI/dD1bdFswXSx0WzBdLHRbMF1dOmU9PT0idmVjNCImJih0PVt0WzBdLHRbMF0sdFswXSx0WzBdXSkpLHI9PT0iY29sb3IiP25ldyBxbiguLi50KTplPT09InZlYzIiP25ldyBKKC4uLnQpOmU9PT0idmVjMyI/bmV3IEEoLi4udCk6ZT09PSJ2ZWM0Ij9uZXcgRnQoLi4udCk6ZT09PSJtYXQzIj9uZXcgQ3QoLi4udCk6ZT09PSJtYXQ0Ij9uZXcgbnQoLi4udCk6cj09PSJib29sIj90WzBdfHwhMTpyPT09ImZsb2F0Inx8cj09PSJpbnQifHxyPT09InVpbnQiP3RbMF18fDA6cj09PSJzdHJpbmciP3RbMF18fCIiOnI9PT0iQXJyYXlCdWZmZXIiP3phKHRbMF0pOm51bGx9ZnVuY3Rpb24gX2Eocil7bGV0IHQ9IiI7Y29uc3QgZT1uZXcgVWludDhBcnJheShyKTtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbc10pO3JldHVybiBidG9hKHQpfWZ1bmN0aW9uIHphKHIpe3JldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihyKSx0PT50LmNoYXJDb2RlQXQoMCkpLmJ1ZmZlcn1jb25zdCB3cj17VkVSVEVYOiJ2ZXJ0ZXgiLEZSQUdNRU5UOiJmcmFnbWVudCJ9LFE9e05PTkU6Im5vbmUiLEZSQU1FOiJmcmFtZSIsUkVOREVSOiJyZW5kZXIiLE9CSkVDVDoib2JqZWN0In0sbnM9WyJ4IiwieSIsInoiLCJ3Il07bGV0IGJhPTA7Y2xhc3MgVSBleHRlbmRzIFple3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJOb2RlIn1jb25zdHJ1Y3Rvcih0PW51bGwpe3N1cGVyKCksdGhpcy5ub2RlVHlwZT10LHRoaXMudXBkYXRlVHlwZT1RLk5PTkUsdGhpcy51cGRhdGVCZWZvcmVUeXBlPVEuTk9ORSx0aGlzLnVwZGF0ZUFmdGVyVHlwZT1RLk5PTkUsdGhpcy51dWlkPWVhLmdlbmVyYXRlVVVJRCgpLHRoaXMudmVyc2lvbj0wLHRoaXMuX2NhY2hlS2V5PW51bGwsdGhpcy5fY2FjaGVLZXlWZXJzaW9uPTAsdGhpcy5nbG9iYWw9ITEsdGhpcy5pc05vZGU9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImlkIix7dmFsdWU6YmErK30pfXNldCBuZWVkc1VwZGF0ZSh0KXt0PT09ITAmJnRoaXMudmVyc2lvbisrfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZX1vblVwZGF0ZSh0LGUpe3JldHVybiB0aGlzLnVwZGF0ZVR5cGU9ZSx0aGlzLnVwZGF0ZT10LmJpbmQodGhpcy5nZXRTZWxmKCkpLHRoaXN9b25GcmFtZVVwZGF0ZSh0KXtyZXR1cm4gdGhpcy5vblVwZGF0ZSh0LFEuRlJBTUUpfW9uUmVuZGVyVXBkYXRlKHQpe3JldHVybiB0aGlzLm9uVXBkYXRlKHQsUS5SRU5ERVIpfW9uT2JqZWN0VXBkYXRlKHQpe3JldHVybiB0aGlzLm9uVXBkYXRlKHQsUS5PQkpFQ1QpfW9uUmVmZXJlbmNlKHQpe3JldHVybiB0aGlzLnVwZGF0ZVJlZmVyZW5jZT10LmJpbmQodGhpcy5nZXRTZWxmKCkpLHRoaXN9Z2V0U2VsZigpe3JldHVybiB0aGlzLnNlbGZ8fHRoaXN9dXBkYXRlUmVmZXJlbmNlKCl7cmV0dXJuIHRoaXN9aXNHbG9iYWwoKXtyZXR1cm4gdGhpcy5nbG9iYWx9KmdldENoaWxkcmVuKCl7Zm9yKGNvbnN0e2NoaWxkTm9kZTp0fW9mIEpuKHRoaXMpKXlpZWxkIHR9ZGlzcG9zZSgpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZToiZGlzcG9zZSJ9KX10cmF2ZXJzZSh0KXt0KHRoaXMpO2Zvcihjb25zdCBlIG9mIHRoaXMuZ2V0Q2hpbGRyZW4oKSllLnRyYXZlcnNlKHQpfWdldENhY2hlS2V5KHQ9ITEpe3JldHVybiB0PXR8fHRoaXMudmVyc2lvbiE9PXRoaXMuX2NhY2hlS2V5VmVyc2lvbiwodD09PSEwfHx0aGlzLl9jYWNoZUtleT09PW51bGwpJiYodGhpcy5fY2FjaGVLZXk9U2EodGhpcyx0KSx0aGlzLl9jYWNoZUtleVZlcnNpb249dGhpcy52ZXJzaW9uKSx0aGlzLl9jYWNoZUtleX1nZXRTY29wZSgpe3JldHVybiB0aGlzfWdldEhhc2goKXtyZXR1cm4gdGhpcy51dWlkfWdldFVwZGF0ZVR5cGUoKXtyZXR1cm4gdGhpcy51cGRhdGVUeXBlfWdldFVwZGF0ZUJlZm9yZVR5cGUoKXtyZXR1cm4gdGhpcy51cGRhdGVCZWZvcmVUeXBlfWdldFVwZGF0ZUFmdGVyVHlwZSgpe3JldHVybiB0aGlzLnVwZGF0ZUFmdGVyVHlwZX1nZXRFbGVtZW50VHlwZSh0KXtjb25zdCBlPXRoaXMuZ2V0Tm9kZVR5cGUodCk7cmV0dXJuIHQuZ2V0RWxlbWVudFR5cGUoZSl9Z2V0Tm9kZVR5cGUodCl7Y29uc3QgZT10LmdldE5vZGVQcm9wZXJ0aWVzKHRoaXMpO3JldHVybiBlLm91dHB1dE5vZGU/ZS5vdXRwdXROb2RlLmdldE5vZGVUeXBlKHQpOnRoaXMubm9kZVR5cGV9Z2V0U2hhcmVkKHQpe2NvbnN0IGU9dGhpcy5nZXRIYXNoKHQpO3JldHVybiB0LmdldE5vZGVGcm9tSGFzaChlKXx8dGhpc31zZXR1cCh0KXtjb25zdCBlPXQuZ2V0Tm9kZVByb3BlcnRpZXModGhpcyk7bGV0IHM9MDtmb3IoY29uc3QgbiBvZiB0aGlzLmdldENoaWxkcmVuKCkpZVsibm9kZSIrcysrXT1uO3JldHVybiBudWxsfWFuYWx5emUodCl7aWYodC5pbmNyZWFzZVVzYWdlKHRoaXMpPT09MSl7Y29uc3Qgcz10LmdldE5vZGVQcm9wZXJ0aWVzKHRoaXMpO2Zvcihjb25zdCBuIG9mIE9iamVjdC52YWx1ZXMocykpbiYmbi5pc05vZGU9PT0hMCYmbi5idWlsZCh0KX19Z2VuZXJhdGUodCxlKXtjb25zdHtvdXRwdXROb2RlOnN9PXQuZ2V0Tm9kZVByb3BlcnRpZXModGhpcyk7aWYocyYmcy5pc05vZGU9PT0hMClyZXR1cm4gcy5idWlsZCh0LGUpfXVwZGF0ZUJlZm9yZSgpe2NvbnNvbGUud2FybigiQWJzdHJhY3QgZnVuY3Rpb24uIil9dXBkYXRlQWZ0ZXIoKXtjb25zb2xlLndhcm4oIkFic3RyYWN0IGZ1bmN0aW9uLiIpfXVwZGF0ZSgpe2NvbnNvbGUud2FybigiQWJzdHJhY3QgZnVuY3Rpb24uIil9YnVpbGQodCxlPW51bGwpe2NvbnN0IHM9dGhpcy5nZXRTaGFyZWQodCk7aWYodGhpcyE9PXMpcmV0dXJuIHMuYnVpbGQodCxlKTt0LmFkZE5vZGUodGhpcyksdC5hZGRDaGFpbih0aGlzKTtsZXQgbj1udWxsO2NvbnN0IGk9dC5nZXRCdWlsZFN0YWdlKCk7aWYoaT09PSJzZXR1cCIpe3RoaXMudXBkYXRlUmVmZXJlbmNlKHQpO2NvbnN0IG89dC5nZXROb2RlUHJvcGVydGllcyh0aGlzKTtpZihvLmluaXRpYWxpemVkIT09ITApe2NvbnN0IGE9dC5zdGFjay5ub2Rlcy5sZW5ndGg7by5pbml0aWFsaXplZD0hMCxvLm91dHB1dE5vZGU9dGhpcy5zZXR1cCh0KSxvLm91dHB1dE5vZGUhPT1udWxsJiZ0LnN0YWNrLm5vZGVzLmxlbmd0aDtmb3IoY29uc3QgYyBvZiBPYmplY3QudmFsdWVzKG8pKWMmJmMuaXNOb2RlPT09ITAmJmMuYnVpbGQodCl9fWVsc2UgaWYoaT09PSJhbmFseXplIil0aGlzLmFuYWx5emUodCk7ZWxzZSBpZihpPT09ImdlbmVyYXRlIilpZih0aGlzLmdlbmVyYXRlLmxlbmd0aD09PTEpe2NvbnN0IGE9dGhpcy5nZXROb2RlVHlwZSh0KSxjPXQuZ2V0RGF0YUZyb21Ob2RlKHRoaXMpO249Yy5zbmlwcGV0LG49PT12b2lkIDA/KG49dGhpcy5nZW5lcmF0ZSh0KXx8IiIsYy5zbmlwcGV0PW4pOmMuZmxvd0NvZGVzIT09dm9pZCAwJiZ0LmNvbnRleHQubm9kZUJsb2NrIT09dm9pZCAwJiZ0LmFkZEZsb3dDb2RlSGllcmFyY2h5KHRoaXMsdC5jb250ZXh0Lm5vZGVCbG9jayksbj10LmZvcm1hdChuLGEsZSl9ZWxzZSBuPXRoaXMuZ2VuZXJhdGUodCxlKXx8IiI7cmV0dXJuIHQucmVtb3ZlQ2hhaW4odGhpcyksbn1nZXRTZXJpYWxpemVDaGlsZHJlbigpe3JldHVybiBKbih0aGlzKX1zZXJpYWxpemUodCl7Y29uc3QgZT10aGlzLmdldFNlcmlhbGl6ZUNoaWxkcmVuKCkscz17fTtmb3IoY29uc3R7cHJvcGVydHk6bixpbmRleDppLGNoaWxkTm9kZTpvfW9mIGUpaSE9PXZvaWQgMD8oc1tuXT09PXZvaWQgMCYmKHNbbl09TnVtYmVyLmlzSW50ZWdlcihpKT9bXTp7fSksc1tuXVtpXT1vLnRvSlNPTih0Lm1ldGEpLnV1aWQpOnNbbl09by50b0pTT04odC5tZXRhKS51dWlkO09iamVjdC5rZXlzKHMpLmxlbmd0aD4wJiYodC5pbnB1dE5vZGVzPXMpfWRlc2VyaWFsaXplKHQpe2lmKHQuaW5wdXROb2RlcyE9PXZvaWQgMCl7Y29uc3QgZT10Lm1ldGEubm9kZXM7Zm9yKGNvbnN0IHMgaW4gdC5pbnB1dE5vZGVzKWlmKEFycmF5LmlzQXJyYXkodC5pbnB1dE5vZGVzW3NdKSl7Y29uc3Qgbj1bXTtmb3IoY29uc3QgaSBvZiB0LmlucHV0Tm9kZXNbc10pbi5wdXNoKGVbaV0pO3RoaXNbc109bn1lbHNlIGlmKHR5cGVvZiB0LmlucHV0Tm9kZXNbc109PSJvYmplY3QiKXtjb25zdCBuPXt9O2Zvcihjb25zdCBpIGluIHQuaW5wdXROb2Rlc1tzXSl7Y29uc3Qgbz10LmlucHV0Tm9kZXNbc11baV07bltpXT1lW29dfXRoaXNbc109bn1lbHNle2NvbnN0IG49dC5pbnB1dE5vZGVzW3NdO3RoaXNbc109ZVtuXX19fXRvSlNPTih0KXtjb25zdHt1dWlkOmUsdHlwZTpzfT10aGlzLG49dD09PXZvaWQgMHx8dHlwZW9mIHQ9PSJzdHJpbmciO24mJih0PXt0ZXh0dXJlczp7fSxpbWFnZXM6e30sbm9kZXM6e319KTtsZXQgaT10Lm5vZGVzW2VdO2k9PT12b2lkIDAmJihpPXt1dWlkOmUsdHlwZTpzLG1ldGE6dCxtZXRhZGF0YTp7dmVyc2lvbjo0LjYsdHlwZToiTm9kZSIsZ2VuZXJhdG9yOiJOb2RlLnRvSlNPTiJ9fSxuIT09ITAmJih0Lm5vZGVzW2kudXVpZF09aSksdGhpcy5zZXJpYWxpemUoaSksZGVsZXRlIGkubWV0YSk7ZnVuY3Rpb24gbyhhKXtjb25zdCBjPVtdO2Zvcihjb25zdCB1IGluIGEpe2NvbnN0IGg9YVt1XTtkZWxldGUgaC5tZXRhZGF0YSxjLnB1c2goaCl9cmV0dXJuIGN9aWYobil7Y29uc3QgYT1vKHQudGV4dHVyZXMpLGM9byh0LmltYWdlcyksdT1vKHQubm9kZXMpO2EubGVuZ3RoPjAmJihpLnRleHR1cmVzPWEpLGMubGVuZ3RoPjAmJihpLmltYWdlcz1jKSx1Lmxlbmd0aD4wJiYoaS5ub2Rlcz11KX1yZXR1cm4gaX19Y2xhc3MgaXMgZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJBcnJheUVsZW1lbnROb2RlIn1jb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpcy5ub2RlPXQsdGhpcy5pbmRleE5vZGU9ZSx0aGlzLmlzQXJyYXlFbGVtZW50Tm9kZT0hMH1nZXROb2RlVHlwZSh0KXtyZXR1cm4gdGhpcy5ub2RlLmdldEVsZW1lbnRUeXBlKHQpfWdlbmVyYXRlKHQpe2NvbnN0IGU9dGhpcy5ub2RlLmJ1aWxkKHQpLHM9dGhpcy5pbmRleE5vZGUuYnVpbGQodCwidWludCIpO3JldHVybmAke2V9WyAke3N9IF1gfX1jbGFzcyBBciBleHRlbmRzIFV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIkNvbnZlcnROb2RlIn1jb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpcy5ub2RlPXQsdGhpcy5jb252ZXJ0VG89ZX1nZXROb2RlVHlwZSh0KXtjb25zdCBlPXRoaXMubm9kZS5nZXROb2RlVHlwZSh0KTtsZXQgcz1udWxsO2Zvcihjb25zdCBuIG9mIHRoaXMuY29udmVydFRvLnNwbGl0KCJ8IikpKHM9PT1udWxsfHx0LmdldFR5cGVMZW5ndGgoZSk9PT10LmdldFR5cGVMZW5ndGgobikpJiYocz1uKTtyZXR1cm4gc31zZXJpYWxpemUodCl7c3VwZXIuc2VyaWFsaXplKHQpLHQuY29udmVydFRvPXRoaXMuY29udmVydFRvfWRlc2VyaWFsaXplKHQpe3N1cGVyLmRlc2VyaWFsaXplKHQpLHRoaXMuY29udmVydFRvPXQuY29udmVydFRvfWdlbmVyYXRlKHQsZSl7Y29uc3Qgcz10aGlzLm5vZGUsbj10aGlzLmdldE5vZGVUeXBlKHQpLGk9cy5idWlsZCh0LG4pO3JldHVybiB0LmZvcm1hdChpLG4sZSl9fWNsYXNzIGR0IGV4dGVuZHMgVXtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iVGVtcE5vZGUifWNvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuaXNUZW1wTm9kZT0hMH1oYXNEZXBlbmRlbmNpZXModCl7cmV0dXJuIHQuZ2V0RGF0YUZyb21Ob2RlKHRoaXMpLnVzYWdlQ291bnQ+MX1idWlsZCh0LGUpe2lmKHQuZ2V0QnVpbGRTdGFnZSgpPT09ImdlbmVyYXRlIil7Y29uc3Qgbj10LmdldFZlY3RvclR5cGUodGhpcy5nZXROb2RlVHlwZSh0LGUpKSxpPXQuZ2V0RGF0YUZyb21Ob2RlKHRoaXMpO2lmKGkucHJvcGVydHlOYW1lIT09dm9pZCAwKXJldHVybiB0LmZvcm1hdChpLnByb3BlcnR5TmFtZSxuLGUpO2lmKG4hPT0idm9pZCImJmUhPT0idm9pZCImJnRoaXMuaGFzRGVwZW5kZW5jaWVzKHQpKXtjb25zdCBvPXN1cGVyLmJ1aWxkKHQsbiksYT10LmdldFZhckZyb21Ob2RlKHRoaXMsbnVsbCxuKSxjPXQuZ2V0UHJvcGVydHlOYW1lKGEpO3JldHVybiB0LmFkZExpbmVGbG93Q29kZShgJHtjfSA9ICR7b31gLHRoaXMpLGkuc25pcHBldD1vLGkucHJvcGVydHlOYW1lPWMsdC5mb3JtYXQoaS5wcm9wZXJ0eU5hbWUsbixlKX19cmV0dXJuIHN1cGVyLmJ1aWxkKHQsZSl9fWNsYXNzIEVhIGV4dGVuZHMgZHR7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIkpvaW5Ob2RlIn1jb25zdHJ1Y3Rvcih0PVtdLGU9bnVsbCl7c3VwZXIoZSksdGhpcy5ub2Rlcz10fWdldE5vZGVUeXBlKHQpe3JldHVybiB0aGlzLm5vZGVUeXBlIT09bnVsbD90LmdldFZlY3RvclR5cGUodGhpcy5ub2RlVHlwZSk6dC5nZXRUeXBlRnJvbUxlbmd0aCh0aGlzLm5vZGVzLnJlZHVjZSgoZSxzKT0+ZSt0LmdldFR5cGVMZW5ndGgocy5nZXROb2RlVHlwZSh0KSksMCkpfWdlbmVyYXRlKHQsZSl7Y29uc3Qgcz10aGlzLmdldE5vZGVUeXBlKHQpLG49dGhpcy5ub2RlcyxpPXQuZ2V0Q29tcG9uZW50VHlwZShzKSxvPVtdO2Zvcihjb25zdCBjIG9mIG4pe2xldCB1PWMuYnVpbGQodCk7Y29uc3QgaD10LmdldENvbXBvbmVudFR5cGUoYy5nZXROb2RlVHlwZSh0KSk7aCE9PWkmJih1PXQuZm9ybWF0KHUsaCxpKSksby5wdXNoKHUpfWNvbnN0IGE9YCR7dC5nZXRUeXBlKHMpfSggJHtvLmpvaW4oIiwgIil9IClgO3JldHVybiB0LmZvcm1hdChhLHMsZSl9fWNvbnN0IENhPW5zLmpvaW4oIiIpO2NsYXNzIE1yIGV4dGVuZHMgVXtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iU3BsaXROb2RlIn1jb25zdHJ1Y3Rvcih0LGU9IngiKXtzdXBlcigpLHRoaXMubm9kZT10LHRoaXMuY29tcG9uZW50cz1lLHRoaXMuaXNTcGxpdE5vZGU9ITB9Z2V0VmVjdG9yTGVuZ3RoKCl7bGV0IHQ9dGhpcy5jb21wb25lbnRzLmxlbmd0aDtmb3IoY29uc3QgZSBvZiB0aGlzLmNvbXBvbmVudHMpdD1NYXRoLm1heChucy5pbmRleE9mKGUpKzEsdCk7cmV0dXJuIHR9Z2V0Q29tcG9uZW50VHlwZSh0KXtyZXR1cm4gdC5nZXRDb21wb25lbnRUeXBlKHRoaXMubm9kZS5nZXROb2RlVHlwZSh0KSl9Z2V0Tm9kZVR5cGUodCl7cmV0dXJuIHQuZ2V0VHlwZUZyb21MZW5ndGgodGhpcy5jb21wb25lbnRzLmxlbmd0aCx0aGlzLmdldENvbXBvbmVudFR5cGUodCkpfWdlbmVyYXRlKHQsZSl7Y29uc3Qgcz10aGlzLm5vZGUsbj10LmdldFR5cGVMZW5ndGgocy5nZXROb2RlVHlwZSh0KSk7bGV0IGk9bnVsbDtpZihuPjEpe2xldCBvPW51bGw7dGhpcy5nZXRWZWN0b3JMZW5ndGgoKT49biYmKG89dC5nZXRUeXBlRnJvbUxlbmd0aCh0aGlzLmdldFZlY3Rvckxlbmd0aCgpLHRoaXMuZ2V0Q29tcG9uZW50VHlwZSh0KSkpO2NvbnN0IGM9cy5idWlsZCh0LG8pO3RoaXMuY29tcG9uZW50cy5sZW5ndGg9PT1uJiZ0aGlzLmNvbXBvbmVudHM9PT1DYS5zbGljZSgwLHRoaXMuY29tcG9uZW50cy5sZW5ndGgpP2k9dC5mb3JtYXQoYyxvLGUpOmk9dC5mb3JtYXQoYCR7Y30uJHt0aGlzLmNvbXBvbmVudHN9YCx0aGlzLmdldE5vZGVUeXBlKHQpLGUpfWVsc2UgaT1zLmJ1aWxkKHQsZSk7cmV0dXJuIGl9c2VyaWFsaXplKHQpe3N1cGVyLnNlcmlhbGl6ZSh0KSx0LmNvbXBvbmVudHM9dGhpcy5jb21wb25lbnRzfWRlc2VyaWFsaXplKHQpe3N1cGVyLmRlc2VyaWFsaXplKHQpLHRoaXMuY29tcG9uZW50cz10LmNvbXBvbmVudHN9fWNsYXNzIEZhIGV4dGVuZHMgZHR7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlNldE5vZGUifWNvbnN0cnVjdG9yKHQsZSxzKXtzdXBlcigpLHRoaXMuc291cmNlTm9kZT10LHRoaXMuY29tcG9uZW50cz1lLHRoaXMudGFyZ2V0Tm9kZT1zfWdldE5vZGVUeXBlKHQpe3JldHVybiB0aGlzLnNvdXJjZU5vZGUuZ2V0Tm9kZVR5cGUodCl9Z2VuZXJhdGUodCl7Y29uc3R7c291cmNlTm9kZTplLGNvbXBvbmVudHM6cyx0YXJnZXROb2RlOm59PXRoaXMsaT10aGlzLmdldE5vZGVUeXBlKHQpLG89dC5nZXRUeXBlRnJvbUxlbmd0aChzLmxlbmd0aCxuLmdldE5vZGVUeXBlKHQpKSxhPW4uYnVpbGQodCxvKSxjPWUuYnVpbGQodCxpKSx1PXQuZ2V0VHlwZUxlbmd0aChpKSxoPVtdO2ZvcihsZXQgbD0wO2w8dTtsKyspe2NvbnN0IGQ9bnNbbF07ZD09PXNbMF0/KGgucHVzaChhKSxsKz1zLmxlbmd0aC0xKTpoLnB1c2goYysiLiIrZCl9cmV0dXJuYCR7dC5nZXRUeXBlKGkpfSggJHtoLmpvaW4oIiwgIil9IClgfX1jbGFzcyBSYSBleHRlbmRzIGR0e3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJGbGlwTm9kZSJ9Y29uc3RydWN0b3IodCxlKXtzdXBlcigpLHRoaXMuc291cmNlTm9kZT10LHRoaXMuY29tcG9uZW50cz1lfWdldE5vZGVUeXBlKHQpe3JldHVybiB0aGlzLnNvdXJjZU5vZGUuZ2V0Tm9kZVR5cGUodCl9Z2VuZXJhdGUodCl7Y29uc3R7Y29tcG9uZW50czplLHNvdXJjZU5vZGU6c309dGhpcyxuPXRoaXMuZ2V0Tm9kZVR5cGUodCksaT1zLmJ1aWxkKHQpLG89dC5nZXRWYXJGcm9tTm9kZSh0aGlzKSxhPXQuZ2V0UHJvcGVydHlOYW1lKG8pO3QuYWRkTGluZUZsb3dDb2RlKGErIiA9ICIraSx0aGlzKTtjb25zdCBjPXQuZ2V0VHlwZUxlbmd0aChuKSx1PVtdO2xldCBoPTA7Zm9yKGxldCBsPTA7bDxjO2wrKyl7Y29uc3QgZD1uc1tsXTtkPT09ZVtoXT8odS5wdXNoKCIxLjAgLSAiKyhhKyIuIitkKSksaCsrKTp1LnB1c2goYSsiLiIrZCl9cmV0dXJuYCR7dC5nZXRUeXBlKG4pfSggJHt1LmpvaW4oIiwgIil9IClgfX1jbGFzcyBqbiBleHRlbmRzIFV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIklucHV0Tm9kZSJ9Y29uc3RydWN0b3IodCxlPW51bGwpe3N1cGVyKGUpLHRoaXMuaXNJbnB1dE5vZGU9ITAsdGhpcy52YWx1ZT10LHRoaXMucHJlY2lzaW9uPW51bGx9Z2V0Tm9kZVR5cGUoKXtyZXR1cm4gdGhpcy5ub2RlVHlwZT09PW51bGw/VnModGhpcy52YWx1ZSk6dGhpcy5ub2RlVHlwZX1nZXRJbnB1dFR5cGUodCl7cmV0dXJuIHRoaXMuZ2V0Tm9kZVR5cGUodCl9c2V0UHJlY2lzaW9uKHQpe3JldHVybiB0aGlzLnByZWNpc2lvbj10LHRoaXN9c2VyaWFsaXplKHQpe3N1cGVyLnNlcmlhbGl6ZSh0KSx0LnZhbHVlPXRoaXMudmFsdWUsdGhpcy52YWx1ZSYmdGhpcy52YWx1ZS50b0FycmF5JiYodC52YWx1ZT10aGlzLnZhbHVlLnRvQXJyYXkoKSksdC52YWx1ZVR5cGU9VnModGhpcy52YWx1ZSksdC5ub2RlVHlwZT10aGlzLm5vZGVUeXBlLHQudmFsdWVUeXBlPT09IkFycmF5QnVmZmVyIiYmKHQudmFsdWU9X2EodC52YWx1ZSkpLHQucHJlY2lzaW9uPXRoaXMucHJlY2lzaW9ufWRlc2VyaWFsaXplKHQpe3N1cGVyLmRlc2VyaWFsaXplKHQpLHRoaXMubm9kZVR5cGU9dC5ub2RlVHlwZSx0aGlzLnZhbHVlPUFycmF5LmlzQXJyYXkodC52YWx1ZSk/TnIodC52YWx1ZVR5cGUsLi4udC52YWx1ZSk6dC52YWx1ZSx0aGlzLnByZWNpc2lvbj10LnByZWNpc2lvbnx8bnVsbCx0aGlzLnZhbHVlJiZ0aGlzLnZhbHVlLmZyb21BcnJheSYmKHRoaXMudmFsdWU9dGhpcy52YWx1ZS5mcm9tQXJyYXkodC52YWx1ZSkpfWdlbmVyYXRlKCl7Y29uc29sZS53YXJuKCJBYnN0cmFjdCBmdW5jdGlvbi4iKX19Y2xhc3MgSnQgZXh0ZW5kcyBqbntzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iQ29uc3ROb2RlIn1jb25zdHJ1Y3Rvcih0LGU9bnVsbCl7c3VwZXIodCxlKSx0aGlzLmlzQ29uc3ROb2RlPSEwfWdlbmVyYXRlQ29uc3QodCl7cmV0dXJuIHQuZ2VuZXJhdGVDb25zdCh0aGlzLmdldE5vZGVUeXBlKHQpLHRoaXMudmFsdWUpfWdlbmVyYXRlKHQsZSl7Y29uc3Qgcz10aGlzLmdldE5vZGVUeXBlKHQpO3JldHVybiB0LmZvcm1hdCh0aGlzLmdlbmVyYXRlQ29uc3QodCkscyxlKX19bGV0IFNyPW51bGw7Y29uc3QgQ2U9bmV3IE1hcDtmdW5jdGlvbiBiKHIsdCl7aWYoQ2UuaGFzKHIpKXtjb25zb2xlLndhcm4oYFJlZGVmaW5pdGlvbiBvZiBtZXRob2QgY2hhaW5pbmcgJHtyfWApO3JldHVybn1pZih0eXBlb2YgdCE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgRXJyb3IoYE5vZGUgZWxlbWVudCAke3J9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7Q2Uuc2V0KHIsdCl9Y29uc3QgX3I9cj0+ci5yZXBsYWNlKC9yfHMvZywieCIpLnJlcGxhY2UoL2d8dC9nLCJ5IikucmVwbGFjZSgvYnxwL2csInoiKS5yZXBsYWNlKC9hfHEvZywidyIpLHpyPXI9Pl9yKHIpLnNwbGl0KCIiKS5zb3J0KCkuam9pbigiIiksYnI9e3NldHVwKHIsdCl7Y29uc3QgZT10LnNoaWZ0KCk7cmV0dXJuIHIoSHMoZSksLi4udCl9LGdldChyLHQsZSl7aWYodHlwZW9mIHQ9PSJzdHJpbmciJiZyW3RdPT09dm9pZCAwKXtpZihyLmlzU3RhY2tOb2RlIT09ITAmJnQ9PT0iYXNzaWduIilyZXR1cm4oLi4ucyk9PihTci5hc3NpZ24oZSwuLi5zKSxlKTtpZihDZS5oYXModCkpe2NvbnN0IHM9Q2UuZ2V0KHQpO3JldHVybiByLmlzU3RhY2tOb2RlPyguLi5uKT0+ZS5hZGQocyguLi5uKSk6KC4uLm4pPT5zKGUsLi4ubil9ZWxzZXtpZih0PT09InNlbGYiKXJldHVybiByO2lmKHQuZW5kc1dpdGgoIkFzc2lnbiIpJiZDZS5oYXModC5zbGljZSgwLHQubGVuZ3RoLTYpKSl7Y29uc3Qgcz1DZS5nZXQodC5zbGljZSgwLHQubGVuZ3RoLTYpKTtyZXR1cm4gci5pc1N0YWNrTm9kZT8oLi4ubik9PmUuYXNzaWduKG5bMF0scyguLi5uKSk6KC4uLm4pPT5lLmFzc2lnbihzKGUsLi4ubikpfWVsc2V7aWYoL15beHl6d3JnYmFzdHBxXXsxLDR9JC8udGVzdCh0KT09PSEwKXJldHVybiB0PV9yKHQpLHYobmV3IE1yKGUsdCkpO2lmKC9ec2V0W1hZWldSR0JBU1RQUV17MSw0fSQvLnRlc3QodCk9PT0hMClyZXR1cm4gdD16cih0LnNsaWNlKDMpLnRvTG93ZXJDYXNlKCkpLHM9PnYobmV3IEZhKHIsdCxzKSk7aWYoL15mbGlwW1hZWldSR0JBU1RQUV17MSw0fSQvLnRlc3QodCk9PT0hMClyZXR1cm4gdD16cih0LnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpLCgpPT52KG5ldyBSYSh2KHIpLHQpKTtpZih0PT09IndpZHRoInx8dD09PSJoZWlnaHQifHx0PT09ImRlcHRoIilyZXR1cm4gdD09PSJ3aWR0aCI/dD0ieCI6dD09PSJoZWlnaHQiP3Q9InkiOnQ9PT0iZGVwdGgiJiYodD0ieiIpLHYobmV3IE1yKHIsdCkpO2lmKC9eXGQrJC8udGVzdCh0KT09PSEwKXJldHVybiB2KG5ldyBpcyhlLG5ldyBKdChOdW1iZXIodCksInVpbnQiKSkpfX19cmV0dXJuIFJlZmxlY3QuZ2V0KHIsdCxlKX0sc2V0KHIsdCxlLHMpe3JldHVybiB0eXBlb2YgdD09InN0cmluZyImJnJbdF09PT12b2lkIDAmJigvXlt4eXp3cmdiYXN0cHFdezEsNH0kLy50ZXN0KHQpPT09ITB8fHQ9PT0id2lkdGgifHx0PT09ImhlaWdodCJ8fHQ9PT0iZGVwdGgifHwvXlxkKyQvLnRlc3QodCk9PT0hMCk/KHNbdF0uYXNzaWduKGUpLCEwKTpSZWZsZWN0LnNldChyLHQsZSxzKX19LFFuPW5ldyBXZWFrTWFwLEVyPW5ldyBXZWFrTWFwLEJhPWZ1bmN0aW9uKHIsdD1udWxsKXtjb25zdCBlPVZzKHIpO2lmKGU9PT0ibm9kZSIpe2xldCBzPVFuLmdldChyKTtyZXR1cm4gcz09PXZvaWQgMCYmKHM9bmV3IFByb3h5KHIsYnIpLFFuLnNldChyLHMpLFFuLnNldChzLHMpKSxzfWVsc2V7aWYodD09PW51bGwmJihlPT09ImZsb2F0Inx8ZT09PSJib29sZWFuIil8fGUmJmUhPT0ic2hhZGVyIiYmZSE9PSJzdHJpbmciKXJldHVybiB2KHNpKHIsdCkpO2lmKGU9PT0ic2hhZGVyIilyZXR1cm4gdHQocil9cmV0dXJuIHJ9LElhPWZ1bmN0aW9uKHIsdD1udWxsKXtmb3IoY29uc3QgZSBpbiByKXJbZV09dihyW2VdLHQpO3JldHVybiByfSx2YT1mdW5jdGlvbihyLHQ9bnVsbCl7Y29uc3QgZT1yLmxlbmd0aDtmb3IobGV0IHM9MDtzPGU7cysrKXJbc109dihyW3NdLHQpO3JldHVybiByfSxQYT1mdW5jdGlvbihyLHQ9bnVsbCxlPW51bGwscz1udWxsKXtjb25zdCBuPWk9PnYocyE9PW51bGw/T2JqZWN0LmFzc2lnbihpLHMpOmkpO3JldHVybiB0PT09bnVsbD8oLi4uaSk9Pm4obmV3IHIoLi4uRmUoaSkpKTplIT09bnVsbD8oZT12KGUpLCguLi5pKT0+bihuZXcgcih0LC4uLkZlKGkpLGUpKSk6KC4uLmkpPT5uKG5ldyByKHQsLi4uRmUoaSkpKX0sTGE9ZnVuY3Rpb24ociwuLi50KXtyZXR1cm4gdihuZXcgciguLi5GZSh0KSkpfTtjbGFzcyBPYSBleHRlbmRzIFV7Y29uc3RydWN0b3IodCxlKXtzdXBlcigpLHRoaXMuc2hhZGVyTm9kZT10LHRoaXMuaW5wdXROb2Rlcz1lfWdldE5vZGVUeXBlKHQpe3JldHVybiB0aGlzLnNoYWRlck5vZGUubm9kZVR5cGV8fHRoaXMuZ2V0T3V0cHV0Tm9kZSh0KS5nZXROb2RlVHlwZSh0KX1jYWxsKHQpe2NvbnN0e3NoYWRlck5vZGU6ZSxpbnB1dE5vZGVzOnN9PXRoaXMsbj10LmdldE5vZGVQcm9wZXJ0aWVzKGUpO2lmKG4ub25jZU91dHB1dClyZXR1cm4gbi5vbmNlT3V0cHV0O2xldCBpPW51bGw7aWYoZS5sYXlvdXQpe2xldCBvPUVyLmdldCh0LmNvbnN0cnVjdG9yKTtvPT09dm9pZCAwJiYobz1uZXcgV2Vha01hcCxFci5zZXQodC5jb25zdHJ1Y3RvcixvKSk7bGV0IGE9by5nZXQoZSk7YT09PXZvaWQgMCYmKGE9dih0LmJ1aWxkRnVuY3Rpb25Ob2RlKGUpKSxvLnNldChlLGEpKSx0LmN1cnJlbnRGdW5jdGlvbk5vZGUhPT1udWxsJiZ0LmN1cnJlbnRGdW5jdGlvbk5vZGUuaW5jbHVkZXMucHVzaChhKSxpPXYoYS5jYWxsKHMpKX1lbHNle2NvbnN0IG89ZS5qc0Z1bmMsYT1zIT09bnVsbD9vKHMsdCk6byh0KTtpPXYoYSl9cmV0dXJuIGUub25jZSYmKG4ub25jZU91dHB1dD1pKSxpfWdldE91dHB1dE5vZGUodCl7Y29uc3QgZT10LmdldE5vZGVQcm9wZXJ0aWVzKHRoaXMpO3JldHVybiBlLm91dHB1dE5vZGU9PT1udWxsJiYoZS5vdXRwdXROb2RlPXRoaXMuc2V0dXBPdXRwdXQodCkpLGUub3V0cHV0Tm9kZX1zZXR1cCh0KXtyZXR1cm4gdGhpcy5nZXRPdXRwdXROb2RlKHQpfXNldHVwT3V0cHV0KHQpe3JldHVybiB0LmFkZFN0YWNrKCksdC5zdGFjay5vdXRwdXROb2RlPXRoaXMuY2FsbCh0KSx0LnJlbW92ZVN0YWNrKCl9Z2VuZXJhdGUodCxlKXtyZXR1cm4gdGhpcy5nZXRPdXRwdXROb2RlKHQpLmJ1aWxkKHQsZSl9fWNsYXNzIERhIGV4dGVuZHMgVXtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKGUpLHRoaXMuanNGdW5jPXQsdGhpcy5sYXlvdXQ9bnVsbCx0aGlzLmdsb2JhbD0hMCx0aGlzLm9uY2U9ITF9c2V0TGF5b3V0KHQpe3JldHVybiB0aGlzLmxheW91dD10LHRoaXN9Y2FsbCh0PW51bGwpe3JldHVybiBIcyh0KSx2KG5ldyBPYSh0aGlzLHQpKX1zZXR1cCgpe3JldHVybiB0aGlzLmNhbGwoKX19Y29uc3QgVmE9WyExLCEwXSxVYT1bMCwxLDIsM10sa2E9Wy0xLC0yXSxDcj1bLjUsMS41LDEvMywxZS02LDFlNixNYXRoLlBJLE1hdGguUEkqMiwxL01hdGguUEksMi9NYXRoLlBJLDEvKE1hdGguUEkqMiksTWF0aC5QSS8yXSxLbj1uZXcgTWFwO2Zvcihjb25zdCByIG9mIFZhKUtuLnNldChyLG5ldyBKdChyKSk7Y29uc3QgdGk9bmV3IE1hcDtmb3IoY29uc3QgciBvZiBVYSl0aS5zZXQocixuZXcgSnQociwidWludCIpKTtjb25zdCBlaT1uZXcgTWFwKFsuLi50aV0ubWFwKHI9Pm5ldyBKdChyLnZhbHVlLCJpbnQiKSkpO2Zvcihjb25zdCByIG9mIGthKWVpLnNldChyLG5ldyBKdChyLCJpbnQiKSk7Y29uc3QgVXM9bmV3IE1hcChbLi4uZWldLm1hcChyPT5uZXcgSnQoci52YWx1ZSkpKTtmb3IoY29uc3QgciBvZiBDcilVcy5zZXQocixuZXcgSnQocikpO2Zvcihjb25zdCByIG9mIENyKVVzLnNldCgtcixuZXcgSnQoLXIpKTtjb25zdCBrcz17Ym9vbDpLbix1aW50OnRpLGludHM6ZWksZmxvYXQ6VXN9LEZyPW5ldyBNYXAoWy4uLktuLC4uLlVzXSksc2k9KHIsdCk9PkZyLmhhcyhyKT9Gci5nZXQocik6ci5pc05vZGU9PT0hMD9yOm5ldyBKdChyLHQpLEhhPXI9Pnt0cnl7cmV0dXJuIHIuZ2V0Tm9kZVR5cGUoKX1jYXRjaHtyZXR1cm59fSxLPWZ1bmN0aW9uKHIsdD1udWxsKXtyZXR1cm4oLi4uZSk9PntpZigoZS5sZW5ndGg9PT0wfHwhWyJib29sIiwiZmxvYXQiLCJpbnQiLCJ1aW50Il0uaW5jbHVkZXMocikmJmUuZXZlcnkobj0+dHlwZW9mIG4hPSJvYmplY3QiKSkmJihlPVtOcihyLC4uLmUpXSksZS5sZW5ndGg9PT0xJiZ0IT09bnVsbCYmdC5oYXMoZVswXSkpcmV0dXJuIHYodC5nZXQoZVswXSkpO2lmKGUubGVuZ3RoPT09MSl7Y29uc3Qgbj1zaShlWzBdLHIpO3JldHVybiBIYShuKT09PXI/dihuKTp2KG5ldyBBcihuLHIpKX1jb25zdCBzPWUubWFwKG49PnNpKG4pKTtyZXR1cm4gdihuZXcgRWEocyxyKSl9fSxxYT1yPT5yIT1udWxsP3Iubm9kZVR5cGV8fHIuY29udmVydFRvfHwodHlwZW9mIHI9PSJzdHJpbmciP3I6bnVsbCk6bnVsbDtmdW5jdGlvbiAkYShyLHQpe3JldHVybiBuZXcgUHJveHkobmV3IERhKHIsdCksYnIpfWNvbnN0IHY9KHIsdD1udWxsKT0+QmEocix0KSxIcz0ocix0PW51bGwpPT5uZXcgSWEocix0KSxGZT0ocix0PW51bGwpPT5uZXcgdmEocix0KSxDPSguLi5yKT0+bmV3IFBhKC4uLnIpLE89KC4uLnIpPT5uZXcgTGEoLi4uciksdHQ9KHIsdCk9Pntjb25zdCBlPW5ldyAkYShyLHQpLHM9KC4uLm4pPT57bGV0IGk7cmV0dXJuIEhzKG4pLG5bMF0mJm5bMF0uaXNOb2RlP2k9Wy4uLm5dOmk9blswXSxlLmNhbGwoaSl9O3JldHVybiBzLnNoYWRlck5vZGU9ZSxzLnNldExheW91dD1uPT4oZS5zZXRMYXlvdXQobikscykscy5vbmNlPSgpPT4oZS5vbmNlPSEwLHMpLHN9O2IoInRvR2xvYmFsIixyPT4oci5nbG9iYWw9ITAscikpO2NvbnN0IG5pPSguLi5yKT0+U3IuSWYoLi4ucik7ZnVuY3Rpb24gR2Eocil7cmV0dXJuIHJ9YigiYXBwZW5kIixHYSk7Y29uc3QgV2E9bmV3IEsoImNvbG9yIikscT1uZXcgSygiZmxvYXQiLGtzLmZsb2F0KSxSZT1uZXcgSygiaW50Iixrcy5pbnRzKSxYYT1uZXcgSygidWludCIsa3MudWludCksWWE9bmV3IEsoImJvb2wiLGtzLmJvb2wpLEQ9bmV3IEsoInZlYzIiKSxaYT1uZXcgSygiaXZlYzIiKSxKYT1uZXcgSygidXZlYzIiKSxqYT1uZXcgSygiYnZlYzIiKSxrPW5ldyBLKCJ2ZWMzIiksUWE9bmV3IEsoIml2ZWMzIiksS2E9bmV3IEsoInV2ZWMzIiksdGM9bmV3IEsoImJ2ZWMzIiksQmU9bmV3IEsoInZlYzQiKSxlYz1uZXcgSygiaXZlYzQiKSxzYz1uZXcgSygidXZlYzQiKSxuYz1uZXcgSygiYnZlYzQiKSxScj1uZXcgSygibWF0MiIpLHFzPW5ldyBLKCJtYXQzIiksaWM9bmV3IEsoIm1hdDQiKTtiKCJ0b0NvbG9yIixXYSksYigidG9GbG9hdCIscSksYigidG9JbnQiLFJlKSxiKCJ0b1VpbnQiLFhhKSxiKCJ0b0Jvb2wiLFlhKSxiKCJ0b1ZlYzIiLEQpLGIoInRvSVZlYzIiLFphKSxiKCJ0b1VWZWMyIixKYSksYigidG9CVmVjMiIsamEpLGIoInRvVmVjMyIsayksYigidG9JVmVjMyIsUWEpLGIoInRvVVZlYzMiLEthKSxiKCJ0b0JWZWMzIix0YyksYigidG9WZWM0IixCZSksYigidG9JVmVjNCIsZWMpLGIoInRvVVZlYzQiLHNjKSxiKCJ0b0JWZWM0IixuYyksYigidG9NYXQyIixSciksYigidG9NYXQzIixxcyksYigidG9NYXQ0IixpYyk7Y29uc3QgcmM9Qyhpcyksb2M9KHIsdCk9PnYobmV3IEFyKHYociksdCkpO2IoImVsZW1lbnQiLHJjKSxiKCJjb252ZXJ0IixvYyk7Y2xhc3MgQnIgZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJVbmlmb3JtR3JvdXBOb2RlIn1jb25zdHJ1Y3Rvcih0LGU9ITEscz0xKXtzdXBlcigic3RyaW5nIiksdGhpcy5uYW1lPXQsdGhpcy52ZXJzaW9uPTAsdGhpcy5zaGFyZWQ9ZSx0aGlzLm9yZGVyPXMsdGhpcy5pc1VuaWZvcm1Hcm91cD0hMH1zZXQgbmVlZHNVcGRhdGUodCl7dD09PSEwJiZ0aGlzLnZlcnNpb24rK31zZXJpYWxpemUodCl7c3VwZXIuc2VyaWFsaXplKHQpLHQubmFtZT10aGlzLm5hbWUsdC52ZXJzaW9uPXRoaXMudmVyc2lvbix0LnNoYXJlZD10aGlzLnNoYXJlZH1kZXNlcmlhbGl6ZSh0KXtzdXBlci5kZXNlcmlhbGl6ZSh0KSx0aGlzLm5hbWU9dC5uYW1lLHRoaXMudmVyc2lvbj10LnZlcnNpb24sdGhpcy5zaGFyZWQ9dC5zaGFyZWR9fWNvbnN0IGFjPXI9Pm5ldyBCcihyKSxkZT0oKHIsdD0wKT0+bmV3IEJyKHIsITAsdCkpKCJyZW5kZXIiKSxjYz1hYygib2JqZWN0Iik7Y2xhc3MgSWUgZXh0ZW5kcyBqbntzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iVW5pZm9ybU5vZGUifWNvbnN0cnVjdG9yKHQsZT1udWxsKXtzdXBlcih0LGUpLHRoaXMuaXNVbmlmb3JtTm9kZT0hMCx0aGlzLm5hbWU9IiIsdGhpcy5ncm91cE5vZGU9Y2N9bGFiZWwodCl7cmV0dXJuIHRoaXMubmFtZT10LHRoaXN9c2V0R3JvdXAodCl7cmV0dXJuIHRoaXMuZ3JvdXBOb2RlPXQsdGhpc31nZXRHcm91cCgpe3JldHVybiB0aGlzLmdyb3VwTm9kZX1nZXRVbmlmb3JtSGFzaCh0KXtyZXR1cm4gdGhpcy5nZXRIYXNoKHQpfW9uVXBkYXRlKHQsZSl7Y29uc3Qgcz10aGlzLmdldFNlbGYoKTtyZXR1cm4gdD10LmJpbmQocyksc3VwZXIub25VcGRhdGUobj0+e2NvbnN0IGk9dChuLHMpO2khPT12b2lkIDAmJih0aGlzLnZhbHVlPWkpfSxlKX1nZW5lcmF0ZSh0LGUpe2NvbnN0IHM9dGhpcy5nZXROb2RlVHlwZSh0KSxuPXRoaXMuZ2V0VW5pZm9ybUhhc2godCk7bGV0IGk9dC5nZXROb2RlRnJvbUhhc2gobik7aT09PXZvaWQgMCYmKHQuc2V0SGFzaE5vZGUodGhpcyxuKSxpPXRoaXMpO2NvbnN0IG89aS5nZXRJbnB1dFR5cGUodCksYT10LmdldFVuaWZvcm1Gcm9tTm9kZShpLG8sdC5zaGFkZXJTdGFnZSx0aGlzLm5hbWV8fHQuY29udGV4dC5sYWJlbCksYz10LmdldFByb3BlcnR5TmFtZShhKTtyZXR1cm4gdC5jb250ZXh0LmxhYmVsIT09dm9pZCAwJiZkZWxldGUgdC5jb250ZXh0LmxhYmVsLHQuZm9ybWF0KGMscyxlKX19Y29uc3QgeHQ9KHIsdCk9Pntjb25zdCBlPXFhKHR8fHIpLHM9ciYmci5pc05vZGU9PT0hMD9yLm5vZGUmJnIubm9kZS52YWx1ZXx8ci52YWx1ZTpyO3JldHVybiB2KG5ldyBJZShzLGUpKX07Y2xhc3MgSXIgZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJQcm9wZXJ0eU5vZGUifWNvbnN0cnVjdG9yKHQsZT1udWxsLHM9ITEpe3N1cGVyKHQpLHRoaXMubmFtZT1lLHRoaXMudmFyeWluZz1zLHRoaXMuaXNQcm9wZXJ0eU5vZGU9ITB9Z2V0SGFzaCh0KXtyZXR1cm4gdGhpcy5uYW1lfHxzdXBlci5nZXRIYXNoKHQpfWlzR2xvYmFsKCl7cmV0dXJuITB9Z2VuZXJhdGUodCl7bGV0IGU7cmV0dXJuIHRoaXMudmFyeWluZz09PSEwPyhlPXQuZ2V0VmFyeWluZ0Zyb21Ob2RlKHRoaXMsdGhpcy5uYW1lKSxlLm5lZWRzSW50ZXJwb2xhdGlvbj0hMCk6ZT10LmdldFZhckZyb21Ob2RlKHRoaXMsdGhpcy5uYW1lKSx0LmdldFByb3BlcnR5TmFtZShlKX19Y29uc3QgdmU9KHIsdCk9PnYobmV3IElyKHIsdCkpLHZyPU8oSXIsInZlYzQiLCJEaWZmdXNlQ29sb3IiKTtjbGFzcyBoYyBleHRlbmRzIGR0e3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJBc3NpZ25Ob2RlIn1jb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpcy50YXJnZXROb2RlPXQsdGhpcy5zb3VyY2VOb2RlPWV9aGFzRGVwZW5kZW5jaWVzKCl7cmV0dXJuITF9Z2V0Tm9kZVR5cGUodCxlKXtyZXR1cm4gZSE9PSJ2b2lkIj90aGlzLnRhcmdldE5vZGUuZ2V0Tm9kZVR5cGUodCk6InZvaWQifW5lZWRzU3BsaXRBc3NpZ24odCl7Y29uc3R7dGFyZ2V0Tm9kZTplfT10aGlzO2lmKHQuaXNBdmFpbGFibGUoInN3aXp6bGVBc3NpZ24iKT09PSExJiZlLmlzU3BsaXROb2RlJiZlLmNvbXBvbmVudHMubGVuZ3RoPjEpe2NvbnN0IHM9dC5nZXRUeXBlTGVuZ3RoKGUubm9kZS5nZXROb2RlVHlwZSh0KSk7cmV0dXJuIG5zLmpvaW4oIiIpLnNsaWNlKDAscykhPT1lLmNvbXBvbmVudHN9cmV0dXJuITF9Z2VuZXJhdGUodCxlKXtjb25zdHt0YXJnZXROb2RlOnMsc291cmNlTm9kZTpufT10aGlzLGk9dGhpcy5uZWVkc1NwbGl0QXNzaWduKHQpLG89cy5nZXROb2RlVHlwZSh0KSxhPXMuY29udGV4dCh7YXNzaWduOiEwfSkuYnVpbGQodCksYz1uLmJ1aWxkKHQsbyksdT1uLmdldE5vZGVUeXBlKHQpLGg9dC5nZXREYXRhRnJvbU5vZGUodGhpcyk7bGV0IGw7aWYoaC5pbml0aWFsaXplZD09PSEwKWUhPT0idm9pZCImJihsPWEpO2Vsc2UgaWYoaSl7Y29uc3QgZD10LmdldFZhckZyb21Ob2RlKHRoaXMsbnVsbCxvKSxmPXQuZ2V0UHJvcGVydHlOYW1lKGQpO3QuYWRkTGluZUZsb3dDb2RlKGAke2Z9ID0gJHtjfWAsdGhpcyk7Y29uc3QgcD1zLm5vZGUuY29udGV4dCh7YXNzaWduOiEwfSkuYnVpbGQodCk7Zm9yKGxldCBtPTA7bTxzLmNvbXBvbmVudHMubGVuZ3RoO20rKyl7Y29uc3QgZz1zLmNvbXBvbmVudHNbbV07dC5hZGRMaW5lRmxvd0NvZGUoYCR7cH0uJHtnfSA9ICR7Zn1bICR7bX0gXWAsdGhpcyl9ZSE9PSJ2b2lkIiYmKGw9YSl9ZWxzZSBsPWAke2F9ID0gJHtjfWAsKGU9PT0idm9pZCJ8fHU9PT0idm9pZCIpJiYodC5hZGRMaW5lRmxvd0NvZGUobCx0aGlzKSxlIT09InZvaWQiJiYobD1hKSk7cmV0dXJuIGguaW5pdGlhbGl6ZWQ9ITAsdC5mb3JtYXQobCxvLGUpfX1iKCJhc3NpZ24iLEMoaGMpKTtjbGFzcyB1YyBleHRlbmRzIGR0e3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJGdW5jdGlvbkNhbGxOb2RlIn1jb25zdHJ1Y3Rvcih0PW51bGwsZT17fSl7c3VwZXIoKSx0aGlzLmZ1bmN0aW9uTm9kZT10LHRoaXMucGFyYW1ldGVycz1lfXNldFBhcmFtZXRlcnModCl7cmV0dXJuIHRoaXMucGFyYW1ldGVycz10LHRoaXN9Z2V0UGFyYW1ldGVycygpe3JldHVybiB0aGlzLnBhcmFtZXRlcnN9Z2V0Tm9kZVR5cGUodCl7cmV0dXJuIHRoaXMuZnVuY3Rpb25Ob2RlLmdldE5vZGVUeXBlKHQpfWdlbmVyYXRlKHQpe2NvbnN0IGU9W10scz10aGlzLmZ1bmN0aW9uTm9kZSxuPXMuZ2V0SW5wdXRzKHQpLGk9dGhpcy5wYXJhbWV0ZXJzO2lmKEFycmF5LmlzQXJyYXkoaSkpZm9yKGxldCBhPTA7YTxpLmxlbmd0aDthKyspe2NvbnN0IGM9blthXSx1PWlbYV07ZS5wdXNoKHUuYnVpbGQodCxjLnR5cGUpKX1lbHNlIGZvcihjb25zdCBhIG9mIG4pe2NvbnN0IGM9aVthLm5hbWVdO2lmKGMhPT12b2lkIDApZS5wdXNoKGMuYnVpbGQodCxhLnR5cGUpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb25DYWxsTm9kZTogSW5wdXQgJyR7YS5uYW1lfScgbm90IGZvdW5kIGluIEZ1bmN0aW9uTm9kZS5gKX1yZXR1cm5gJHtzLmJ1aWxkKHQsInByb3BlcnR5Iil9KCAke2Uuam9pbigiLCAiKX0gKWB9fWIoImNhbGwiLChyLC4uLnQpPT4odD10Lmxlbmd0aD4xfHx0WzBdJiZ0WzBdLmlzTm9kZT09PSEwP0ZlKHQpOkhzKHRbMF0pLHYobmV3IHVjKHYociksdCkpKSk7Y2xhc3MgWSBleHRlbmRzIGR0e3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJPcGVyYXRvck5vZGUifWNvbnN0cnVjdG9yKHQsZSxzLC4uLm4pe2lmKHN1cGVyKCksbi5sZW5ndGg+MCl7bGV0IGk9bmV3IFkodCxlLHMpO2ZvcihsZXQgbz0wO288bi5sZW5ndGgtMTtvKyspaT1uZXcgWSh0LGksbltvXSk7ZT1pLHM9bltuLmxlbmd0aC0xXX10aGlzLm9wPXQsdGhpcy5hTm9kZT1lLHRoaXMuYk5vZGU9c31nZXROb2RlVHlwZSh0LGUpe2NvbnN0IHM9dGhpcy5vcCxuPXRoaXMuYU5vZGUsaT10aGlzLmJOb2RlLG89bi5nZXROb2RlVHlwZSh0KSxhPXR5cGVvZiBpPCJ1Ij9pLmdldE5vZGVUeXBlKHQpOm51bGw7aWYobz09PSJ2b2lkInx8YT09PSJ2b2lkIilyZXR1cm4idm9pZCI7aWYocz09PSIlIilyZXR1cm4gbztpZihzPT09In4ifHxzPT09IiYifHxzPT09InwifHxzPT09Il4ifHxzPT09Ij4+Inx8cz09PSI8PCIpcmV0dXJuIHQuZ2V0SW50ZWdlclR5cGUobyk7aWYocz09PSIhInx8cz09PSI9PSJ8fHM9PT0iJiYifHxzPT09Inx8Inx8cz09PSJeXiIpcmV0dXJuImJvb2wiO2lmKHM9PT0iPCJ8fHM9PT0iPiJ8fHM9PT0iPD0ifHxzPT09Ij49Iil7Y29uc3QgYz1lP3QuZ2V0VHlwZUxlbmd0aChlKTpNYXRoLm1heCh0LmdldFR5cGVMZW5ndGgobyksdC5nZXRUeXBlTGVuZ3RoKGEpKTtyZXR1cm4gYz4xP2BidmVjJHtjfWA6ImJvb2wifWVsc2UgcmV0dXJuIG89PT0iZmxvYXQiJiZ0LmlzTWF0cml4KGEpP2E6dC5pc01hdHJpeChvKSYmdC5pc1ZlY3RvcihhKT90LmdldFZlY3RvckZyb21NYXRyaXgobyk6dC5pc1ZlY3RvcihvKSYmdC5pc01hdHJpeChhKT90LmdldFZlY3RvckZyb21NYXRyaXgoYSk6dC5nZXRUeXBlTGVuZ3RoKGEpPnQuZ2V0VHlwZUxlbmd0aChvKT9hOm99Z2VuZXJhdGUodCxlKXtjb25zdCBzPXRoaXMub3Asbj10aGlzLmFOb2RlLGk9dGhpcy5iTm9kZSxvPXRoaXMuZ2V0Tm9kZVR5cGUodCxlKTtsZXQgYT1udWxsLGM9bnVsbDtvIT09InZvaWQiPyhhPW4uZ2V0Tm9kZVR5cGUodCksYz10eXBlb2YgaTwidSI/aS5nZXROb2RlVHlwZSh0KTpudWxsLHM9PT0iPCJ8fHM9PT0iPiJ8fHM9PT0iPD0ifHxzPT09Ij49Inx8cz09PSI9PSI/dC5pc1ZlY3RvcihhKT9jPWE6YSE9PWMmJihhPWM9ImZsb2F0Iik6cz09PSI+PiJ8fHM9PT0iPDwiPyhhPW8sYz10LmNoYW5nZUNvbXBvbmVudFR5cGUoYywidWludCIpKTp0LmlzTWF0cml4KGEpJiZ0LmlzVmVjdG9yKGMpP2M9dC5nZXRWZWN0b3JGcm9tTWF0cml4KGEpOnQuaXNWZWN0b3IoYSkmJnQuaXNNYXRyaXgoYyk/YT10LmdldFZlY3RvckZyb21NYXRyaXgoYyk6YT1jPW8pOmE9Yz1vO2NvbnN0IHU9bi5idWlsZCh0LGEpLGg9dHlwZW9mIGk8InUiP2kuYnVpbGQodCxjKTpudWxsLGw9dC5nZXRUeXBlTGVuZ3RoKGUpLGQ9dC5nZXRGdW5jdGlvbk9wZXJhdG9yKHMpO2lmKGUhPT0idm9pZCIpcmV0dXJuIHM9PT0iPCImJmw+MT90LnVzZUNvbXBhcmlzb25NZXRob2Q/dC5mb3JtYXQoYCR7dC5nZXRNZXRob2QoImxlc3NUaGFuIixlKX0oICR7dX0sICR7aH0gKWAsbyxlKTp0LmZvcm1hdChgKCAke3V9IDwgJHtofSApYCxvLGUpOnM9PT0iPD0iJiZsPjE/dC51c2VDb21wYXJpc29uTWV0aG9kP3QuZm9ybWF0KGAke3QuZ2V0TWV0aG9kKCJsZXNzVGhhbkVxdWFsIixlKX0oICR7dX0sICR7aH0gKWAsbyxlKTp0LmZvcm1hdChgKCAke3V9IDw9ICR7aH0gKWAsbyxlKTpzPT09Ij4iJiZsPjE/dC51c2VDb21wYXJpc29uTWV0aG9kP3QuZm9ybWF0KGAke3QuZ2V0TWV0aG9kKCJncmVhdGVyVGhhbiIsZSl9KCAke3V9LCAke2h9IClgLG8sZSk6dC5mb3JtYXQoYCggJHt1fSA+ICR7aH0gKWAsbyxlKTpzPT09Ij49IiYmbD4xP3QudXNlQ29tcGFyaXNvbk1ldGhvZD90LmZvcm1hdChgJHt0LmdldE1ldGhvZCgiZ3JlYXRlclRoYW5FcXVhbCIsZSl9KCAke3V9LCAke2h9IClgLG8sZSk6dC5mb3JtYXQoYCggJHt1fSA+PSAke2h9IClgLG8sZSk6cz09PSIhInx8cz09PSJ+Ij90LmZvcm1hdChgKCR7c30ke3V9KWAsYSxlKTpkP3QuZm9ybWF0KGAke2R9KCAke3V9LCAke2h9IClgLG8sZSk6dC5mb3JtYXQoYCggJHt1fSAke3N9ICR7aH0gKWAsbyxlKTtpZihhIT09InZvaWQiKXJldHVybiBkP3QuZm9ybWF0KGAke2R9KCAke3V9LCAke2h9IClgLG8sZSk6dC5mb3JtYXQoYCR7dX0gJHtzfSAke2h9YCxvLGUpfXNlcmlhbGl6ZSh0KXtzdXBlci5zZXJpYWxpemUodCksdC5vcD10aGlzLm9wfWRlc2VyaWFsaXplKHQpe3N1cGVyLmRlc2VyaWFsaXplKHQpLHRoaXMub3A9dC5vcH19Y29uc3QgZmU9QyhZLCIrIiksJHM9QyhZLCItIiksR3M9QyhZLCIqIiksUHI9QyhZLCIvIiksTHI9QyhZLCIlIiksbGM9QyhZLCI9PSIpLGRjPUMoWSwiIT0iKSxmYz1DKFksIjwiKSxwYz1DKFksIj4iKSxtYz1DKFksIjw9IikseWM9QyhZLCI+PSIpLGdjPUMoWSwiJiYiKSx4Yz1DKFksInx8IiksVGM9QyhZLCIhIiksTmM9QyhZLCJeXiIpLHdjPUMoWSwiJiIpLEFjPUMoWSwifiIpLE1jPUMoWSwifCIpLFNjPUMoWSwiXiIpLF9jPUMoWSwiPDwiKSx6Yz1DKFksIj4+Iik7YigiYWRkIixmZSksYigic3ViIiwkcyksYigibXVsIixHcyksYigiZGl2IixQciksYigibW9kSW50IixMciksYigiZXF1YWwiLGxjKSxiKCJub3RFcXVhbCIsZGMpLGIoImxlc3NUaGFuIixmYyksYigiZ3JlYXRlclRoYW4iLHBjKSxiKCJsZXNzVGhhbkVxdWFsIixtYyksYigiZ3JlYXRlclRoYW5FcXVhbCIseWMpLGIoImFuZCIsZ2MpLGIoIm9yIix4YyksYigibm90IixUYyksYigieG9yIixOYyksYigiYml0QW5kIix3YyksYigiYml0Tm90IixBYyksYigiYml0T3IiLE1jKSxiKCJiaXRYb3IiLFNjKSxiKCJzaGlmdExlZnQiLF9jKSxiKCJzaGlmdFJpZ2h0Iix6YyksYigicmVtYWluZGVyIiwoLi4ucik9Pihjb25zb2xlLndhcm4oIlRTTC5PcGVyYXRvck5vZGU6IC5yZW1haW5kZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tb2RJbnQoKS4iKSxMciguLi5yKSkpO2NsYXNzIHggZXh0ZW5kcyBkdHtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iTWF0aE5vZGUifWNvbnN0cnVjdG9yKHQsZSxzPW51bGwsbj1udWxsKXtzdXBlcigpLHRoaXMubWV0aG9kPXQsdGhpcy5hTm9kZT1lLHRoaXMuYk5vZGU9cyx0aGlzLmNOb2RlPW59Z2V0SW5wdXRUeXBlKHQpe2NvbnN0IGU9dGhpcy5hTm9kZS5nZXROb2RlVHlwZSh0KSxzPXRoaXMuYk5vZGU/dGhpcy5iTm9kZS5nZXROb2RlVHlwZSh0KTpudWxsLG49dGhpcy5jTm9kZT90aGlzLmNOb2RlLmdldE5vZGVUeXBlKHQpOm51bGwsaT10LmlzTWF0cml4KGUpPzA6dC5nZXRUeXBlTGVuZ3RoKGUpLG89dC5pc01hdHJpeChzKT8wOnQuZ2V0VHlwZUxlbmd0aChzKSxhPXQuaXNNYXRyaXgobik/MDp0LmdldFR5cGVMZW5ndGgobik7cmV0dXJuIGk+byYmaT5hP2U6bz5hP3M6YT5pP246ZX1nZXROb2RlVHlwZSh0KXtjb25zdCBlPXRoaXMubWV0aG9kO3JldHVybiBlPT09eC5MRU5HVEh8fGU9PT14LkRJU1RBTkNFfHxlPT09eC5ET1Q/ImZsb2F0IjplPT09eC5DUk9TUz8idmVjMyI6ZT09PXguQUxMPyJib29sIjplPT09eC5FUVVBTFM/dC5jaGFuZ2VDb21wb25lbnRUeXBlKHRoaXMuYU5vZGUuZ2V0Tm9kZVR5cGUodCksImJvb2wiKTplPT09eC5NT0Q/dGhpcy5hTm9kZS5nZXROb2RlVHlwZSh0KTp0aGlzLmdldElucHV0VHlwZSh0KX1nZW5lcmF0ZSh0LGUpe2NvbnN0IHM9dGhpcy5tZXRob2Qsbj10aGlzLmdldE5vZGVUeXBlKHQpLGk9dGhpcy5nZXRJbnB1dFR5cGUodCksbz10aGlzLmFOb2RlLGE9dGhpcy5iTm9kZSxjPXRoaXMuY05vZGUsdT10LnJlbmRlcmVyLmlzV2ViR0xSZW5kZXJlcj09PSEwO2lmKHM9PT14LlRSQU5TRk9STV9ESVJFQ1RJT04pe2xldCBoPW8sbD1hO3QuaXNNYXRyaXgoaC5nZXROb2RlVHlwZSh0KSk/bD1CZShrKGwpLDApOmg9QmUoayhoKSwwKTtjb25zdCBkPUdzKGgsbCkueHl6O3JldHVybiBPcihkKS5idWlsZCh0LGUpfWVsc2V7aWYocz09PXguTkVHQVRFKXJldHVybiB0LmZvcm1hdCgiKCAtICIrby5idWlsZCh0LGkpKyIgKSIsbixlKTtpZihzPT09eC5PTkVfTUlOVVMpcmV0dXJuICRzKDEsbykuYnVpbGQodCxlKTtpZihzPT09eC5SRUNJUFJPQ0FMKXJldHVybiBQcigxLG8pLmJ1aWxkKHQsZSk7aWYocz09PXguRElGRkVSRU5DRSlyZXR1cm4gb2koJHMobyxhKSkuYnVpbGQodCxlKTt7Y29uc3QgaD1bXTtyZXR1cm4gcz09PXguQ1JPU1N8fHM9PT14Lk1PRD9oLnB1c2goby5idWlsZCh0LG4pLGEuYnVpbGQodCxuKSk6dSYmcz09PXguU1RFUD9oLnB1c2goby5idWlsZCh0LHQuZ2V0VHlwZUxlbmd0aChvLmdldE5vZGVUeXBlKHQpKT09PTE/ImZsb2F0IjppKSxhLmJ1aWxkKHQsaSkpOnUmJihzPT09eC5NSU58fHM9PT14Lk1BWCl8fHM9PT14Lk1PRD9oLnB1c2goby5idWlsZCh0LGkpLGEuYnVpbGQodCx0LmdldFR5cGVMZW5ndGgoYS5nZXROb2RlVHlwZSh0KSk9PT0xPyJmbG9hdCI6aSkpOnM9PT14LlJFRlJBQ1Q/aC5wdXNoKG8uYnVpbGQodCxpKSxhLmJ1aWxkKHQsaSksYy5idWlsZCh0LCJmbG9hdCIpKTpzPT09eC5NSVg/aC5wdXNoKG8uYnVpbGQodCxpKSxhLmJ1aWxkKHQsaSksYy5idWlsZCh0LHQuZ2V0VHlwZUxlbmd0aChjLmdldE5vZGVUeXBlKHQpKT09PTE/ImZsb2F0IjppKSk6KGgucHVzaChvLmJ1aWxkKHQsaSkpLGEhPT1udWxsJiZoLnB1c2goYS5idWlsZCh0LGkpKSxjIT09bnVsbCYmaC5wdXNoKGMuYnVpbGQodCxpKSkpLHQuZm9ybWF0KGAke3QuZ2V0TWV0aG9kKHMsbil9KCAke2guam9pbigiLCAiKX0gKWAsbixlKX19fXNlcmlhbGl6ZSh0KXtzdXBlci5zZXJpYWxpemUodCksdC5tZXRob2Q9dGhpcy5tZXRob2R9ZGVzZXJpYWxpemUodCl7c3VwZXIuZGVzZXJpYWxpemUodCksdGhpcy5tZXRob2Q9dC5tZXRob2R9fXguQUxMPSJhbGwiLHguQU5ZPSJhbnkiLHguRVFVQUxTPSJlcXVhbHMiLHguUkFESUFOUz0icmFkaWFucyIseC5ERUdSRUVTPSJkZWdyZWVzIix4LkVYUD0iZXhwIix4LkVYUDI9ImV4cDIiLHguTE9HPSJsb2ciLHguTE9HMj0ibG9nMiIseC5TUVJUPSJzcXJ0Iix4LklOVkVSU0VfU1FSVD0iaW52ZXJzZXNxcnQiLHguRkxPT1I9ImZsb29yIix4LkNFSUw9ImNlaWwiLHguTk9STUFMSVpFPSJub3JtYWxpemUiLHguRlJBQ1Q9ImZyYWN0Iix4LlNJTj0ic2luIix4LkNPUz0iY29zIix4LlRBTj0idGFuIix4LkFTSU49ImFzaW4iLHguQUNPUz0iYWNvcyIseC5BVEFOPSJhdGFuIix4LkFCUz0iYWJzIix4LlNJR049InNpZ24iLHguTEVOR1RIPSJsZW5ndGgiLHguTkVHQVRFPSJuZWdhdGUiLHguT05FX01JTlVTPSJvbmVNaW51cyIseC5ERkRYPSJkRmR4Iix4LkRGRFk9ImRGZHkiLHguUk9VTkQ9InJvdW5kIix4LlJFQ0lQUk9DQUw9InJlY2lwcm9jYWwiLHguVFJVTkM9InRydW5jIix4LkZXSURUSD0iZndpZHRoIix4LkJJVENBU1Q9ImJpdGNhc3QiLHguVFJBTlNQT1NFPSJ0cmFuc3Bvc2UiLHguQVRBTjI9ImF0YW4yIix4Lk1JTj0ibWluIix4Lk1BWD0ibWF4Iix4Lk1PRD0ibW9kIix4LlNURVA9InN0ZXAiLHguUkVGTEVDVD0icmVmbGVjdCIseC5ESVNUQU5DRT0iZGlzdGFuY2UiLHguRElGRkVSRU5DRT0iZGlmZmVyZW5jZSIseC5ET1Q9ImRvdCIseC5DUk9TUz0iY3Jvc3MiLHguUE9XPSJwb3ciLHguVFJBTlNGT1JNX0RJUkVDVElPTj0idHJhbnNmb3JtRGlyZWN0aW9uIix4Lk1JWD0ibWl4Iix4LkNMQU1QPSJjbGFtcCIseC5SRUZSQUNUPSJyZWZyYWN0Iix4LlNNT09USFNURVA9InNtb290aHN0ZXAiLHguRkFDRUZPUldBUkQ9ImZhY2Vmb3J3YXJkIjtjb25zdCBiYz1xKE1hdGguUEkpLEVjPUMoeCx4LkFMTCksQ2M9Qyh4LHguQU5ZKSxGYz1DKHgseC5FUVVBTFMpLFJjPUMoeCx4LlJBRElBTlMpLEJjPUMoeCx4LkRFR1JFRVMpLEljPUMoeCx4LkVYUCksdmM9Qyh4LHguRVhQMiksUGM9Qyh4LHguTE9HKSxMYz1DKHgseC5MT0cyKSxpaT1DKHgseC5TUVJUKSxPYz1DKHgseC5JTlZFUlNFX1NRUlQpLERjPUMoeCx4LkZMT09SKSxWYz1DKHgseC5DRUlMKSxPcj1DKHgseC5OT1JNQUxJWkUpLHJpPUMoeCx4LkZSQUNUKSxEcj1DKHgseC5TSU4pLFVjPUMoeCx4LkNPUyksa2M9Qyh4LHguVEFOKSxIYz1DKHgseC5BU0lOKSxxYz1DKHgseC5BQ09TKSwkYz1DKHgseC5BVEFOKSxvaT1DKHgseC5BQlMpLFZyPUMoeCx4LlNJR04pLEdjPUMoeCx4LkxFTkdUSCksV2M9Qyh4LHguTkVHQVRFKSxYYz1DKHgseC5PTkVfTUlOVVMpLFljPUMoeCx4LkRGRFgpLFpjPUMoeCx4LkRGRFkpLEpjPUMoeCx4LlJPVU5EKSxqYz1DKHgseC5SRUNJUFJPQ0FMKSxRYz1DKHgseC5UUlVOQyksS2M9Qyh4LHguRldJRFRIKTt4LkJJVENBU1Q7Y29uc3QgdGg9Qyh4LHguVFJBTlNQT1NFKSxlaD1DKHgseC5BVEFOMiksc2g9Qyh4LHguTUlOKSxhaT1DKHgseC5NQVgpLFVyPUMoeCx4Lk1PRCksa3I9Qyh4LHguU1RFUCksbmg9Qyh4LHguUkVGTEVDVCksaWg9Qyh4LHguRElTVEFOQ0UpLHJoPUMoeCx4LkRJRkZFUkVOQ0UpLGNpPUMoeCx4LkRPVCksb2g9Qyh4LHguQ1JPU1MpLEhyPUMoeCx4LlBPVyksYWg9Qyh4LHguUE9XLDIpLGNoPUMoeCx4LlBPVywzKSxoaD1DKHgseC5QT1csNCksdWg9Qyh4LHguVFJBTlNGT1JNX0RJUkVDVElPTiksbGg9cj0+R3MoVnIociksSHIob2kociksMS8zKSksZGg9cj0+Y2kocixyKSxyZT1DKHgseC5NSVgpLFdzPShyLHQ9MCxlPTEpPT52KG5ldyB4KHguQ0xBTVAsdihyKSx2KHQpLHYoZSkpKSxmaD1yPT5XcyhyKSxwaD1DKHgseC5SRUZSQUNUKSxoaT1DKHgseC5TTU9PVEhTVEVQKSxtaD1DKHgseC5GQUNFRk9SV0FSRCkseWg9dHQoKFtyXSk9Pntjb25zdCBzPTQzNzU4LjU0NTMsbj1jaShyLnh5LEQoMTIuOTg5OCw3OC4yMzMpKSxpPVVyKG4sYmMpO3JldHVybiByaShEcihpKS5tdWwocykpfSksZ2g9KHIsdCxlKT0+cmUodCxlLHIpLHhoPShyLHQsZSk9PmhpKHQsZSxyKTtiKCJhbGwiLEVjKSxiKCJhbnkiLENjKSxiKCJlcXVhbHMiLEZjKSxiKCJyYWRpYW5zIixSYyksYigiZGVncmVlcyIsQmMpLGIoImV4cCIsSWMpLGIoImV4cDIiLHZjKSxiKCJsb2ciLFBjKSxiKCJsb2cyIixMYyksYigic3FydCIsaWkpLGIoImludmVyc2VTcXJ0IixPYyksYigiZmxvb3IiLERjKSxiKCJjZWlsIixWYyksYigibm9ybWFsaXplIixPciksYigiZnJhY3QiLHJpKSxiKCJzaW4iLERyKSxiKCJjb3MiLFVjKSxiKCJ0YW4iLGtjKSxiKCJhc2luIixIYyksYigiYWNvcyIscWMpLGIoImF0YW4iLCRjKSxiKCJhYnMiLG9pKSxiKCJzaWduIixWciksYigibGVuZ3RoIixHYyksYigibGVuZ3RoU3EiLGRoKSxiKCJuZWdhdGUiLFdjKSxiKCJvbmVNaW51cyIsWGMpLGIoImRGZHgiLFljKSxiKCJkRmR5IixaYyksYigicm91bmQiLEpjKSxiKCJyZWNpcHJvY2FsIixqYyksYigidHJ1bmMiLFFjKSxiKCJmd2lkdGgiLEtjKSxiKCJhdGFuMiIsZWgpLGIoIm1pbiIsc2gpLGIoIm1heCIsYWkpLGIoIm1vZCIsVXIpLGIoInN0ZXAiLGtyKSxiKCJyZWZsZWN0IixuaCksYigiZGlzdGFuY2UiLGloKSxiKCJkb3QiLGNpKSxiKCJjcm9zcyIsb2gpLGIoInBvdyIsSHIpLGIoInBvdzIiLGFoKSxiKCJwb3czIixjaCksYigicG93NCIsaGgpLGIoInRyYW5zZm9ybURpcmVjdGlvbiIsdWgpLGIoIm1peCIsZ2gpLGIoImNsYW1wIixXcyksYigicmVmcmFjdCIscGgpLGIoInNtb290aHN0ZXAiLHhoKSxiKCJmYWNlRm9yd2FyZCIsbWgpLGIoImRpZmZlcmVuY2UiLHJoKSxiKCJzYXR1cmF0ZSIsZmgpLGIoImNicnQiLGxoKSxiKCJ0cmFuc3Bvc2UiLHRoKSxiKCJyYW5kIix5aCk7Y2xhc3MgVGggZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJDb25kaXRpb25hbE5vZGUifWNvbnN0cnVjdG9yKHQsZSxzPW51bGwpe3N1cGVyKCksdGhpcy5jb25kTm9kZT10LHRoaXMuaWZOb2RlPWUsdGhpcy5lbHNlTm9kZT1zfWdldE5vZGVUeXBlKHQpe2NvbnN0IGU9dGhpcy5pZk5vZGUuZ2V0Tm9kZVR5cGUodCk7aWYodGhpcy5lbHNlTm9kZSE9PW51bGwpe2NvbnN0IHM9dGhpcy5lbHNlTm9kZS5nZXROb2RlVHlwZSh0KTtpZih0LmdldFR5cGVMZW5ndGgocyk+dC5nZXRUeXBlTGVuZ3RoKGUpKXJldHVybiBzfXJldHVybiBlfXNldHVwKHQpe2NvbnN0IGU9dGhpcy5jb25kTm9kZS5jYWNoZSgpLHM9dGhpcy5pZk5vZGUuY2FjaGUoKSxuPXRoaXMuZWxzZU5vZGU/dGhpcy5lbHNlTm9kZS5jYWNoZSgpOm51bGwsaT10LmNvbnRleHQubm9kZUJsb2NrO3QuZ2V0RGF0YUZyb21Ob2RlKHMpLnBhcmVudE5vZGVCbG9jaz1pLG4hPT1udWxsJiYodC5nZXREYXRhRnJvbU5vZGUobikucGFyZW50Tm9kZUJsb2NrPWkpO2NvbnN0IG89dC5nZXROb2RlUHJvcGVydGllcyh0aGlzKTtvLmNvbmROb2RlPWUsby5pZk5vZGU9cy5jb250ZXh0KHtub2RlQmxvY2s6c30pLG8uZWxzZU5vZGU9bj9uLmNvbnRleHQoe25vZGVCbG9jazpufSk6bnVsbH1nZW5lcmF0ZSh0LGUpe2NvbnN0IHM9dGhpcy5nZXROb2RlVHlwZSh0KSxuPXQuZ2V0RGF0YUZyb21Ob2RlKHRoaXMpO2lmKG4ubm9kZVByb3BlcnR5IT09dm9pZCAwKXJldHVybiBuLm5vZGVQcm9wZXJ0eTtjb25zdHtjb25kTm9kZTppLGlmTm9kZTpvLGVsc2VOb2RlOmF9PXQuZ2V0Tm9kZVByb3BlcnRpZXModGhpcyksYz1lIT09InZvaWQiLHU9Yz92ZShzKS5idWlsZCh0KToiIjtuLm5vZGVQcm9wZXJ0eT11O2NvbnN0IGg9aS5idWlsZCh0LCJib29sIik7dC5hZGRGbG93Q29kZShgCiR7dC50YWJ9aWYgKCAke2h9ICkgewoKYCkuYWRkRmxvd1RhYigpO2xldCBsPW8uYnVpbGQodCxzKTtpZihsJiYoYz9sPXUrIiA9ICIrbCsiOyI6bD0icmV0dXJuICIrbCsiOyIpLHQucmVtb3ZlRmxvd1RhYigpLmFkZEZsb3dDb2RlKHQudGFiKyIJIitsK2AKCmArdC50YWIrIn0iKSxhIT09bnVsbCl7dC5hZGRGbG93Q29kZShgIGVsc2UgewoKYCkuYWRkRmxvd1RhYigpO2xldCBkPWEuYnVpbGQodCxzKTtkJiYoYz9kPXUrIiA9ICIrZCsiOyI6ZD0icmV0dXJuICIrZCsiOyIpLHQucmVtb3ZlRmxvd1RhYigpLmFkZEZsb3dDb2RlKHQudGFiKyIJIitkK2AKCmArdC50YWIrYH0KCmApfWVsc2UgdC5hZGRGbG93Q29kZShgCgpgKTtyZXR1cm4gdC5mb3JtYXQodSxzLGUpfX1jb25zdCB1aT1DKFRoKTtiKCJzZWxlY3QiLHVpKSxiKCJjb25kIiwoLi4ucik9Pihjb25zb2xlLndhcm4oIlRTTC5Db25kaXRpb25hbE5vZGU6IGNvbmQoKSBoYXMgYmVlbiByZW5hbWVkIHRvIHNlbGVjdCgpLiIpLHVpKC4uLnIpKSk7Y2xhc3MgTmggZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJDb250ZXh0Tm9kZSJ9Y29uc3RydWN0b3IodCxlPXt9KXtzdXBlcigpLHRoaXMuaXNDb250ZXh0Tm9kZT0hMCx0aGlzLm5vZGU9dCx0aGlzLnZhbHVlPWV9Z2V0U2NvcGUoKXtyZXR1cm4gdGhpcy5ub2RlLmdldFNjb3BlKCl9Z2V0Tm9kZVR5cGUodCl7cmV0dXJuIHRoaXMubm9kZS5nZXROb2RlVHlwZSh0KX1hbmFseXplKHQpe3RoaXMubm9kZS5idWlsZCh0KX1zZXR1cCh0KXtjb25zdCBlPXQuZ2V0Q29udGV4dCgpO3Quc2V0Q29udGV4dCh7Li4udC5jb250ZXh0LC4uLnRoaXMudmFsdWV9KTtjb25zdCBzPXRoaXMubm9kZS5idWlsZCh0KTtyZXR1cm4gdC5zZXRDb250ZXh0KGUpLHN9Z2VuZXJhdGUodCxlKXtjb25zdCBzPXQuZ2V0Q29udGV4dCgpO3Quc2V0Q29udGV4dCh7Li4udC5jb250ZXh0LC4uLnRoaXMudmFsdWV9KTtjb25zdCBuPXRoaXMubm9kZS5idWlsZCh0LGUpO3JldHVybiB0LnNldENvbnRleHQocyksbn19Y29uc3QgcXI9QyhOaCksd2g9KHIsdCk9PnFyKHIse2xhYmVsOnR9KTtiKCJjb250ZXh0IixxciksYigibGFiZWwiLHdoKTtjbGFzcyBBaCBleHRlbmRzIFV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlZhck5vZGUifWNvbnN0cnVjdG9yKHQsZT1udWxsKXtzdXBlcigpLHRoaXMubm9kZT10LHRoaXMubmFtZT1lLHRoaXMuZ2xvYmFsPSEwLHRoaXMuaXNWYXJOb2RlPSEwfWdldEhhc2godCl7cmV0dXJuIHRoaXMubmFtZXx8c3VwZXIuZ2V0SGFzaCh0KX1nZXROb2RlVHlwZSh0KXtyZXR1cm4gdGhpcy5ub2RlLmdldE5vZGVUeXBlKHQpfWdlbmVyYXRlKHQpe2NvbnN0e25vZGU6ZSxuYW1lOnN9PXRoaXMsbj10LmdldFZhckZyb21Ob2RlKHRoaXMscyx0LmdldFZlY3RvclR5cGUodGhpcy5nZXROb2RlVHlwZSh0KSkpLGk9dC5nZXRQcm9wZXJ0eU5hbWUobiksbz1lLmJ1aWxkKHQsbi50eXBlKTtyZXR1cm4gdC5hZGRMaW5lRmxvd0NvZGUoYCR7aX0gPSAke299YCx0aGlzKSxpfX1jb25zdCAkcj1DKEFoKTtiKCJ0ZW1wIiwkciksYigidG9WYXIiLCguLi5yKT0+JHIoLi4ucikuYXBwZW5kKCkpO2NsYXNzIE1oIGV4dGVuZHMgVXtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iVmFyeWluZ05vZGUifWNvbnN0cnVjdG9yKHQsZT1udWxsKXtzdXBlcigpLHRoaXMubm9kZT10LHRoaXMubmFtZT1lLHRoaXMuaXNWYXJ5aW5nTm9kZT0hMH1pc0dsb2JhbCgpe3JldHVybiEwfWdldEhhc2godCl7cmV0dXJuIHRoaXMubmFtZXx8c3VwZXIuZ2V0SGFzaCh0KX1nZXROb2RlVHlwZSh0KXtyZXR1cm4gdGhpcy5ub2RlLmdldE5vZGVUeXBlKHQpfXNldHVwVmFyeWluZyh0KXtjb25zdCBlPXQuZ2V0Tm9kZVByb3BlcnRpZXModGhpcyk7bGV0IHM9ZS52YXJ5aW5nO2lmKHM9PT12b2lkIDApe2NvbnN0IG49dGhpcy5uYW1lLGk9dGhpcy5nZXROb2RlVHlwZSh0KTtlLnZhcnlpbmc9cz10LmdldFZhcnlpbmdGcm9tTm9kZSh0aGlzLG4saSksZS5ub2RlPXRoaXMubm9kZX1yZXR1cm4gcy5uZWVkc0ludGVycG9sYXRpb258fChzLm5lZWRzSW50ZXJwb2xhdGlvbj10LnNoYWRlclN0YWdlPT09ImZyYWdtZW50Iiksc31zZXR1cCh0KXt0aGlzLnNldHVwVmFyeWluZyh0KX1hbmFseXplKHQpe3JldHVybiB0aGlzLnNldHVwVmFyeWluZyh0KSx0aGlzLm5vZGUuYW5hbHl6ZSh0KX1nZW5lcmF0ZSh0KXtjb25zdCBlPXQuZ2V0Tm9kZVByb3BlcnRpZXModGhpcykscz10aGlzLnNldHVwVmFyeWluZyh0KTtpZihlLnByb3BlcnR5TmFtZT09PXZvaWQgMCl7Y29uc3Qgbj10aGlzLmdldE5vZGVUeXBlKHQpLGk9dC5nZXRQcm9wZXJ0eU5hbWUocyx3ci5WRVJURVgpO3QuZmxvd05vZGVGcm9tU2hhZGVyU3RhZ2Uod3IuVkVSVEVYLHRoaXMubm9kZSxuLGkpLGUucHJvcGVydHlOYW1lPWl9cmV0dXJuIHQuZ2V0UHJvcGVydHlOYW1lKHMpfX1jb25zdCBQZT1DKE1oKTtiKCJ2YXJ5aW5nIixQZSk7Y29uc3QgcnM9IldvcmtpbmdDb2xvclNwYWNlIixsaT0iT3V0cHV0Q29sb3JTcGFjZSI7ZnVuY3Rpb24gR3Iocil7bGV0IHQ9bnVsbDtyZXR1cm4gcj09PUVzP3Q9IkxpbmVhciI6cj09PSR0JiYodD0ic1JHQiIpLHR9ZnVuY3Rpb24gU2gocix0KXtyZXR1cm4gR3IocikrIlRvIitHcih0KX1jbGFzcyBYcyBleHRlbmRzIGR0e3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJDb2xvclNwYWNlTm9kZSJ9Y29uc3RydWN0b3IodCxlLHMpe3N1cGVyKCJ2ZWM0IiksdGhpcy5jb2xvck5vZGU9dCx0aGlzLnNvdXJjZT1lLHRoaXMudGFyZ2V0PXN9Z2V0Q29sb3JTcGFjZSh0LGUpe3JldHVybiBlPT09cnM/bXQud29ya2luZ0NvbG9yU3BhY2U6ZT09PWxpP3QuY29udGV4dC5vdXRwdXRDb2xvclNwYWNlfHx0LnJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2U6ZX1zZXR1cCh0KXtjb25zdHtyZW5kZXJlcjplfT10LHtjb2xvck5vZGU6c309dGhpcyxuPXRoaXMuZ2V0Q29sb3JTcGFjZSh0LHRoaXMuc291cmNlKSxpPXRoaXMuZ2V0Q29sb3JTcGFjZSh0LHRoaXMudGFyZ2V0KTtpZihuPT09aSlyZXR1cm4gcztjb25zdCBvPVNoKG4saSk7bGV0IGE9bnVsbDtjb25zdCBjPWUubm9kZXMubGlicmFyeS5nZXRDb2xvclNwYWNlRnVuY3Rpb24obyk7cmV0dXJuIGMhPT1udWxsP2E9QmUoYyhzLnJnYikscy5hKTooY29uc29sZS5lcnJvcigiQ29sb3JTcGFjZU5vZGU6IFVuc3VwcG9ydGVkIENvbG9yIFNwYWNlIGNvbmZpZ3VyYXRpb24uIixvKSxhPXMpLGF9fWNvbnN0IF9oPXI9PnYobmV3IFhzKHYocikscnMsbGkpKSx6aD1yPT52KG5ldyBYcyh2KHIpLGxpLHJzKSksYmg9KHIsdCk9PnYobmV3IFhzKHYocikscnMsdCkpLFdyPShyLHQpPT52KG5ldyBYcyh2KHIpLHQscnMpKTtiKCJ0b091dHB1dENvbG9yU3BhY2UiLF9oKSxiKCJ0b1dvcmtpbmdDb2xvclNwYWNlIix6aCksYigid29ya2luZ1RvQ29sb3JTcGFjZSIsYmgpLGIoImNvbG9yU3BhY2VUb1dvcmtpbmciLFdyKTtsZXQgRWg9Y2xhc3MgZXh0ZW5kcyBpc3tzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iUmVmZXJlbmNlRWxlbWVudE5vZGUifWNvbnN0cnVjdG9yKHQsZSl7c3VwZXIodCxlKSx0aGlzLnJlZmVyZW5jZU5vZGU9dCx0aGlzLmlzUmVmZXJlbmNlRWxlbWVudE5vZGU9ITB9Z2V0Tm9kZVR5cGUoKXtyZXR1cm4gdGhpcy5yZWZlcmVuY2VOb2RlLnVuaWZvcm1UeXBlfWdlbmVyYXRlKHQpe2NvbnN0IGU9c3VwZXIuZ2VuZXJhdGUodCkscz10aGlzLnJlZmVyZW5jZU5vZGUuZ2V0Tm9kZVR5cGUoKSxuPXRoaXMuZ2V0Tm9kZVR5cGUoKTtyZXR1cm4gdC5mb3JtYXQoZSxzLG4pfX07Y2xhc3MgQ2ggZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJSZWZlcmVuY2VCYXNlTm9kZSJ9Y29uc3RydWN0b3IodCxlLHM9bnVsbCxuPW51bGwpe3N1cGVyKCksdGhpcy5wcm9wZXJ0eT10LHRoaXMudW5pZm9ybVR5cGU9ZSx0aGlzLm9iamVjdD1zLHRoaXMuY291bnQ9bix0aGlzLnByb3BlcnRpZXM9dC5zcGxpdCgiLiIpLHRoaXMucmVmZXJlbmNlPXMsdGhpcy5ub2RlPW51bGwsdGhpcy5ncm91cD1udWxsLHRoaXMudXBkYXRlVHlwZT1RLk9CSkVDVH1zZXRHcm91cCh0KXtyZXR1cm4gdGhpcy5ncm91cD10LHRoaXN9ZWxlbWVudCh0KXtyZXR1cm4gdihuZXcgRWgodGhpcyx2KHQpKSl9c2V0Tm9kZVR5cGUodCl7Y29uc3QgZT14dChudWxsLHQpLmdldFNlbGYoKTt0aGlzLmdyb3VwIT09bnVsbCYmZS5zZXRHcm91cCh0aGlzLmdyb3VwKSx0aGlzLm5vZGU9ZX1nZXROb2RlVHlwZSh0KXtyZXR1cm4gdGhpcy5ub2RlPT09bnVsbCYmKHRoaXMudXBkYXRlUmVmZXJlbmNlKHQpLHRoaXMudXBkYXRlVmFsdWUoKSksdGhpcy5ub2RlLmdldE5vZGVUeXBlKHQpfWdldFZhbHVlRnJvbVJlZmVyZW5jZSh0PXRoaXMucmVmZXJlbmNlKXtjb25zdHtwcm9wZXJ0aWVzOmV9PXRoaXM7bGV0IHM9dFtlWzBdXTtmb3IobGV0IG49MTtuPGUubGVuZ3RoO24rKylzPXNbZVtuXV07cmV0dXJuIHN9dXBkYXRlUmVmZXJlbmNlKHQpe3JldHVybiB0aGlzLnJlZmVyZW5jZT10aGlzLm9iamVjdCE9PW51bGw/dGhpcy5vYmplY3Q6dC5vYmplY3QsdGhpcy5yZWZlcmVuY2V9c2V0dXAoKXtyZXR1cm4gdGhpcy51cGRhdGVWYWx1ZSgpLHRoaXMubm9kZX11cGRhdGUoKXt0aGlzLnVwZGF0ZVZhbHVlKCl9dXBkYXRlVmFsdWUoKXt0aGlzLm5vZGU9PT1udWxsJiZ0aGlzLnNldE5vZGVUeXBlKHRoaXMudW5pZm9ybVR5cGUpO2NvbnN0IHQ9dGhpcy5nZXRWYWx1ZUZyb21SZWZlcmVuY2UoKTtBcnJheS5pc0FycmF5KHQpP3RoaXMubm9kZS5hcnJheT10OnRoaXMubm9kZS52YWx1ZT10fX1jbGFzcyBGaCBleHRlbmRzIENoe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJSZW5kZXJlclJlZmVyZW5jZU5vZGUifWNvbnN0cnVjdG9yKHQsZSxzPW51bGwpe3N1cGVyKHQsZSxzKSx0aGlzLnJlbmRlcmVyPXMsdGhpcy5zZXRHcm91cChkZSl9dXBkYXRlUmVmZXJlbmNlKHQpe3JldHVybiB0aGlzLnJlZmVyZW5jZT10aGlzLnJlbmRlcmVyIT09bnVsbD90aGlzLnJlbmRlcmVyOnQucmVuZGVyZXIsdGhpcy5yZWZlcmVuY2V9fWNvbnN0IFJoPShyLHQsZSk9PnYobmV3IEZoKHIsdCxlKSk7Y2xhc3MgQmggZXh0ZW5kcyBkdHtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iVG9uZU1hcHBpbmdOb2RlIn1jb25zdHJ1Y3Rvcih0LGU9dmgscz1udWxsKXtzdXBlcigidmVjMyIpLHRoaXMudG9uZU1hcHBpbmc9dCx0aGlzLmV4cG9zdXJlTm9kZT1lLHRoaXMuY29sb3JOb2RlPXN9Z2V0Q2FjaGVLZXkoKXtyZXR1cm4gTWEoc3VwZXIuZ2V0Q2FjaGVLZXkoKSx0aGlzLnRvbmVNYXBwaW5nKX1zZXR1cCh0KXtjb25zdCBlPXRoaXMuY29sb3JOb2RlfHx0LmNvbnRleHQuY29sb3Iscz10aGlzLnRvbmVNYXBwaW5nO2lmKHM9PT1NbilyZXR1cm4gZTtsZXQgbj1udWxsO2NvbnN0IGk9dC5yZW5kZXJlci5ub2Rlcy5saWJyYXJ5LmdldFRvbmVNYXBwaW5nRnVuY3Rpb24ocyk7cmV0dXJuIGkhPT1udWxsP249QmUoaShlLnJnYix0aGlzLmV4cG9zdXJlTm9kZSksZS5hKTooY29uc29sZS5lcnJvcigiVG9uZU1hcHBpbmdOb2RlOiBVbnN1cHBvcnRlZCBUb25lIE1hcHBpbmcgY29uZmlndXJhdGlvbi4iLHMpLG49ZSksbn19Y29uc3QgSWg9KHIsdCxlKT0+dihuZXcgQmgocix2KHQpLHYoZSkpKSx2aD1SaCgidG9uZU1hcHBpbmdFeHBvc3VyZSIsImZsb2F0Iik7YigidG9uZU1hcHBpbmciLChyLHQsZSk9PkloKHQsZSxyKSk7Y2xhc3MgUGggZXh0ZW5kcyBqbntzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iQnVmZmVyQXR0cmlidXRlTm9kZSJ9Y29uc3RydWN0b3IodCxlPW51bGwscz0wLG49MCl7c3VwZXIodCxlKSx0aGlzLmlzQnVmZmVyTm9kZT0hMCx0aGlzLmJ1ZmZlclR5cGU9ZSx0aGlzLmJ1ZmZlclN0cmlkZT1zLHRoaXMuYnVmZmVyT2Zmc2V0PW4sdGhpcy51c2FnZT1Dcyx0aGlzLmluc3RhbmNlZD0hMSx0aGlzLmF0dHJpYnV0ZT1udWxsLHRoaXMuZ2xvYmFsPSEwLHQmJnQuaXNCdWZmZXJBdHRyaWJ1dGU9PT0hMCYmKHRoaXMuYXR0cmlidXRlPXQsdGhpcy51c2FnZT10LnVzYWdlLHRoaXMuaW5zdGFuY2VkPXQuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUpfWdldEhhc2godCl7aWYodGhpcy5idWZmZXJTdHJpZGU9PT0wJiZ0aGlzLmJ1ZmZlck9mZnNldD09PTApe2xldCBlPXQuZ2xvYmFsQ2FjaGUuZ2V0RGF0YSh0aGlzLnZhbHVlKTtyZXR1cm4gZT09PXZvaWQgMCYmKGU9e25vZGU6dGhpc30sdC5nbG9iYWxDYWNoZS5zZXREYXRhKHRoaXMudmFsdWUsZSkpLGUubm9kZS51dWlkfXJldHVybiB0aGlzLnV1aWR9Z2V0Tm9kZVR5cGUodCl7cmV0dXJuIHRoaXMuYnVmZmVyVHlwZT09PW51bGwmJih0aGlzLmJ1ZmZlclR5cGU9dC5nZXRUeXBlRnJvbUF0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZSkpLHRoaXMuYnVmZmVyVHlwZX1zZXR1cCh0KXtpZih0aGlzLmF0dHJpYnV0ZSE9PW51bGwpcmV0dXJuO2NvbnN0IGU9dGhpcy5nZXROb2RlVHlwZSh0KSxzPXRoaXMudmFsdWUsbj10LmdldFR5cGVMZW5ndGgoZSksaT10aGlzLmJ1ZmZlclN0cmlkZXx8bixvPXRoaXMuYnVmZmVyT2Zmc2V0LGE9cy5pc0ludGVybGVhdmVkQnVmZmVyPT09ITA/czpuZXcgd2EocyxpKSxjPW5ldyBZbihhLG4sbyk7YS5zZXRVc2FnZSh0aGlzLnVzYWdlKSx0aGlzLmF0dHJpYnV0ZT1jLHRoaXMuYXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlPXRoaXMuaW5zdGFuY2VkfWdlbmVyYXRlKHQpe2NvbnN0IGU9dGhpcy5nZXROb2RlVHlwZSh0KSxzPXQuZ2V0QnVmZmVyQXR0cmlidXRlRnJvbU5vZGUodGhpcyxlKSxuPXQuZ2V0UHJvcGVydHlOYW1lKHMpO2xldCBpPW51bGw7cmV0dXJuIHQuc2hhZGVyU3RhZ2U9PT0idmVydGV4Inx8dC5zaGFkZXJTdGFnZT09PSJjb21wdXRlIj8odGhpcy5uYW1lPW4saT1uKTppPVBlKHRoaXMpLmJ1aWxkKHQsZSksaX1nZXRJbnB1dFR5cGUoKXtyZXR1cm4iYnVmZmVyQXR0cmlidXRlIn1zZXRVc2FnZSh0KXtyZXR1cm4gdGhpcy51c2FnZT10LHRoaXMuYXR0cmlidXRlJiZ0aGlzLmF0dHJpYnV0ZS5pc0J1ZmZlckF0dHJpYnV0ZT09PSEwJiYodGhpcy5hdHRyaWJ1dGUudXNhZ2U9dCksdGhpc31zZXRJbnN0YW5jZWQodCl7cmV0dXJuIHRoaXMuaW5zdGFuY2VkPXQsdGhpc319Y29uc3QgTGg9KHIsdCxlLHMpPT52KG5ldyBQaChyLHQsZSxzKSk7YigidG9BdHRyaWJ1dGUiLHI9PkxoKHIudmFsdWUpKTtjbGFzcyBPaCBleHRlbmRzIFV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIkNvbXB1dGVOb2RlIn1jb25zdHJ1Y3Rvcih0LGUscz1bNjRdKXtzdXBlcigidm9pZCIpLHRoaXMuaXNDb21wdXRlTm9kZT0hMCx0aGlzLmNvbXB1dGVOb2RlPXQsdGhpcy5jb3VudD1lLHRoaXMud29ya2dyb3VwU2l6ZT1zLHRoaXMuZGlzcGF0Y2hDb3VudD0wLHRoaXMudmVyc2lvbj0xLHRoaXMudXBkYXRlQmVmb3JlVHlwZT1RLk9CSkVDVCx0aGlzLnVwZGF0ZURpc3BhdGNoQ291bnQoKX1kaXNwb3NlKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiJkaXNwb3NlIn0pfXNldCBuZWVkc1VwZGF0ZSh0KXt0PT09ITAmJnRoaXMudmVyc2lvbisrfXVwZGF0ZURpc3BhdGNoQ291bnQoKXtjb25zdHtjb3VudDp0LHdvcmtncm91cFNpemU6ZX09dGhpcztsZXQgcz1lWzBdO2ZvcihsZXQgbj0xO248ZS5sZW5ndGg7bisrKXMqPWVbbl07dGhpcy5kaXNwYXRjaENvdW50PU1hdGguY2VpbCh0L3MpfW9uSW5pdCgpe311cGRhdGVCZWZvcmUoe3JlbmRlcmVyOnR9KXt0LmNvbXB1dGUodGhpcyl9Z2VuZXJhdGUodCl7Y29uc3R7c2hhZGVyU3RhZ2U6ZX09dDtpZihlPT09ImNvbXB1dGUiKXtjb25zdCBzPXRoaXMuY29tcHV0ZU5vZGUuYnVpbGQodCwidm9pZCIpO3MhPT0iIiYmdC5hZGRMaW5lRmxvd0NvZGUocyx0aGlzKX19fWIoImNvbXB1dGUiLChyLHQsZSk9PnYobmV3IE9oKHYociksdCxlKSkpO2NsYXNzIERoIGV4dGVuZHMgVXtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iQ2FjaGVOb2RlIn1jb25zdHJ1Y3Rvcih0LGU9ITApe3N1cGVyKCksdGhpcy5ub2RlPXQsdGhpcy5wYXJlbnQ9ZSx0aGlzLmlzQ2FjaGVOb2RlPSEwfWdldE5vZGVUeXBlKHQpe3JldHVybiB0aGlzLm5vZGUuZ2V0Tm9kZVR5cGUodCl9YnVpbGQodCwuLi5lKXtjb25zdCBzPXQuZ2V0Q2FjaGUoKSxuPXQuZ2V0Q2FjaGVGcm9tTm9kZSh0aGlzLHRoaXMucGFyZW50KTt0LnNldENhY2hlKG4pO2NvbnN0IGk9dGhpcy5ub2RlLmJ1aWxkKHQsLi4uZSk7cmV0dXJuIHQuc2V0Q2FjaGUocyksaX19YigiY2FjaGUiLChyLC4uLnQpPT52KG5ldyBEaCh2KHIpLC4uLnQpKSk7Y2xhc3MgVmggZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJCeXBhc3NOb2RlIn1jb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpcy5pc0J5cGFzc05vZGU9ITAsdGhpcy5vdXRwdXROb2RlPXQsdGhpcy5jYWxsTm9kZT1lfWdldE5vZGVUeXBlKHQpe3JldHVybiB0aGlzLm91dHB1dE5vZGUuZ2V0Tm9kZVR5cGUodCl9Z2VuZXJhdGUodCl7Y29uc3QgZT10aGlzLmNhbGxOb2RlLmJ1aWxkKHQsInZvaWQiKTtyZXR1cm4gZSE9PSIiJiZ0LmFkZExpbmVGbG93Q29kZShlLHRoaXMpLHRoaXMub3V0cHV0Tm9kZS5idWlsZCh0KX19YigiYnlwYXNzIixDKFZoKSk7Y2xhc3MgWHIgZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJSZW1hcE5vZGUifWNvbnN0cnVjdG9yKHQsZSxzLG49cSgwKSxpPXEoMSkpe3N1cGVyKCksdGhpcy5ub2RlPXQsdGhpcy5pbkxvd05vZGU9ZSx0aGlzLmluSGlnaE5vZGU9cyx0aGlzLm91dExvd05vZGU9bix0aGlzLm91dEhpZ2hOb2RlPWksdGhpcy5kb0NsYW1wPSEwfXNldHVwKCl7Y29uc3R7bm9kZTp0LGluTG93Tm9kZTplLGluSGlnaE5vZGU6cyxvdXRMb3dOb2RlOm4sb3V0SGlnaE5vZGU6aSxkb0NsYW1wOm99PXRoaXM7bGV0IGE9dC5zdWIoZSkuZGl2KHMuc3ViKGUpKTtyZXR1cm4gbz09PSEwJiYoYT1hLmNsYW1wKCkpLGEubXVsKGkuc3ViKG4pKS5hZGQobil9fWNvbnN0IFVoPUMoWHIsbnVsbCxudWxsLHtkb0NsYW1wOiExfSksa2g9QyhYcik7YigicmVtYXAiLFVoKSxiKCJyZW1hcENsYW1wIixraCk7Y2xhc3MgSGggZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJFeHByZXNzaW9uTm9kZSJ9Y29uc3RydWN0b3IodD0iIixlPSJ2b2lkIil7c3VwZXIoZSksdGhpcy5zbmlwcGV0PXR9Z2VuZXJhdGUodCxlKXtjb25zdCBzPXRoaXMuZ2V0Tm9kZVR5cGUodCksbj10aGlzLnNuaXBwZXQ7aWYocz09PSJ2b2lkIil0LmFkZExpbmVGbG93Q29kZShuLHRoaXMpO2Vsc2UgcmV0dXJuIHQuZm9ybWF0KGAoICR7bn0gKWAscyxlKX19Y29uc3QgWXM9QyhIaCk7YigiZGlzY2FyZCIscj0+KHI/dWkocixZcygiZGlzY2FyZCIpKTpZcygiZGlzY2FyZCIpKS5hcHBlbmQoKSk7Y2xhc3MgcWggZXh0ZW5kcyBkdHtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iUmVuZGVyT3V0cHV0Tm9kZSJ9Y29uc3RydWN0b3IodCxlLHMpe3N1cGVyKCJ2ZWM0IiksdGhpcy5jb2xvck5vZGU9dCx0aGlzLnRvbmVNYXBwaW5nPWUsdGhpcy5vdXRwdXRDb2xvclNwYWNlPXMsdGhpcy5pc1JlbmRlck91dHB1dD0hMH1zZXR1cCh7Y29udGV4dDp0fSl7bGV0IGU9dGhpcy5jb2xvck5vZGV8fHQuY29sb3I7Y29uc3Qgcz0odGhpcy50b25lTWFwcGluZyE9PW51bGw/dGhpcy50b25lTWFwcGluZzp0LnRvbmVNYXBwaW5nKXx8TW4sbj0odGhpcy5vdXRwdXRDb2xvclNwYWNlIT09bnVsbD90aGlzLm91dHB1dENvbG9yU3BhY2U6dC5vdXRwdXRDb2xvclNwYWNlKXx8YnM7cmV0dXJuIHMhPT1NbiYmKGU9ZS50b25lTWFwcGluZyhzKSksbiE9PWJzJiZuIT09bXQud29ya2luZ0NvbG9yU3BhY2UmJihlPWUud29ya2luZ1RvQ29sb3JTcGFjZShuKSksZX19YigicmVuZGVyT3V0cHV0Iiwocix0PW51bGwsZT1udWxsKT0+dihuZXcgcWgodihyKSx0LGUpKSk7Y2xhc3MgJGggZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJBdHRyaWJ1dGVOb2RlIn1jb25zdHJ1Y3Rvcih0LGU9bnVsbCl7c3VwZXIoZSksdGhpcy5nbG9iYWw9ITAsdGhpcy5fYXR0cmlidXRlTmFtZT10fWdldEhhc2godCl7cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlTmFtZSh0KX1nZXROb2RlVHlwZSh0KXtsZXQgZT10aGlzLm5vZGVUeXBlO2lmKGU9PT1udWxsKXtjb25zdCBzPXRoaXMuZ2V0QXR0cmlidXRlTmFtZSh0KTtpZih0Lmhhc0dlb21ldHJ5QXR0cmlidXRlKHMpKXtjb25zdCBuPXQuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKHMpO2U9dC5nZXRUeXBlRnJvbUF0dHJpYnV0ZShuKX1lbHNlIGU9ImZsb2F0In1yZXR1cm4gZX1zZXRBdHRyaWJ1dGVOYW1lKHQpe3JldHVybiB0aGlzLl9hdHRyaWJ1dGVOYW1lPXQsdGhpc31nZXRBdHRyaWJ1dGVOYW1lKCl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZU5hbWV9Z2VuZXJhdGUodCl7Y29uc3QgZT10aGlzLmdldEF0dHJpYnV0ZU5hbWUodCkscz10aGlzLmdldE5vZGVUeXBlKHQpO2lmKHQuaGFzR2VvbWV0cnlBdHRyaWJ1dGUoZSk9PT0hMCl7Y29uc3QgaT10Lmdlb21ldHJ5LmdldEF0dHJpYnV0ZShlKSxvPXQuZ2V0VHlwZUZyb21BdHRyaWJ1dGUoaSksYT10LmdldEF0dHJpYnV0ZShlLG8pO3JldHVybiB0LnNoYWRlclN0YWdlPT09InZlcnRleCI/dC5mb3JtYXQoYS5uYW1lLG8scyk6UGUodGhpcykuYnVpbGQodCxzKX1lbHNlIHJldHVybiBjb25zb2xlLndhcm4oYEF0dHJpYnV0ZU5vZGU6IFZlcnRleCBhdHRyaWJ1dGUgIiR7ZX0iIG5vdCBmb3VuZCBvbiBnZW9tZXRyeS5gKSx0LmdlbmVyYXRlQ29uc3Qocyl9c2VyaWFsaXplKHQpe3N1cGVyLnNlcmlhbGl6ZSh0KSx0Lmdsb2JhbD10aGlzLmdsb2JhbCx0Ll9hdHRyaWJ1dGVOYW1lPXRoaXMuX2F0dHJpYnV0ZU5hbWV9ZGVzZXJpYWxpemUodCl7c3VwZXIuZGVzZXJpYWxpemUodCksdGhpcy5nbG9iYWw9dC5nbG9iYWwsdGhpcy5fYXR0cmlidXRlTmFtZT10Ll9hdHRyaWJ1dGVOYW1lfX1jb25zdCBvcz0ocix0KT0+dihuZXcgJGgocix0KSksWnM9cj0+b3MoInV2Iisocj4wP3I6IiIpLCJ2ZWMyIik7Y2xhc3MgR2ggZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJUZXh0dXJlU2l6ZU5vZGUifWNvbnN0cnVjdG9yKHQsZT1udWxsKXtzdXBlcigidXZlYzIiKSx0aGlzLmlzVGV4dHVyZVNpemVOb2RlPSEwLHRoaXMudGV4dHVyZU5vZGU9dCx0aGlzLmxldmVsTm9kZT1lfWdlbmVyYXRlKHQsZSl7Y29uc3Qgcz10aGlzLnRleHR1cmVOb2RlLmJ1aWxkKHQsInByb3BlcnR5Iiksbj10aGlzLmxldmVsTm9kZT09PW51bGw/IjAiOnRoaXMubGV2ZWxOb2RlLmJ1aWxkKHQsImludCIpO3JldHVybiB0LmZvcm1hdChgJHt0LmdldE1ldGhvZCgidGV4dHVyZURpbWVuc2lvbnMiKX0oICR7c30sICR7bn0gKWAsdGhpcy5nZXROb2RlVHlwZSh0KSxlKX19Y29uc3QgWXI9QyhHaCk7Y2xhc3MgV2ggZXh0ZW5kcyBJZXtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iTWF4TWlwTGV2ZWxOb2RlIn1jb25zdHJ1Y3Rvcih0KXtzdXBlcigwKSx0aGlzLl90ZXh0dXJlTm9kZT10LHRoaXMudXBkYXRlVHlwZT1RLkZSQU1FfWdldCB0ZXh0dXJlTm9kZSgpe3JldHVybiB0aGlzLl90ZXh0dXJlTm9kZX1nZXQgdGV4dHVyZSgpe3JldHVybiB0aGlzLl90ZXh0dXJlTm9kZS52YWx1ZX11cGRhdGUoKXtjb25zdCB0PXRoaXMudGV4dHVyZSxlPXQuaW1hZ2VzLHM9ZSYmZS5sZW5ndGg+MD9lWzBdJiZlWzBdLmltYWdlfHxlWzBdOnQuaW1hZ2U7aWYocyYmcy53aWR0aCE9PXZvaWQgMCl7Y29uc3R7d2lkdGg6bixoZWlnaHQ6aX09czt0aGlzLnZhbHVlPU1hdGgubG9nMihNYXRoLm1heChuLGkpKX19fWNvbnN0IFhoPUMoV2gpO2NsYXNzIEpzIGV4dGVuZHMgSWV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlRleHR1cmVOb2RlIn1jb25zdHJ1Y3Rvcih0LGU9bnVsbCxzPW51bGwsbj1udWxsKXtzdXBlcih0KSx0aGlzLmlzVGV4dHVyZU5vZGU9ITAsdGhpcy51dk5vZGU9ZSx0aGlzLmxldmVsTm9kZT1zLHRoaXMuYmlhc05vZGU9bix0aGlzLmNvbXBhcmVOb2RlPW51bGwsdGhpcy5kZXB0aE5vZGU9bnVsbCx0aGlzLmdyYWROb2RlPW51bGwsdGhpcy5zYW1wbGVyPSEwLHRoaXMudXBkYXRlTWF0cml4PSExLHRoaXMudXBkYXRlVHlwZT1RLk5PTkUsdGhpcy5yZWZlcmVuY2VOb2RlPW51bGwsdGhpcy5fdmFsdWU9dCx0aGlzLl9tYXRyaXhVbmlmb3JtPW51bGwsdGhpcy5zZXRVcGRhdGVNYXRyaXgoZT09PW51bGwpfXNldCB2YWx1ZSh0KXt0aGlzLnJlZmVyZW5jZU5vZGU/dGhpcy5yZWZlcmVuY2VOb2RlLnZhbHVlPXQ6dGhpcy5fdmFsdWU9dH1nZXQgdmFsdWUoKXtyZXR1cm4gdGhpcy5yZWZlcmVuY2VOb2RlP3RoaXMucmVmZXJlbmNlTm9kZS52YWx1ZTp0aGlzLl92YWx1ZX1nZXRVbmlmb3JtSGFzaCgpe3JldHVybiB0aGlzLnZhbHVlLnV1aWR9Z2V0Tm9kZVR5cGUoKXtyZXR1cm4gdGhpcy52YWx1ZS5pc0RlcHRoVGV4dHVyZT09PSEwPyJmbG9hdCI6dGhpcy52YWx1ZS50eXBlPT09V2k/InV2ZWM0Ijp0aGlzLnZhbHVlLnR5cGU9PT1Cbz8iaXZlYzQiOiJ2ZWM0In1nZXRJbnB1dFR5cGUoKXtyZXR1cm4idGV4dHVyZSJ9Z2V0RGVmYXVsdFVWKCl7cmV0dXJuIFpzKHRoaXMudmFsdWUuY2hhbm5lbCl9dXBkYXRlUmVmZXJlbmNlKCl7cmV0dXJuIHRoaXMudmFsdWV9Z2V0VHJhbnNmb3JtZWRVVih0KXtyZXR1cm4gdGhpcy5fbWF0cml4VW5pZm9ybT09PW51bGwmJih0aGlzLl9tYXRyaXhVbmlmb3JtPXh0KHRoaXMudmFsdWUubWF0cml4KSksdGhpcy5fbWF0cml4VW5pZm9ybS5tdWwoayh0LDEpKS54eX1zZXRVcGRhdGVNYXRyaXgodCl7cmV0dXJuIHRoaXMudXBkYXRlTWF0cml4PXQsdGhpcy51cGRhdGVUeXBlPXQ/US5GUkFNRTpRLk5PTkUsdGhpc31zZXR1cFVWKHQsZSl7Y29uc3Qgcz10aGlzLnZhbHVlO3JldHVybiB0LmlzRmxpcFkoKSYmKHMuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPT09ITB8fHMuaXNGcmFtZWJ1ZmZlclRleHR1cmU9PT0hMHx8cy5pc0RlcHRoVGV4dHVyZT09PSEwKSYmKHRoaXMuc2FtcGxlcj9lPWUuZmxpcFkoKTplPWUuc2V0WShSZShZcih0aGlzLHRoaXMubGV2ZWxOb2RlKS55KS5zdWIoZS55KS5zdWIoMSkpKSxlfXNldHVwKHQpe2NvbnN0IGU9dC5nZXROb2RlUHJvcGVydGllcyh0aGlzKTtlLnJlZmVyZW5jZU5vZGU9dGhpcy5yZWZlcmVuY2VOb2RlO2xldCBzPXRoaXMudXZOb2RlOyhzPT09bnVsbHx8dC5jb250ZXh0LmZvcmNlVVZDb250ZXh0PT09ITApJiZ0LmNvbnRleHQuZ2V0VVYmJihzPXQuY29udGV4dC5nZXRVVih0aGlzKSksc3x8KHM9dGhpcy5nZXREZWZhdWx0VVYoKSksdGhpcy51cGRhdGVNYXRyaXg9PT0hMCYmKHM9dGhpcy5nZXRUcmFuc2Zvcm1lZFVWKHMpKSxzPXRoaXMuc2V0dXBVVih0LHMpO2xldCBuPXRoaXMubGV2ZWxOb2RlO249PT1udWxsJiZ0LmNvbnRleHQuZ2V0VGV4dHVyZUxldmVsJiYobj10LmNvbnRleHQuZ2V0VGV4dHVyZUxldmVsKHRoaXMpKSxlLnV2Tm9kZT1zLGUubGV2ZWxOb2RlPW4sZS5iaWFzTm9kZT10aGlzLmJpYXNOb2RlLGUuY29tcGFyZU5vZGU9dGhpcy5jb21wYXJlTm9kZSxlLmdyYWROb2RlPXRoaXMuZ3JhZE5vZGUsZS5kZXB0aE5vZGU9dGhpcy5kZXB0aE5vZGV9Z2VuZXJhdGVVVih0LGUpe3JldHVybiBlLmJ1aWxkKHQsdGhpcy5zYW1wbGVyPT09ITA/InZlYzIiOiJpdmVjMiIpfWdlbmVyYXRlU25pcHBldCh0LGUscyxuLGksbyxhLGMpe2NvbnN0IHU9dGhpcy52YWx1ZTtsZXQgaDtyZXR1cm4gbj9oPXQuZ2VuZXJhdGVUZXh0dXJlTGV2ZWwodSxlLHMsbixvKTppP2g9dC5nZW5lcmF0ZVRleHR1cmVCaWFzKHUsZSxzLGksbyk6Yz9oPXQuZ2VuZXJhdGVUZXh0dXJlR3JhZCh1LGUscyxjLG8pOmE/aD10LmdlbmVyYXRlVGV4dHVyZUNvbXBhcmUodSxlLHMsYSxvKTp0aGlzLnNhbXBsZXI9PT0hMT9oPXQuZ2VuZXJhdGVUZXh0dXJlTG9hZCh1LGUscyxvKTpoPXQuZ2VuZXJhdGVUZXh0dXJlKHUsZSxzLG8pLGh9Z2VuZXJhdGUodCxlKXtjb25zdCBzPXQuZ2V0Tm9kZVByb3BlcnRpZXModGhpcyksbj10aGlzLnZhbHVlO2lmKCFufHxuLmlzVGV4dHVyZSE9PSEwKXRocm93IG5ldyBFcnJvcigiVGV4dHVyZU5vZGU6IE5lZWQgYSB0aHJlZS5qcyB0ZXh0dXJlLiIpO2NvbnN0IGk9c3VwZXIuZ2VuZXJhdGUodCwicHJvcGVydHkiKTtpZihlPT09InNhbXBsZXIiKXJldHVybiBpKyJfc2FtcGxlciI7aWYodC5pc1JlZmVyZW5jZShlKSlyZXR1cm4gaTt7Y29uc3Qgbz10LmdldERhdGFGcm9tTm9kZSh0aGlzKTtsZXQgYT1vLnByb3BlcnR5TmFtZTtpZihhPT09dm9pZCAwKXtjb25zdHt1dk5vZGU6aCxsZXZlbE5vZGU6bCxiaWFzTm9kZTpkLGNvbXBhcmVOb2RlOmYsZGVwdGhOb2RlOnAsZ3JhZE5vZGU6bX09cyxnPXRoaXMuZ2VuZXJhdGVVVih0LGgpLHk9bD9sLmJ1aWxkKHQsImZsb2F0Iik6bnVsbCxUPWQ/ZC5idWlsZCh0LCJmbG9hdCIpOm51bGwsdz1wP3AuYnVpbGQodCwiaW50Iik6bnVsbCxNPWY/Zi5idWlsZCh0LCJmbG9hdCIpOm51bGwsTj1tP1ttWzBdLmJ1aWxkKHQsInZlYzIiKSxtWzFdLmJ1aWxkKHQsInZlYzIiKV06bnVsbCxfPXQuZ2V0VmFyRnJvbU5vZGUodGhpcyk7YT10LmdldFByb3BlcnR5TmFtZShfKTtjb25zdCBTPXRoaXMuZ2VuZXJhdGVTbmlwcGV0KHQsaSxnLHksVCx3LE0sTik7dC5hZGRMaW5lRmxvd0NvZGUoYCR7YX0gPSAke1N9YCx0aGlzKSxvLnNuaXBwZXQ9UyxvLnByb3BlcnR5TmFtZT1hfWxldCBjPWE7Y29uc3QgdT10aGlzLmdldE5vZGVUeXBlKHQpO3JldHVybiB0Lm5lZWRzVG9Xb3JraW5nQ29sb3JTcGFjZShuKSYmKGM9V3IoWXMoYyx1KSxuLmNvbG9yU3BhY2UpLnNldHVwKHQpLmJ1aWxkKHQsdSkpLHQuZm9ybWF0KGMsdSxlKX19c2V0U2FtcGxlcih0KXtyZXR1cm4gdGhpcy5zYW1wbGVyPXQsdGhpc31nZXRTYW1wbGVyKCl7cmV0dXJuIHRoaXMuc2FtcGxlcn11dih0KXtjb25zdCBlPXRoaXMuY2xvbmUoKTtyZXR1cm4gZS51dk5vZGU9dih0KSxlLnJlZmVyZW5jZU5vZGU9dGhpcy5nZXRTZWxmKCksdihlKX1ibHVyKHQpe2NvbnN0IGU9dGhpcy5jbG9uZSgpO3JldHVybiBlLmJpYXNOb2RlPXYodCkubXVsKFhoKGUpKSxlLnJlZmVyZW5jZU5vZGU9dGhpcy5nZXRTZWxmKCksdihlKX1sZXZlbCh0KXtjb25zdCBlPXRoaXMuY2xvbmUoKTtyZXR1cm4gZS5sZXZlbE5vZGU9dih0KSxlLnJlZmVyZW5jZU5vZGU9dGhpcy5nZXRTZWxmKCksdihlKX1zaXplKHQpe3JldHVybiBZcih0aGlzLHQpfWJpYXModCl7Y29uc3QgZT10aGlzLmNsb25lKCk7cmV0dXJuIGUuYmlhc05vZGU9dih0KSxlLnJlZmVyZW5jZU5vZGU9dGhpcy5nZXRTZWxmKCksdihlKX1jb21wYXJlKHQpe2NvbnN0IGU9dGhpcy5jbG9uZSgpO3JldHVybiBlLmNvbXBhcmVOb2RlPXYodCksZS5yZWZlcmVuY2VOb2RlPXRoaXMuZ2V0U2VsZigpLHYoZSl9Z3JhZCh0LGUpe2NvbnN0IHM9dGhpcy5jbG9uZSgpO3JldHVybiBzLmdyYWROb2RlPVt2KHQpLHYoZSldLHMucmVmZXJlbmNlTm9kZT10aGlzLmdldFNlbGYoKSx2KHMpfWRlcHRoKHQpe2NvbnN0IGU9dGhpcy5jbG9uZSgpO3JldHVybiBlLmRlcHRoTm9kZT12KHQpLGUucmVmZXJlbmNlTm9kZT10aGlzLmdldFNlbGYoKSx2KGUpfXNlcmlhbGl6ZSh0KXtzdXBlci5zZXJpYWxpemUodCksdC52YWx1ZT10aGlzLnZhbHVlLnRvSlNPTih0Lm1ldGEpLnV1aWQsdC5zYW1wbGVyPXRoaXMuc2FtcGxlcix0LnVwZGF0ZU1hdHJpeD10aGlzLnVwZGF0ZU1hdHJpeCx0LnVwZGF0ZVR5cGU9dGhpcy51cGRhdGVUeXBlfWRlc2VyaWFsaXplKHQpe3N1cGVyLmRlc2VyaWFsaXplKHQpLHRoaXMudmFsdWU9dC5tZXRhLnRleHR1cmVzW3QudmFsdWVdLHRoaXMuc2FtcGxlcj10LnNhbXBsZXIsdGhpcy51cGRhdGVNYXRyaXg9dC51cGRhdGVNYXRyaXgsdGhpcy51cGRhdGVUeXBlPXQudXBkYXRlVHlwZX11cGRhdGUoKXtjb25zdCB0PXRoaXMudmFsdWUsZT10aGlzLl9tYXRyaXhVbmlmb3JtO2UhPT1udWxsJiYoZS52YWx1ZT10Lm1hdHJpeCksdC5tYXRyaXhBdXRvVXBkYXRlPT09ITAmJnQudXBkYXRlTWF0cml4KCl9Y2xvbmUoKXtjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudmFsdWUsdGhpcy51dk5vZGUsdGhpcy5sZXZlbE5vZGUsdGhpcy5iaWFzTm9kZSk7cmV0dXJuIHQuc2FtcGxlcj10aGlzLnNhbXBsZXIsdH19Y29uc3QgYXM9QyhKcyksY3M9eHQoImZsb2F0IikubGFiZWwoImNhbWVyYU5lYXIiKS5zZXRHcm91cChkZSkub25SZW5kZXJVcGRhdGUoKHtjYW1lcmE6cn0pPT5yLm5lYXIpLGhzPXh0KCJmbG9hdCIpLmxhYmVsKCJjYW1lcmFGYXIiKS5zZXRHcm91cChkZSkub25SZW5kZXJVcGRhdGUoKHtjYW1lcmE6cn0pPT5yLmZhciksanM9eHQoIm1hdDQiKS5sYWJlbCgiY2FtZXJhVmlld01hdHJpeCIpLnNldEdyb3VwKGRlKS5vblJlbmRlclVwZGF0ZSgoe2NhbWVyYTpyfSk9PnIubWF0cml4V29ybGRJbnZlcnNlKTtjbGFzcyBIIGV4dGVuZHMgVXtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iT2JqZWN0M0ROb2RlIn1jb25zdHJ1Y3Rvcih0LGU9bnVsbCl7c3VwZXIoKSx0aGlzLnNjb3BlPXQsdGhpcy5vYmplY3QzZD1lLHRoaXMudXBkYXRlVHlwZT1RLk9CSkVDVCx0aGlzLl91bmlmb3JtTm9kZT1uZXcgSWUobnVsbCl9Z2V0Tm9kZVR5cGUoKXtjb25zdCB0PXRoaXMuc2NvcGU7aWYodD09PUguV09STERfTUFUUklYKXJldHVybiJtYXQ0IjtpZih0PT09SC5QT1NJVElPTnx8dD09PUguVklFV19QT1NJVElPTnx8dD09PUguRElSRUNUSU9OfHx0PT09SC5TQ0FMRSlyZXR1cm4idmVjMyJ9dXBkYXRlKHQpe2NvbnN0IGU9dGhpcy5vYmplY3QzZCxzPXRoaXMuX3VuaWZvcm1Ob2RlLG49dGhpcy5zY29wZTtpZihuPT09SC5XT1JMRF9NQVRSSVgpcy52YWx1ZT1lLm1hdHJpeFdvcmxkO2Vsc2UgaWYobj09PUguUE9TSVRJT04pcy52YWx1ZT1zLnZhbHVlfHxuZXcgQSxzLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbihlLm1hdHJpeFdvcmxkKTtlbHNlIGlmKG49PT1ILlNDQUxFKXMudmFsdWU9cy52YWx1ZXx8bmV3IEEscy52YWx1ZS5zZXRGcm9tTWF0cml4U2NhbGUoZS5tYXRyaXhXb3JsZCk7ZWxzZSBpZihuPT09SC5ESVJFQ1RJT04pcy52YWx1ZT1zLnZhbHVlfHxuZXcgQSxlLmdldFdvcmxkRGlyZWN0aW9uKHMudmFsdWUpO2Vsc2UgaWYobj09PUguVklFV19QT1NJVElPTil7Y29uc3QgaT10LmNhbWVyYTtzLnZhbHVlPXMudmFsdWV8fG5ldyBBLHMudmFsdWUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUubWF0cml4V29ybGQpLHMudmFsdWUuYXBwbHlNYXRyaXg0KGkubWF0cml4V29ybGRJbnZlcnNlKX19Z2VuZXJhdGUodCl7Y29uc3QgZT10aGlzLnNjb3BlO3JldHVybiBlPT09SC5XT1JMRF9NQVRSSVg/dGhpcy5fdW5pZm9ybU5vZGUubm9kZVR5cGU9Im1hdDQiOihlPT09SC5QT1NJVElPTnx8ZT09PUguVklFV19QT1NJVElPTnx8ZT09PUguRElSRUNUSU9OfHxlPT09SC5TQ0FMRSkmJih0aGlzLl91bmlmb3JtTm9kZS5ub2RlVHlwZT0idmVjMyIpLHRoaXMuX3VuaWZvcm1Ob2RlLmJ1aWxkKHQpfXNlcmlhbGl6ZSh0KXtzdXBlci5zZXJpYWxpemUodCksdC5zY29wZT10aGlzLnNjb3BlfWRlc2VyaWFsaXplKHQpe3N1cGVyLmRlc2VyaWFsaXplKHQpLHRoaXMuc2NvcGU9dC5zY29wZX19SC5XT1JMRF9NQVRSSVg9IndvcmxkTWF0cml4IixILlBPU0lUSU9OPSJwb3NpdGlvbiIsSC5TQ0FMRT0ic2NhbGUiLEguVklFV19QT1NJVElPTj0idmlld1Bvc2l0aW9uIixILkRJUkVDVElPTj0iZGlyZWN0aW9uIixILkRJUkVDVElPTixILldPUkxEX01BVFJJWCxILlBPU0lUSU9OLEguU0NBTEUsSC5WSUVXX1BPU0lUSU9OO2NsYXNzIFZ0IGV4dGVuZHMgSHtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iTW9kZWxOb2RlIn1jb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX11cGRhdGUodCl7dGhpcy5vYmplY3QzZD10Lm9iamVjdCxzdXBlci51cGRhdGUodCl9fVZ0LkRJUkVDVElPTjtjb25zdCBZaD1PKFZ0LFZ0LldPUkxEX01BVFJJWCk7VnQuUE9TSVRJT04sVnQuU0NBTEUsVnQuVklFV19QT1NJVElPTjtjb25zdCBaaD14dChuZXcgQ3QpLm9uT2JqZWN0VXBkYXRlKCh7b2JqZWN0OnJ9LHQpPT50LnZhbHVlLmdldE5vcm1hbE1hdHJpeChyLm1hdHJpeFdvcmxkKSksWnI9anMubXVsKFloKS50b1ZhcigibW9kZWxWaWV3TWF0cml4XzIiKSxKaD1vcygicG9zaXRpb24iLCJ2ZWMzIikudmFyeWluZygicG9zaXRpb25Mb2NhbCIpLE10PVpyLm11bChKaCkueHl6LnZhcnlpbmcoInZfcG9zaXRpb25WaWV3IiksSnI9TXQubmVnYXRlKCkudmFyeWluZygidl9wb3NpdGlvblZpZXdEaXJlY3Rpb24iKS5ub3JtYWxpemUoKS50b1ZhcigicG9zaXRpb25WaWV3RGlyZWN0aW9uIik7Y2xhc3MgamggZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJGcm9udEZhY2luZ05vZGUifWNvbnN0cnVjdG9yKCl7c3VwZXIoImJvb2wiKSx0aGlzLmlzRnJvbnRGYWNpbmdOb2RlPSEwfWdlbmVyYXRlKHQpe2NvbnN0e3JlbmRlcmVyOmUsbWF0ZXJpYWw6c309dDtyZXR1cm4gZS5jb29yZGluYXRlU3lzdGVtPT09WWUmJnMuc2lkZT09PVVpPyJmYWxzZSI6dC5nZXRGcm9udEZhY2luZygpfX1jb25zdCBkaT1xKE8oamgpKS5tdWwoMikuc3ViKDEpLFFoPW9zKCJub3JtYWwiLCJ2ZWMzIiksS2g9dHQocj0+ci5nZW9tZXRyeS5oYXNBdHRyaWJ1dGUoIm5vcm1hbCIpPT09ITE/KGNvbnNvbGUud2FybignVFNMLk5vcm1hbE5vZGU6IFZlcnRleCBhdHRyaWJ1dGUgIm5vcm1hbCIgbm90IGZvdW5kIG9uIGdlb21ldHJ5LicpLGsoMCwxLDApKTpRaCwidmVjMyIpLm9uY2UoKSgpLnRvVmFyKCJub3JtYWxMb2NhbCIpLHR1PU10LmRGZHgoKS5jcm9zcyhNdC5kRmR5KCkpLm5vcm1hbGl6ZSgpLnRvVmFyKCJub3JtYWxGbGF0IiksTGU9dHQocj0+e2xldCB0O3JldHVybiByLm1hdGVyaWFsLmZsYXRTaGFkaW5nPT09ITA/dD10dTp0PVBlKFFyKEtoKSwidl9ub3JtYWxWaWV3Iikubm9ybWFsaXplKCksdH0sInZlYzMiKS5vbmNlKCkoKS50b1Zhcigibm9ybWFsVmlldyIpLGpyPXR0KHI9PnIuY29udGV4dC5zZXR1cE5vcm1hbCgpLCJ2ZWMzIikub25jZSgpKCkubXVsKGRpKS50b1ZhcigidHJhbnNmb3JtZWROb3JtYWxWaWV3IiksUXI9dHQoKFtyXSx0KT0+e2NvbnN0IGU9dC5yZW5kZXJlci5ub2Rlcy5tb2RlbE5vcm1hbFZpZXdNYXRyaXg7aWYoZSE9PW51bGwpcmV0dXJuIGUudHJhbnNmb3JtRGlyZWN0aW9uKHIpO2NvbnN0IHM9WmgubXVsKHIpO3JldHVybiBqcy50cmFuc2Zvcm1EaXJlY3Rpb24ocyl9KSxldT14dCgwKS5vblJlZmVyZW5jZSgoe21hdGVyaWFsOnJ9KT0+cikub25SZW5kZXJVcGRhdGUoKHttYXRlcmlhbDpyfSk9PnIucmVmcmFjdGlvblJhdGlvKSxzdT1Kci5uZWdhdGUoKS5yZWZsZWN0KGpyKSxudT1Kci5uZWdhdGUoKS5yZWZyYWN0KGpyLGV1KSxpdT1zdS50cmFuc2Zvcm1EaXJlY3Rpb24oanMpLnRvVmFyKCJyZWZsZWN0VmVjdG9yIikscnU9bnUudHJhbnNmb3JtRGlyZWN0aW9uKGpzKS50b1ZhcigicmVmbGVjdFZlY3RvciIpO2NsYXNzIG91IGV4dGVuZHMgSnN7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIkN1YmVUZXh0dXJlTm9kZSJ9Y29uc3RydWN0b3IodCxlPW51bGwscz1udWxsLG49bnVsbCl7c3VwZXIodCxlLHMsbiksdGhpcy5pc0N1YmVUZXh0dXJlTm9kZT0hMH1nZXRJbnB1dFR5cGUoKXtyZXR1cm4iY3ViZVRleHR1cmUifWdldERlZmF1bHRVVigpe2NvbnN0IHQ9dGhpcy52YWx1ZTtyZXR1cm4gdC5tYXBwaW5nPT09Q28/aXU6dC5tYXBwaW5nPT09Rm8/cnU6KGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkN1YmVUZXh0dXJlTm9kZTogTWFwcGluZyAiJXMiIG5vdCBzdXBwb3J0ZWQuJyx0Lm1hcHBpbmcpLGsoMCwwLDApKX1zZXRVcGRhdGVNYXRyaXgoKXt9c2V0dXBVVih0LGUpe2NvbnN0IHM9dGhpcy52YWx1ZTtyZXR1cm4gdC5yZW5kZXJlci5jb29yZGluYXRlU3lzdGVtPT09em58fCFzLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT9rKGUueC5uZWdhdGUoKSxlLnl6KTplfWdlbmVyYXRlVVYodCxlKXtyZXR1cm4gZS5idWlsZCh0LCJ2ZWMzIil9fWNvbnN0IGF1PUMob3UpO2NsYXNzIEtyIGV4dGVuZHMgSWV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIkJ1ZmZlck5vZGUifWNvbnN0cnVjdG9yKHQsZSxzPTApe3N1cGVyKHQsZSksdGhpcy5pc0J1ZmZlck5vZGU9ITAsdGhpcy5idWZmZXJUeXBlPWUsdGhpcy5idWZmZXJDb3VudD1zfWdldEVsZW1lbnRUeXBlKHQpe3JldHVybiB0aGlzLmdldE5vZGVUeXBlKHQpfWdldElucHV0VHlwZSgpe3JldHVybiJidWZmZXIifX1jb25zdCBjdT0ocix0LGUpPT52KG5ldyBLcihyLHQsZSkpO2NsYXNzIGh1IGV4dGVuZHMgaXN7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlVuaWZvcm1BcnJheUVsZW1lbnROb2RlIn1jb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQsZSksdGhpcy5pc0FycmF5QnVmZmVyRWxlbWVudE5vZGU9ITB9Z2VuZXJhdGUodCl7Y29uc3QgZT1zdXBlci5nZW5lcmF0ZSh0KSxzPXRoaXMuZ2V0Tm9kZVR5cGUoKTtyZXR1cm4gdC5mb3JtYXQoZSwidmVjNCIscyl9fWNsYXNzIHV1IGV4dGVuZHMgS3J7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlVuaWZvcm1BcnJheU5vZGUifWNvbnN0cnVjdG9yKHQsZT1udWxsKXtzdXBlcihudWxsLCJ2ZWM0IiksdGhpcy5hcnJheT10LHRoaXMuZWxlbWVudFR5cGU9ZSx0aGlzLl9lbGVtZW50VHlwZT1udWxsLHRoaXMuX2VsZW1lbnRMZW5ndGg9MCx0aGlzLnVwZGF0ZVR5cGU9US5SRU5ERVIsdGhpcy5pc0FycmF5QnVmZmVyTm9kZT0hMH1nZXRFbGVtZW50VHlwZSgpe3JldHVybiB0aGlzLmVsZW1lbnRUeXBlfHx0aGlzLl9lbGVtZW50VHlwZX1nZXRFbGVtZW50TGVuZ3RoKCl7cmV0dXJuIHRoaXMuX2VsZW1lbnRMZW5ndGh9dXBkYXRlKCl7Y29uc3R7YXJyYXk6dCx2YWx1ZTplfT10aGlzLHM9dGhpcy5nZXRFbGVtZW50TGVuZ3RoKCksbj10aGlzLmdldEVsZW1lbnRUeXBlKCk7aWYocz09PTEpZm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IG89aSo0O2Vbb109dFtpXX1lbHNlIGlmKG49PT0iY29sb3IiKWZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCBvPWkqNCxhPXRbaV07ZVtvXT1hLnIsZVtvKzFdPWEuZyxlW28rMl09YS5ifHwwfWVsc2UgZm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IG89aSo0LGE9dFtpXTtlW29dPWEueCxlW28rMV09YS55LGVbbysyXT1hLnp8fDAsZVtvKzNdPWEud3x8MH19c2V0dXAodCl7Y29uc3QgZT10aGlzLmFycmF5Lmxlbmd0aDt0aGlzLl9lbGVtZW50VHlwZT10aGlzLmVsZW1lbnRUeXBlPT09bnVsbD9Wcyh0aGlzLmFycmF5WzBdKTp0aGlzLmVsZW1lbnRUeXBlLHRoaXMuX2VsZW1lbnRMZW5ndGg9dC5nZXRUeXBlTGVuZ3RoKHRoaXMuX2VsZW1lbnRUeXBlKTtsZXQgcz1GbG9hdDMyQXJyYXk7cmV0dXJuIHRoaXMuX2VsZW1lbnRUeXBlLmNoYXJBdCgwKT09PSJpIj9zPUludDMyQXJyYXk6dGhpcy5fZWxlbWVudFR5cGUuY2hhckF0KDApPT09InUiJiYocz1VaW50MzJBcnJheSksdGhpcy52YWx1ZT1uZXcgcyhlKjQpLHRoaXMuYnVmZmVyQ291bnQ9ZSx0aGlzLmJ1ZmZlclR5cGU9dC5jaGFuZ2VDb21wb25lbnRUeXBlKCJ2ZWM0Iix0LmdldENvbXBvbmVudFR5cGUodGhpcy5fZWxlbWVudFR5cGUpKSxzdXBlci5zZXR1cCh0KX1lbGVtZW50KHQpe3JldHVybiB2KG5ldyBodSh0aGlzLHYodCkpKX19Y29uc3QgZmk9KHIsdCk9PnYobmV3IHV1KHIsdCkpO2NsYXNzIGx1IGV4dGVuZHMgaXN7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlJlZmVyZW5jZUVsZW1lbnROb2RlIn1jb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKHQsZSksdGhpcy5yZWZlcmVuY2VOb2RlPXQsdGhpcy5pc1JlZmVyZW5jZUVsZW1lbnROb2RlPSEwfWdldE5vZGVUeXBlKCl7cmV0dXJuIHRoaXMucmVmZXJlbmNlTm9kZS51bmlmb3JtVHlwZX1nZW5lcmF0ZSh0KXtjb25zdCBlPXN1cGVyLmdlbmVyYXRlKHQpLHM9dGhpcy5yZWZlcmVuY2VOb2RlLmdldE5vZGVUeXBlKCksbj10aGlzLmdldE5vZGVUeXBlKCk7cmV0dXJuIHQuZm9ybWF0KGUscyxuKX19Y2xhc3MgdG8gZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJSZWZlcmVuY2VOb2RlIn1jb25zdHJ1Y3Rvcih0LGUscz1udWxsLG49bnVsbCl7c3VwZXIoKSx0aGlzLnByb3BlcnR5PXQsdGhpcy51bmlmb3JtVHlwZT1lLHRoaXMub2JqZWN0PXMsdGhpcy5jb3VudD1uLHRoaXMucHJvcGVydGllcz10LnNwbGl0KCIuIiksdGhpcy5yZWZlcmVuY2U9cyx0aGlzLm5vZGU9bnVsbCx0aGlzLmdyb3VwPW51bGwsdGhpcy5uYW1lPW51bGwsdGhpcy51cGRhdGVUeXBlPVEuT0JKRUNUfWVsZW1lbnQodCl7cmV0dXJuIHYobmV3IGx1KHRoaXMsdih0KSkpfXNldEdyb3VwKHQpe3JldHVybiB0aGlzLmdyb3VwPXQsdGhpc31sYWJlbCh0KXtyZXR1cm4gdGhpcy5uYW1lPXQsdGhpc31zZXROb2RlVHlwZSh0KXtsZXQgZT1udWxsO3RoaXMuY291bnQhPT1udWxsP2U9Y3UobnVsbCx0LHRoaXMuY291bnQpOkFycmF5LmlzQXJyYXkodGhpcy5nZXRWYWx1ZUZyb21SZWZlcmVuY2UoKSk/ZT1maShudWxsLHQpOnQ9PT0idGV4dHVyZSI/ZT1hcyhudWxsKTp0PT09ImN1YmVUZXh0dXJlIj9lPWF1KG51bGwpOmU9eHQobnVsbCx0KSx0aGlzLmdyb3VwIT09bnVsbCYmZS5zZXRHcm91cCh0aGlzLmdyb3VwKSx0aGlzLm5hbWUhPT1udWxsJiZlLmxhYmVsKHRoaXMubmFtZSksdGhpcy5ub2RlPWUuZ2V0U2VsZigpfWdldE5vZGVUeXBlKHQpe3JldHVybiB0aGlzLm5vZGU9PT1udWxsJiYodGhpcy51cGRhdGVSZWZlcmVuY2UodCksdGhpcy51cGRhdGVWYWx1ZSgpKSx0aGlzLm5vZGUuZ2V0Tm9kZVR5cGUodCl9Z2V0VmFsdWVGcm9tUmVmZXJlbmNlKHQ9dGhpcy5yZWZlcmVuY2Upe2NvbnN0e3Byb3BlcnRpZXM6ZX09dGhpcztsZXQgcz10W2VbMF1dO2ZvcihsZXQgbj0xO248ZS5sZW5ndGg7bisrKXM9c1tlW25dXTtyZXR1cm4gc311cGRhdGVSZWZlcmVuY2UodCl7cmV0dXJuIHRoaXMucmVmZXJlbmNlPXRoaXMub2JqZWN0IT09bnVsbD90aGlzLm9iamVjdDp0Lm9iamVjdCx0aGlzLnJlZmVyZW5jZX1zZXR1cCgpe3JldHVybiB0aGlzLnVwZGF0ZVZhbHVlKCksdGhpcy5ub2RlfXVwZGF0ZSgpe3RoaXMudXBkYXRlVmFsdWUoKX11cGRhdGVWYWx1ZSgpe3RoaXMubm9kZT09PW51bGwmJnRoaXMuc2V0Tm9kZVR5cGUodGhpcy51bmlmb3JtVHlwZSk7Y29uc3QgdD10aGlzLmdldFZhbHVlRnJvbVJlZmVyZW5jZSgpO0FycmF5LmlzQXJyYXkodCk/dGhpcy5ub2RlLmFycmF5PXQ6dGhpcy5ub2RlLnZhbHVlPXR9fWNvbnN0IHBlPShyLHQsZSk9PnYobmV3IHRvKHIsdCxlKSk7Y2xhc3MgZHUgZXh0ZW5kcyB0b3tzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iTWF0ZXJpYWxSZWZlcmVuY2VOb2RlIn1jb25zdHJ1Y3Rvcih0LGUscz1udWxsKXtzdXBlcih0LGUscyksdGhpcy5tYXRlcmlhbD1zLHRoaXMuaXNNYXRlcmlhbFJlZmVyZW5jZU5vZGU9ITB9dXBkYXRlUmVmZXJlbmNlKHQpe3JldHVybiB0aGlzLnJlZmVyZW5jZT10aGlzLm1hdGVyaWFsIT09bnVsbD90aGlzLm1hdGVyaWFsOnQubWF0ZXJpYWwsdGhpcy5yZWZlcmVuY2V9fWNvbnN0IGZ1PShyLHQsZSk9PnYobmV3IGR1KHIsdCxlKSksZW89dHQocj0+KHIuZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCJ0YW5nZW50Iik9PT0hMSYmci5nZW9tZXRyeS5jb21wdXRlVGFuZ2VudHMoKSxvcygidGFuZ2VudCIsInZlYzQiKSkpKCkscHU9ZW8ueHl6LnRvVmFyKCJ0YW5nZW50TG9jYWwiKSxzbz1aci5tdWwoQmUocHUsMCkpLnh5ei52YXJ5aW5nKCJ2X3RhbmdlbnRWaWV3Iikubm9ybWFsaXplKCkudG9WYXIoInRhbmdlbnRWaWV3IiksbXU9cXMoc28sUGUoKHI9PnIubXVsKGVvLncpLnh5eikoTGUuY3Jvc3Moc28pKSwidl9iaXRhbmdlbnRWaWV3Iikubm9ybWFsaXplKCkudG9WYXIoImJpdGFuZ2VudFZpZXciKSxMZSkseXU9dHQocj0+e2NvbnN0e2V5ZV9wb3M6dCxzdXJmX25vcm06ZSxtYXBOOnMsdXY6bn09cixpPXQuZEZkeCgpLG89dC5kRmR5KCksYT1uLmRGZHgoKSxjPW4uZEZkeSgpLHU9ZSxoPW8uY3Jvc3ModSksbD11LmNyb3NzKGkpLGQ9aC5tdWwoYS54KS5hZGQobC5tdWwoYy54KSksZj1oLm11bChhLnkpLmFkZChsLm11bChjLnkpKSxwPWQuZG90KGQpLm1heChmLmRvdChmKSksbT1kaS5tdWwocC5pbnZlcnNlU3FydCgpKTtyZXR1cm4gZmUoZC5tdWwocy54LG0pLGYubXVsKHMueSxtKSx1Lm11bChzLnopKS5ub3JtYWxpemUoKX0pO2NsYXNzIGd1IGV4dGVuZHMgZHR7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIk5vcm1hbE1hcE5vZGUifWNvbnN0cnVjdG9yKHQsZT1udWxsKXtzdXBlcigidmVjMyIpLHRoaXMubm9kZT10LHRoaXMuc2NhbGVOb2RlPWUsdGhpcy5ub3JtYWxNYXBUeXBlPVlpfXNldHVwKHQpe2NvbnN0e25vcm1hbE1hcFR5cGU6ZSxzY2FsZU5vZGU6c309dGhpcztsZXQgbj10aGlzLm5vZGUubXVsKDIpLnN1YigxKTtzIT09bnVsbCYmKG49ayhuLnh5Lm11bChzKSxuLnopKTtsZXQgaT1udWxsO3JldHVybiBlPT09T28/aT1RcihuKTplPT09WWkmJih0Lmhhc0dlb21ldHJ5QXR0cmlidXRlKCJ0YW5nZW50Iik9PT0hMD9pPW11Lm11bChuKS5ub3JtYWxpemUoKTppPXl1KHtleWVfcG9zOk10LHN1cmZfbm9ybTpMZSxtYXBOOm4sdXY6WnMoKX0pKSxpfX1jb25zdCBubz1DKGd1KSx4dT10dCgoe3RleHR1cmVOb2RlOnIsYnVtcFNjYWxlOnR9KT0+e2NvbnN0IGU9bj0+ci5jYWNoZSgpLmNvbnRleHQoe2dldFVWOmk9Pm4oaS51dk5vZGV8fFpzKCkpLGZvcmNlVVZDb250ZXh0OiEwfSkscz1xKGUobj0+bikpO3JldHVybiBEKHEoZShuPT5uLmFkZChuLmRGZHgoKSkpKS5zdWIocykscShlKG49Pm4uYWRkKG4uZEZkeSgpKSkpLnN1YihzKSkubXVsKHQpfSksVHU9dHQocj0+e2NvbnN0e3N1cmZfcG9zOnQsc3VyZl9ub3JtOmUsZEhkeHk6c309cixuPXQuZEZkeCgpLm5vcm1hbGl6ZSgpLGk9dC5kRmR5KCkubm9ybWFsaXplKCksbz1lLGE9aS5jcm9zcyhvKSxjPW8uY3Jvc3MobiksdT1uLmRvdChhKS5tdWwoZGkpLGg9dS5zaWduKCkubXVsKHMueC5tdWwoYSkuYWRkKHMueS5tdWwoYykpKTtyZXR1cm4gdS5hYnMoKS5tdWwoZSkuc3ViKGgpLm5vcm1hbGl6ZSgpfSk7Y2xhc3MgTnUgZXh0ZW5kcyBkdHtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iQnVtcE1hcE5vZGUifWNvbnN0cnVjdG9yKHQsZT1udWxsKXtzdXBlcigidmVjMyIpLHRoaXMudGV4dHVyZU5vZGU9dCx0aGlzLnNjYWxlTm9kZT1lfXNldHVwKCl7Y29uc3QgdD10aGlzLnNjYWxlTm9kZSE9PW51bGw/dGhpcy5zY2FsZU5vZGU6MSxlPXh1KHt0ZXh0dXJlTm9kZTp0aGlzLnRleHR1cmVOb2RlLGJ1bXBTY2FsZTp0fSk7cmV0dXJuIFR1KHtzdXJmX3BvczpNdCxzdXJmX25vcm06TGUsZEhkeHk6ZX0pfX1jb25zdCB3dT1DKE51KSxpbz1uZXcgTWFwO2NsYXNzIHogZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJNYXRlcmlhbE5vZGUifWNvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5zY29wZT10fWdldENhY2hlKHQsZSl7bGV0IHM9aW8uZ2V0KHQpO3JldHVybiBzPT09dm9pZCAwJiYocz1mdSh0LGUpLGlvLnNldCh0LHMpKSxzfWdldEZsb2F0KHQpe3JldHVybiB0aGlzLmdldENhY2hlKHQsImZsb2F0Iil9Z2V0Q29sb3IodCl7cmV0dXJuIHRoaXMuZ2V0Q2FjaGUodCwiY29sb3IiKX1nZXRUZXh0dXJlKHQpe3JldHVybiB0aGlzLmdldENhY2hlKHQ9PT0ibWFwIj8ibWFwIjp0KyJNYXAiLCJ0ZXh0dXJlIil9c2V0dXAodCl7Y29uc3QgZT10LmNvbnRleHQubWF0ZXJpYWwscz10aGlzLnNjb3BlO2xldCBuPW51bGw7aWYocz09PXouQ09MT1Ipe2NvbnN0IGk9ZS5jb2xvciE9PXZvaWQgMD90aGlzLmdldENvbG9yKHMpOmsoKTtlLm1hcCYmZS5tYXAuaXNUZXh0dXJlPT09ITA/bj1pLm11bCh0aGlzLmdldFRleHR1cmUoIm1hcCIpKTpuPWl9ZWxzZSBpZihzPT09ei5PUEFDSVRZKXtjb25zdCBpPXRoaXMuZ2V0RmxvYXQocyk7ZS5hbHBoYU1hcCYmZS5hbHBoYU1hcC5pc1RleHR1cmU9PT0hMD9uPWkubXVsKHRoaXMuZ2V0VGV4dHVyZSgiYWxwaGEiKSk6bj1pfWVsc2UgaWYocz09PXouU1BFQ1VMQVJfU1RSRU5HVEgpZS5zcGVjdWxhck1hcCYmZS5zcGVjdWxhck1hcC5pc1RleHR1cmU9PT0hMD9uPXRoaXMuZ2V0VGV4dHVyZSgic3BlY3VsYXIiKS5yOm49cSgxKTtlbHNlIGlmKHM9PT16LlNQRUNVTEFSX0lOVEVOU0lUWSl7Y29uc3QgaT10aGlzLmdldEZsb2F0KHMpO2Uuc3BlY3VsYXJNYXA/bj1pLm11bCh0aGlzLmdldFRleHR1cmUocykuYSk6bj1pfWVsc2UgaWYocz09PXouU1BFQ1VMQVJfQ09MT1Ipe2NvbnN0IGk9dGhpcy5nZXRDb2xvcihzKTtlLnNwZWN1bGFyQ29sb3JNYXAmJmUuc3BlY3VsYXJDb2xvck1hcC5pc1RleHR1cmU9PT0hMD9uPWkubXVsKHRoaXMuZ2V0VGV4dHVyZShzKS5yZ2IpOm49aX1lbHNlIGlmKHM9PT16LlJPVUdITkVTUyl7Y29uc3QgaT10aGlzLmdldEZsb2F0KHMpO2Uucm91Z2huZXNzTWFwJiZlLnJvdWdobmVzc01hcC5pc1RleHR1cmU9PT0hMD9uPWkubXVsKHRoaXMuZ2V0VGV4dHVyZShzKS5nKTpuPWl9ZWxzZSBpZihzPT09ei5NRVRBTE5FU1Mpe2NvbnN0IGk9dGhpcy5nZXRGbG9hdChzKTtlLm1ldGFsbmVzc01hcCYmZS5tZXRhbG5lc3NNYXAuaXNUZXh0dXJlPT09ITA/bj1pLm11bCh0aGlzLmdldFRleHR1cmUocykuYik6bj1pfWVsc2UgaWYocz09PXouRU1JU1NJVkUpe2NvbnN0IGk9dGhpcy5nZXRGbG9hdCgiZW1pc3NpdmVJbnRlbnNpdHkiKSxvPXRoaXMuZ2V0Q29sb3IocykubXVsKGkpO2UuZW1pc3NpdmVNYXAmJmUuZW1pc3NpdmVNYXAuaXNUZXh0dXJlPT09ITA/bj1vLm11bCh0aGlzLmdldFRleHR1cmUocykpOm49b31lbHNlIGlmKHM9PT16Lk5PUk1BTCllLm5vcm1hbE1hcD8obj1ubyh0aGlzLmdldFRleHR1cmUoIm5vcm1hbCIpLHRoaXMuZ2V0Q2FjaGUoIm5vcm1hbFNjYWxlIiwidmVjMiIpKSxuLm5vcm1hbE1hcFR5cGU9ZS5ub3JtYWxNYXBUeXBlKTplLmJ1bXBNYXA/bj13dSh0aGlzLmdldFRleHR1cmUoImJ1bXAiKS5yLHRoaXMuZ2V0RmxvYXQoImJ1bXBTY2FsZSIpKTpuPUxlO2Vsc2UgaWYocz09PXouQ0xFQVJDT0FUKXtjb25zdCBpPXRoaXMuZ2V0RmxvYXQocyk7ZS5jbGVhcmNvYXRNYXAmJmUuY2xlYXJjb2F0TWFwLmlzVGV4dHVyZT09PSEwP249aS5tdWwodGhpcy5nZXRUZXh0dXJlKHMpLnIpOm49aX1lbHNlIGlmKHM9PT16LkNMRUFSQ09BVF9ST1VHSE5FU1Mpe2NvbnN0IGk9dGhpcy5nZXRGbG9hdChzKTtlLmNsZWFyY29hdFJvdWdobmVzc01hcCYmZS5jbGVhcmNvYXRSb3VnaG5lc3NNYXAuaXNUZXh0dXJlPT09ITA/bj1pLm11bCh0aGlzLmdldFRleHR1cmUocykucik6bj1pfWVsc2UgaWYocz09PXouQ0xFQVJDT0FUX05PUk1BTCllLmNsZWFyY29hdE5vcm1hbE1hcD9uPW5vKHRoaXMuZ2V0VGV4dHVyZShzKSx0aGlzLmdldENhY2hlKHMrIlNjYWxlIiwidmVjMiIpKTpuPUxlO2Vsc2UgaWYocz09PXouU0hFRU4pe2NvbnN0IGk9dGhpcy5nZXRDb2xvcigic2hlZW5Db2xvciIpLm11bCh0aGlzLmdldEZsb2F0KCJzaGVlbiIpKTtlLnNoZWVuQ29sb3JNYXAmJmUuc2hlZW5Db2xvck1hcC5pc1RleHR1cmU9PT0hMD9uPWkubXVsKHRoaXMuZ2V0VGV4dHVyZSgic2hlZW5Db2xvciIpLnJnYik6bj1pfWVsc2UgaWYocz09PXouU0hFRU5fUk9VR0hORVNTKXtjb25zdCBpPXRoaXMuZ2V0RmxvYXQocyk7ZS5zaGVlblJvdWdobmVzc01hcCYmZS5zaGVlblJvdWdobmVzc01hcC5pc1RleHR1cmU9PT0hMD9uPWkubXVsKHRoaXMuZ2V0VGV4dHVyZShzKS5hKTpuPWksbj1uLmNsYW1wKC4wNywxKX1lbHNlIGlmKHM9PT16LkFOSVNPVFJPUFkpaWYoZS5hbmlzb3Ryb3B5TWFwJiZlLmFuaXNvdHJvcHlNYXAuaXNUZXh0dXJlPT09ITApe2NvbnN0IGk9dGhpcy5nZXRUZXh0dXJlKHMpO249UnIodXMueCx1cy55LHVzLnkubmVnYXRlKCksdXMueCkubXVsKGkucmcubXVsKDIpLnN1YihEKDEpKS5ub3JtYWxpemUoKS5tdWwoaS5iKSl9ZWxzZSBuPXVzO2Vsc2UgaWYocz09PXouSVJJREVTQ0VOQ0VfVEhJQ0tORVNTKXtjb25zdCBpPXBlKCIxIiwiZmxvYXQiLGUuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSk7aWYoZS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCl7Y29uc3Qgbz1wZSgiMCIsImZsb2F0IixlLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UpO249aS5zdWIobykubXVsKHRoaXMuZ2V0VGV4dHVyZShzKS5nKS5hZGQobyl9ZWxzZSBuPWl9ZWxzZSBpZihzPT09ei5UUkFOU01JU1NJT04pe2NvbnN0IGk9dGhpcy5nZXRGbG9hdChzKTtlLnRyYW5zbWlzc2lvbk1hcD9uPWkubXVsKHRoaXMuZ2V0VGV4dHVyZShzKS5yKTpuPWl9ZWxzZSBpZihzPT09ei5USElDS05FU1Mpe2NvbnN0IGk9dGhpcy5nZXRGbG9hdChzKTtlLnRoaWNrbmVzc01hcD9uPWkubXVsKHRoaXMuZ2V0VGV4dHVyZShzKS5nKTpuPWl9ZWxzZSBpZihzPT09ei5JT1Ipbj10aGlzLmdldEZsb2F0KHMpO2Vsc2UgaWYocz09PXouTElHSFRfTUFQKW49dGhpcy5nZXRUZXh0dXJlKHMpLnJnYi5tdWwodGhpcy5nZXRGbG9hdCgibGlnaHRNYXBJbnRlbnNpdHkiKSk7ZWxzZSBpZihzPT09ei5BT19NQVApbj10aGlzLmdldFRleHR1cmUocykuci5zdWIoMSkubXVsKHRoaXMuZ2V0RmxvYXQoImFvTWFwSW50ZW5zaXR5IikpLmFkZCgxKTtlbHNle2NvbnN0IGk9dGhpcy5nZXROb2RlVHlwZSh0KTtuPXRoaXMuZ2V0Q2FjaGUocyxpKX1yZXR1cm4gbn19ei5BTFBIQV9URVNUPSJhbHBoYVRlc3QiLHouQ09MT1I9ImNvbG9yIix6Lk9QQUNJVFk9Im9wYWNpdHkiLHouU0hJTklORVNTPSJzaGluaW5lc3MiLHouU1BFQ1VMQVI9InNwZWN1bGFyIix6LlNQRUNVTEFSX1NUUkVOR1RIPSJzcGVjdWxhclN0cmVuZ3RoIix6LlNQRUNVTEFSX0lOVEVOU0lUWT0ic3BlY3VsYXJJbnRlbnNpdHkiLHouU1BFQ1VMQVJfQ09MT1I9InNwZWN1bGFyQ29sb3IiLHouUkVGTEVDVElWSVRZPSJyZWZsZWN0aXZpdHkiLHouUk9VR0hORVNTPSJyb3VnaG5lc3MiLHouTUVUQUxORVNTPSJtZXRhbG5lc3MiLHouTk9STUFMPSJub3JtYWwiLHouQ0xFQVJDT0FUPSJjbGVhcmNvYXQiLHouQ0xFQVJDT0FUX1JPVUdITkVTUz0iY2xlYXJjb2F0Um91Z2huZXNzIix6LkNMRUFSQ09BVF9OT1JNQUw9ImNsZWFyY29hdE5vcm1hbCIsei5FTUlTU0lWRT0iZW1pc3NpdmUiLHouUk9UQVRJT049InJvdGF0aW9uIix6LlNIRUVOPSJzaGVlbiIsei5TSEVFTl9ST1VHSE5FU1M9InNoZWVuUm91Z2huZXNzIix6LkFOSVNPVFJPUFk9ImFuaXNvdHJvcHkiLHouSVJJREVTQ0VOQ0U9ImlyaWRlc2NlbmNlIix6LklSSURFU0NFTkNFX0lPUj0iaXJpZGVzY2VuY2VJT1IiLHouSVJJREVTQ0VOQ0VfVEhJQ0tORVNTPSJpcmlkZXNjZW5jZVRoaWNrbmVzcyIsei5JT1I9ImlvciIsei5UUkFOU01JU1NJT049InRyYW5zbWlzc2lvbiIsei5USElDS05FU1M9InRoaWNrbmVzcyIsei5BVFRFTlVBVElPTl9ESVNUQU5DRT0iYXR0ZW51YXRpb25EaXN0YW5jZSIsei5BVFRFTlVBVElPTl9DT0xPUj0iYXR0ZW51YXRpb25Db2xvciIsei5MSU5FX1NDQUxFPSJzY2FsZSIsei5MSU5FX0RBU0hfU0laRT0iZGFzaFNpemUiLHouTElORV9HQVBfU0laRT0iZ2FwU2l6ZSIsei5MSU5FX1dJRFRIPSJsaW5ld2lkdGgiLHouTElORV9EQVNIX09GRlNFVD0iZGFzaE9mZnNldCIsei5QT0lOVF9XSURUSD0icG9pbnRXaWR0aCIsei5ESVNQRVJTSU9OPSJkaXNwZXJzaW9uIix6LkxJR0hUX01BUD0ibGlnaHQiLHouQU9fTUFQPSJhbyIsei5BTFBIQV9URVNULHouQ09MT1Isei5TSElOSU5FU1Msei5FTUlTU0lWRSx6Lk9QQUNJVFksei5TUEVDVUxBUix6LlNQRUNVTEFSX0lOVEVOU0lUWSx6LlNQRUNVTEFSX0NPTE9SLHouU1BFQ1VMQVJfU1RSRU5HVEgsei5SRUZMRUNUSVZJVFksei5ST1VHSE5FU1Msei5NRVRBTE5FU1Msei5DTEVBUkNPQVQsei5DTEVBUkNPQVRfUk9VR0hORVNTLHouUk9UQVRJT04sei5TSEVFTix6LlNIRUVOX1JPVUdITkVTUyx6LkFOSVNPVFJPUFksei5JUklERVNDRU5DRSx6LklSSURFU0NFTkNFX0lPUix6LklSSURFU0NFTkNFX1RISUNLTkVTUyx6LlRSQU5TTUlTU0lPTix6LlRISUNLTkVTUyx6LklPUix6LkFUVEVOVUFUSU9OX0RJU1RBTkNFLHouQVRURU5VQVRJT05fQ09MT1Isei5MSU5FX1NDQUxFLHouTElORV9EQVNIX1NJWkUsei5MSU5FX0dBUF9TSVpFLHouTElORV9XSURUSCx6LkxJTkVfREFTSF9PRkZTRVQsei5QT0lOVF9XSURUSCx6LkRJU1BFUlNJT04sei5MSUdIVF9NQVAsei5BT19NQVA7Y29uc3QgdXM9eHQobmV3IEopLm9uUmVmZXJlbmNlKGZ1bmN0aW9uKHIpe3JldHVybiByLm1hdGVyaWFsfSkub25SZW5kZXJVcGRhdGUoZnVuY3Rpb24oe21hdGVyaWFsOnJ9KXt0aGlzLnZhbHVlLnNldChyLmFuaXNvdHJvcHkqTWF0aC5jb3Moci5hbmlzb3Ryb3B5Um90YXRpb24pLHIuYW5pc290cm9weSpNYXRoLnNpbihyLmFuaXNvdHJvcHlSb3RhdGlvbikpfSk7Y2xhc3MgVyBleHRlbmRzIFV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIkluZGV4Tm9kZSJ9Y29uc3RydWN0b3IodCl7c3VwZXIoInVpbnQiKSx0aGlzLnNjb3BlPXQsdGhpcy5pc0luc3RhbmNlSW5kZXhOb2RlPSEwfWdlbmVyYXRlKHQpe2NvbnN0IGU9dGhpcy5nZXROb2RlVHlwZSh0KSxzPXRoaXMuc2NvcGU7bGV0IG47aWYocz09PVcuVkVSVEVYKW49dC5nZXRWZXJ0ZXhJbmRleCgpO2Vsc2UgaWYocz09PVcuSU5TVEFOQ0Upbj10LmdldEluc3RhbmNlSW5kZXgoKTtlbHNlIGlmKHM9PT1XLkRSQVcpbj10LmdldERyYXdJbmRleCgpO2Vsc2UgaWYocz09PVcuSU5WT0NBVElPTl9MT0NBTCluPXQuZ2V0SW52b2NhdGlvbkxvY2FsSW5kZXgoKTtlbHNlIGlmKHM9PT1XLklOVk9DQVRJT05fU1VCR1JPVVApbj10LmdldEludm9jYXRpb25TdWJncm91cEluZGV4KCk7ZWxzZSBpZihzPT09Vy5TVUJHUk9VUCluPXQuZ2V0U3ViZ3JvdXBJbmRleCgpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5JbmRleE5vZGU6IFVua25vd24gc2NvcGU6ICIrcyk7bGV0IGk7cmV0dXJuIHQuc2hhZGVyU3RhZ2U9PT0idmVydGV4Inx8dC5zaGFkZXJTdGFnZT09PSJjb21wdXRlIj9pPW46aT1QZSh0aGlzKS5idWlsZCh0LGUpLGl9fVcuVkVSVEVYPSJ2ZXJ0ZXgiLFcuSU5TVEFOQ0U9Imluc3RhbmNlIixXLlNVQkdST1VQPSJzdWJncm91cCIsVy5JTlZPQ0FUSU9OX0xPQ0FMPSJpbnZvY2F0aW9uTG9jYWwiLFcuSU5WT0NBVElPTl9TVUJHUk9VUD0iaW52b2NhdGlvblN1Ymdyb3VwIixXLkRSQVc9ImRyYXciLFcuVkVSVEVYLFcuSU5TVEFOQ0UsVy5TVUJHUk9VUCxXLklOVk9DQVRJT05fU1VCR1JPVVAsVy5JTlZPQ0FUSU9OX0xPQ0FMLFcuRFJBVztjbGFzcyBBdSBleHRlbmRzIFV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIkxvb3BOb2RlIn1jb25zdHJ1Y3Rvcih0PVtdKXtzdXBlcigpLHRoaXMucGFyYW1zPXR9Z2V0VmFyTmFtZSh0KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgiaSIuY2hhckNvZGVBdCgpK3QpfWdldFByb3BlcnRpZXModCl7Y29uc3QgZT10LmdldE5vZGVQcm9wZXJ0aWVzKHRoaXMpO2lmKGUuc3RhY2tOb2RlIT09dm9pZCAwKXJldHVybiBlO2NvbnN0IHM9e307Zm9yKGxldCBpPTAsbz10aGlzLnBhcmFtcy5sZW5ndGgtMTtpPG87aSsrKXtjb25zdCBhPXRoaXMucGFyYW1zW2ldLGM9YS5pc05vZGUhPT0hMCYmYS5uYW1lfHx0aGlzLmdldFZhck5hbWUoaSksdT1hLmlzTm9kZSE9PSEwJiZhLnR5cGV8fCJpbnQiO3NbY109WXMoYyx1KX1jb25zdCBuPXQuYWRkU3RhY2soKTtyZXR1cm4gZS5yZXR1cm5zTm9kZT10aGlzLnBhcmFtc1t0aGlzLnBhcmFtcy5sZW5ndGgtMV0ocyxuLHQpLGUuc3RhY2tOb2RlPW4sdC5yZW1vdmVTdGFjaygpLGV9Z2V0Tm9kZVR5cGUodCl7Y29uc3R7cmV0dXJuc05vZGU6ZX09dGhpcy5nZXRQcm9wZXJ0aWVzKHQpO3JldHVybiBlP2UuZ2V0Tm9kZVR5cGUodCk6InZvaWQifXNldHVwKHQpe3RoaXMuZ2V0UHJvcGVydGllcyh0KX1nZW5lcmF0ZSh0KXtjb25zdCBlPXRoaXMuZ2V0UHJvcGVydGllcyh0KSxzPXRoaXMucGFyYW1zLG49ZS5zdGFja05vZGU7Zm9yKGxldCBhPTAsYz1zLmxlbmd0aC0xO2E8YzthKyspe2NvbnN0IHU9c1thXTtsZXQgaD1udWxsLGw9bnVsbCxkPW51bGwsZj1udWxsLHA9bnVsbCxtPW51bGw7dS5pc05vZGU/KGY9ImludCIsZD10aGlzLmdldFZhck5hbWUoYSksaD0iMCIsbD11LmJ1aWxkKHQsZikscD0iPCIpOihmPXUudHlwZXx8ImludCIsZD11Lm5hbWV8fHRoaXMuZ2V0VmFyTmFtZShhKSxoPXUuc3RhcnQsbD11LmVuZCxwPXUuY29uZGl0aW9uLG09dS51cGRhdGUsdHlwZW9mIGg9PSJudW1iZXIiP2g9aC50b1N0cmluZygpOmgmJmguaXNOb2RlJiYoaD1oLmJ1aWxkKHQsZikpLHR5cGVvZiBsPT0ibnVtYmVyIj9sPWwudG9TdHJpbmcoKTpsJiZsLmlzTm9kZSYmKGw9bC5idWlsZCh0LGYpKSxoIT09dm9pZCAwJiZsPT09dm9pZCAwPyhoPWgrIiAtIDEiLGw9IjAiLHA9Ij49Iik6bCE9PXZvaWQgMCYmaD09PXZvaWQgMCYmKGg9IjAiLHA9IjwiKSxwPT09dm9pZCAwJiYoTnVtYmVyKGgpPk51bWJlcihsKT9wPSI+PSI6cD0iPCIpKTtjb25zdCBnPXtzdGFydDpoLGVuZDpsLGNvbmRpdGlvbjpwfSx5PWcuc3RhcnQsVD1nLmVuZDtsZXQgdz0iIixNPSIiLE49IiI7bXx8KGY9PT0iaW50Inx8Zj09PSJ1aW50Ij9wLmluY2x1ZGVzKCI8Iik/bT0iKysiOm09Ii0tIjpwLmluY2x1ZGVzKCI8Iik/bT0iKz0gMS4iOm09Ii09IDEuIiksdys9dC5nZXRWYXIoZixkKSsiID0gIit5LE0rPWQrIiAiK3ArIiAiK1QsTis9ZCsiICIrbTtjb25zdCBfPWBmb3IgKCAke3d9OyAke019OyAke059IClgO3QuYWRkRmxvd0NvZGUoKGE9PT0wP2AKYDoiIikrdC50YWIrXytgIHsKCmApLmFkZEZsb3dUYWIoKX1jb25zdCBpPW4uYnVpbGQodCwidm9pZCIpLG89ZS5yZXR1cm5zTm9kZT9lLnJldHVybnNOb2RlLmJ1aWxkKHQpOiIiO3QucmVtb3ZlRmxvd1RhYigpLmFkZEZsb3dDb2RlKGAKYCt0LnRhYitpKTtmb3IobGV0IGE9MCxjPXRoaXMucGFyYW1zLmxlbmd0aC0xO2E8YzthKyspdC5hZGRGbG93Q29kZSgoYT09PTA/IiI6dC50YWIpK2B9CgpgKS5yZW1vdmVGbG93VGFiKCk7cmV0dXJuIHQuYWRkRmxvd1RhYigpLG99fWNvbnN0IE9lPSguLi5yKT0+dihuZXcgQXUoRmUociwiaW50IikpKS5hcHBlbmQoKTtsZXQgbHMsZHM7Y2xhc3MgZXQgZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJTY3JlZW5Ob2RlIn1jb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuc2NvcGU9dCx0aGlzLmlzVmlld3BvcnROb2RlPSEwfWdldE5vZGVUeXBlKCl7cmV0dXJuIHRoaXMuc2NvcGU9PT1ldC5WSUVXUE9SVD8idmVjNCI6InZlYzIifWdldFVwZGF0ZVR5cGUoKXtsZXQgdD1RLk5PTkU7cmV0dXJuKHRoaXMuc2NvcGU9PT1ldC5TSVpFfHx0aGlzLnNjb3BlPT09ZXQuVklFV1BPUlQpJiYodD1RLlJFTkRFUiksdGhpcy51cGRhdGVUeXBlPXQsdH11cGRhdGUoe3JlbmRlcmVyOnR9KXtjb25zdCBlPXQuZ2V0UmVuZGVyVGFyZ2V0KCk7dGhpcy5zY29wZT09PWV0LlZJRVdQT1JUP2UhPT1udWxsP2RzLmNvcHkoZS52aWV3cG9ydCk6KHQuZ2V0Vmlld3BvcnQoZHMpLGRzLm11bHRpcGx5U2NhbGFyKHQuZ2V0UGl4ZWxSYXRpbygpKSk6ZSE9PW51bGw/KGxzLndpZHRoPWUud2lkdGgsbHMuaGVpZ2h0PWUuaGVpZ2h0KTp0LmdldERyYXdpbmdCdWZmZXJTaXplKGxzKX1zZXR1cCgpe2NvbnN0IHQ9dGhpcy5zY29wZTtsZXQgZT1udWxsO3JldHVybiB0PT09ZXQuU0laRT9lPXh0KGxzfHwobHM9bmV3IEopKTp0PT09ZXQuVklFV1BPUlQ/ZT14dChkc3x8KGRzPW5ldyBGdCkpOmU9RChRcy5kaXYocm8pKSxlfWdlbmVyYXRlKHQpe2lmKHRoaXMuc2NvcGU9PT1ldC5DT09SRElOQVRFKXtsZXQgZT10LmdldEZyYWdDb29yZCgpO2lmKHQuaXNGbGlwWSgpKXtjb25zdCBzPXQuZ2V0Tm9kZVByb3BlcnRpZXMocm8pLm91dHB1dE5vZGUuYnVpbGQodCk7ZT1gJHt0LmdldFR5cGUoInZlYzIiKX0oICR7ZX0ueCwgJHtzfS55IC0gJHtlfS55IClgfXJldHVybiBlfXJldHVybiBzdXBlci5nZW5lcmF0ZSh0KX19ZXQuQ09PUkRJTkFURT0iY29vcmRpbmF0ZSIsZXQuVklFV1BPUlQ9InZpZXdwb3J0IixldC5TSVpFPSJzaXplIixldC5VVj0idXYiO2NvbnN0IHBpPU8oZXQsZXQuVVYpLHJvPU8oZXQsZXQuU0laRSksUXM9TyhldCxldC5DT09SRElOQVRFKSxvbz1PKGV0LGV0LlZJRVdQT1JUKTtvby56dyxvby54eTtjb25zdCBmcz1uZXcgSjtjbGFzcyBNdSBleHRlbmRzIEpze3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJWaWV3cG9ydFRleHR1cmVOb2RlIn1jb25zdHJ1Y3Rvcih0PXBpLGU9bnVsbCxzPW51bGwpe3M9PT1udWxsJiYocz1uZXcgQWEscy5taW5GaWx0ZXI9R2kpLHN1cGVyKHMsdCxlKSx0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMSx0aGlzLmlzT3V0cHV0VGV4dHVyZU5vZGU9ITAsdGhpcy51cGRhdGVCZWZvcmVUeXBlPVEuRlJBTUV9dXBkYXRlQmVmb3JlKHQpe2NvbnN0IGU9dC5yZW5kZXJlcjtlLmdldERyYXdpbmdCdWZmZXJTaXplKGZzKTtjb25zdCBzPXRoaXMudmFsdWU7KHMuaW1hZ2Uud2lkdGghPT1mcy53aWR0aHx8cy5pbWFnZS5oZWlnaHQhPT1mcy5oZWlnaHQpJiYocy5pbWFnZS53aWR0aD1mcy53aWR0aCxzLmltYWdlLmhlaWdodD1mcy5oZWlnaHQscy5uZWVkc1VwZGF0ZT0hMCk7Y29uc3Qgbj1zLmdlbmVyYXRlTWlwbWFwcztzLmdlbmVyYXRlTWlwbWFwcz10aGlzLmdlbmVyYXRlTWlwbWFwcyxlLmNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZShzKSxzLmdlbmVyYXRlTWlwbWFwcz1ufWNsb25lKCl7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnV2Tm9kZSx0aGlzLmxldmVsTm9kZSx0aGlzLnZhbHVlKTtyZXR1cm4gdC5nZW5lcmF0ZU1pcG1hcHM9dGhpcy5nZW5lcmF0ZU1pcG1hcHMsdH19bGV0IG1pPW51bGw7Y2xhc3MgU3UgZXh0ZW5kcyBNdXtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iVmlld3BvcnREZXB0aFRleHR1cmVOb2RlIn1jb25zdHJ1Y3Rvcih0PXBpLGU9bnVsbCl7bWk9PT1udWxsJiYobWk9bmV3IHhyKSxzdXBlcih0LGUsbWkpfX1jb25zdCBfdT1DKFN1KTtjbGFzcyBmdCBleHRlbmRzIFV7c3RhdGljIGdldCB0eXBlKCl7cmV0dXJuIlZpZXdwb3J0RGVwdGhOb2RlIn1jb25zdHJ1Y3Rvcih0LGU9bnVsbCl7c3VwZXIoImZsb2F0IiksdGhpcy5zY29wZT10LHRoaXMudmFsdWVOb2RlPWUsdGhpcy5pc1ZpZXdwb3J0RGVwdGhOb2RlPSEwfWdlbmVyYXRlKHQpe2NvbnN0e3Njb3BlOmV9PXRoaXM7cmV0dXJuIGU9PT1mdC5ERVBUSF9CQVNFP3QuZ2V0RnJhZ0RlcHRoKCk6c3VwZXIuZ2VuZXJhdGUodCl9c2V0dXAoe2NhbWVyYTp0fSl7Y29uc3R7c2NvcGU6ZX09dGhpcyxzPXRoaXMudmFsdWVOb2RlO2xldCBuPW51bGw7aWYoZT09PWZ0LkRFUFRIX0JBU0UpcyE9PW51bGwmJihuPWNvKCkuYXNzaWduKHMpKTtlbHNlIGlmKGU9PT1mdC5ERVBUSCl0LmlzUGVyc3BlY3RpdmVDYW1lcmE/bj16dShNdC56LGNzLGhzKTpuPUtzKE10LnosY3MsaHMpO2Vsc2UgaWYoZT09PWZ0LkxJTkVBUl9ERVBUSClpZihzIT09bnVsbClpZih0LmlzUGVyc3BlY3RpdmVDYW1lcmEpe2NvbnN0IGk9YW8ocyxjcyxocyk7bj1LcyhpLGNzLGhzKX1lbHNlIG49cztlbHNlIG49S3MoTXQueixjcyxocyk7cmV0dXJuIG59fWZ0LkRFUFRIX0JBU0U9ImRlcHRoQmFzZSIsZnQuREVQVEg9ImRlcHRoIixmdC5MSU5FQVJfREVQVEg9ImxpbmVhckRlcHRoIjtjb25zdCBLcz0ocix0LGUpPT5yLmFkZCh0KS5kaXYodC5zdWIoZSkpLHp1PShyLHQsZSk9PnQuYWRkKHIpLm11bChlKS5kaXYoZS5zdWIodCkubXVsKHIpKSxhbz0ocix0LGUpPT50Lm11bChlKS5kaXYoZS5zdWIodCkubXVsKHIpLnN1YihlKSksY289QyhmdCxmdC5ERVBUSF9CQVNFKSxidT1PKGZ0LGZ0LkRFUFRIKSxFdT1DKGZ0LGZ0LkxJTkVBUl9ERVBUSCk7X3UoKSxidS5hc3NpZ249cj0+Y28ocik7Y2xhc3MgcHMgZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJDbGlwcGluZ05vZGUifWNvbnN0cnVjdG9yKHQ9cHMuREVGQVVMVCl7c3VwZXIoKSx0aGlzLnNjb3BlPXR9c2V0dXAodCl7c3VwZXIuc2V0dXAodCk7Y29uc3QgZT10LmNsaXBwaW5nQ29udGV4dCx7bG9jYWxDbGlwSW50ZXJzZWN0aW9uOnMsbG9jYWxDbGlwcGluZ0NvdW50Om4sZ2xvYmFsQ2xpcHBpbmdDb3VudDppfT1lLG89aStuLGE9cz9vLW46bztyZXR1cm4gdGhpcy5zY29wZT09PXBzLkFMUEhBX1RPX0NPVkVSQUdFP3RoaXMuc2V0dXBBbHBoYVRvQ292ZXJhZ2UoZS5wbGFuZXMsbyxhKTp0aGlzLnNldHVwRGVmYXVsdChlLnBsYW5lcyxvLGEpfXNldHVwQWxwaGFUb0NvdmVyYWdlKHQsZSxzKXtyZXR1cm4gdHQoKCk9Pntjb25zdCBuPWZpKHQpLGk9dmUoImZsb2F0IiwiZGlzdGFuY2VUb1BsYW5lIiksbz12ZSgiZmxvYXQiLCJkaXN0YW5jZVRvR3JhZGllbnQiKSxhPXZlKCJmbG9hdCIsImNsaXBPcGFjaXR5Iik7YS5hc3NpZ24oMSk7bGV0IGM7aWYoT2Uocywoe2k6dX0pPT57Yz1uLmVsZW1lbnQodSksaS5hc3NpZ24oTXQuZG90KGMueHl6KS5uZWdhdGUoKS5hZGQoYy53KSksby5hc3NpZ24oaS5md2lkdGgoKS5kaXYoMikpLGEubXVsQXNzaWduKGhpKG8ubmVnYXRlKCksbyxpKSksYS5lcXVhbCgwKS5kaXNjYXJkKCl9KSxzPGUpe2NvbnN0IHU9dmUoImZsb2F0IiwidW5pb25jbGlwT3BhY2l0eSIpO3UuYXNzaWduKDEpLE9lKHtzdGFydDpzLGVuZDplfSwoe2k6aH0pPT57Yz1uLmVsZW1lbnQoaCksaS5hc3NpZ24oTXQuZG90KGMueHl6KS5uZWdhdGUoKS5hZGQoYy53KSksby5hc3NpZ24oaS5md2lkdGgoKS5kaXYoMikpLHUubXVsQXNzaWduKGhpKG8ubmVnYXRlKCksbyxpKS5vbmVNaW51cygpKX0pLGEubXVsQXNzaWduKHUub25lTWludXMoKSl9dnIuYS5tdWxBc3NpZ24oYSksdnIuYS5lcXVhbCgwKS5kaXNjYXJkKCl9KSgpfXNldHVwRGVmYXVsdCh0LGUscyl7cmV0dXJuIHR0KCgpPT57Y29uc3Qgbj1maSh0KTtsZXQgaTtpZihPZShzLCh7aTpvfSk9PntpPW4uZWxlbWVudChvKSxNdC5kb3QoaS54eXopLmdyZWF0ZXJUaGFuKGkudykuZGlzY2FyZCgpfSksczxlKXtjb25zdCBvPXZlKCJib29sIiwiY2xpcHBlZCIpO28uYXNzaWduKCEwKSxPZSh7c3RhcnQ6cyxlbmQ6ZX0sKHtpOmF9KT0+e2k9bi5lbGVtZW50KGEpLG8uYXNzaWduKE10LmRvdChpLnh5eikuZ3JlYXRlclRoYW4oaS53KS5hbmQobykpfSksby5kaXNjYXJkKCl9fSkoKX19cHMuQUxQSEFfVE9fQ09WRVJBR0U9ImFscGhhVG9Db3ZlcmFnZSIscHMuREVGQVVMVD0iZGVmYXVsdCIsayguMDQpLHEoMSk7Y29uc3QgQ3U9dHQoKFtyLHRdKT0+e2NvbnN0IGU9ci50b1ZhcigpO2UuYXNzaWduKEdzKDIsZSkuc3ViKDEpKTtjb25zdCBzPWsoZSwxKS50b1ZhcigpO3JldHVybiBuaSh0LmVxdWFsKDApLCgpPT57cy5hc3NpZ24ocy56eXgpfSkuRWxzZUlmKHQuZXF1YWwoMSksKCk9PntzLmFzc2lnbihzLnh6eSkscy54ei5tdWxBc3NpZ24oLTEpfSkuRWxzZUlmKHQuZXF1YWwoMiksKCk9PntzLngubXVsQXNzaWduKC0xKX0pLkVsc2VJZih0LmVxdWFsKDMpLCgpPT57cy5hc3NpZ24ocy56eXgpLHMueHoubXVsQXNzaWduKC0xKX0pLkVsc2VJZih0LmVxdWFsKDQpLCgpPT57cy5hc3NpZ24ocy54enkpLHMueHkubXVsQXNzaWduKC0xKX0pLkVsc2VJZih0LmVxdWFsKDUpLCgpPT57cy56Lm11bEFzc2lnbigtMSl9KSxzfSkuc2V0TGF5b3V0KHtuYW1lOiJnZXREaXJlY3Rpb24iLHR5cGU6InZlYzMiLGlucHV0czpbe25hbWU6InV2Iix0eXBlOiJ2ZWMyIn0se25hbWU6ImZhY2UiLHR5cGU6ImZsb2F0In1dfSk7dHQoKHt0ZXh0dXJlOnIsdXY6dH0pPT57Y29uc3Qgcz1rKCkudG9WYXIoKTtyZXR1cm4gbmkodC54Lmxlc3NUaGFuKDFlLTQpLCgpPT57cy5hc3NpZ24oaygxLDAsMCkpfSkuRWxzZUlmKHQueS5sZXNzVGhhbigxZS00KSwoKT0+e3MuYXNzaWduKGsoMCwxLDApKX0pLkVsc2VJZih0LnoubGVzc1RoYW4oMWUtNCksKCk9PntzLmFzc2lnbihrKDAsMCwxKSl9KS5FbHNlSWYodC54LmdyZWF0ZXJUaGFuKDEtMWUtNCksKCk9PntzLmFzc2lnbihrKC0xLDAsMCkpfSkuRWxzZUlmKHQueS5ncmVhdGVyVGhhbigxLTFlLTQpLCgpPT57cy5hc3NpZ24oaygwLC0xLDApKX0pLkVsc2VJZih0LnouZ3JlYXRlclRoYW4oMS0xZS00KSwoKT0+e3MuYXNzaWduKGsoMCwwLC0xKSl9KS5FbHNlKCgpPT57Y29uc3QgaT1yLnV2KHQuYWRkKGsoLS4wMSwwLDApKSkuci5zdWIoci51dih0LmFkZChrKC4wMSwwLDApKSkuciksbz1yLnV2KHQuYWRkKGsoMCwtLjAxLDApKSkuci5zdWIoci51dih0LmFkZChrKDAsLjAxLDApKSkuciksYT1yLnV2KHQuYWRkKGsoMCwwLC0uMDEpKSkuci5zdWIoci51dih0LmFkZChrKDAsMCwuMDEpKSkucik7cy5hc3NpZ24oayhpLG8sYSkpfSkscy5ub3JtYWxpemUoKX0pO2NvbnN0IHlpPUN1KFpzKCksb3MoImZhY2VJbmRleCIpKS5ub3JtYWxpemUoKTtrKHlpLngseWkueS5uZWdhdGUoKSx5aS56KTtjbGFzcyBQdCBleHRlbmRzIElle3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJUaW1lck5vZGUifWNvbnN0cnVjdG9yKHQ9UHQuTE9DQUwsZT0xLHM9MCl7c3VwZXIocyksdGhpcy5zY29wZT10LHRoaXMuc2NhbGU9ZSx0aGlzLnVwZGF0ZVR5cGU9US5GUkFNRX11cGRhdGUodCl7Y29uc3QgZT10aGlzLnNjb3BlLHM9dGhpcy5zY2FsZTtlPT09UHQuTE9DQUw/dGhpcy52YWx1ZSs9dC5kZWx0YVRpbWUqczplPT09UHQuREVMVEE/dGhpcy52YWx1ZT10LmRlbHRhVGltZSpzOmU9PT1QdC5GUkFNRT90aGlzLnZhbHVlPXQuZnJhbWVJZDp0aGlzLnZhbHVlPXQudGltZSpzfXNlcmlhbGl6ZSh0KXtzdXBlci5zZXJpYWxpemUodCksdC5zY29wZT10aGlzLnNjb3BlLHQuc2NhbGU9dGhpcy5zY2FsZX1kZXNlcmlhbGl6ZSh0KXtzdXBlci5kZXNlcmlhbGl6ZSh0KSx0aGlzLnNjb3BlPXQuc2NvcGUsdGhpcy5zY2FsZT10LnNjYWxlfX1QdC5MT0NBTD0ibG9jYWwiLFB0LkdMT0JBTD0iZ2xvYmFsIixQdC5ERUxUQT0iZGVsdGEiLFB0LkZSQU1FPSJmcmFtZSI7Y29uc3QgRnU9KHIsdD0wKT0+dihuZXcgUHQoUHQuTE9DQUwscix0KSk7Y2xhc3MgcnQgZXh0ZW5kcyBVe3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJPc2NOb2RlIn1jb25zdHJ1Y3Rvcih0PXJ0LlNJTkUsZT1GdSgpKXtzdXBlcigpLHRoaXMubWV0aG9kPXQsdGhpcy50aW1lTm9kZT1lfWdldE5vZGVUeXBlKHQpe3JldHVybiB0aGlzLnRpbWVOb2RlLmdldE5vZGVUeXBlKHQpfXNldHVwKCl7Y29uc3QgdD10aGlzLm1ldGhvZCxlPXYodGhpcy50aW1lTm9kZSk7bGV0IHM9bnVsbDtyZXR1cm4gdD09PXJ0LlNJTkU/cz1lLmFkZCguNzUpLm11bChNYXRoLlBJKjIpLnNpbigpLm11bCguNSkuYWRkKC41KTp0PT09cnQuU1FVQVJFP3M9ZS5mcmFjdCgpLnJvdW5kKCk6dD09PXJ0LlRSSUFOR0xFP3M9ZS5hZGQoLjUpLmZyYWN0KCkubXVsKDIpLnN1YigxKS5hYnMoKTp0PT09cnQuU0FXVE9PVEgmJihzPWUuZnJhY3QoKSksc31zZXJpYWxpemUodCl7c3VwZXIuc2VyaWFsaXplKHQpLHQubWV0aG9kPXRoaXMubWV0aG9kfWRlc2VyaWFsaXplKHQpe3N1cGVyLmRlc2VyaWFsaXplKHQpLHRoaXMubWV0aG9kPXQubWV0aG9kfX1ydC5TSU5FPSJzaW5lIixydC5TUVVBUkU9InNxdWFyZSIscnQuVFJJQU5HTEU9InRyaWFuZ2xlIixydC5TQVdUT09USD0ic2F3dG9vdGgiLHJ0LlNJTkUscnQuU1FVQVJFLHJ0LlRSSUFOR0xFLHJ0LlNBV1RPT1RILG5ldyBYbixuZXcgQSxuZXcgQSxuZXcgQSxuZXcgbnQsbmV3IEEoMCwwLC0xKSxuZXcgRnQsbmV3IEEsbmV3IEEsbmV3IEZ0LG5ldyBKLG5ldyBvcixwaS5mbGlwWCgpO2NsYXNzIFV0IGV4dGVuZHMgVXtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iU2NlbmVOb2RlIn1jb25zdHJ1Y3Rvcih0PVV0LkJBQ0tHUk9VTkRfQkxVUlJJTkVTUyxlPW51bGwpe3N1cGVyKCksdGhpcy5zY29wZT10LHRoaXMuc2NlbmU9ZX1zZXR1cCh0KXtjb25zdCBlPXRoaXMuc2NvcGUscz10aGlzLnNjZW5lIT09bnVsbD90aGlzLnNjZW5lOnQuc2NlbmU7bGV0IG47cmV0dXJuIGU9PT1VdC5CQUNLR1JPVU5EX0JMVVJSSU5FU1M/bj1wZSgiYmFja2dyb3VuZEJsdXJyaW5lc3MiLCJmbG9hdCIscyk6ZT09PVV0LkJBQ0tHUk9VTkRfSU5URU5TSVRZP249cGUoImJhY2tncm91bmRJbnRlbnNpdHkiLCJmbG9hdCIscyk6Y29uc29sZS5lcnJvcigiVEhSRUUuU2NlbmVOb2RlOiBVbmtub3duIHNjb3BlOiIsZSksbn19VXQuQkFDS0dST1VORF9CTFVSUklORVNTPSJiYWNrZ3JvdW5kQmx1cnJpbmVzcyIsVXQuQkFDS0dST1VORF9JTlRFTlNJVFk9ImJhY2tncm91bmRJbnRlbnNpdHkiLFV0LkJBQ0tHUk9VTkRfQkxVUlJJTkVTUyxVdC5CQUNLR1JPVU5EX0lOVEVOU0lUWTtjb25zdCBSdT1uZXcgSjtjbGFzcyBCdSBleHRlbmRzIEpze3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJQYXNzVGV4dHVyZU5vZGUifWNvbnN0cnVjdG9yKHQsZSl7c3VwZXIoZSksdGhpcy5wYXNzTm9kZT10LHRoaXMuc2V0VXBkYXRlTWF0cml4KCExKX1zZXR1cCh0KXtyZXR1cm4gdC5vYmplY3QuaXNRdWFkTWVzaCYmdGhpcy5wYXNzTm9kZS5idWlsZCh0KSxzdXBlci5zZXR1cCh0KX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnBhc3NOb2RlLHRoaXMudmFsdWUpfX1jbGFzcyBobyBleHRlbmRzIEJ1e3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJQYXNzTXVsdGlwbGVUZXh0dXJlTm9kZSJ9Y29uc3RydWN0b3IodCxlLHM9ITEpe3N1cGVyKHQsbnVsbCksdGhpcy50ZXh0dXJlTmFtZT1lLHRoaXMucHJldmlvdXNUZXh0dXJlPXN9dXBkYXRlVGV4dHVyZSgpe3RoaXMudmFsdWU9dGhpcy5wcmV2aW91c1RleHR1cmU/dGhpcy5wYXNzTm9kZS5nZXRQcmV2aW91c1RleHR1cmUodGhpcy50ZXh0dXJlTmFtZSk6dGhpcy5wYXNzTm9kZS5nZXRUZXh0dXJlKHRoaXMudGV4dHVyZU5hbWUpfXNldHVwKHQpe3JldHVybiB0aGlzLnVwZGF0ZVRleHR1cmUoKSxzdXBlci5zZXR1cCh0KX1jbG9uZSgpe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnBhc3NOb2RlLHRoaXMudGV4dHVyZU5hbWUsdGhpcy5wcmV2aW91c1RleHR1cmUpfX1jbGFzcyB0biBleHRlbmRzIGR0e3N0YXRpYyBnZXQgdHlwZSgpe3JldHVybiJQYXNzTm9kZSJ9Y29uc3RydWN0b3IodCxlLHMsbj17fSl7c3VwZXIoInZlYzQiKSx0aGlzLnNjb3BlPXQsdGhpcy5zY2VuZT1lLHRoaXMuY2FtZXJhPXMsdGhpcy5vcHRpb25zPW4sdGhpcy5fcGl4ZWxSYXRpbz0xLHRoaXMuX3dpZHRoPTEsdGhpcy5faGVpZ2h0PTE7Y29uc3QgaT1uZXcgeHI7aS5pc1JlbmRlclRhcmdldFRleHR1cmU9ITAsaS5uYW1lPSJkZXB0aCI7Y29uc3Qgbz1uZXcgb3IodGhpcy5fd2lkdGgqdGhpcy5fcGl4ZWxSYXRpbyx0aGlzLl9oZWlnaHQqdGhpcy5fcGl4ZWxSYXRpbyx7dHlwZTp2bywuLi5ufSk7by50ZXh0dXJlLm5hbWU9Im91dHB1dCIsby5kZXB0aFRleHR1cmU9aSx0aGlzLnJlbmRlclRhcmdldD1vLHRoaXMudXBkYXRlQmVmb3JlVHlwZT1RLkZSQU1FLHRoaXMuX3RleHR1cmVzPXtvdXRwdXQ6by50ZXh0dXJlLGRlcHRoOml9LHRoaXMuX3RleHR1cmVOb2Rlcz17fSx0aGlzLl9saW5lYXJEZXB0aE5vZGVzPXt9LHRoaXMuX3ZpZXdaTm9kZXM9e30sdGhpcy5fcHJldmlvdXNUZXh0dXJlcz17fSx0aGlzLl9wcmV2aW91c1RleHR1cmVOb2Rlcz17fSx0aGlzLl9jYW1lcmFOZWFyPXh0KDApLHRoaXMuX2NhbWVyYUZhcj14dCgwKSx0aGlzLl9tcnQ9bnVsbCx0aGlzLmlzUGFzc05vZGU9ITB9c2V0TVJUKHQpe3JldHVybiB0aGlzLl9tcnQ9dCx0aGlzfWdldE1SVCgpe3JldHVybiB0aGlzLl9tcnR9aXNHbG9iYWwoKXtyZXR1cm4hMH1nZXRUZXh0dXJlKHQpe2xldCBlPXRoaXMuX3RleHR1cmVzW3RdO3JldHVybiBlPT09dm9pZCAwJiYoZT10aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLmNsb25lKCksZS5pc1JlbmRlclRhcmdldFRleHR1cmU9ITAsZS5uYW1lPXQsdGhpcy5fdGV4dHVyZXNbdF09ZSx0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlcy5wdXNoKGUpKSxlfWdldFByZXZpb3VzVGV4dHVyZSh0KXtsZXQgZT10aGlzLl9wcmV2aW91c1RleHR1cmVzW3RdO3JldHVybiBlPT09dm9pZCAwJiYoZT10aGlzLmdldFRleHR1cmUodCkuY2xvbmUoKSxlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hMCx0aGlzLl9wcmV2aW91c1RleHR1cmVzW3RdPWUpLGV9dG9nZ2xlVGV4dHVyZSh0KXtjb25zdCBlPXRoaXMuX3ByZXZpb3VzVGV4dHVyZXNbdF07aWYoZSE9PXZvaWQgMCl7Y29uc3Qgcz10aGlzLl90ZXh0dXJlc1t0XSxuPXRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmVzLmluZGV4T2Yocyk7dGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZXNbbl09ZSx0aGlzLl90ZXh0dXJlc1t0XT1lLHRoaXMuX3ByZXZpb3VzVGV4dHVyZXNbdF09cyx0aGlzLl90ZXh0dXJlTm9kZXNbdF0udXBkYXRlVGV4dHVyZSgpLHRoaXMuX3ByZXZpb3VzVGV4dHVyZU5vZGVzW3RdLnVwZGF0ZVRleHR1cmUoKX19Z2V0VGV4dHVyZU5vZGUodD0ib3V0cHV0Iil7bGV0IGU9dGhpcy5fdGV4dHVyZU5vZGVzW3RdO3JldHVybiBlPT09dm9pZCAwJiYodGhpcy5fdGV4dHVyZU5vZGVzW3RdPWU9dihuZXcgaG8odGhpcyx0KSksdGhpcy5fdGV4dHVyZU5vZGVzW3RdLnVwZGF0ZVRleHR1cmUoKSksZX1nZXRQcmV2aW91c1RleHR1cmVOb2RlKHQ9Im91dHB1dCIpe2xldCBlPXRoaXMuX3ByZXZpb3VzVGV4dHVyZU5vZGVzW3RdO3JldHVybiBlPT09dm9pZCAwJiYodGhpcy5fdGV4dHVyZU5vZGVzW3RdPT09dm9pZCAwJiZ0aGlzLmdldFRleHR1cmVOb2RlKHQpLHRoaXMuX3ByZXZpb3VzVGV4dHVyZU5vZGVzW3RdPWU9dihuZXcgaG8odGhpcyx0LCEwKSksdGhpcy5fcHJldmlvdXNUZXh0dXJlTm9kZXNbdF0udXBkYXRlVGV4dHVyZSgpKSxlfWdldFZpZXdaTm9kZSh0PSJkZXB0aCIpe2xldCBlPXRoaXMuX3ZpZXdaTm9kZXNbdF07aWYoZT09PXZvaWQgMCl7Y29uc3Qgcz10aGlzLl9jYW1lcmFOZWFyLG49dGhpcy5fY2FtZXJhRmFyO3RoaXMuX3ZpZXdaTm9kZXNbdF09ZT1hbyh0aGlzLmdldFRleHR1cmVOb2RlKHQpLHMsbil9cmV0dXJuIGV9Z2V0TGluZWFyRGVwdGhOb2RlKHQ9ImRlcHRoIil7bGV0IGU9dGhpcy5fbGluZWFyRGVwdGhOb2Rlc1t0XTtpZihlPT09dm9pZCAwKXtjb25zdCBzPXRoaXMuX2NhbWVyYU5lYXIsbj10aGlzLl9jYW1lcmFGYXIsaT10aGlzLmdldFZpZXdaTm9kZSh0KTt0aGlzLl9saW5lYXJEZXB0aE5vZGVzW3RdPWU9S3MoaSxzLG4pfXJldHVybiBlfXNldHVwKHtyZW5kZXJlcjp0fSl7cmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnNhbXBsZXM9dGhpcy5vcHRpb25zLnNhbXBsZXM9PT12b2lkIDA/dC5zYW1wbGVzOnRoaXMub3B0aW9ucy5zYW1wbGVzLHQuYmFja2VuZC5pc1dlYkdMQmFja2VuZD09PSEwJiYodGhpcy5yZW5kZXJUYXJnZXQuc2FtcGxlcz0wKSx0aGlzLnJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaXNNdWx0aXNhbXBsZVJlbmRlclRhcmdldFRleHR1cmU9dGhpcy5yZW5kZXJUYXJnZXQuc2FtcGxlcz4xLHRoaXMuc2NvcGU9PT10bi5DT0xPUj90aGlzLmdldFRleHR1cmVOb2RlKCk6dGhpcy5nZXRMaW5lYXJEZXB0aE5vZGUoKX11cGRhdGVCZWZvcmUodCl7Y29uc3R7cmVuZGVyZXI6ZX09dCx7c2NlbmU6cyxjYW1lcmE6bn09dGhpczt0aGlzLl9waXhlbFJhdGlvPWUuZ2V0UGl4ZWxSYXRpbygpO2NvbnN0IGk9ZS5nZXRTaXplKFJ1KTt0aGlzLnNldFNpemUoaS53aWR0aCxpLmhlaWdodCk7Y29uc3Qgbz1lLmdldFJlbmRlclRhcmdldCgpLGE9ZS5nZXRNUlQoKTt0aGlzLl9jYW1lcmFOZWFyLnZhbHVlPW4ubmVhcix0aGlzLl9jYW1lcmFGYXIudmFsdWU9bi5mYXI7Zm9yKGNvbnN0IGMgaW4gdGhpcy5fcHJldmlvdXNUZXh0dXJlcyl0aGlzLnRvZ2dsZVRleHR1cmUoYyk7ZS5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUYXJnZXQpLGUuc2V0TVJUKHRoaXMuX21ydCksZS5yZW5kZXIocyxuKSxlLnNldFJlbmRlclRhcmdldChvKSxlLnNldE1SVChhKX1zZXRTaXplKHQsZSl7dGhpcy5fd2lkdGg9dCx0aGlzLl9oZWlnaHQ9ZTtjb25zdCBzPXRoaXMuX3dpZHRoKnRoaXMuX3BpeGVsUmF0aW8sbj10aGlzLl9oZWlnaHQqdGhpcy5fcGl4ZWxSYXRpbzt0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHMsbil9c2V0UGl4ZWxSYXRpbyh0KXt0aGlzLl9waXhlbFJhdGlvPXQsdGhpcy5zZXRTaXplKHRoaXMuX3dpZHRoLHRoaXMuX2hlaWdodCl9ZGlzcG9zZSgpe3RoaXMucmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKX19dG4uQ09MT1I9ImNvbG9yIix0bi5ERVBUSD0iZGVwdGgiLHR0KCh7ZGVwdGhUZXh0dXJlOnIsc2hhZG93Q29vcmQ6dH0pPT5hcyhyLHQueHkpLmNvbXBhcmUodC56KSksdHQoKHtkZXB0aFRleHR1cmU6cixzaGFkb3dDb29yZDp0LHNoYWRvdzplfSk9Pntjb25zdCBzPShtLGcpPT5hcyhyLG0pLmNvbXBhcmUoZyksbj1wZSgibWFwU2l6ZSIsInZlYzIiLGUpLnNldEdyb3VwKGRlKSxpPXBlKCJyYWRpdXMiLCJmbG9hdCIsZSkuc2V0R3JvdXAoZGUpLG89RCgxKS5kaXYobiksYT1vLngubmVnYXRlKCkubXVsKGkpLGM9by55Lm5lZ2F0ZSgpLm11bChpKSx1PW8ueC5tdWwoaSksaD1vLnkubXVsKGkpLGw9YS5kaXYoMiksZD1jLmRpdigyKSxmPXUuZGl2KDIpLHA9aC5kaXYoMik7cmV0dXJuIGZlKHModC54eS5hZGQoRChhLGMpKSx0LnopLHModC54eS5hZGQoRCgwLGMpKSx0LnopLHModC54eS5hZGQoRCh1LGMpKSx0LnopLHModC54eS5hZGQoRChsLGQpKSx0LnopLHModC54eS5hZGQoRCgwLGQpKSx0LnopLHModC54eS5hZGQoRChmLGQpKSx0LnopLHModC54eS5hZGQoRChhLDApKSx0LnopLHModC54eS5hZGQoRChsLDApKSx0LnopLHModC54eSx0LnopLHModC54eS5hZGQoRChmLDApKSx0LnopLHModC54eS5hZGQoRCh1LDApKSx0LnopLHModC54eS5hZGQoRChsLHApKSx0LnopLHModC54eS5hZGQoRCgwLHApKSx0LnopLHModC54eS5hZGQoRChmLHApKSx0LnopLHModC54eS5hZGQoRChhLGgpKSx0LnopLHModC54eS5hZGQoRCgwLGgpKSx0LnopLHModC54eS5hZGQoRCh1LGgpKSx0LnopKS5tdWwoMS8xNyl9KSx0dCgoe2RlcHRoVGV4dHVyZTpyLHNoYWRvd0Nvb3JkOnQsc2hhZG93OmV9KT0+e2NvbnN0IHM9KGgsbCk9PmFzKHIsaCkuY29tcGFyZShsKSxuPXBlKCJtYXBTaXplIiwidmVjMiIsZSkuc2V0R3JvdXAoZGUpLGk9RCgxKS5kaXYobiksbz1pLngsYT1pLnksYz10Lnh5LHU9cmkoYy5tdWwobikuYWRkKC41KSk7cmV0dXJuIGMuc3ViQXNzaWduKHUubXVsKGkpKSxmZShzKGMsdC56KSxzKGMuYWRkKEQobywwKSksdC56KSxzKGMuYWRkKEQoMCxhKSksdC56KSxzKGMuYWRkKGkpLHQueikscmUocyhjLmFkZChEKG8ubmVnYXRlKCksMCkpLHQueikscyhjLmFkZChEKG8ubXVsKDIpLDApKSx0LnopLHUueCkscmUocyhjLmFkZChEKG8ubmVnYXRlKCksYSkpLHQueikscyhjLmFkZChEKG8ubXVsKDIpLGEpKSx0LnopLHUueCkscmUocyhjLmFkZChEKDAsYS5uZWdhdGUoKSkpLHQueikscyhjLmFkZChEKDAsYS5tdWwoMikpKSx0LnopLHUueSkscmUocyhjLmFkZChEKG8sYS5uZWdhdGUoKSkpLHQueikscyhjLmFkZChEKG8sYS5tdWwoMikpKSx0LnopLHUueSkscmUocmUocyhjLmFkZChEKG8ubmVnYXRlKCksYS5uZWdhdGUoKSkpLHQueikscyhjLmFkZChEKG8ubXVsKDIpLGEubmVnYXRlKCkpKSx0LnopLHUueCkscmUocyhjLmFkZChEKG8ubmVnYXRlKCksYS5tdWwoMikpKSx0LnopLHMoYy5hZGQoRChvLm11bCgyKSxhLm11bCgyKSkpLHQueiksdS54KSx1LnkpKS5tdWwoMS85KX0pLHR0KCh7ZGVwdGhUZXh0dXJlOnIsc2hhZG93Q29vcmQ6dH0pPT57Y29uc3QgZT1xKDEpLnRvVmFyKCkscz1hcyhyKS51dih0Lnh5KS5yZyxuPWtyKHQueixzLngpO3JldHVybiBuaShuLm5vdEVxdWFsKHEoMSkpLCgpPT57Y29uc3QgaT10Lnouc3ViKHMueCksbz1haSgwLHMueS5tdWwocy55KSk7bGV0IGE9by5kaXYoby5hZGQoaS5tdWwoaSkpKTthPVdzKCRzKGEsLjMpLmRpdiguOTUtLjMpKSxlLmFzc2lnbihXcyhhaShuLGEpKSl9KSxlfSksdHQoKHtzYW1wbGVzOnIscmFkaXVzOnQsc2l6ZTplLHNoYWRvd1Bhc3M6c30pPT57Y29uc3Qgbj1xKDApLnRvVmFyKCksaT1xKDApLnRvVmFyKCksbz1yLmxlc3NUaGFuRXF1YWwocSgxKSkuc2VsZWN0KHEoMCkscSgyKS5kaXYoci5zdWIoMSkpKSxhPXIubGVzc1RoYW5FcXVhbChxKDEpKS5zZWxlY3QocSgwKSxxKC0xKSk7T2Uoe3N0YXJ0OlJlKDApLGVuZDpSZShyKSx0eXBlOiJpbnQiLGNvbmRpdGlvbjoiPCJ9LCh7aTp1fSk9Pntjb25zdCBoPWEuYWRkKHEodSkubXVsKG8pKSxsPXMudXYoZmUoUXMueHksRCgwLGgpLm11bCh0KSkuZGl2KGUpKS54O24uYWRkQXNzaWduKGwpLGkuYWRkQXNzaWduKGwubXVsKGwpKX0pLG4uZGl2QXNzaWduKHIpLGkuZGl2QXNzaWduKHIpO2NvbnN0IGM9aWkoaS5zdWIobi5tdWwobikpKTtyZXR1cm4gRChuLGMpfSksdHQoKHtzYW1wbGVzOnIscmFkaXVzOnQsc2l6ZTplLHNoYWRvd1Bhc3M6c30pPT57Y29uc3Qgbj1xKDApLnRvVmFyKCksaT1xKDApLnRvVmFyKCksbz1yLmxlc3NUaGFuRXF1YWwocSgxKSkuc2VsZWN0KHEoMCkscSgyKS5kaXYoci5zdWIoMSkpKSxhPXIubGVzc1RoYW5FcXVhbChxKDEpKS5zZWxlY3QocSgwKSxxKC0xKSk7T2Uoe3N0YXJ0OlJlKDApLGVuZDpSZShyKSx0eXBlOiJpbnQiLGNvbmRpdGlvbjoiPCJ9LCh7aTp1fSk9Pntjb25zdCBoPWEuYWRkKHEodSkubXVsKG8pKSxsPXMudXYoZmUoUXMueHksRChoLDApLm11bCh0KSkuZGl2KGUpKTtuLmFkZEFzc2lnbihsLngpLGkuYWRkQXNzaWduKGZlKGwueS5tdWwobC55KSxsLngubXVsKGwueCkpKX0pLG4uZGl2QXNzaWduKHIpLGkuZGl2QXNzaWduKHIpO2NvbnN0IGM9aWkoaS5zdWIobi5tdWwobikpKTtyZXR1cm4gRChuLGMpfSksaygxLjY2MDUsLS4xMjQ2LC0uMDE4MiksaygtLjU4NzYsMS4xMzI5LC0uMTAwNiksaygtLjA3MjgsLS4wMDgzLDEuMTE4NyksayguNjI3NCwuMDY5MSwuMDE2NCksayguMzI5MywuOTE5NSwuMDg4KSxrKC4wNDMzLC4wMTEzLC44OTU2KTtjbGFzcyBJdSBleHRlbmRzIFV7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnNjb3BlPXR9Z2VuZXJhdGUodCl7Y29uc3R7c2NvcGU6ZX09dGhpcyx7cmVuZGVyZXI6c309dDtzLmJhY2tlbmQuaXNXZWJHTEJhY2tlbmQ9PT0hMD90LmFkZEZsb3dDb2RlKGAJLy8gJHtlfUJhcnJpZXIgCmApOnQuYWRkTGluZUZsb3dDb2RlKGAke2V9QmFycmllcigpYCx0aGlzKX19QyhJdSk7Y2xhc3Mga3QgZXh0ZW5kcyBkdHtzdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm4iQXRvbWljRnVuY3Rpb25Ob2RlIn1jb25zdHJ1Y3Rvcih0LGUscyxuPW51bGwpe3N1cGVyKCJ1aW50IiksdGhpcy5tZXRob2Q9dCx0aGlzLnBvaW50ZXJOb2RlPWUsdGhpcy52YWx1ZU5vZGU9cyx0aGlzLnN0b3JlTm9kZT1ufWdldElucHV0VHlwZSh0KXtyZXR1cm4gdGhpcy5wb2ludGVyTm9kZS5nZXROb2RlVHlwZSh0KX1nZXROb2RlVHlwZSh0KXtyZXR1cm4gdGhpcy5nZXRJbnB1dFR5cGUodCl9Z2VuZXJhdGUodCl7Y29uc3QgZT10aGlzLm1ldGhvZCxzPXRoaXMuZ2V0Tm9kZVR5cGUodCksbj10aGlzLmdldElucHV0VHlwZSh0KSxpPXRoaXMucG9pbnRlck5vZGUsbz10aGlzLnZhbHVlTm9kZSxhPVtdO2EucHVzaChgJiR7aS5idWlsZCh0LG4pfWApLGEucHVzaChvLmJ1aWxkKHQsbikpO2NvbnN0IGM9YCR7dC5nZXRNZXRob2QoZSxzKX0oICR7YS5qb2luKCIsICIpfSApYDtpZih0aGlzLnN0b3JlTm9kZSE9PW51bGwpe2NvbnN0IHU9dGhpcy5zdG9yZU5vZGUuYnVpbGQodCxuKTt0LmFkZExpbmVGbG93Q29kZShgJHt1fSA9ICR7Y31gLHRoaXMpfWVsc2UgdC5hZGRMaW5lRmxvd0NvZGUoYyx0aGlzKX19aWYoa3QuQVRPTUlDX0xPQUQ9ImF0b21pY0xvYWQiLGt0LkFUT01JQ19TVE9SRT0iYXRvbWljU3RvcmUiLGt0LkFUT01JQ19BREQ9ImF0b21pY0FkZCIsa3QuQVRPTUlDX1NVQj0iYXRvbWljU3ViIixrdC5BVE9NSUNfTUFYPSJhdG9taWNNYXgiLGt0LkFUT01JQ19NSU49ImF0b21pY01pbiIsa3QuQVRPTUlDX0FORD0iYXRvbWljQW5kIixrdC5BVE9NSUNfT1I9ImF0b21pY09yIixrdC5BVE9NSUNfWE9SPSJhdG9taWNYb3IiLEMoa3QpLHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX188InUiJiZfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoInJlZ2lzdGVyIix7ZGV0YWlsOntyZXZpc2lvbjpYZX19KSksdHlwZW9mIHdpbmRvdzwidSIpe3RyeXtBbiYmQW4udGFnTmFtZS50b1VwcGVyQ2FzZSgpPT09IlNDUklQVCImJkFuLnNyY3x8bmV3IFVSTCgiYXNzZXRzL2dlbmVyYXRlTWVzaEJWSC53b3JrZXItYjc3ODg5MzkuanMiLGRvY3VtZW50LmJhc2VVUkkpLmhyZWYsd2luZG93Ll9fVEhSRUVfX0lNUE9SVFNfX3x8KHdpbmRvdy5fX1RIUkVFX19JTVBPUlRTX189W10pLHdpbmRvdy5fX1RIUkVFX19JTVBPUlRTX18ucHVzaCh7dXJsOnNlbGYubG9jYXRpb24uaHJlZixyZXZpc2lvbjpYZX0pfWNhdGNoe313aW5kb3cuX19USFJFRV9fPyhjb25zb2xlLndhcm4oIldBUk5JTkc6IE11bHRpcGxlIGluc3RhbmNlcyBvZiBUaHJlZS5qcyBiZWluZyBpbXBvcnRlZC4gRXhpc3Rpbmc6ICIrd2luZG93Ll9fVEhSRUVfXysiLCBuZXc6ICIrWGUpLGNvbnNvbGUud2Fybih3aW5kb3cuX19USFJFRV9fSU1QT1JUU19fKSk6d2luZG93Ll9fVEhSRUVfXz1YZX1jb25zdCB1bz0wLHZ1PTEsUHU9Mixsbz0yLGdpPTEuMjUsZm89MSxtcz02KjQrNCs0LGVuPTY1NTM1LEx1PU1hdGgucG93KDIsLTI0KSx4aT1TeW1ib2woIlNLSVBfR0VORVJBVElPTiIpO2Z1bmN0aW9uIE91KHIpe3JldHVybiByLmluZGV4P3IuaW5kZXguY291bnQ6ci5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50fWZ1bmN0aW9uIERlKHIpe3JldHVybiBPdShyKS8zfWZ1bmN0aW9uIER1KHIsdD1BcnJheUJ1ZmZlcil7cmV0dXJuIHI+NjU1MzU/bmV3IFVpbnQzMkFycmF5KG5ldyB0KDQqcikpOm5ldyBVaW50MTZBcnJheShuZXcgdCgyKnIpKX1mdW5jdGlvbiBWdShyLHQpe2lmKCFyLmluZGV4KXtjb25zdCBlPXIuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCxzPXQudXNlU2hhcmVkQXJyYXlCdWZmZXI/U2hhcmVkQXJyYXlCdWZmZXI6QXJyYXlCdWZmZXIsbj1EdShlLHMpO3Iuc2V0SW5kZXgobmV3IHZ0KG4sMSkpO2ZvcihsZXQgaT0wO2k8ZTtpKyspbltpXT1pfX1mdW5jdGlvbiBwbyhyLHQpe2NvbnN0IGU9RGUocikscz10fHxyLmRyYXdSYW5nZSxuPXMuc3RhcnQvMyxpPShzLnN0YXJ0K3MuY291bnQpLzMsbz1NYXRoLm1heCgwLG4pLGE9TWF0aC5taW4oZSxpKS1vO3JldHVyblt7b2Zmc2V0Ok1hdGguZmxvb3IobyksY291bnQ6TWF0aC5mbG9vcihhKX1dfWZ1bmN0aW9uIG1vKHIsdCl7aWYoIXIuZ3JvdXBzfHwhci5ncm91cHMubGVuZ3RoKXJldHVybiBwbyhyLHQpO2NvbnN0IGU9W10scz1uZXcgU2V0LG49dHx8ci5kcmF3UmFuZ2UsaT1uLnN0YXJ0LzMsbz0obi5zdGFydCtuLmNvdW50KS8zO2Zvcihjb25zdCBjIG9mIHIuZ3JvdXBzKXtjb25zdCB1PWMuc3RhcnQvMyxoPShjLnN0YXJ0K2MuY291bnQpLzM7cy5hZGQoTWF0aC5tYXgoaSx1KSkscy5hZGQoTWF0aC5taW4obyxoKSl9Y29uc3QgYT1BcnJheS5mcm9tKHMudmFsdWVzKCkpLnNvcnQoKGMsdSk9PmMtdSk7Zm9yKGxldCBjPTA7YzxhLmxlbmd0aC0xO2MrKyl7Y29uc3QgdT1hW2NdLGg9YVtjKzFdO2UucHVzaCh7b2Zmc2V0Ok1hdGguZmxvb3IodSksY291bnQ6TWF0aC5mbG9vcihoLXUpfSl9cmV0dXJuIGV9ZnVuY3Rpb24gVXUocix0KXtjb25zdCBlPURlKHIpLHM9bW8ocix0KS5zb3J0KChvLGEpPT5vLm9mZnNldC1hLm9mZnNldCksbj1zW3MubGVuZ3RoLTFdO24uY291bnQ9TWF0aC5taW4oZS1uLm9mZnNldCxuLmNvdW50KTtsZXQgaT0wO3JldHVybiBzLmZvckVhY2goKHtjb3VudDpvfSk9PmkrPW8pLGUhPT1pfWZ1bmN0aW9uIFRpKHIsdCxlLHMsbil7bGV0IGk9MS8wLG89MS8wLGE9MS8wLGM9LTEvMCx1PS0xLzAsaD0tMS8wLGw9MS8wLGQ9MS8wLGY9MS8wLHA9LTEvMCxtPS0xLzAsZz0tMS8wO2ZvcihsZXQgeT10KjYsVD0odCtlKSo2O3k8VDt5Kz02KXtjb25zdCB3PXJbeSswXSxNPXJbeSsxXSxOPXctTSxfPXcrTTtOPGkmJihpPU4pLF8+YyYmKGM9XyksdzxsJiYobD13KSx3PnAmJihwPXcpO2NvbnN0IFM9clt5KzJdLEU9clt5KzNdLEY9Uy1FLFI9UytFO0Y8byYmKG89RiksUj51JiYodT1SKSxTPGQmJihkPVMpLFM+bSYmKG09Uyk7Y29uc3QgST1yW3krNF0sQj1yW3krNV0sUD1JLUIsTD1JK0I7UDxhJiYoYT1QKSxMPmgmJihoPUwpLEk8ZiYmKGY9SSksST5nJiYoZz1JKX1zWzBdPWksc1sxXT1vLHNbMl09YSxzWzNdPWMsc1s0XT11LHNbNV09aCxuWzBdPWwsblsxXT1kLG5bMl09ZixuWzNdPXAsbls0XT1tLG5bNV09Z31mdW5jdGlvbiBrdShyLHQ9bnVsbCxlPW51bGwscz1udWxsKXtjb25zdCBuPXIuYXR0cmlidXRlcy5wb3NpdGlvbixpPXIuaW5kZXg/ci5pbmRleC5hcnJheTpudWxsLG89RGUociksYT1uLm5vcm1hbGl6ZWQ7bGV0IGM7dD09PW51bGw/KGM9bmV3IEZsb2F0MzJBcnJheShvKjYpLGU9MCxzPW8pOihjPXQsZT1lfHwwLHM9c3x8byk7Y29uc3QgdT1uLmFycmF5LGg9bi5vZmZzZXR8fDA7bGV0IGw9MztuLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUmJihsPW4uZGF0YS5zdHJpZGUpO2NvbnN0IGQ9WyJnZXRYIiwiZ2V0WSIsImdldFoiXTtmb3IobGV0IGY9ZTtmPGUrcztmKyspe2NvbnN0IHA9ZiozLG09Zio2O2xldCBnPXArMCx5PXArMSxUPXArMjtpJiYoZz1pW2ddLHk9aVt5XSxUPWlbVF0pLGF8fChnPWcqbCtoLHk9eSpsK2gsVD1UKmwraCk7Zm9yKGxldCB3PTA7dzwzO3crKyl7bGV0IE0sTixfO2E/KE09bltkW3ddXShnKSxOPW5bZFt3XV0oeSksXz1uW2Rbd11dKFQpKTooTT11W2crd10sTj11W3krd10sXz11W1Qrd10pO2xldCBTPU07TjxTJiYoUz1OKSxfPFMmJihTPV8pO2xldCBFPU07Tj5FJiYoRT1OKSxfPkUmJihFPV8pO2NvbnN0IEY9KEUtUykvMixSPXcqMjtjW20rUiswXT1TK0YsY1ttK1IrMV09RisoTWF0aC5hYnMoUykrRikqTHV9fXJldHVybiBjfWZ1bmN0aW9uIFoocix0LGUpe3JldHVybiBlLm1pbi54PXRbcl0sZS5taW4ueT10W3IrMV0sZS5taW4uej10W3IrMl0sZS5tYXgueD10W3IrM10sZS5tYXgueT10W3IrNF0sZS5tYXguej10W3IrNV0sZX1mdW5jdGlvbiB5byhyKXtsZXQgdD0tMSxlPS0xLzA7Zm9yKGxldCBzPTA7czwzO3MrKyl7Y29uc3Qgbj1yW3MrM10tcltzXTtuPmUmJihlPW4sdD1zKX1yZXR1cm4gdH1mdW5jdGlvbiBnbyhyLHQpe3Quc2V0KHIpfWZ1bmN0aW9uIHhvKHIsdCxlKXtsZXQgcyxuO2ZvcihsZXQgaT0wO2k8MztpKyspe2NvbnN0IG89aSszO3M9cltpXSxuPXRbaV0sZVtpXT1zPG4/czpuLHM9cltvXSxuPXRbb10sZVtvXT1zPm4/czpufX1mdW5jdGlvbiBzbihyLHQsZSl7Zm9yKGxldCBzPTA7czwzO3MrKyl7Y29uc3Qgbj10W3IrMipzXSxpPXRbcisyKnMrMV0sbz1uLWksYT1uK2k7bzxlW3NdJiYoZVtzXT1vKSxhPmVbcyszXSYmKGVbcyszXT1hKX19ZnVuY3Rpb24geXMocil7Y29uc3QgdD1yWzNdLXJbMF0sZT1yWzRdLXJbMV0scz1yWzVdLXJbMl07cmV0dXJuIDIqKHQqZStlKnMrcyp0KX1jb25zdCBqdD0zMixIdT0ocix0KT0+ci5jYW5kaWRhdGUtdC5jYW5kaWRhdGUsb2U9bmV3IEFycmF5KGp0KS5maWxsKCkubWFwKCgpPT4oe2NvdW50OjAsYm91bmRzOm5ldyBGbG9hdDMyQXJyYXkoNikscmlnaHRDYWNoZUJvdW5kczpuZXcgRmxvYXQzMkFycmF5KDYpLGxlZnRDYWNoZUJvdW5kczpuZXcgRmxvYXQzMkFycmF5KDYpLGNhbmRpZGF0ZTowfSkpLG5uPW5ldyBGbG9hdDMyQXJyYXkoNik7ZnVuY3Rpb24gcXUocix0LGUscyxuLGkpe2xldCBvPS0xLGE9MDtpZihpPT09dW8pbz15byh0KSxvIT09LTEmJihhPSh0W29dK3RbbyszXSkvMik7ZWxzZSBpZihpPT09dnUpbz15byhyKSxvIT09LTEmJihhPSR1KGUscyxuLG8pKTtlbHNlIGlmKGk9PT1QdSl7Y29uc3QgYz15cyhyKTtsZXQgdT1naSpuO2NvbnN0IGg9cyo2LGw9KHMrbikqNjtmb3IobGV0IGQ9MDtkPDM7ZCsrKXtjb25zdCBmPXRbZF0sZz0odFtkKzNdLWYpL2p0O2lmKG48anQvNCl7Y29uc3QgeT1bLi4ub2VdO3kubGVuZ3RoPW47bGV0IFQ9MDtmb3IobGV0IE09aDtNPGw7TSs9NixUKyspe2NvbnN0IE49eVtUXTtOLmNhbmRpZGF0ZT1lW00rMipkXSxOLmNvdW50PTA7Y29uc3R7Ym91bmRzOl8sbGVmdENhY2hlQm91bmRzOlMscmlnaHRDYWNoZUJvdW5kczpFfT1OO2ZvcihsZXQgRj0wO0Y8MztGKyspRVtGXT0xLzAsRVtGKzNdPS0xLzAsU1tGXT0xLzAsU1tGKzNdPS0xLzAsX1tGXT0xLzAsX1tGKzNdPS0xLzA7c24oTSxlLF8pfXkuc29ydChIdSk7bGV0IHc9bjtmb3IobGV0IE09MDtNPHc7TSsrKXtjb25zdCBOPXlbTV07Zm9yKDtNKzE8dyYmeVtNKzFdLmNhbmRpZGF0ZT09PU4uY2FuZGlkYXRlOyl5LnNwbGljZShNKzEsMSksdy0tfWZvcihsZXQgTT1oO008bDtNKz02KXtjb25zdCBOPWVbTSsyKmRdO2ZvcihsZXQgXz0wO188dztfKyspe2NvbnN0IFM9eVtfXTtOPj1TLmNhbmRpZGF0ZT9zbihNLGUsUy5yaWdodENhY2hlQm91bmRzKTooc24oTSxlLFMubGVmdENhY2hlQm91bmRzKSxTLmNvdW50KyspfX1mb3IobGV0IE09MDtNPHc7TSsrKXtjb25zdCBOPXlbTV0sXz1OLmNvdW50LFM9bi1OLmNvdW50LEU9Ti5sZWZ0Q2FjaGVCb3VuZHMsRj1OLnJpZ2h0Q2FjaGVCb3VuZHM7bGV0IFI9MDtfIT09MCYmKFI9eXMoRSkvYyk7bGV0IEk9MDtTIT09MCYmKEk9eXMoRikvYyk7Y29uc3QgQj1mbytnaSooUipfK0kqUyk7Qjx1JiYobz1kLHU9QixhPU4uY2FuZGlkYXRlKX19ZWxzZXtmb3IobGV0IHc9MDt3PGp0O3crKyl7Y29uc3QgTT1vZVt3XTtNLmNvdW50PTAsTS5jYW5kaWRhdGU9ZitnK3cqZztjb25zdCBOPU0uYm91bmRzO2ZvcihsZXQgXz0wO188MztfKyspTltfXT0xLzAsTltfKzNdPS0xLzB9Zm9yKGxldCB3PWg7dzxsO3crPTYpe2xldCBfPX5+KChlW3crMipkXS1mKS9nKTtfPj1qdCYmKF89anQtMSk7Y29uc3QgUz1vZVtfXTtTLmNvdW50Kyssc24odyxlLFMuYm91bmRzKX1jb25zdCB5PW9lW2p0LTFdO2dvKHkuYm91bmRzLHkucmlnaHRDYWNoZUJvdW5kcyk7Zm9yKGxldCB3PWp0LTI7dz49MDt3LS0pe2NvbnN0IE09b2Vbd10sTj1vZVt3KzFdO3hvKE0uYm91bmRzLE4ucmlnaHRDYWNoZUJvdW5kcyxNLnJpZ2h0Q2FjaGVCb3VuZHMpfWxldCBUPTA7Zm9yKGxldCB3PTA7dzxqdC0xO3crKyl7Y29uc3QgTT1vZVt3XSxOPU0uY291bnQsXz1NLmJvdW5kcyxFPW9lW3crMV0ucmlnaHRDYWNoZUJvdW5kcztOIT09MCYmKFQ9PT0wP2dvKF8sbm4pOnhvKF8sbm4sbm4pKSxUKz1OO2xldCBGPTAsUj0wO1QhPT0wJiYoRj15cyhubikvYyk7Y29uc3QgST1uLVQ7SSE9PTAmJihSPXlzKEUpL2MpO2NvbnN0IEI9Zm8rZ2kqKEYqVCtSKkkpO0I8dSYmKG89ZCx1PUIsYT1NLmNhbmRpZGF0ZSl9fX19ZWxzZSBjb25zb2xlLndhcm4oYE1lc2hCVkg6IEludmFsaWQgYnVpbGQgc3RyYXRlZ3kgdmFsdWUgJHtpfSB1c2VkLmApO3JldHVybntheGlzOm8scG9zOmF9fWZ1bmN0aW9uICR1KHIsdCxlLHMpe2xldCBuPTA7Zm9yKGxldCBpPXQsbz10K2U7aTxvO2krKyluKz1yW2kqNitzKjJdO3JldHVybiBuL2V9Y2xhc3MgTml7Y29uc3RydWN0b3IoKXt0aGlzLmJvdW5kaW5nRGF0YT1uZXcgRmxvYXQzMkFycmF5KDYpfX1mdW5jdGlvbiBHdShyLHQsZSxzLG4saSl7bGV0IG89cyxhPXMrbi0xO2NvbnN0IGM9aS5wb3MsdT1pLmF4aXMqMjtmb3IoOzspe2Zvcig7bzw9YSYmZVtvKjYrdV08YzspbysrO2Zvcig7bzw9YSYmZVthKjYrdV0+PWM7KWEtLTtpZihvPGEpe2ZvcihsZXQgaD0wO2g8MztoKyspe2xldCBsPXRbbyozK2hdO3RbbyozK2hdPXRbYSozK2hdLHRbYSozK2hdPWx9Zm9yKGxldCBoPTA7aDw2O2grKyl7bGV0IGw9ZVtvKjYraF07ZVtvKjYraF09ZVthKjYraF0sZVthKjYraF09bH1vKyssYS0tfWVsc2UgcmV0dXJuIG99fWZ1bmN0aW9uIFd1KHIsdCxlLHMsbixpKXtsZXQgbz1zLGE9cytuLTE7Y29uc3QgYz1pLnBvcyx1PWkuYXhpcyoyO2Zvcig7Oyl7Zm9yKDtvPD1hJiZlW28qNit1XTxjOylvKys7Zm9yKDtvPD1hJiZlW2EqNit1XT49YzspYS0tO2lmKG88YSl7bGV0IGg9cltvXTtyW29dPXJbYV0sclthXT1oO2ZvcihsZXQgbD0wO2w8NjtsKyspe2xldCBkPWVbbyo2K2xdO2Vbbyo2K2xdPWVbYSo2K2xdLGVbYSo2K2xdPWR9bysrLGEtLX1lbHNlIHJldHVybiBvfX1mdW5jdGlvbiBwdChyLHQpe3JldHVybiB0W3IrMTVdPT09NjU1MzV9ZnVuY3Rpb24gVHQocix0KXtyZXR1cm4gdFtyKzZdfWZ1bmN0aW9uIFN0KHIsdCl7cmV0dXJuIHRbcisxNF19ZnVuY3Rpb24gX3Qocil7cmV0dXJuIHIrOH1mdW5jdGlvbiB6dChyLHQpe3JldHVybiB0W3IrNl19ZnVuY3Rpb24gVG8ocix0KXtyZXR1cm4gdFtyKzddfWZ1bmN0aW9uIGpsKHIpe3JldHVybiByfWxldCBObyxncyxybix3bztjb25zdCBYdT1NYXRoLnBvdygyLDMyKTtmdW5jdGlvbiB3aShyKXtyZXR1cm4iY291bnQiaW4gcj8xOjErd2koci5sZWZ0KSt3aShyLnJpZ2h0KX1mdW5jdGlvbiBZdShyLHQsZSl7cmV0dXJuIE5vPW5ldyBGbG9hdDMyQXJyYXkoZSksZ3M9bmV3IFVpbnQzMkFycmF5KGUpLHJuPW5ldyBVaW50MTZBcnJheShlKSx3bz1uZXcgVWludDhBcnJheShlKSxBaShyLHQpfWZ1bmN0aW9uIEFpKHIsdCl7Y29uc3QgZT1yLzQscz1yLzIsbj0iY291bnQiaW4gdCxpPXQuYm91bmRpbmdEYXRhO2ZvcihsZXQgbz0wO288NjtvKyspTm9bZStvXT1pW29dO2lmKG4paWYodC5idWZmZXIpe2NvbnN0IG89dC5idWZmZXI7d28uc2V0KG5ldyBVaW50OEFycmF5KG8pLHIpO2ZvcihsZXQgYT1yLGM9citvLmJ5dGVMZW5ndGg7YTxjO2ErPW1zKXtjb25zdCB1PWEvMjtwdCh1LHJuKXx8KGdzW2EvNCs2XSs9ZSl9cmV0dXJuIHIrby5ieXRlTGVuZ3RofWVsc2V7Y29uc3Qgbz10Lm9mZnNldCxhPXQuY291bnQ7cmV0dXJuIGdzW2UrNl09byxybltzKzE0XT1hLHJuW3MrMTVdPWVuLHIrbXN9ZWxzZXtjb25zdCBvPXQubGVmdCxhPXQucmlnaHQsYz10LnNwbGl0QXhpcztsZXQgdTtpZih1PUFpKHIrbXMsbyksdS80Plh1KXRocm93IG5ldyBFcnJvcigiTWVzaEJWSDogQ2Fubm90IHN0b3JlIGNoaWxkIHBvaW50ZXIgZ3JlYXRlciB0aGFuIDMyIGJpdHMuIik7cmV0dXJuIGdzW2UrNl09dS80LHU9QWkodSxhKSxnc1tlKzddPWMsdX19ZnVuY3Rpb24gWnUocix0KXtjb25zdCBlPShyLmluZGV4P3IuaW5kZXguY291bnQ6ci5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50KS8zLHM9ZT4yKioxNixuPXM/NDoyLGk9dD9uZXcgU2hhcmVkQXJyYXlCdWZmZXIoZSpuKTpuZXcgQXJyYXlCdWZmZXIoZSpuKSxvPXM/bmV3IFVpbnQzMkFycmF5KGkpOm5ldyBVaW50MTZBcnJheShpKTtmb3IobGV0IGE9MCxjPW8ubGVuZ3RoO2E8YzthKyspb1thXT1hO3JldHVybiBvfWZ1bmN0aW9uIEp1KHIsdCxlLHMsbil7Y29uc3R7bWF4RGVwdGg6aSx2ZXJib3NlOm8sbWF4TGVhZlRyaXM6YSxzdHJhdGVneTpjLG9uUHJvZ3Jlc3M6dSxpbmRpcmVjdDpofT1uLGw9ci5faW5kaXJlY3RCdWZmZXIsZD1yLmdlb21ldHJ5LGY9ZC5pbmRleD9kLmluZGV4LmFycmF5Om51bGwscD1oP1d1Okd1LG09RGUoZCksZz1uZXcgRmxvYXQzMkFycmF5KDYpO2xldCB5PSExO2NvbnN0IFQ9bmV3IE5pO3JldHVybiBUaSh0LGUscyxULmJvdW5kaW5nRGF0YSxnKSxNKFQsZSxzLGcpLFQ7ZnVuY3Rpb24gdyhOKXt1JiZ1KE4vbSl9ZnVuY3Rpb24gTShOLF8sUyxFPW51bGwsRj0wKXtpZigheSYmRj49aSYmKHk9ITAsbyYmKGNvbnNvbGUud2FybihgTWVzaEJWSDogTWF4IGRlcHRoIG9mICR7aX0gcmVhY2hlZCB3aGVuIGdlbmVyYXRpbmcgQlZILiBDb25zaWRlciBpbmNyZWFzaW5nIG1heERlcHRoLmApLGNvbnNvbGUud2FybihkKSkpLFM8PWF8fEY+PWkpcmV0dXJuIHcoXytTKSxOLm9mZnNldD1fLE4uY291bnQ9UyxOO2NvbnN0IFI9cXUoTi5ib3VuZGluZ0RhdGEsRSx0LF8sUyxjKTtpZihSLmF4aXM9PT0tMSlyZXR1cm4gdyhfK1MpLE4ub2Zmc2V0PV8sTi5jb3VudD1TLE47Y29uc3QgST1wKGwsZix0LF8sUyxSKTtpZihJPT09X3x8ST09PV8rUyl3KF8rUyksTi5vZmZzZXQ9XyxOLmNvdW50PVM7ZWxzZXtOLnNwbGl0QXhpcz1SLmF4aXM7Y29uc3QgQj1uZXcgTmksUD1fLEw9SS1fO04ubGVmdD1CLFRpKHQsUCxMLEIuYm91bmRpbmdEYXRhLGcpLE0oQixQLEwsZyxGKzEpO2NvbnN0IFY9bmV3IE5pLEc9SSxOdD1TLUw7Ti5yaWdodD1WLFRpKHQsRyxOdCxWLmJvdW5kaW5nRGF0YSxnKSxNKFYsRyxOdCxnLEYrMSl9cmV0dXJuIE59fWZ1bmN0aW9uIGp1KHIsdCl7Y29uc3QgZT1yLmdlb21ldHJ5O3QuaW5kaXJlY3QmJihyLl9pbmRpcmVjdEJ1ZmZlcj1adShlLHQudXNlU2hhcmVkQXJyYXlCdWZmZXIpLFV1KGUsdC5yYW5nZSkmJiF0LnZlcmJvc2UmJmNvbnNvbGUud2FybignTWVzaEJWSDogUHJvdmlkZWQgZ2VvbWV0cnkgY29udGFpbnMgZ3JvdXBzIG9yIGEgcmFuZ2UgdGhhdCBkbyBub3QgZnVsbHkgc3BhbiB0aGUgdmVydGV4IGNvbnRlbnRzIHdoaWxlIHVzaW5nIHRoZSAiaW5kaXJlY3QiIG9wdGlvbi4gQlZIIG1heSBpbmNvcnJlY3RseSByZXBvcnQgaW50ZXJzZWN0aW9ucyBvbiB1bnJlbmRlcmVkIHBvcnRpb25zIG9mIHRoZSBnZW9tZXRyeS4nKSksci5faW5kaXJlY3RCdWZmZXJ8fFZ1KGUsdCk7Y29uc3Qgcz10LnVzZVNoYXJlZEFycmF5QnVmZmVyP1NoYXJlZEFycmF5QnVmZmVyOkFycmF5QnVmZmVyLG49a3UoZSksaT10LmluZGlyZWN0P3BvKGUsdC5yYW5nZSk6bW8oZSx0LnJhbmdlKTtyLl9yb290cz1pLm1hcChvPT57Y29uc3QgYT1KdShyLG4sby5vZmZzZXQsby5jb3VudCx0KSxjPXdpKGEpLHU9bmV3IHMobXMqYyk7cmV0dXJuIFl1KDAsYSx1KSx1fSl9Y2xhc3MgUXR7Y29uc3RydWN0b3IoKXt0aGlzLm1pbj0xLzAsdGhpcy5tYXg9LTEvMH1zZXRGcm9tUG9pbnRzRmllbGQodCxlKXtsZXQgcz0xLzAsbj0tMS8wO2ZvcihsZXQgaT0wLG89dC5sZW5ndGg7aTxvO2krKyl7Y29uc3QgYz10W2ldW2VdO3M9YzxzP2M6cyxuPWM+bj9jOm59dGhpcy5taW49cyx0aGlzLm1heD1ufXNldEZyb21Qb2ludHModCxlKXtsZXQgcz0xLzAsbj0tMS8wO2ZvcihsZXQgaT0wLG89ZS5sZW5ndGg7aTxvO2krKyl7Y29uc3QgYT1lW2ldLGM9dC5kb3QoYSk7cz1jPHM/YzpzLG49Yz5uP2M6bn10aGlzLm1pbj1zLHRoaXMubWF4PW59aXNTZXBhcmF0ZWQodCl7cmV0dXJuIHRoaXMubWluPnQubWF4fHx0Lm1pbj50aGlzLm1heH19UXQucHJvdG90eXBlLnNldEZyb21Cb3g9ZnVuY3Rpb24oKXtjb25zdCByPW5ldyBBO3JldHVybiBmdW5jdGlvbihlLHMpe2NvbnN0IG49cy5taW4saT1zLm1heDtsZXQgbz0xLzAsYT0tMS8wO2ZvcihsZXQgYz0wO2M8PTE7YysrKWZvcihsZXQgdT0wO3U8PTE7dSsrKWZvcihsZXQgaD0wO2g8PTE7aCsrKXtyLng9bi54KmMraS54KigxLWMpLHIueT1uLnkqdStpLnkqKDEtdSksci56PW4ueipoK2kueiooMS1oKTtjb25zdCBsPWUuZG90KHIpO289TWF0aC5taW4obCxvKSxhPU1hdGgubWF4KGwsYSl9dGhpcy5taW49byx0aGlzLm1heD1hfX0oKTtjb25zdCBRdT1mdW5jdGlvbigpe2NvbnN0IHI9bmV3IEEsdD1uZXcgQSxlPW5ldyBBO3JldHVybiBmdW5jdGlvbihuLGksbyl7Y29uc3QgYT1uLnN0YXJ0LGM9cix1PWkuc3RhcnQsaD10O2Uuc3ViVmVjdG9ycyhhLHUpLHIuc3ViVmVjdG9ycyhuLmVuZCxuLnN0YXJ0KSx0LnN1YlZlY3RvcnMoaS5lbmQsaS5zdGFydCk7Y29uc3QgbD1lLmRvdChoKSxkPWguZG90KGMpLGY9aC5kb3QoaCkscD1lLmRvdChjKSxnPWMuZG90KGMpKmYtZCpkO2xldCB5LFQ7ZyE9PTA/eT0obCpkLXAqZikvZzp5PTAsVD0obCt5KmQpL2Ysby54PXksby55PVR9fSgpLE1pPWZ1bmN0aW9uKCl7Y29uc3Qgcj1uZXcgSix0PW5ldyBBLGU9bmV3IEE7cmV0dXJuIGZ1bmN0aW9uKG4saSxvLGEpe1F1KG4saSxyKTtsZXQgYz1yLngsdT1yLnk7aWYoYz49MCYmYzw9MSYmdT49MCYmdTw9MSl7bi5hdChjLG8pLGkuYXQodSxhKTtyZXR1cm59ZWxzZSBpZihjPj0wJiZjPD0xKXt1PDA/aS5hdCgwLGEpOmkuYXQoMSxhKSxuLmNsb3Nlc3RQb2ludFRvUG9pbnQoYSwhMCxvKTtyZXR1cm59ZWxzZSBpZih1Pj0wJiZ1PD0xKXtjPDA/bi5hdCgwLG8pOm4uYXQoMSxvKSxpLmNsb3Nlc3RQb2ludFRvUG9pbnQobywhMCxhKTtyZXR1cm59ZWxzZXtsZXQgaDtjPDA/aD1uLnN0YXJ0Omg9bi5lbmQ7bGV0IGw7dTwwP2w9aS5zdGFydDpsPWkuZW5kO2NvbnN0IGQ9dCxmPWU7aWYobi5jbG9zZXN0UG9pbnRUb1BvaW50KGwsITAsdCksaS5jbG9zZXN0UG9pbnRUb1BvaW50KGgsITAsZSksZC5kaXN0YW5jZVRvU3F1YXJlZChsKTw9Zi5kaXN0YW5jZVRvU3F1YXJlZChoKSl7by5jb3B5KGQpLGEuY29weShsKTtyZXR1cm59ZWxzZXtvLmNvcHkoaCksYS5jb3B5KGYpO3JldHVybn19fX0oKSxLdT1mdW5jdGlvbigpe2NvbnN0IHI9bmV3IEEsdD1uZXcgQSxlPW5ldyBYbixzPW5ldyBadDtyZXR1cm4gZnVuY3Rpb24oaSxvKXtjb25zdHtyYWRpdXM6YSxjZW50ZXI6Y309aSx7YTp1LGI6aCxjOmx9PW87aWYocy5zdGFydD11LHMuZW5kPWgscy5jbG9zZXN0UG9pbnRUb1BvaW50KGMsITAscikuZGlzdGFuY2VUbyhjKTw9YXx8KHMuc3RhcnQ9dSxzLmVuZD1sLHMuY2xvc2VzdFBvaW50VG9Qb2ludChjLCEwLHIpLmRpc3RhbmNlVG8oYyk8PWEpfHwocy5zdGFydD1oLHMuZW5kPWwscy5jbG9zZXN0UG9pbnRUb1BvaW50KGMsITAscikuZGlzdGFuY2VUbyhjKTw9YSkpcmV0dXJuITA7Y29uc3QgbT1vLmdldFBsYW5lKGUpO2lmKE1hdGguYWJzKG0uZGlzdGFuY2VUb1BvaW50KGMpKTw9YSl7Y29uc3QgeT1tLnByb2plY3RQb2ludChjLHQpO2lmKG8uY29udGFpbnNQb2ludCh5KSlyZXR1cm4hMH1yZXR1cm4hMX19KCksdGw9MWUtMTU7ZnVuY3Rpb24gU2kocil7cmV0dXJuIE1hdGguYWJzKHIpPHRsfWNsYXNzIEx0IGV4dGVuZHMgd3R7Y29uc3RydWN0b3IoLi4udCl7c3VwZXIoLi4udCksdGhpcy5pc0V4dGVuZGVkVHJpYW5nbGU9ITAsdGhpcy5zYXRBeGVzPW5ldyBBcnJheSg0KS5maWxsKCkubWFwKCgpPT5uZXcgQSksdGhpcy5zYXRCb3VuZHM9bmV3IEFycmF5KDQpLmZpbGwoKS5tYXAoKCk9Pm5ldyBRdCksdGhpcy5wb2ludHM9W3RoaXMuYSx0aGlzLmIsdGhpcy5jXSx0aGlzLnNwaGVyZT1uZXcgY3IsdGhpcy5wbGFuZT1uZXcgWG4sdGhpcy5uZWVkc1VwZGF0ZT0hMH1pbnRlcnNlY3RzU3BoZXJlKHQpe3JldHVybiBLdSh0LHRoaXMpfXVwZGF0ZSgpe2NvbnN0IHQ9dGhpcy5hLGU9dGhpcy5iLHM9dGhpcy5jLG49dGhpcy5wb2ludHMsaT10aGlzLnNhdEF4ZXMsbz10aGlzLnNhdEJvdW5kcyxhPWlbMF0sYz1vWzBdO3RoaXMuZ2V0Tm9ybWFsKGEpLGMuc2V0RnJvbVBvaW50cyhhLG4pO2NvbnN0IHU9aVsxXSxoPW9bMV07dS5zdWJWZWN0b3JzKHQsZSksaC5zZXRGcm9tUG9pbnRzKHUsbik7Y29uc3QgbD1pWzJdLGQ9b1syXTtsLnN1YlZlY3RvcnMoZSxzKSxkLnNldEZyb21Qb2ludHMobCxuKTtjb25zdCBmPWlbM10scD1vWzNdO2Yuc3ViVmVjdG9ycyhzLHQpLHAuc2V0RnJvbVBvaW50cyhmLG4pLHRoaXMuc3BoZXJlLnNldEZyb21Qb2ludHModGhpcy5wb2ludHMpLHRoaXMucGxhbmUuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoYSx0KSx0aGlzLm5lZWRzVXBkYXRlPSExfX1MdC5wcm90b3R5cGUuY2xvc2VzdFBvaW50VG9TZWdtZW50PWZ1bmN0aW9uKCl7Y29uc3Qgcj1uZXcgQSx0PW5ldyBBLGU9bmV3IFp0O3JldHVybiBmdW5jdGlvbihuLGk9bnVsbCxvPW51bGwpe2NvbnN0e3N0YXJ0OmEsZW5kOmN9PW4sdT10aGlzLnBvaW50cztsZXQgaCxsPTEvMDtmb3IobGV0IGQ9MDtkPDM7ZCsrKXtjb25zdCBmPShkKzEpJTM7ZS5zdGFydC5jb3B5KHVbZF0pLGUuZW5kLmNvcHkodVtmXSksTWkoZSxuLHIsdCksaD1yLmRpc3RhbmNlVG9TcXVhcmVkKHQpLGg8bCYmKGw9aCxpJiZpLmNvcHkociksbyYmby5jb3B5KHQpKX1yZXR1cm4gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KGEsciksaD1hLmRpc3RhbmNlVG9TcXVhcmVkKHIpLGg8bCYmKGw9aCxpJiZpLmNvcHkociksbyYmby5jb3B5KGEpKSx0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoYyxyKSxoPWMuZGlzdGFuY2VUb1NxdWFyZWQociksaDxsJiYobD1oLGkmJmkuY29weShyKSxvJiZvLmNvcHkoYykpLE1hdGguc3FydChsKX19KCksTHQucHJvdG90eXBlLmludGVyc2VjdHNUcmlhbmdsZT1mdW5jdGlvbigpe2NvbnN0IHI9bmV3IEx0LHQ9bmV3IEFycmF5KDMpLGU9bmV3IEFycmF5KDMpLHM9bmV3IFF0LG49bmV3IFF0LGk9bmV3IEEsbz1uZXcgQSxhPW5ldyBBLGM9bmV3IEEsdT1uZXcgQSxoPW5ldyBadCxsPW5ldyBadCxkPW5ldyBadCxmPW5ldyBBO2Z1bmN0aW9uIHAobSxnLHkpe2NvbnN0IFQ9bS5wb2ludHM7bGV0IHc9MCxNPS0xO2ZvcihsZXQgTj0wO048MztOKyspe2NvbnN0e3N0YXJ0Ol8sZW5kOlN9PWg7Xy5jb3B5KFRbTl0pLFMuY29weShUWyhOKzEpJTNdKSxoLmRlbHRhKG8pO2NvbnN0IEU9U2koZy5kaXN0YW5jZVRvUG9pbnQoXykpO2lmKFNpKGcubm9ybWFsLmRvdChvKSkmJkUpe3kuY29weShoKSx3PTI7YnJlYWt9Y29uc3QgRj1nLmludGVyc2VjdExpbmUoaCxmKTtpZighRiYmRSYmZi5jb3B5KF8pLChGfHxFKSYmIVNpKGYuZGlzdGFuY2VUbyhTKSkpe2lmKHc8PTEpKHc9PT0xP3kuc3RhcnQ6eS5lbmQpLmNvcHkoZiksRSYmKE09dyk7ZWxzZSBpZih3Pj0yKXsoTT09PTE/eS5zdGFydDp5LmVuZCkuY29weShmKSx3PTI7YnJlYWt9aWYodysrLHc9PT0yJiZNPT09LTEpYnJlYWt9fXJldHVybiB3fXJldHVybiBmdW5jdGlvbihnLHk9bnVsbCxUPSExKXt0aGlzLm5lZWRzVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpLGcuaXNFeHRlbmRlZFRyaWFuZ2xlP2cubmVlZHNVcGRhdGUmJmcudXBkYXRlKCk6KHIuY29weShnKSxyLnVwZGF0ZSgpLGc9cik7Y29uc3Qgdz10aGlzLnBsYW5lLE09Zy5wbGFuZTtpZihNYXRoLmFicyh3Lm5vcm1hbC5kb3QoTS5ub3JtYWwpKT4xLTFlLTEwKXtjb25zdCBOPXRoaXMuc2F0Qm91bmRzLF89dGhpcy5zYXRBeGVzO2VbMF09Zy5hLGVbMV09Zy5iLGVbMl09Zy5jO2ZvcihsZXQgRj0wO0Y8NDtGKyspe2NvbnN0IFI9TltGXSxJPV9bRl07aWYocy5zZXRGcm9tUG9pbnRzKEksZSksUi5pc1NlcGFyYXRlZChzKSlyZXR1cm4hMX1jb25zdCBTPWcuc2F0Qm91bmRzLEU9Zy5zYXRBeGVzO3RbMF09dGhpcy5hLHRbMV09dGhpcy5iLHRbMl09dGhpcy5jO2ZvcihsZXQgRj0wO0Y8NDtGKyspe2NvbnN0IFI9U1tGXSxJPUVbRl07aWYocy5zZXRGcm9tUG9pbnRzKEksdCksUi5pc1NlcGFyYXRlZChzKSlyZXR1cm4hMX1mb3IobGV0IEY9MDtGPDQ7RisrKXtjb25zdCBSPV9bRl07Zm9yKGxldCBJPTA7STw0O0krKyl7Y29uc3QgQj1FW0ldO2lmKGkuY3Jvc3NWZWN0b3JzKFIsQikscy5zZXRGcm9tUG9pbnRzKGksdCksbi5zZXRGcm9tUG9pbnRzKGksZSkscy5pc1NlcGFyYXRlZChuKSlyZXR1cm4hMX19cmV0dXJuIHkmJihUfHxjb25zb2xlLndhcm4oIkV4dGVuZGVkVHJpYW5nbGUuaW50ZXJzZWN0c1RyaWFuZ2xlOiBUcmlhbmdsZXMgYXJlIGNvcGxhbmFyIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgYW4gb3V0cHV0IGVkZ2UuIFNldHRpbmcgZWRnZSB0byAwLCAwLCAwLiIpLHkuc3RhcnQuc2V0KDAsMCwwKSx5LmVuZC5zZXQoMCwwLDApKSwhMH1lbHNle2NvbnN0IE49cCh0aGlzLE0sbCk7aWYoTj09PTEmJmcuY29udGFpbnNQb2ludChsLmVuZCkpcmV0dXJuIHkmJih5LnN0YXJ0LmNvcHkobC5lbmQpLHkuZW5kLmNvcHkobC5lbmQpKSwhMDtpZihOIT09MilyZXR1cm4hMTtjb25zdCBfPXAoZyx3LGQpO2lmKF89PT0xJiZ0aGlzLmNvbnRhaW5zUG9pbnQoZC5lbmQpKXJldHVybiB5JiYoeS5zdGFydC5jb3B5KGQuZW5kKSx5LmVuZC5jb3B5KGQuZW5kKSksITA7aWYoXyE9PTIpcmV0dXJuITE7aWYobC5kZWx0YShhKSxkLmRlbHRhKGMpLGEuZG90KGMpPDApe2xldCBQPWQuc3RhcnQ7ZC5zdGFydD1kLmVuZCxkLmVuZD1QfWNvbnN0IFM9bC5zdGFydC5kb3QoYSksRT1sLmVuZC5kb3QoYSksRj1kLnN0YXJ0LmRvdChhKSxSPWQuZW5kLmRvdChhKSxJPUU8RixCPVM8UjtyZXR1cm4gUyE9PVImJkYhPT1FJiZJPT09Qj8hMTooeSYmKHUuc3ViVmVjdG9ycyhsLnN0YXJ0LGQuc3RhcnQpLHUuZG90KGEpPjA/eS5zdGFydC5jb3B5KGwuc3RhcnQpOnkuc3RhcnQuY29weShkLnN0YXJ0KSx1LnN1YlZlY3RvcnMobC5lbmQsZC5lbmQpLHUuZG90KGEpPDA/eS5lbmQuY29weShsLmVuZCk6eS5lbmQuY29weShkLmVuZCkpLCEwKX19fSgpLEx0LnByb3RvdHlwZS5kaXN0YW5jZVRvUG9pbnQ9ZnVuY3Rpb24oKXtjb25zdCByPW5ldyBBO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KGUsciksZS5kaXN0YW5jZVRvKHIpfX0oKSxMdC5wcm90b3R5cGUuZGlzdGFuY2VUb1RyaWFuZ2xlPWZ1bmN0aW9uKCl7Y29uc3Qgcj1uZXcgQSx0PW5ldyBBLGU9WyJhIiwiYiIsImMiXSxzPW5ldyBadCxuPW5ldyBadDtyZXR1cm4gZnVuY3Rpb24obyxhPW51bGwsYz1udWxsKXtjb25zdCB1PWF8fGM/czpudWxsO2lmKHRoaXMuaW50ZXJzZWN0c1RyaWFuZ2xlKG8sdSkpcmV0dXJuKGF8fGMpJiYoYSYmdS5nZXRDZW50ZXIoYSksYyYmdS5nZXRDZW50ZXIoYykpLDA7bGV0IGg9MS8wO2ZvcihsZXQgbD0wO2w8MztsKyspe2xldCBkO2NvbnN0IGY9ZVtsXSxwPW9bZl07dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KHAsciksZD1wLmRpc3RhbmNlVG9TcXVhcmVkKHIpLGQ8aCYmKGg9ZCxhJiZhLmNvcHkociksYyYmYy5jb3B5KHApKTtjb25zdCBtPXRoaXNbZl07by5jbG9zZXN0UG9pbnRUb1BvaW50KG0sciksZD1tLmRpc3RhbmNlVG9TcXVhcmVkKHIpLGQ8aCYmKGg9ZCxhJiZhLmNvcHkobSksYyYmYy5jb3B5KHIpKX1mb3IobGV0IGw9MDtsPDM7bCsrKXtjb25zdCBkPWVbbF0sZj1lWyhsKzEpJTNdO3Muc2V0KHRoaXNbZF0sdGhpc1tmXSk7Zm9yKGxldCBwPTA7cDwzO3ArKyl7Y29uc3QgbT1lW3BdLGc9ZVsocCsxKSUzXTtuLnNldChvW21dLG9bZ10pLE1pKHMsbixyLHQpO2NvbnN0IHk9ci5kaXN0YW5jZVRvU3F1YXJlZCh0KTt5PGgmJihoPXksYSYmYS5jb3B5KHIpLGMmJmMuY29weSh0KSl9fXJldHVybiBNYXRoLnNxcnQoaCl9fSgpO2NsYXNzIGx0e2NvbnN0cnVjdG9yKHQsZSxzKXt0aGlzLmlzT3JpZW50ZWRCb3g9ITAsdGhpcy5taW49bmV3IEEsdGhpcy5tYXg9bmV3IEEsdGhpcy5tYXRyaXg9bmV3IG50LHRoaXMuaW52TWF0cml4PW5ldyBudCx0aGlzLnBvaW50cz1uZXcgQXJyYXkoOCkuZmlsbCgpLm1hcCgoKT0+bmV3IEEpLHRoaXMuc2F0QXhlcz1uZXcgQXJyYXkoMykuZmlsbCgpLm1hcCgoKT0+bmV3IEEpLHRoaXMuc2F0Qm91bmRzPW5ldyBBcnJheSgzKS5maWxsKCkubWFwKCgpPT5uZXcgUXQpLHRoaXMuYWxpZ25lZFNhdEJvdW5kcz1uZXcgQXJyYXkoMykuZmlsbCgpLm1hcCgoKT0+bmV3IFF0KSx0aGlzLm5lZWRzVXBkYXRlPSExLHQmJnRoaXMubWluLmNvcHkodCksZSYmdGhpcy5tYXguY29weShlKSxzJiZ0aGlzLm1hdHJpeC5jb3B5KHMpfXNldCh0LGUscyl7dGhpcy5taW4uY29weSh0KSx0aGlzLm1heC5jb3B5KGUpLHRoaXMubWF0cml4LmNvcHkocyksdGhpcy5uZWVkc1VwZGF0ZT0hMH1jb3B5KHQpe3RoaXMubWluLmNvcHkodC5taW4pLHRoaXMubWF4LmNvcHkodC5tYXgpLHRoaXMubWF0cml4LmNvcHkodC5tYXRyaXgpLHRoaXMubmVlZHNVcGRhdGU9ITB9fWx0LnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXtjb25zdCB0PXRoaXMubWF0cml4LGU9dGhpcy5taW4scz10aGlzLm1heCxuPXRoaXMucG9pbnRzO2ZvcihsZXQgdT0wO3U8PTE7dSsrKWZvcihsZXQgaD0wO2g8PTE7aCsrKWZvcihsZXQgbD0wO2w8PTE7bCsrKXtjb25zdCBkPTEqdXwyKmh8NCpsLGY9bltkXTtmLng9dT9zLng6ZS54LGYueT1oP3MueTplLnksZi56PWw/cy56OmUueixmLmFwcGx5TWF0cml4NCh0KX1jb25zdCBpPXRoaXMuc2F0Qm91bmRzLG89dGhpcy5zYXRBeGVzLGE9blswXTtmb3IobGV0IHU9MDt1PDM7dSsrKXtjb25zdCBoPW9bdV0sbD1pW3VdLGQ9MTw8dSxmPW5bZF07aC5zdWJWZWN0b3JzKGEsZiksbC5zZXRGcm9tUG9pbnRzKGgsbil9Y29uc3QgYz10aGlzLmFsaWduZWRTYXRCb3VuZHM7Y1swXS5zZXRGcm9tUG9pbnRzRmllbGQobiwieCIpLGNbMV0uc2V0RnJvbVBvaW50c0ZpZWxkKG4sInkiKSxjWzJdLnNldEZyb21Qb2ludHNGaWVsZChuLCJ6IiksdGhpcy5pbnZNYXRyaXguY29weSh0aGlzLm1hdHJpeCkuaW52ZXJ0KCksdGhpcy5uZWVkc1VwZGF0ZT0hMX19KCksbHQucHJvdG90eXBlLmludGVyc2VjdHNCb3g9ZnVuY3Rpb24oKXtjb25zdCByPW5ldyBRdDtyZXR1cm4gZnVuY3Rpb24oZSl7dGhpcy5uZWVkc1VwZGF0ZSYmdGhpcy51cGRhdGUoKTtjb25zdCBzPWUubWluLG49ZS5tYXgsaT10aGlzLnNhdEJvdW5kcyxvPXRoaXMuc2F0QXhlcyxhPXRoaXMuYWxpZ25lZFNhdEJvdW5kcztpZihyLm1pbj1zLngsci5tYXg9bi54LGFbMF0uaXNTZXBhcmF0ZWQocil8fChyLm1pbj1zLnksci5tYXg9bi55LGFbMV0uaXNTZXBhcmF0ZWQocikpfHwoci5taW49cy56LHIubWF4PW4ueixhWzJdLmlzU2VwYXJhdGVkKHIpKSlyZXR1cm4hMTtmb3IobGV0IGM9MDtjPDM7YysrKXtjb25zdCB1PW9bY10saD1pW2NdO2lmKHIuc2V0RnJvbUJveCh1LGUpLGguaXNTZXBhcmF0ZWQocikpcmV0dXJuITF9cmV0dXJuITB9fSgpLGx0LnByb3RvdHlwZS5pbnRlcnNlY3RzVHJpYW5nbGU9ZnVuY3Rpb24oKXtjb25zdCByPW5ldyBMdCx0PW5ldyBBcnJheSgzKSxlPW5ldyBRdCxzPW5ldyBRdCxuPW5ldyBBO3JldHVybiBmdW5jdGlvbihvKXt0aGlzLm5lZWRzVXBkYXRlJiZ0aGlzLnVwZGF0ZSgpLG8uaXNFeHRlbmRlZFRyaWFuZ2xlP28ubmVlZHNVcGRhdGUmJm8udXBkYXRlKCk6KHIuY29weShvKSxyLnVwZGF0ZSgpLG89cik7Y29uc3QgYT10aGlzLnNhdEJvdW5kcyxjPXRoaXMuc2F0QXhlczt0WzBdPW8uYSx0WzFdPW8uYix0WzJdPW8uYztmb3IobGV0IGQ9MDtkPDM7ZCsrKXtjb25zdCBmPWFbZF0scD1jW2RdO2lmKGUuc2V0RnJvbVBvaW50cyhwLHQpLGYuaXNTZXBhcmF0ZWQoZSkpcmV0dXJuITF9Y29uc3QgdT1vLnNhdEJvdW5kcyxoPW8uc2F0QXhlcyxsPXRoaXMucG9pbnRzO2ZvcihsZXQgZD0wO2Q8MztkKyspe2NvbnN0IGY9dVtkXSxwPWhbZF07aWYoZS5zZXRGcm9tUG9pbnRzKHAsbCksZi5pc1NlcGFyYXRlZChlKSlyZXR1cm4hMX1mb3IobGV0IGQ9MDtkPDM7ZCsrKXtjb25zdCBmPWNbZF07Zm9yKGxldCBwPTA7cDw0O3ArKyl7Y29uc3QgbT1oW3BdO2lmKG4uY3Jvc3NWZWN0b3JzKGYsbSksZS5zZXRGcm9tUG9pbnRzKG4sdCkscy5zZXRGcm9tUG9pbnRzKG4sbCksZS5pc1NlcGFyYXRlZChzKSlyZXR1cm4hMX19cmV0dXJuITB9fSgpLGx0LnByb3RvdHlwZS5jbG9zZXN0UG9pbnRUb1BvaW50PWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubmVlZHNVcGRhdGUmJnRoaXMudXBkYXRlKCksZS5jb3B5KHQpLmFwcGx5TWF0cml4NCh0aGlzLmludk1hdHJpeCkuY2xhbXAodGhpcy5taW4sdGhpcy5tYXgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeCksZX19KCksbHQucHJvdG90eXBlLmRpc3RhbmNlVG9Qb2ludD1mdW5jdGlvbigpe2NvbnN0IHI9bmV3IEE7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoZSxyKSxlLmRpc3RhbmNlVG8ocil9fSgpLGx0LnByb3RvdHlwZS5kaXN0YW5jZVRvQm94PWZ1bmN0aW9uKCl7Y29uc3Qgcj1bIngiLCJ5IiwieiJdLHQ9bmV3IEFycmF5KDEyKS5maWxsKCkubWFwKCgpPT5uZXcgWnQpLGU9bmV3IEFycmF5KDEyKS5maWxsKCkubWFwKCgpPT5uZXcgWnQpLHM9bmV3IEEsbj1uZXcgQTtyZXR1cm4gZnVuY3Rpb24obyxhPTAsYz1udWxsLHU9bnVsbCl7aWYodGhpcy5uZWVkc1VwZGF0ZSYmdGhpcy51cGRhdGUoKSx0aGlzLmludGVyc2VjdHNCb3gobykpcmV0dXJuKGN8fHUpJiYoby5nZXRDZW50ZXIobiksdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KG4scyksby5jbG9zZXN0UG9pbnRUb1BvaW50KHMsbiksYyYmYy5jb3B5KHMpLHUmJnUuY29weShuKSksMDtjb25zdCBoPWEqYSxsPW8ubWluLGQ9by5tYXgsZj10aGlzLnBvaW50cztsZXQgcD0xLzA7Zm9yKGxldCBnPTA7Zzw4O2crKyl7Y29uc3QgeT1mW2ddO24uY29weSh5KS5jbGFtcChsLGQpO2NvbnN0IFQ9eS5kaXN0YW5jZVRvU3F1YXJlZChuKTtpZihUPHAmJihwPVQsYyYmYy5jb3B5KHkpLHUmJnUuY29weShuKSxUPGgpKXJldHVybiBNYXRoLnNxcnQoVCl9bGV0IG09MDtmb3IobGV0IGc9MDtnPDM7ZysrKWZvcihsZXQgeT0wO3k8PTE7eSsrKWZvcihsZXQgVD0wO1Q8PTE7VCsrKXtjb25zdCB3PShnKzEpJTMsTT0oZysyKSUzLE49eTw8d3xUPDxNLF89MTw8Z3x5PDx3fFQ8PE0sUz1mW05dLEU9ZltfXTt0W21dLnNldChTLEUpO2NvbnN0IFI9cltnXSxJPXJbd10sQj1yW01dLFA9ZVttXSxMPVAuc3RhcnQsVj1QLmVuZDtMW1JdPWxbUl0sTFtJXT15P2xbSV06ZFtJXSxMW0JdPVQ/bFtCXTpkW0ldLFZbUl09ZFtSXSxWW0ldPXk/bFtJXTpkW0ldLFZbQl09VD9sW0JdOmRbSV0sbSsrfWZvcihsZXQgZz0wO2c8PTE7ZysrKWZvcihsZXQgeT0wO3k8PTE7eSsrKWZvcihsZXQgVD0wO1Q8PTE7VCsrKXtuLng9Zz9kLng6bC54LG4ueT15P2QueTpsLnksbi56PVQ/ZC56Omwueix0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQobixzKTtjb25zdCB3PW4uZGlzdGFuY2VUb1NxdWFyZWQocyk7aWYodzxwJiYocD13LGMmJmMuY29weShzKSx1JiZ1LmNvcHkobiksdzxoKSlyZXR1cm4gTWF0aC5zcXJ0KHcpfWZvcihsZXQgZz0wO2c8MTI7ZysrKXtjb25zdCB5PXRbZ107Zm9yKGxldCBUPTA7VDwxMjtUKyspe2NvbnN0IHc9ZVtUXTtNaSh5LHcscyxuKTtjb25zdCBNPXMuZGlzdGFuY2VUb1NxdWFyZWQobik7aWYoTTxwJiYocD1NLGMmJmMuY29weShzKSx1JiZ1LmNvcHkobiksTTxoKSlyZXR1cm4gTWF0aC5zcXJ0KE0pfX1yZXR1cm4gTWF0aC5zcXJ0KHApfX0oKTtjbGFzcyBfaXtjb25zdHJ1Y3Rvcih0KXt0aGlzLl9nZXROZXdQcmltaXRpdmU9dCx0aGlzLl9wcmltaXRpdmVzPVtdfWdldFByaW1pdGl2ZSgpe2NvbnN0IHQ9dGhpcy5fcHJpbWl0aXZlcztyZXR1cm4gdC5sZW5ndGg9PT0wP3RoaXMuX2dldE5ld1ByaW1pdGl2ZSgpOnQucG9wKCl9cmVsZWFzZVByaW1pdGl2ZSh0KXt0aGlzLl9wcmltaXRpdmVzLnB1c2godCl9fWNsYXNzIGVsIGV4dGVuZHMgX2l7Y29uc3RydWN0b3IoKXtzdXBlcigoKT0+bmV3IEx0KX19Y29uc3QgYnQ9bmV3IGVsO2NsYXNzIHNse2NvbnN0cnVjdG9yKCl7dGhpcy5mbG9hdDMyQXJyYXk9bnVsbCx0aGlzLnVpbnQxNkFycmF5PW51bGwsdGhpcy51aW50MzJBcnJheT1udWxsO2NvbnN0IHQ9W107bGV0IGU9bnVsbDt0aGlzLnNldEJ1ZmZlcj1zPT57ZSYmdC5wdXNoKGUpLGU9cyx0aGlzLmZsb2F0MzJBcnJheT1uZXcgRmxvYXQzMkFycmF5KHMpLHRoaXMudWludDE2QXJyYXk9bmV3IFVpbnQxNkFycmF5KHMpLHRoaXMudWludDMyQXJyYXk9bmV3IFVpbnQzMkFycmF5KHMpfSx0aGlzLmNsZWFyQnVmZmVyPSgpPT57ZT1udWxsLHRoaXMuZmxvYXQzMkFycmF5PW51bGwsdGhpcy51aW50MTZBcnJheT1udWxsLHRoaXMudWludDMyQXJyYXk9bnVsbCx0Lmxlbmd0aCE9PTAmJnRoaXMuc2V0QnVmZmVyKHQucG9wKCkpfX19Y29uc3QgWD1uZXcgc2w7bGV0IGFlLFZlO2NvbnN0IFVlPVtdLG9uPW5ldyBfaSgoKT0+bmV3IGh0KTtmdW5jdGlvbiBubChyLHQsZSxzLG4saSl7YWU9b24uZ2V0UHJpbWl0aXZlKCksVmU9b24uZ2V0UHJpbWl0aXZlKCksVWUucHVzaChhZSxWZSksWC5zZXRCdWZmZXIoci5fcm9vdHNbdF0pO2NvbnN0IG89emkoMCxyLmdlb21ldHJ5LGUscyxuLGkpO1guY2xlYXJCdWZmZXIoKSxvbi5yZWxlYXNlUHJpbWl0aXZlKGFlKSxvbi5yZWxlYXNlUHJpbWl0aXZlKFZlKSxVZS5wb3AoKSxVZS5wb3AoKTtjb25zdCBhPVVlLmxlbmd0aDtyZXR1cm4gYT4wJiYoVmU9VWVbYS0xXSxhZT1VZVthLTJdKSxvfWZ1bmN0aW9uIHppKHIsdCxlLHMsbj1udWxsLGk9MCxvPTApe2NvbnN0e2Zsb2F0MzJBcnJheTphLHVpbnQxNkFycmF5OmMsdWludDMyQXJyYXk6dX09WDtsZXQgaD1yKjI7aWYocHQoaCxjKSl7Y29uc3QgZD1UdChyLHUpLGY9U3QoaCxjKTtyZXR1cm4gWihyLGEsYWUpLHMoZCxmLCExLG8saStyLGFlKX1lbHNle2xldCBSPWZ1bmN0aW9uKEIpe2NvbnN0e3VpbnQxNkFycmF5OlAsdWludDMyQXJyYXk6TH09WDtsZXQgVj1CKjI7Zm9yKDshcHQoVixQKTspQj1fdChCKSxWPUIqMjtyZXR1cm4gVHQoQixMKX0sST1mdW5jdGlvbihCKXtjb25zdHt1aW50MTZBcnJheTpQLHVpbnQzMkFycmF5Okx9PVg7bGV0IFY9QioyO2Zvcig7IXB0KFYsUCk7KUI9enQoQixMKSxWPUIqMjtyZXR1cm4gVHQoQixMKStTdChWLFApfTtjb25zdCBkPV90KHIpLGY9enQocix1KTtsZXQgcD1kLG09ZixnLHksVCx3O2lmKG4mJihUPWFlLHc9VmUsWihwLGEsVCksWihtLGEsdyksZz1uKFQpLHk9bih3KSx5PGcpKXtwPWYsbT1kO2NvbnN0IEI9ZztnPXkseT1CLFQ9d31UfHwoVD1hZSxaKHAsYSxUKSk7Y29uc3QgTT1wdChwKjIsYyksTj1lKFQsTSxnLG8rMSxpK3ApO2xldCBfO2lmKE49PT1sbyl7Y29uc3QgQj1SKHApLEw9SShwKS1CO189cyhCLEwsITAsbysxLGkrcCxUKX1lbHNlIF89TiYmemkocCx0LGUscyxuLGksbysxKTtpZihfKXJldHVybiEwO3c9VmUsWihtLGEsdyk7Y29uc3QgUz1wdChtKjIsYyksRT1lKHcsUyx5LG8rMSxpK20pO2xldCBGO2lmKEU9PT1sbyl7Y29uc3QgQj1SKG0pLEw9SShtKS1CO0Y9cyhCLEwsITAsbysxLGkrbSx3KX1lbHNlIEY9RSYmemkobSx0LGUscyxuLGksbysxKTtyZXR1cm4hIUZ9fWNvbnN0IHhzPW5ldyBBLGJpPW5ldyBBO2Z1bmN0aW9uIGlsKHIsdCxlPXt9LHM9MCxuPTEvMCl7Y29uc3QgaT1zKnMsbz1uKm47bGV0IGE9MS8wLGM9bnVsbDtpZihyLnNoYXBlY2FzdCh7Ym91bmRzVHJhdmVyc2VPcmRlcjpoPT4oeHMuY29weSh0KS5jbGFtcChoLm1pbixoLm1heCkseHMuZGlzdGFuY2VUb1NxdWFyZWQodCkpLGludGVyc2VjdHNCb3VuZHM6KGgsbCxkKT0+ZDxhJiZkPG8saW50ZXJzZWN0c1RyaWFuZ2xlOihoLGwpPT57aC5jbG9zZXN0UG9pbnRUb1BvaW50KHQseHMpO2NvbnN0IGQ9dC5kaXN0YW5jZVRvU3F1YXJlZCh4cyk7cmV0dXJuIGQ8YSYmKGJpLmNvcHkoeHMpLGE9ZCxjPWwpLGQ8aX19KSxhPT09MS8wKXJldHVybiBudWxsO2NvbnN0IHU9TWF0aC5zcXJ0KGEpO3JldHVybiBlLnBvaW50P2UucG9pbnQuY29weShiaSk6ZS5wb2ludD1iaS5jbG9uZSgpLGUuZGlzdGFuY2U9dSxlLmZhY2VJbmRleD1jLGV9Y29uc3Qgcmw9cGFyc2VJbnQoWGUpPj0xNjksbWU9bmV3IEEseWU9bmV3IEEsZ2U9bmV3IEEsYW49bmV3IEosY249bmV3IEosaG49bmV3IEosQW89bmV3IEEsTW89bmV3IEEsU289bmV3IEEsVHM9bmV3IEE7ZnVuY3Rpb24gb2wocix0LGUscyxuLGksbyxhKXtsZXQgYztpZihpPT09VWk/Yz1yLmludGVyc2VjdFRyaWFuZ2xlKHMsZSx0LCEwLG4pOmM9ci5pbnRlcnNlY3RUcmlhbmdsZSh0LGUscyxpIT09RW8sbiksYz09PW51bGwpcmV0dXJuIG51bGw7Y29uc3QgdT1yLm9yaWdpbi5kaXN0YW5jZVRvKG4pO3JldHVybiB1PG98fHU+YT9udWxsOntkaXN0YW5jZTp1LHBvaW50Om4uY2xvbmUoKX19ZnVuY3Rpb24gYWwocix0LGUscyxuLGksbyxhLGMsdSxoKXttZS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsaSkseWUuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LG8pLGdlLmZyb21CdWZmZXJBdHRyaWJ1dGUodCxhKTtjb25zdCBsPW9sKHIsbWUseWUsZ2UsVHMsYyx1LGgpO2lmKGwpe2NvbnN0IGQ9bmV3IEE7d3QuZ2V0QmFyeWNvb3JkKFRzLG1lLHllLGdlLGQpLHMmJihhbi5mcm9tQnVmZmVyQXR0cmlidXRlKHMsaSksY24uZnJvbUJ1ZmZlckF0dHJpYnV0ZShzLG8pLGhuLmZyb21CdWZmZXJBdHRyaWJ1dGUocyxhKSxsLnV2PXd0LmdldEludGVycG9sYXRpb24oVHMsbWUseWUsZ2UsYW4sY24saG4sbmV3IEopKSxuJiYoYW4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShuLGkpLGNuLmZyb21CdWZmZXJBdHRyaWJ1dGUobixvKSxobi5mcm9tQnVmZmVyQXR0cmlidXRlKG4sYSksbC51djE9d3QuZ2V0SW50ZXJwb2xhdGlvbihUcyxtZSx5ZSxnZSxhbixjbixobixuZXcgSikpLGUmJihBby5mcm9tQnVmZmVyQXR0cmlidXRlKGUsaSksTW8uZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLG8pLFNvLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSxhKSxsLm5vcm1hbD13dC5nZXRJbnRlcnBvbGF0aW9uKFRzLG1lLHllLGdlLEFvLE1vLFNvLG5ldyBBKSxsLm5vcm1hbC5kb3Qoci5kaXJlY3Rpb24pPjAmJmwubm9ybWFsLm11bHRpcGx5U2NhbGFyKC0xKSk7Y29uc3QgZj17YTppLGI6byxjOmEsbm9ybWFsOm5ldyBBLG1hdGVyaWFsSW5kZXg6MH07d3QuZ2V0Tm9ybWFsKG1lLHllLGdlLGYubm9ybWFsKSxsLmZhY2U9ZixsLmZhY2VJbmRleD1pLHJsJiYobC5iYXJ5Y29vcmQ9ZCl9cmV0dXJuIGx9ZnVuY3Rpb24gdW4ocix0LGUscyxuLGksbyl7Y29uc3QgYT1zKjM7bGV0IGM9YSswLHU9YSsxLGg9YSsyO2NvbnN0IGw9ci5pbmRleDtyLmluZGV4JiYoYz1sLmdldFgoYyksdT1sLmdldFgodSksaD1sLmdldFgoaCkpO2NvbnN0e3Bvc2l0aW9uOmQsbm9ybWFsOmYsdXY6cCx1djE6bX09ci5hdHRyaWJ1dGVzLGc9YWwoZSxkLGYscCxtLGMsdSxoLHQsaSxvKTtyZXR1cm4gZz8oZy5mYWNlSW5kZXg9cyxuJiZuLnB1c2goZyksZyk6bnVsbH1mdW5jdGlvbiBzdChyLHQsZSxzKXtjb25zdCBuPXIuYSxpPXIuYixvPXIuYztsZXQgYT10LGM9dCsxLHU9dCsyO2UmJihhPWUuZ2V0WChhKSxjPWUuZ2V0WChjKSx1PWUuZ2V0WCh1KSksbi54PXMuZ2V0WChhKSxuLnk9cy5nZXRZKGEpLG4uej1zLmdldFooYSksaS54PXMuZ2V0WChjKSxpLnk9cy5nZXRZKGMpLGkuej1zLmdldFooYyksby54PXMuZ2V0WCh1KSxvLnk9cy5nZXRZKHUpLG8uej1zLmdldFoodSl9ZnVuY3Rpb24gY2wocix0LGUscyxuLGksbyxhKXtjb25zdHtnZW9tZXRyeTpjLF9pbmRpcmVjdEJ1ZmZlcjp1fT1yO2ZvcihsZXQgaD1zLGw9cytuO2g8bDtoKyspdW4oYyx0LGUsaCxpLG8sYSl9ZnVuY3Rpb24gaGwocix0LGUscyxuLGksbyl7Y29uc3R7Z2VvbWV0cnk6YSxfaW5kaXJlY3RCdWZmZXI6Y309cjtsZXQgdT0xLzAsaD1udWxsO2ZvcihsZXQgbD1zLGQ9cytuO2w8ZDtsKyspe2xldCBmO2Y9dW4oYSx0LGUsbCxudWxsLGksbyksZiYmZi5kaXN0YW5jZTx1JiYoaD1mLHU9Zi5kaXN0YW5jZSl9cmV0dXJuIGh9ZnVuY3Rpb24gdWwocix0LGUscyxuLGksbyl7Y29uc3R7Z2VvbWV0cnk6YX09ZSx7aW5kZXg6Y309YSx1PWEuYXR0cmlidXRlcy5wb3NpdGlvbjtmb3IobGV0IGg9cixsPXQrcjtoPGw7aCsrKXtsZXQgZDtpZihkPWgsc3QobyxkKjMsYyx1KSxvLm5lZWRzVXBkYXRlPSEwLHMobyxkLG4saSkpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gbGwocix0PW51bGwpe3QmJkFycmF5LmlzQXJyYXkodCkmJih0PW5ldyBTZXQodCkpO2NvbnN0IGU9ci5nZW9tZXRyeSxzPWUuaW5kZXg/ZS5pbmRleC5hcnJheTpudWxsLG49ZS5hdHRyaWJ1dGVzLnBvc2l0aW9uO2xldCBpLG8sYSxjLHU9MDtjb25zdCBoPXIuX3Jvb3RzO2ZvcihsZXQgZD0wLGY9aC5sZW5ndGg7ZDxmO2QrKylpPWhbZF0sbz1uZXcgVWludDMyQXJyYXkoaSksYT1uZXcgVWludDE2QXJyYXkoaSksYz1uZXcgRmxvYXQzMkFycmF5KGkpLGwoMCx1KSx1Kz1pLmJ5dGVMZW5ndGg7ZnVuY3Rpb24gbChkLGYscD0hMSl7Y29uc3QgbT1kKjI7aWYoYVttKzE1XT09PWVuKXtjb25zdCB5PW9bZCs2XSxUPWFbbSsxNF07bGV0IHc9MS8wLE09MS8wLE49MS8wLF89LTEvMCxTPS0xLzAsRT0tMS8wO2ZvcihsZXQgRj0zKnksUj0zKih5K1QpO0Y8UjtGKyspe2xldCBJPXNbRl07Y29uc3QgQj1uLmdldFgoSSksUD1uLmdldFkoSSksTD1uLmdldFooSSk7Qjx3JiYodz1CKSxCPl8mJihfPUIpLFA8TSYmKE09UCksUD5TJiYoUz1QKSxMPE4mJihOPUwpLEw+RSYmKEU9TCl9cmV0dXJuIGNbZCswXSE9PXd8fGNbZCsxXSE9PU18fGNbZCsyXSE9PU58fGNbZCszXSE9PV98fGNbZCs0XSE9PVN8fGNbZCs1XSE9PUU/KGNbZCswXT13LGNbZCsxXT1NLGNbZCsyXT1OLGNbZCszXT1fLGNbZCs0XT1TLGNbZCs1XT1FLCEwKTohMX1lbHNle2NvbnN0IHk9ZCs4LFQ9b1tkKzZdLHc9eStmLE09VCtmO2xldCBOPXAsXz0hMSxTPSExO3Q/Tnx8KF89dC5oYXModyksUz10LmhhcyhNKSxOPSFfJiYhUyk6KF89ITAsUz0hMCk7Y29uc3QgRT1OfHxfLEY9Tnx8UztsZXQgUj0hMTtFJiYoUj1sKHksZixOKSk7bGV0IEk9ITE7RiYmKEk9bChULGYsTikpO2NvbnN0IEI9Unx8STtpZihCKWZvcihsZXQgUD0wO1A8MztQKyspe2NvbnN0IEw9eStQLFY9VCtQLEc9Y1tMXSxOdD1jW0wrM10sSHQ9Y1tWXSxxdD1jW1YrM107Y1tkK1BdPUc8SHQ/RzpIdCxjW2QrUCszXT1OdD5xdD9OdDpxdH1yZXR1cm4gQn19fWZ1bmN0aW9uIGNlKHIsdCxlLHMsbil7bGV0IGksbyxhLGMsdSxoO2NvbnN0IGw9MS9lLmRpcmVjdGlvbi54LGQ9MS9lLmRpcmVjdGlvbi55LGY9MS9lLmRpcmVjdGlvbi56LHA9ZS5vcmlnaW4ueCxtPWUub3JpZ2luLnksZz1lLm9yaWdpbi56O2xldCB5PXRbcl0sVD10W3IrM10sdz10W3IrMV0sTT10W3IrMysxXSxOPXRbcisyXSxfPXRbciszKzJdO3JldHVybiBsPj0wPyhpPSh5LXApKmwsbz0oVC1wKSpsKTooaT0oVC1wKSpsLG89KHktcCkqbCksZD49MD8oYT0ody1tKSpkLGM9KE0tbSkqZCk6KGE9KE0tbSkqZCxjPSh3LW0pKmQpLGk+Y3x8YT5vfHwoKGE+aXx8aXNOYU4oaSkpJiYoaT1hKSwoYzxvfHxpc05hTihvKSkmJihvPWMpLGY+PTA/KHU9KE4tZykqZixoPShfLWcpKmYpOih1PShfLWcpKmYsaD0oTi1nKSpmKSxpPmh8fHU+byk/ITE6KCh1Pml8fGkhPT1pKSYmKGk9dSksKGg8b3x8byE9PW8pJiYobz1oKSxpPD1uJiZvPj1zKX1mdW5jdGlvbiBkbChyLHQsZSxzLG4saSxvLGEpe2NvbnN0e2dlb21ldHJ5OmMsX2luZGlyZWN0QnVmZmVyOnV9PXI7Zm9yKGxldCBoPXMsbD1zK247aDxsO2grKyl7bGV0IGQ9dT91W2hdOmg7dW4oYyx0LGUsZCxpLG8sYSl9fWZ1bmN0aW9uIGZsKHIsdCxlLHMsbixpLG8pe2NvbnN0e2dlb21ldHJ5OmEsX2luZGlyZWN0QnVmZmVyOmN9PXI7bGV0IHU9MS8wLGg9bnVsbDtmb3IobGV0IGw9cyxkPXMrbjtsPGQ7bCsrKXtsZXQgZjtmPXVuKGEsdCxlLGM/Y1tsXTpsLG51bGwsaSxvKSxmJiZmLmRpc3RhbmNlPHUmJihoPWYsdT1mLmRpc3RhbmNlKX1yZXR1cm4gaH1mdW5jdGlvbiBwbChyLHQsZSxzLG4saSxvKXtjb25zdHtnZW9tZXRyeTphfT1lLHtpbmRleDpjfT1hLHU9YS5hdHRyaWJ1dGVzLnBvc2l0aW9uO2ZvcihsZXQgaD1yLGw9dCtyO2g8bDtoKyspe2xldCBkO2lmKGQ9ZS5yZXNvbHZlVHJpYW5nbGVJbmRleChoKSxzdChvLGQqMyxjLHUpLG8ubmVlZHNVcGRhdGU9ITAscyhvLGQsbixpKSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBtbChyLHQsZSxzLG4saSxvKXtYLnNldEJ1ZmZlcihyLl9yb290c1t0XSksRWkoMCxyLGUscyxuLGksbyksWC5jbGVhckJ1ZmZlcigpfWZ1bmN0aW9uIEVpKHIsdCxlLHMsbixpLG8pe2NvbnN0e2Zsb2F0MzJBcnJheTphLHVpbnQxNkFycmF5OmMsdWludDMyQXJyYXk6dX09WCxoPXIqMjtpZihwdChoLGMpKXtjb25zdCBkPVR0KHIsdSksZj1TdChoLGMpO2NsKHQsZSxzLGQsZixuLGksbyl9ZWxzZXtjb25zdCBkPV90KHIpO2NlKGQsYSxzLGksbykmJkVpKGQsdCxlLHMsbixpLG8pO2NvbnN0IGY9enQocix1KTtjZShmLGEscyxpLG8pJiZFaShmLHQsZSxzLG4saSxvKX19Y29uc3QgeWw9WyJ4IiwieSIsInoiXTtmdW5jdGlvbiBnbChyLHQsZSxzLG4saSl7WC5zZXRCdWZmZXIoci5fcm9vdHNbdF0pO2NvbnN0IG89Q2koMCxyLGUscyxuLGkpO3JldHVybiBYLmNsZWFyQnVmZmVyKCksb31mdW5jdGlvbiBDaShyLHQsZSxzLG4saSl7Y29uc3R7ZmxvYXQzMkFycmF5Om8sdWludDE2QXJyYXk6YSx1aW50MzJBcnJheTpjfT1YO2xldCB1PXIqMjtpZihwdCh1LGEpKXtjb25zdCBsPVR0KHIsYyksZD1TdCh1LGEpO3JldHVybiBobCh0LGUscyxsLGQsbixpKX1lbHNle2NvbnN0IGw9VG8ocixjKSxkPXlsW2xdLHA9cy5kaXJlY3Rpb25bZF0+PTA7bGV0IG0sZztwPyhtPV90KHIpLGc9enQocixjKSk6KG09enQocixjKSxnPV90KHIpKTtjb25zdCBUPWNlKG0sbyxzLG4saSk/Q2kobSx0LGUscyxuLGkpOm51bGw7aWYoVCl7Y29uc3QgTj1ULnBvaW50W2RdO2lmKHA/Tjw9b1tnK2xdOk4+PW9bZytsKzNdKXJldHVybiBUfWNvbnN0IE09Y2UoZyxvLHMsbixpKT9DaShnLHQsZSxzLG4saSk6bnVsbDtyZXR1cm4gVCYmTT9ULmRpc3RhbmNlPD1NLmRpc3RhbmNlP1Q6TTpUfHxNfHxudWxsfX1jb25zdCBsbj1uZXcgaHQsa2U9bmV3IEx0LEhlPW5ldyBMdCxOcz1uZXcgbnQsX289bmV3IGx0LGRuPW5ldyBsdDtmdW5jdGlvbiB4bChyLHQsZSxzKXtYLnNldEJ1ZmZlcihyLl9yb290c1t0XSk7Y29uc3Qgbj1GaSgwLHIsZSxzKTtyZXR1cm4gWC5jbGVhckJ1ZmZlcigpLG59ZnVuY3Rpb24gRmkocix0LGUscyxuPW51bGwpe2NvbnN0e2Zsb2F0MzJBcnJheTppLHVpbnQxNkFycmF5Om8sdWludDMyQXJyYXk6YX09WDtsZXQgYz1yKjI7aWYobj09PW51bGwmJihlLmJvdW5kaW5nQm94fHxlLmNvbXB1dGVCb3VuZGluZ0JveCgpLF9vLnNldChlLmJvdW5kaW5nQm94Lm1pbixlLmJvdW5kaW5nQm94Lm1heCxzKSxuPV9vKSxwdChjLG8pKXtjb25zdCBoPXQuZ2VvbWV0cnksbD1oLmluZGV4LGQ9aC5hdHRyaWJ1dGVzLnBvc2l0aW9uLGY9ZS5pbmRleCxwPWUuYXR0cmlidXRlcy5wb3NpdGlvbixtPVR0KHIsYSksZz1TdChjLG8pO2lmKE5zLmNvcHkocykuaW52ZXJ0KCksZS5ib3VuZHNUcmVlKXJldHVybiBaKHIsaSxkbiksZG4ubWF0cml4LmNvcHkoTnMpLGRuLm5lZWRzVXBkYXRlPSEwLGUuYm91bmRzVHJlZS5zaGFwZWNhc3Qoe2ludGVyc2VjdHNCb3VuZHM6VD0+ZG4uaW50ZXJzZWN0c0JveChUKSxpbnRlcnNlY3RzVHJpYW5nbGU6VD0+e1QuYS5hcHBseU1hdHJpeDQocyksVC5iLmFwcGx5TWF0cml4NChzKSxULmMuYXBwbHlNYXRyaXg0KHMpLFQubmVlZHNVcGRhdGU9ITA7Zm9yKGxldCB3PW0qMyxNPShnK20pKjM7dzxNO3crPTMpaWYoc3QoSGUsdyxsLGQpLEhlLm5lZWRzVXBkYXRlPSEwLFQuaW50ZXJzZWN0c1RyaWFuZ2xlKEhlKSlyZXR1cm4hMDtyZXR1cm4hMX19KTtmb3IobGV0IHk9bSozLFQ9KGcrbSkqMzt5PFQ7eSs9Myl7c3Qoa2UseSxsLGQpLGtlLmEuYXBwbHlNYXRyaXg0KE5zKSxrZS5iLmFwcGx5TWF0cml4NChOcyksa2UuYy5hcHBseU1hdHJpeDQoTnMpLGtlLm5lZWRzVXBkYXRlPSEwO2ZvcihsZXQgdz0wLE09Zi5jb3VudDt3PE07dys9MylpZihzdChIZSx3LGYscCksSGUubmVlZHNVcGRhdGU9ITAsa2UuaW50ZXJzZWN0c1RyaWFuZ2xlKEhlKSlyZXR1cm4hMH19ZWxzZXtjb25zdCBoPXIrOCxsPWFbcis2XTtyZXR1cm4gWihoLGksbG4pLCEhKG4uaW50ZXJzZWN0c0JveChsbikmJkZpKGgsdCxlLHMsbil8fChaKGwsaSxsbiksbi5pbnRlcnNlY3RzQm94KGxuKSYmRmkobCx0LGUscyxuKSkpfX1jb25zdCBmbj1uZXcgbnQsUmk9bmV3IGx0LHdzPW5ldyBsdCxUbD1uZXcgQSxObD1uZXcgQSx3bD1uZXcgQSxBbD1uZXcgQTtmdW5jdGlvbiBNbChyLHQsZSxzPXt9LG49e30saT0wLG89MS8wKXt0LmJvdW5kaW5nQm94fHx0LmNvbXB1dGVCb3VuZGluZ0JveCgpLFJpLnNldCh0LmJvdW5kaW5nQm94Lm1pbix0LmJvdW5kaW5nQm94Lm1heCxlKSxSaS5uZWVkc1VwZGF0ZT0hMDtjb25zdCBhPXIuZ2VvbWV0cnksYz1hLmF0dHJpYnV0ZXMucG9zaXRpb24sdT1hLmluZGV4LGg9dC5hdHRyaWJ1dGVzLnBvc2l0aW9uLGw9dC5pbmRleCxkPWJ0LmdldFByaW1pdGl2ZSgpLGY9YnQuZ2V0UHJpbWl0aXZlKCk7bGV0IHA9VGwsbT1ObCxnPW51bGwseT1udWxsO24mJihnPXdsLHk9QWwpO2xldCBUPTEvMCx3PW51bGwsTT1udWxsO3JldHVybiBmbi5jb3B5KGUpLmludmVydCgpLHdzLm1hdHJpeC5jb3B5KGZuKSxyLnNoYXBlY2FzdCh7Ym91bmRzVHJhdmVyc2VPcmRlcjpOPT5SaS5kaXN0YW5jZVRvQm94KE4pLGludGVyc2VjdHNCb3VuZHM6KE4sXyxTKT0+UzxUJiZTPG8/KF8mJih3cy5taW4uY29weShOLm1pbiksd3MubWF4LmNvcHkoTi5tYXgpLHdzLm5lZWRzVXBkYXRlPSEwKSwhMCk6ITEsaW50ZXJzZWN0c1JhbmdlOihOLF8pPT57aWYodC5ib3VuZHNUcmVlKXJldHVybiB0LmJvdW5kc1RyZWUuc2hhcGVjYXN0KHtib3VuZHNUcmF2ZXJzZU9yZGVyOkU9PndzLmRpc3RhbmNlVG9Cb3goRSksaW50ZXJzZWN0c0JvdW5kczooRSxGLFIpPT5SPFQmJlI8byxpbnRlcnNlY3RzUmFuZ2U6KEUsRik9Pntmb3IobGV0IFI9RSxJPUUrRjtSPEk7UisrKXtzdChmLDMqUixsLGgpLGYuYS5hcHBseU1hdHJpeDQoZSksZi5iLmFwcGx5TWF0cml4NChlKSxmLmMuYXBwbHlNYXRyaXg0KGUpLGYubmVlZHNVcGRhdGU9ITA7Zm9yKGxldCBCPU4sUD1OK187QjxQO0IrKyl7c3QoZCwzKkIsdSxjKSxkLm5lZWRzVXBkYXRlPSEwO2NvbnN0IEw9ZC5kaXN0YW5jZVRvVHJpYW5nbGUoZixwLGcpO2lmKEw8VCYmKG0uY29weShwKSx5JiZ5LmNvcHkoZyksVD1MLHc9QixNPVIpLEw8aSlyZXR1cm4hMH19fX0pO3tjb25zdCBTPURlKHQpO2ZvcihsZXQgRT0wLEY9UztFPEY7RSsrKXtzdChmLDMqRSxsLGgpLGYuYS5hcHBseU1hdHJpeDQoZSksZi5iLmFwcGx5TWF0cml4NChlKSxmLmMuYXBwbHlNYXRyaXg0KGUpLGYubmVlZHNVcGRhdGU9ITA7Zm9yKGxldCBSPU4sST1OK187UjxJO1IrKyl7c3QoZCwzKlIsdSxjKSxkLm5lZWRzVXBkYXRlPSEwO2NvbnN0IEI9ZC5kaXN0YW5jZVRvVHJpYW5nbGUoZixwLGcpO2lmKEI8VCYmKG0uY29weShwKSx5JiZ5LmNvcHkoZyksVD1CLHc9UixNPUUpLEI8aSlyZXR1cm4hMH19fX19KSxidC5yZWxlYXNlUHJpbWl0aXZlKGQpLGJ0LnJlbGVhc2VQcmltaXRpdmUoZiksVD09PTEvMD9udWxsOihzLnBvaW50P3MucG9pbnQuY29weShtKTpzLnBvaW50PW0uY2xvbmUoKSxzLmRpc3RhbmNlPVQscy5mYWNlSW5kZXg9dyxuJiYobi5wb2ludD9uLnBvaW50LmNvcHkoeSk6bi5wb2ludD15LmNsb25lKCksbi5wb2ludC5hcHBseU1hdHJpeDQoZm4pLG0uYXBwbHlNYXRyaXg0KGZuKSxuLmRpc3RhbmNlPW0uc3ViKG4ucG9pbnQpLmxlbmd0aCgpLG4uZmFjZUluZGV4PU0pLHMpfWZ1bmN0aW9uIFNsKHIsdD1udWxsKXt0JiZBcnJheS5pc0FycmF5KHQpJiYodD1uZXcgU2V0KHQpKTtjb25zdCBlPXIuZ2VvbWV0cnkscz1lLmluZGV4P2UuaW5kZXguYXJyYXk6bnVsbCxuPWUuYXR0cmlidXRlcy5wb3NpdGlvbjtsZXQgaSxvLGEsYyx1PTA7Y29uc3QgaD1yLl9yb290cztmb3IobGV0IGQ9MCxmPWgubGVuZ3RoO2Q8ZjtkKyspaT1oW2RdLG89bmV3IFVpbnQzMkFycmF5KGkpLGE9bmV3IFVpbnQxNkFycmF5KGkpLGM9bmV3IEZsb2F0MzJBcnJheShpKSxsKDAsdSksdSs9aS5ieXRlTGVuZ3RoO2Z1bmN0aW9uIGwoZCxmLHA9ITEpe2NvbnN0IG09ZCoyO2lmKGFbbSsxNV09PT1lbil7Y29uc3QgeT1vW2QrNl0sVD1hW20rMTRdO2xldCB3PTEvMCxNPTEvMCxOPTEvMCxfPS0xLzAsUz0tMS8wLEU9LTEvMDtmb3IobGV0IEY9eSxSPXkrVDtGPFI7RisrKXtjb25zdCBJPTMqci5yZXNvbHZlVHJpYW5nbGVJbmRleChGKTtmb3IobGV0IEI9MDtCPDM7QisrKXtsZXQgUD1JK0I7UD1zP3NbUF06UDtjb25zdCBMPW4uZ2V0WChQKSxWPW4uZ2V0WShQKSxHPW4uZ2V0WihQKTtMPHcmJih3PUwpLEw+XyYmKF89TCksVjxNJiYoTT1WKSxWPlMmJihTPVYpLEc8TiYmKE49RyksRz5FJiYoRT1HKX19cmV0dXJuIGNbZCswXSE9PXd8fGNbZCsxXSE9PU18fGNbZCsyXSE9PU58fGNbZCszXSE9PV98fGNbZCs0XSE9PVN8fGNbZCs1XSE9PUU/KGNbZCswXT13LGNbZCsxXT1NLGNbZCsyXT1OLGNbZCszXT1fLGNbZCs0XT1TLGNbZCs1XT1FLCEwKTohMX1lbHNle2NvbnN0IHk9ZCs4LFQ9b1tkKzZdLHc9eStmLE09VCtmO2xldCBOPXAsXz0hMSxTPSExO3Q/Tnx8KF89dC5oYXModyksUz10LmhhcyhNKSxOPSFfJiYhUyk6KF89ITAsUz0hMCk7Y29uc3QgRT1OfHxfLEY9Tnx8UztsZXQgUj0hMTtFJiYoUj1sKHksZixOKSk7bGV0IEk9ITE7RiYmKEk9bChULGYsTikpO2NvbnN0IEI9Unx8STtpZihCKWZvcihsZXQgUD0wO1A8MztQKyspe2NvbnN0IEw9eStQLFY9VCtQLEc9Y1tMXSxOdD1jW0wrM10sSHQ9Y1tWXSxxdD1jW1YrM107Y1tkK1BdPUc8SHQ/RzpIdCxjW2QrUCszXT1OdD5xdD9OdDpxdH1yZXR1cm4gQn19fWZ1bmN0aW9uIF9sKHIsdCxlLHMsbixpLG8pe1guc2V0QnVmZmVyKHIuX3Jvb3RzW3RdKSxCaSgwLHIsZSxzLG4saSxvKSxYLmNsZWFyQnVmZmVyKCl9ZnVuY3Rpb24gQmkocix0LGUscyxuLGksbyl7Y29uc3R7ZmxvYXQzMkFycmF5OmEsdWludDE2QXJyYXk6Yyx1aW50MzJBcnJheTp1fT1YLGg9cioyO2lmKHB0KGgsYykpe2NvbnN0IGQ9VHQocix1KSxmPVN0KGgsYyk7ZGwodCxlLHMsZCxmLG4saSxvKX1lbHNle2NvbnN0IGQ9X3Qocik7Y2UoZCxhLHMsaSxvKSYmQmkoZCx0LGUscyxuLGksbyk7Y29uc3QgZj16dChyLHUpO2NlKGYsYSxzLGksbykmJkJpKGYsdCxlLHMsbixpLG8pfX1jb25zdCB6bD1bIngiLCJ5IiwieiJdO2Z1bmN0aW9uIGJsKHIsdCxlLHMsbixpKXtYLnNldEJ1ZmZlcihyLl9yb290c1t0XSk7Y29uc3Qgbz1JaSgwLHIsZSxzLG4saSk7cmV0dXJuIFguY2xlYXJCdWZmZXIoKSxvfWZ1bmN0aW9uIElpKHIsdCxlLHMsbixpKXtjb25zdHtmbG9hdDMyQXJyYXk6byx1aW50MTZBcnJheTphLHVpbnQzMkFycmF5OmN9PVg7bGV0IHU9cioyO2lmKHB0KHUsYSkpe2NvbnN0IGw9VHQocixjKSxkPVN0KHUsYSk7cmV0dXJuIGZsKHQsZSxzLGwsZCxuLGkpfWVsc2V7Y29uc3QgbD1UbyhyLGMpLGQ9emxbbF0scD1zLmRpcmVjdGlvbltkXT49MDtsZXQgbSxnO3A/KG09X3QociksZz16dChyLGMpKToobT16dChyLGMpLGc9X3QocikpO2NvbnN0IFQ9Y2UobSxvLHMsbixpKT9JaShtLHQsZSxzLG4saSk6bnVsbDtpZihUKXtjb25zdCBOPVQucG9pbnRbZF07aWYocD9OPD1vW2crbF06Tj49b1tnK2wrM10pcmV0dXJuIFR9Y29uc3QgTT1jZShnLG8scyxuLGkpP0lpKGcsdCxlLHMsbixpKTpudWxsO3JldHVybiBUJiZNP1QuZGlzdGFuY2U8PU0uZGlzdGFuY2U/VDpNOlR8fE18fG51bGx9fWNvbnN0IHBuPW5ldyBodCxxZT1uZXcgTHQsJGU9bmV3IEx0LEFzPW5ldyBudCx6bz1uZXcgbHQsbW49bmV3IGx0O2Z1bmN0aW9uIEVsKHIsdCxlLHMpe1guc2V0QnVmZmVyKHIuX3Jvb3RzW3RdKTtjb25zdCBuPXZpKDAscixlLHMpO3JldHVybiBYLmNsZWFyQnVmZmVyKCksbn1mdW5jdGlvbiB2aShyLHQsZSxzLG49bnVsbCl7Y29uc3R7ZmxvYXQzMkFycmF5OmksdWludDE2QXJyYXk6byx1aW50MzJBcnJheTphfT1YO2xldCBjPXIqMjtpZihuPT09bnVsbCYmKGUuYm91bmRpbmdCb3h8fGUuY29tcHV0ZUJvdW5kaW5nQm94KCksem8uc2V0KGUuYm91bmRpbmdCb3gubWluLGUuYm91bmRpbmdCb3gubWF4LHMpLG49em8pLHB0KGMsbykpe2NvbnN0IGg9dC5nZW9tZXRyeSxsPWguaW5kZXgsZD1oLmF0dHJpYnV0ZXMucG9zaXRpb24sZj1lLmluZGV4LHA9ZS5hdHRyaWJ1dGVzLnBvc2l0aW9uLG09VHQocixhKSxnPVN0KGMsbyk7aWYoQXMuY29weShzKS5pbnZlcnQoKSxlLmJvdW5kc1RyZWUpcmV0dXJuIFoocixpLG1uKSxtbi5tYXRyaXguY29weShBcyksbW4ubmVlZHNVcGRhdGU9ITAsZS5ib3VuZHNUcmVlLnNoYXBlY2FzdCh7aW50ZXJzZWN0c0JvdW5kczpUPT5tbi5pbnRlcnNlY3RzQm94KFQpLGludGVyc2VjdHNUcmlhbmdsZTpUPT57VC5hLmFwcGx5TWF0cml4NChzKSxULmIuYXBwbHlNYXRyaXg0KHMpLFQuYy5hcHBseU1hdHJpeDQocyksVC5uZWVkc1VwZGF0ZT0hMDtmb3IobGV0IHc9bSxNPWcrbTt3PE07dysrKWlmKHN0KCRlLDMqdC5yZXNvbHZlVHJpYW5nbGVJbmRleCh3KSxsLGQpLCRlLm5lZWRzVXBkYXRlPSEwLFQuaW50ZXJzZWN0c1RyaWFuZ2xlKCRlKSlyZXR1cm4hMDtyZXR1cm4hMX19KTtmb3IobGV0IHk9bSxUPWcrbTt5PFQ7eSsrKXtjb25zdCB3PXQucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoeSk7c3QocWUsMyp3LGwsZCkscWUuYS5hcHBseU1hdHJpeDQoQXMpLHFlLmIuYXBwbHlNYXRyaXg0KEFzKSxxZS5jLmFwcGx5TWF0cml4NChBcykscWUubmVlZHNVcGRhdGU9ITA7Zm9yKGxldCBNPTAsTj1mLmNvdW50O008TjtNKz0zKWlmKHN0KCRlLE0sZixwKSwkZS5uZWVkc1VwZGF0ZT0hMCxxZS5pbnRlcnNlY3RzVHJpYW5nbGUoJGUpKXJldHVybiEwfX1lbHNle2NvbnN0IGg9cis4LGw9YVtyKzZdO3JldHVybiBaKGgsaSxwbiksISEobi5pbnRlcnNlY3RzQm94KHBuKSYmdmkoaCx0LGUscyxuKXx8KFoobCxpLHBuKSxuLmludGVyc2VjdHNCb3gocG4pJiZ2aShsLHQsZSxzLG4pKSl9fWNvbnN0IHluPW5ldyBudCxQaT1uZXcgbHQsTXM9bmV3IGx0LENsPW5ldyBBLEZsPW5ldyBBLFJsPW5ldyBBLEJsPW5ldyBBO2Z1bmN0aW9uIElsKHIsdCxlLHM9e30sbj17fSxpPTAsbz0xLzApe3QuYm91bmRpbmdCb3h8fHQuY29tcHV0ZUJvdW5kaW5nQm94KCksUGkuc2V0KHQuYm91bmRpbmdCb3gubWluLHQuYm91bmRpbmdCb3gubWF4LGUpLFBpLm5lZWRzVXBkYXRlPSEwO2NvbnN0IGE9ci5nZW9tZXRyeSxjPWEuYXR0cmlidXRlcy5wb3NpdGlvbix1PWEuaW5kZXgsaD10LmF0dHJpYnV0ZXMucG9zaXRpb24sbD10LmluZGV4LGQ9YnQuZ2V0UHJpbWl0aXZlKCksZj1idC5nZXRQcmltaXRpdmUoKTtsZXQgcD1DbCxtPUZsLGc9bnVsbCx5PW51bGw7biYmKGc9UmwseT1CbCk7bGV0IFQ9MS8wLHc9bnVsbCxNPW51bGw7cmV0dXJuIHluLmNvcHkoZSkuaW52ZXJ0KCksTXMubWF0cml4LmNvcHkoeW4pLHIuc2hhcGVjYXN0KHtib3VuZHNUcmF2ZXJzZU9yZGVyOk49PlBpLmRpc3RhbmNlVG9Cb3goTiksaW50ZXJzZWN0c0JvdW5kczooTixfLFMpPT5TPFQmJlM8bz8oXyYmKE1zLm1pbi5jb3B5KE4ubWluKSxNcy5tYXguY29weShOLm1heCksTXMubmVlZHNVcGRhdGU9ITApLCEwKTohMSxpbnRlcnNlY3RzUmFuZ2U6KE4sXyk9PntpZih0LmJvdW5kc1RyZWUpe2NvbnN0IFM9dC5ib3VuZHNUcmVlO3JldHVybiBTLnNoYXBlY2FzdCh7Ym91bmRzVHJhdmVyc2VPcmRlcjpFPT5Ncy5kaXN0YW5jZVRvQm94KEUpLGludGVyc2VjdHNCb3VuZHM6KEUsRixSKT0+UjxUJiZSPG8saW50ZXJzZWN0c1JhbmdlOihFLEYpPT57Zm9yKGxldCBSPUUsST1FK0Y7UjxJO1IrKyl7Y29uc3QgQj1TLnJlc29sdmVUcmlhbmdsZUluZGV4KFIpO3N0KGYsMypCLGwsaCksZi5hLmFwcGx5TWF0cml4NChlKSxmLmIuYXBwbHlNYXRyaXg0KGUpLGYuYy5hcHBseU1hdHJpeDQoZSksZi5uZWVkc1VwZGF0ZT0hMDtmb3IobGV0IFA9TixMPU4rXztQPEw7UCsrKXtjb25zdCBWPXIucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoUCk7c3QoZCwzKlYsdSxjKSxkLm5lZWRzVXBkYXRlPSEwO2NvbnN0IEc9ZC5kaXN0YW5jZVRvVHJpYW5nbGUoZixwLGcpO2lmKEc8VCYmKG0uY29weShwKSx5JiZ5LmNvcHkoZyksVD1HLHc9UCxNPVIpLEc8aSlyZXR1cm4hMH19fX0pfWVsc2V7Y29uc3QgUz1EZSh0KTtmb3IobGV0IEU9MCxGPVM7RTxGO0UrKyl7c3QoZiwzKkUsbCxoKSxmLmEuYXBwbHlNYXRyaXg0KGUpLGYuYi5hcHBseU1hdHJpeDQoZSksZi5jLmFwcGx5TWF0cml4NChlKSxmLm5lZWRzVXBkYXRlPSEwO2ZvcihsZXQgUj1OLEk9TitfO1I8STtSKyspe2NvbnN0IEI9ci5yZXNvbHZlVHJpYW5nbGVJbmRleChSKTtzdChkLDMqQix1LGMpLGQubmVlZHNVcGRhdGU9ITA7Y29uc3QgUD1kLmRpc3RhbmNlVG9UcmlhbmdsZShmLHAsZyk7aWYoUDxUJiYobS5jb3B5KHApLHkmJnkuY29weShnKSxUPVAsdz1SLE09RSksUDxpKXJldHVybiEwfX19fX0pLGJ0LnJlbGVhc2VQcmltaXRpdmUoZCksYnQucmVsZWFzZVByaW1pdGl2ZShmKSxUPT09MS8wP251bGw6KHMucG9pbnQ/cy5wb2ludC5jb3B5KG0pOnMucG9pbnQ9bS5jbG9uZSgpLHMuZGlzdGFuY2U9VCxzLmZhY2VJbmRleD13LG4mJihuLnBvaW50P24ucG9pbnQuY29weSh5KTpuLnBvaW50PXkuY2xvbmUoKSxuLnBvaW50LmFwcGx5TWF0cml4NCh5biksbS5hcHBseU1hdHJpeDQoeW4pLG4uZGlzdGFuY2U9bS5zdWIobi5wb2ludCkubGVuZ3RoKCksbi5mYWNlSW5kZXg9TSkscyl9ZnVuY3Rpb24gdmwoKXtyZXR1cm4gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPCJ1In1jb25zdCBTcz1uZXcgWC5jb25zdHJ1Y3Rvcixnbj1uZXcgWC5jb25zdHJ1Y3RvcixoZT1uZXcgX2koKCk9Pm5ldyBodCksR2U9bmV3IGh0LFdlPW5ldyBodCxMaT1uZXcgaHQsT2k9bmV3IGh0O2xldCBEaT0hMTtmdW5jdGlvbiBQbChyLHQsZSxzKXtpZihEaSl0aHJvdyBuZXcgRXJyb3IoIk1lc2hCVkg6IFJlY3Vyc2l2ZSBjYWxscyB0byBidmhjYXN0IG5vdCBzdXBwb3J0ZWQuIik7RGk9ITA7Y29uc3Qgbj1yLl9yb290cyxpPXQuX3Jvb3RzO2xldCBvLGE9MCxjPTA7Y29uc3QgdT1uZXcgbnQoKS5jb3B5KGUpLmludmVydCgpO2ZvcihsZXQgaD0wLGw9bi5sZW5ndGg7aDxsO2grKyl7U3Muc2V0QnVmZmVyKG5baF0pLGM9MDtjb25zdCBkPWhlLmdldFByaW1pdGl2ZSgpO1ooMCxTcy5mbG9hdDMyQXJyYXksZCksZC5hcHBseU1hdHJpeDQodSk7Zm9yKGxldCBmPTAscD1pLmxlbmd0aDtmPHAmJihnbi5zZXRCdWZmZXIoaVtmXSksbz1PdCgwLDAsZSx1LHMsYSxjLDAsMCxkKSxnbi5jbGVhckJ1ZmZlcigpLGMrPWlbZl0ubGVuZ3RoLCFvKTtmKyspO2lmKGhlLnJlbGVhc2VQcmltaXRpdmUoZCksU3MuY2xlYXJCdWZmZXIoKSxhKz1uW2hdLmxlbmd0aCxvKWJyZWFrfXJldHVybiBEaT0hMSxvfWZ1bmN0aW9uIE90KHIsdCxlLHMsbixpPTAsbz0wLGE9MCxjPTAsdT1udWxsLGg9ITEpe2xldCBsLGQ7aD8obD1nbixkPVNzKToobD1TcyxkPWduKTtjb25zdCBmPWwuZmxvYXQzMkFycmF5LHA9bC51aW50MzJBcnJheSxtPWwudWludDE2QXJyYXksZz1kLmZsb2F0MzJBcnJheSx5PWQudWludDMyQXJyYXksVD1kLnVpbnQxNkFycmF5LHc9cioyLE09dCoyLE49cHQodyxtKSxfPXB0KE0sVCk7bGV0IFM9ITE7aWYoXyYmTiloP1M9bihUdCh0LHkpLFN0KHQqMixUKSxUdChyLHApLFN0KHIqMixtKSxjLG8rdCxhLGkrcik6Uz1uKFR0KHIscCksU3QocioyLG0pLFR0KHQseSksU3QodCoyLFQpLGEsaStyLGMsbyt0KTtlbHNlIGlmKF8pe2NvbnN0IEU9aGUuZ2V0UHJpbWl0aXZlKCk7Wih0LGcsRSksRS5hcHBseU1hdHJpeDQoZSk7Y29uc3QgRj1fdChyKSxSPXp0KHIscCk7WihGLGYsR2UpLFooUixmLFdlKTtjb25zdCBJPUUuaW50ZXJzZWN0c0JveChHZSksQj1FLmludGVyc2VjdHNCb3goV2UpO1M9SSYmT3QodCxGLHMsZSxuLG8saSxjLGErMSxFLCFoKXx8QiYmT3QodCxSLHMsZSxuLG8saSxjLGErMSxFLCFoKSxoZS5yZWxlYXNlUHJpbWl0aXZlKEUpfWVsc2V7Y29uc3QgRT1fdCh0KSxGPXp0KHQseSk7WihFLGcsTGkpLFooRixnLE9pKTtjb25zdCBSPXUuaW50ZXJzZWN0c0JveChMaSksST11LmludGVyc2VjdHNCb3goT2kpO2lmKFImJkkpUz1PdChyLEUsZSxzLG4saSxvLGEsYysxLHUsaCl8fE90KHIsRixlLHMsbixpLG8sYSxjKzEsdSxoKTtlbHNlIGlmKFIpaWYoTilTPU90KHIsRSxlLHMsbixpLG8sYSxjKzEsdSxoKTtlbHNle2NvbnN0IEI9aGUuZ2V0UHJpbWl0aXZlKCk7Qi5jb3B5KExpKS5hcHBseU1hdHJpeDQoZSk7Y29uc3QgUD1fdChyKSxMPXp0KHIscCk7WihQLGYsR2UpLFooTCxmLFdlKTtjb25zdCBWPUIuaW50ZXJzZWN0c0JveChHZSksRz1CLmludGVyc2VjdHNCb3goV2UpO1M9ViYmT3QoRSxQLHMsZSxuLG8saSxjLGErMSxCLCFoKXx8RyYmT3QoRSxMLHMsZSxuLG8saSxjLGErMSxCLCFoKSxoZS5yZWxlYXNlUHJpbWl0aXZlKEIpfWVsc2UgaWYoSSlpZihOKVM9T3QocixGLGUscyxuLGksbyxhLGMrMSx1LGgpO2Vsc2V7Y29uc3QgQj1oZS5nZXRQcmltaXRpdmUoKTtCLmNvcHkoT2kpLmFwcGx5TWF0cml4NChlKTtjb25zdCBQPV90KHIpLEw9enQocixwKTtaKFAsZixHZSksWihMLGYsV2UpO2NvbnN0IFY9Qi5pbnRlcnNlY3RzQm94KEdlKSxHPUIuaW50ZXJzZWN0c0JveChXZSk7Uz1WJiZPdChGLFAscyxlLG4sbyxpLGMsYSsxLEIsIWgpfHxHJiZPdChGLEwscyxlLG4sbyxpLGMsYSsxLEIsIWgpLGhlLnJlbGVhc2VQcmltaXRpdmUoQil9fXJldHVybiBTfWNvbnN0IHhuPW5ldyBsdCxibz1uZXcgaHQsTGw9e3N0cmF0ZWd5OnVvLG1heERlcHRoOjQwLG1heExlYWZUcmlzOjEwLHVzZVNoYXJlZEFycmF5QnVmZmVyOiExLHNldEJvdW5kaW5nQm94OiEwLG9uUHJvZ3Jlc3M6bnVsbCxpbmRpcmVjdDohMSx2ZXJib3NlOiEwLHJhbmdlOm51bGx9O2NsYXNzIFRue3N0YXRpYyBzZXJpYWxpemUodCxlPXt9KXtlPXtjbG9uZUJ1ZmZlcnM6ITAsLi4uZX07Y29uc3Qgcz10Lmdlb21ldHJ5LG49dC5fcm9vdHMsaT10Ll9pbmRpcmVjdEJ1ZmZlcixvPXMuZ2V0SW5kZXgoKTtsZXQgYTtyZXR1cm4gZS5jbG9uZUJ1ZmZlcnM/YT17cm9vdHM6bi5tYXAoYz0+Yy5zbGljZSgpKSxpbmRleDpvP28uYXJyYXkuc2xpY2UoKTpudWxsLGluZGlyZWN0QnVmZmVyOmk/aS5zbGljZSgpOm51bGx9OmE9e3Jvb3RzOm4saW5kZXg6bz9vLmFycmF5Om51bGwsaW5kaXJlY3RCdWZmZXI6aX0sYX1zdGF0aWMgZGVzZXJpYWxpemUodCxlLHM9e30pe3M9e3NldEluZGV4OiEwLGluZGlyZWN0OiEhdC5pbmRpcmVjdEJ1ZmZlciwuLi5zfTtjb25zdHtpbmRleDpuLHJvb3RzOmksaW5kaXJlY3RCdWZmZXI6b309dCxhPW5ldyBUbihlLHsuLi5zLFt4aV06ITB9KTtpZihhLl9yb290cz1pLGEuX2luZGlyZWN0QnVmZmVyPW98fG51bGwscy5zZXRJbmRleCl7Y29uc3QgYz1lLmdldEluZGV4KCk7aWYoYz09PW51bGwpe2NvbnN0IHU9bmV3IHZ0KHQuaW5kZXgsMSwhMSk7ZS5zZXRJbmRleCh1KX1lbHNlIGMuYXJyYXkhPT1uJiYoYy5hcnJheS5zZXQobiksYy5uZWVkc1VwZGF0ZT0hMCl9cmV0dXJuIGF9Z2V0IGluZGlyZWN0KCl7cmV0dXJuISF0aGlzLl9pbmRpcmVjdEJ1ZmZlcn1jb25zdHJ1Y3Rvcih0LGU9e30pe2lmKHQuaXNCdWZmZXJHZW9tZXRyeSl7aWYodC5pbmRleCYmdC5pbmRleC5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKXRocm93IG5ldyBFcnJvcigiTWVzaEJWSDogSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIGluZGV4IGF0dHJpYnV0ZS4iKX1lbHNlIHRocm93IG5ldyBFcnJvcigiTWVzaEJWSDogT25seSBCdWZmZXJHZW9tZXRyaWVzIGFyZSBzdXBwb3J0ZWQuIik7aWYoZT1PYmplY3QuYXNzaWduKHsuLi5MbCxbeGldOiExfSxlKSxlLnVzZVNoYXJlZEFycmF5QnVmZmVyJiYhdmwoKSl0aHJvdyBuZXcgRXJyb3IoIk1lc2hCVkg6IFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUuIik7dGhpcy5nZW9tZXRyeT10LHRoaXMuX3Jvb3RzPW51bGwsdGhpcy5faW5kaXJlY3RCdWZmZXI9bnVsbCxlW3hpXXx8KGp1KHRoaXMsZSksIXQuYm91bmRpbmdCb3gmJmUuc2V0Qm91bmRpbmdCb3gmJih0LmJvdW5kaW5nQm94PXRoaXMuZ2V0Qm91bmRpbmdCb3gobmV3IGh0KSkpLHRoaXMucmVzb2x2ZVRyaWFuZ2xlSW5kZXg9ZS5pbmRpcmVjdD9zPT50aGlzLl9pbmRpcmVjdEJ1ZmZlcltzXTpzPT5zfXJlZml0KHQ9bnVsbCl7cmV0dXJuKHRoaXMuaW5kaXJlY3Q/U2w6bGwpKHRoaXMsdCl9dHJhdmVyc2UodCxlPTApe2NvbnN0IHM9dGhpcy5fcm9vdHNbZV0sbj1uZXcgVWludDMyQXJyYXkocyksaT1uZXcgVWludDE2QXJyYXkocyk7bygwKTtmdW5jdGlvbiBvKGEsYz0wKXtjb25zdCB1PWEqMixoPWlbdSsxNV09PT1lbjtpZihoKXtjb25zdCBsPW5bYSs2XSxkPWlbdSsxNF07dChjLGgsbmV3IEZsb2F0MzJBcnJheShzLGEqNCw2KSxsLGQpfWVsc2V7Y29uc3QgbD1hK21zLzQsZD1uW2ErNl0sZj1uW2ErN107dChjLGgsbmV3IEZsb2F0MzJBcnJheShzLGEqNCw2KSxmKXx8KG8obCxjKzEpLG8oZCxjKzEpKX19fXJheWNhc3QodCxlPVZpLHM9MCxuPTEvMCl7Y29uc3QgaT10aGlzLl9yb290cyxvPXRoaXMuZ2VvbWV0cnksYT1bXSxjPWUuaXNNYXRlcmlhbCx1PUFycmF5LmlzQXJyYXkoZSksaD1vLmdyb3VwcyxsPWM/ZS5zaWRlOmUsZD10aGlzLmluZGlyZWN0P19sOm1sO2ZvcihsZXQgZj0wLHA9aS5sZW5ndGg7ZjxwO2YrKyl7Y29uc3QgbT11P2VbaFtmXS5tYXRlcmlhbEluZGV4XS5zaWRlOmwsZz1hLmxlbmd0aDtpZihkKHRoaXMsZixtLHQsYSxzLG4pLHUpe2NvbnN0IHk9aFtmXS5tYXRlcmlhbEluZGV4O2ZvcihsZXQgVD1nLHc9YS5sZW5ndGg7VDx3O1QrKylhW1RdLmZhY2UubWF0ZXJpYWxJbmRleD15fX1yZXR1cm4gYX1yYXljYXN0Rmlyc3QodCxlPVZpLHM9MCxuPTEvMCl7Y29uc3QgaT10aGlzLl9yb290cyxvPXRoaXMuZ2VvbWV0cnksYT1lLmlzTWF0ZXJpYWwsYz1BcnJheS5pc0FycmF5KGUpO2xldCB1PW51bGw7Y29uc3QgaD1vLmdyb3VwcyxsPWE/ZS5zaWRlOmUsZD10aGlzLmluZGlyZWN0P2JsOmdsO2ZvcihsZXQgZj0wLHA9aS5sZW5ndGg7ZjxwO2YrKyl7Y29uc3QgbT1jP2VbaFtmXS5tYXRlcmlhbEluZGV4XS5zaWRlOmwsZz1kKHRoaXMsZixtLHQscyxuKTtnIT1udWxsJiYodT09bnVsbHx8Zy5kaXN0YW5jZTx1LmRpc3RhbmNlKSYmKHU9ZyxjJiYoZy5mYWNlLm1hdGVyaWFsSW5kZXg9aFtmXS5tYXRlcmlhbEluZGV4KSl9cmV0dXJuIHV9aW50ZXJzZWN0c0dlb21ldHJ5KHQsZSl7bGV0IHM9ITE7Y29uc3Qgbj10aGlzLl9yb290cyxpPXRoaXMuaW5kaXJlY3Q/RWw6eGw7Zm9yKGxldCBvPTAsYT1uLmxlbmd0aDtvPGEmJihzPWkodGhpcyxvLHQsZSksIXMpO28rKyk7cmV0dXJuIHN9c2hhcGVjYXN0KHQpe2NvbnN0IGU9YnQuZ2V0UHJpbWl0aXZlKCkscz10aGlzLmluZGlyZWN0P3BsOnVsO2xldHtib3VuZHNUcmF2ZXJzZU9yZGVyOm4saW50ZXJzZWN0c0JvdW5kczppLGludGVyc2VjdHNSYW5nZTpvLGludGVyc2VjdHNUcmlhbmdsZTphfT10O2lmKG8mJmEpe2NvbnN0IGw9bztvPShkLGYscCxtLGcpPT5sKGQsZixwLG0sZyk/ITA6cyhkLGYsdGhpcyxhLHAsbSxlKX1lbHNlIG98fChhP289KGwsZCxmLHApPT5zKGwsZCx0aGlzLGEsZixwLGUpOm89KGwsZCxmKT0+Zik7bGV0IGM9ITEsdT0wO2NvbnN0IGg9dGhpcy5fcm9vdHM7Zm9yKGxldCBsPTAsZD1oLmxlbmd0aDtsPGQ7bCsrKXtjb25zdCBmPWhbbF07aWYoYz1ubCh0aGlzLGwsaSxvLG4sdSksYylicmVhazt1Kz1mLmJ5dGVMZW5ndGh9cmV0dXJuIGJ0LnJlbGVhc2VQcmltaXRpdmUoZSksY31idmhjYXN0KHQsZSxzKXtsZXR7aW50ZXJzZWN0c1JhbmdlczpuLGludGVyc2VjdHNUcmlhbmdsZXM6aX09cztjb25zdCBvPWJ0LmdldFByaW1pdGl2ZSgpLGE9dGhpcy5nZW9tZXRyeS5pbmRleCxjPXRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbix1PXRoaXMuaW5kaXJlY3Q/cD0+e2NvbnN0IG09dGhpcy5yZXNvbHZlVHJpYW5nbGVJbmRleChwKTtzdChvLG0qMyxhLGMpfTpwPT57c3QobyxwKjMsYSxjKX0saD1idC5nZXRQcmltaXRpdmUoKSxsPXQuZ2VvbWV0cnkuaW5kZXgsZD10Lmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24sZj10LmluZGlyZWN0P3A9Pntjb25zdCBtPXQucmVzb2x2ZVRyaWFuZ2xlSW5kZXgocCk7c3QoaCxtKjMsbCxkKX06cD0+e3N0KGgscCozLGwsZCl9O2lmKGkpe2NvbnN0IHA9KG0sZyx5LFQsdyxNLE4sXyk9Pntmb3IobGV0IFM9eSxFPXkrVDtTPEU7UysrKXtmKFMpLGguYS5hcHBseU1hdHJpeDQoZSksaC5iLmFwcGx5TWF0cml4NChlKSxoLmMuYXBwbHlNYXRyaXg0KGUpLGgubmVlZHNVcGRhdGU9ITA7Zm9yKGxldCBGPW0sUj1tK2c7RjxSO0YrKylpZih1KEYpLG8ubmVlZHNVcGRhdGU9ITAsaShvLGgsRixTLHcsTSxOLF8pKXJldHVybiEwfXJldHVybiExfTtpZihuKXtjb25zdCBtPW47bj1mdW5jdGlvbihnLHksVCx3LE0sTixfLFMpe3JldHVybiBtKGcseSxULHcsTSxOLF8sUyk/ITA6cChnLHksVCx3LE0sTixfLFMpfX1lbHNlIG49cH1yZXR1cm4gUGwodGhpcyx0LGUsbil9aW50ZXJzZWN0c0JveCh0LGUpe3JldHVybiB4bi5zZXQodC5taW4sdC5tYXgsZSkseG4ubmVlZHNVcGRhdGU9ITAsdGhpcy5zaGFwZWNhc3Qoe2ludGVyc2VjdHNCb3VuZHM6cz0+eG4uaW50ZXJzZWN0c0JveChzKSxpbnRlcnNlY3RzVHJpYW5nbGU6cz0+eG4uaW50ZXJzZWN0c1RyaWFuZ2xlKHMpfSl9aW50ZXJzZWN0c1NwaGVyZSh0KXtyZXR1cm4gdGhpcy5zaGFwZWNhc3Qoe2ludGVyc2VjdHNCb3VuZHM6ZT0+dC5pbnRlcnNlY3RzQm94KGUpLGludGVyc2VjdHNUcmlhbmdsZTplPT5lLmludGVyc2VjdHNTcGhlcmUodCl9KX1jbG9zZXN0UG9pbnRUb0dlb21ldHJ5KHQsZSxzPXt9LG49e30saT0wLG89MS8wKXtyZXR1cm4odGhpcy5pbmRpcmVjdD9JbDpNbCkodGhpcyx0LGUscyxuLGksbyl9Y2xvc2VzdFBvaW50VG9Qb2ludCh0LGU9e30scz0wLG49MS8wKXtyZXR1cm4gaWwodGhpcyx0LGUscyxuKX1nZXRCb3VuZGluZ0JveCh0KXtyZXR1cm4gdC5tYWtlRW1wdHkoKSx0aGlzLl9yb290cy5mb3JFYWNoKHM9PntaKDAsbmV3IEZsb2F0MzJBcnJheShzKSxibyksdC51bmlvbihibyl9KSx0fX1vbm1lc3NhZ2U9KHtkYXRhOnJ9KT0+e2xldCB0PXBlcmZvcm1hbmNlLm5vdygpO2Z1bmN0aW9uIGUobyl7bz1NYXRoLm1pbihvLDEpO2NvbnN0IGE9cGVyZm9ybWFuY2Uubm93KCk7YS10Pj0xMCYmbyE9PTEmJihwb3N0TWVzc2FnZSh7ZXJyb3I6bnVsbCxzZXJpYWxpemVkOm51bGwscG9zaXRpb246bnVsbCxwcm9ncmVzczpvfSksdD1hKX1jb25zdHtpbmRleDpzLHBvc2l0aW9uOm4sb3B0aW9uczppfT1yO3RyeXtjb25zdCBvPW5ldyBHbjtpZihvLnNldEF0dHJpYnV0ZSgicG9zaXRpb24iLG5ldyB2dChuLDMsITEpKSxzJiZvLnNldEluZGV4KG5ldyB2dChzLDEsITEpKSxpLmluY2x1ZGVkUHJvZ3Jlc3NDYWxsYmFjayYmKGkub25Qcm9ncmVzcz1lKSxpLmdyb3Vwcyl7Y29uc3QgaD1pLmdyb3Vwcztmb3IoY29uc3QgbCBpbiBoKXtjb25zdCBkPWhbbF07by5hZGRHcm91cChkLnN0YXJ0LGQuY291bnQsZC5tYXRlcmlhbEluZGV4KX19Y29uc3QgYT1uZXcgVG4obyxpKSxjPVRuLnNlcmlhbGl6ZShhLHtjb3B5SW5kZXhCdWZmZXI6ITF9KTtsZXQgdT1bbi5idWZmZXIsLi4uYy5yb290c107Yy5pbmRleCYmdS5wdXNoKGMuaW5kZXguYnVmZmVyKSx1PXUuZmlsdGVyKGg9PnR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj4idSJ8fCEoaCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSksYS5faW5kaXJlY3RCdWZmZXImJnUucHVzaChjLmluZGlyZWN0QnVmZmVyLmJ1ZmZlcikscG9zdE1lc3NhZ2Uoe2Vycm9yOm51bGwsc2VyaWFsaXplZDpjLHBvc2l0aW9uOm4scHJvZ3Jlc3M6MX0sdSl9Y2F0Y2gobyl7cG9zdE1lc3NhZ2Uoe2Vycm9yOm8sc2VyaWFsaXplZDpudWxsLHBvc2l0aW9uOm51bGwscHJvZ3Jlc3M6MX0pfX19KSgpOwo=", jr = typeof window < "u" && window.Blob && new Blob([atob(Xc)], { type: "text/javascript;charset=utf-8" });
function wu() {
  let s;
  try {
    if (s = jr && (window.URL || window.webkitURL).createObjectURL(jr), !s)
      throw "";
    return new Worker(s);
  } catch {
    return new Worker("data:application/javascript;base64," + Xc);
  } finally {
    s && (window.URL || window.webkitURL).revokeObjectURL(s);
  }
}
export {
  Va as $70d766613f57b014$export$2e2bcd8739ae039,
  Ju as BatchedParticleRenderer,
  el as Builder,
  on as ByteBuffer,
  ci as ConstantColor,
  Q as ConstantValue,
  $t as Matrix4,
  Ee as MeshBVH,
  ku as MotionController,
  ho as ParticleSystem,
  K as RenderMode,
  Uc as SIZE_PREFIX_LENGTH,
  ao as TrailParticle,
  Tt as Vector4,
  Qu as WorkerBase,
  wu as WorkerWrapper,
  Hu as bundler,
  Uu as createNoise4D,
  Yu as fetchProfile,
  Pu as index,
  Fu as index$1,
  Iu as md5,
  Nu as v5
};
