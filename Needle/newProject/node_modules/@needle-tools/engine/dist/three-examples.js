import { Mesh as z, SphereGeometry as ci, Vector3 as P, MeshBasicMaterial as Qt, Node as ra, PerspectiveCamera as ds, NodeFrame as aa, ShaderLib as wt, NodeBuilder as Aa, GLSLNodeParser as ca, UniformsUtils as li, UniformsLib as Un, normalView as la, defaultShaderStages as Kn, ShaderChunk as ha, Material as tn, TrianglesDrawMode as ua, TriangleFanDrawMode as Js, TriangleStripDrawMode as So, Matrix4 as ue, Loader as Nt, LoaderUtils as nn, FileLoader as ft, Color as Se, LinearSRGBColorSpace as We, SpotLight as To, PointLight as Vs, DirectionalLight as vo, SRGBColorSpace as ge, MeshPhysicalMaterial as vt, Vector2 as Le, InstancedMesh as ga, InstancedBufferAttribute as da, Object3D as xt, TextureLoader as hi, ImageBitmapLoader as pa, BufferAttribute as nt, InterleavedBuffer as fa, LinearFilter as mt, LinearMipmapLinearFilter as ps, RepeatWrapping as rn, PointsMaterial as Dn, LineBasicMaterial as Lt, MeshStandardMaterial as ui, DoubleSide as gi, PropertyBinding as It, BufferGeometry as ut, SkinnedMesh as di, LineSegments as As, Line as dt, LineLoop as ma, Points as is, Group as sn, MathUtils as ye, OrthographicCamera as Ro, Skeleton as _o, AnimationClip as pi, Bone as Ws, InterpolateLinear as jn, ColorManagement as Ve, Quaternion as Te, NearestFilter as Do, NearestMipmapNearestFilter as Mo, LinearMipmapNearestFilter as ko, NearestMipmapLinearFilter as Fo, ClampToEdgeWrapping as cs, MirroredRepeatWrapping as Lo, InterpolateDiscrete as fi, FrontSide as No, InterleavedBufferAttribute as en, Texture as Xs, VectorKeyframeTrack as ls, NumberKeyframeTrack as hs, QuaternionKeyframeTrack as us, Box3 as fs, Sphere as mi, Interpolant as Ia, CompressedCubeTexture as ba, UnsignedByteType as pt, CompressedArrayTexture as Ea, CompressedTexture as Gn, RGBAFormat as Kt, RGBA_ASTC_4x4_Format as Uo, RGBA_BPTC_Format as Ca, RGBA_ETC2_EAC_Format as Ba, RGBA_PVRTC_4BPPV1_Format as wa, RGBA_S3TC_DXT5_Format as ya, RGB_ETC1_Format as Qa, RGB_ETC2_Format as xa, RGB_PVRTC_4BPPV1_Format as Sa, RGBA_S3TC_DXT1_Format as Ta, FloatType as St, HalfFloatType as st, DataTexture as va, Data3DTexture as Ra, DisplayP3ColorSpace as _a, LinearDisplayP3ColorSpace as Da, NoColorSpace as gs, RGFormat as Mn, RedFormat as dn, RGBA_ASTC_6x6_Format as Ri, ExtrudeGeometry as Ma, ShapePath as ka, Raycaster as Ii, Euler as zt, CylinderGeometry as Ke, BoxGeometry as je, Float32BufferAttribute as ke, OctahedronGeometry as Yn, TorusGeometry as Cn, Controls as Go, PlaneGeometry as bi, DataTextureLoader as Po, DataUtils as pn, Vector4 as Ut, Curve as Fa, MeshPhongMaterial as Pn, MeshLambertMaterial as La, EquirectangularReflectionMapping as Na, AmbientLight as Ua, Uint16BufferAttribute as Ga, Matrix3 as Oo, ShapeUtils as Pa, DefaultLoadingManager as Oa, Ray as Ha, Plane as ja, MOUSE as mn, TOUCH as fn, Spherical as _i, ShaderMaterial as Ho, Uniform$1 as qa, Scene as Zs, WebGLRenderer as za, CanvasTexture as jo, REVISION as Ka, Source as Ya, InstancedBufferGeometry as Ja, InstancedInterleavedBuffer as $s, WireframeGeometry as Va, Line3 as Wa, ColorKeyframeTrack as Xa } from "./three.js";
class th extends z {
  constructor(e, t, s, n = 128) {
    if (t <= 0 || s <= 0 || n <= 0)
      throw new Error("GroundedSkybox height, radius, and resolution must be positive.");
    const i = new ci(s, 2 * n, n);
    i.scale(1, 1, -1);
    const o = i.getAttribute("position"), r = new P();
    for (let a = 0; a < o.count; ++a)
      if (r.fromBufferAttribute(o, a), r.y < 0) {
        const c = -t * 3 / 2, l = r.y < c ? -t / r.y : 1 - r.y * r.y / (3 * c * c);
        r.multiplyScalar(l), r.toArray(o.array, 3 * a);
      }
    o.needsUpdate = !0, super(i, new Qt({ map: e, depthWrite: !1 }));
  }
}
class Za extends ra {
  constructor(e) {
    super(e.nodeType), this.node = null, this.source = null, this.target = null, this.inclusionType = "replace", Object.assign(this, e);
  }
  generate(e) {
    return this.node.build(e, this.getNodeType(e));
  }
}
const Ce = Za, tt = new aa();
tt.camera = new ds();
const Di = {
  LineBasicNodeMaterial: wt.basic,
  MeshBasicNodeMaterial: wt.basic,
  PointsNodeMaterial: wt.points,
  MeshStandardNodeMaterial: wt.standard,
  MeshPhysicalNodeMaterial: wt.physical,
  MeshPhongNodeMaterial: wt.phong
}, $a = {
  atan2: "atan"
}, eA = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
function Ot(A) {
  return `#include <${A}>`;
}
function Bn(A) {
  return `${A}Shader`;
}
class tA extends Aa {
  constructor(e, t, s, n = null) {
    super(e, t, new ca(), null, n), this.shader = s, this.slots = { vertex: [], fragment: [] }, this._parseShaderLib(), this._parseInclude("fragment", "lights_physical_fragment", "clearcoat_normal_fragment_begin", "transmission_fragment"), this._parseObject(), this._sortSlotsToFlow(), this.useComparisonMethod = !0;
  }
  getMethod(e) {
    return $a[e] || e;
  }
  addSlot(e, t) {
    this.slots[e].push(t);
  }
  _parseShaderLib() {
    const e = this.material;
    let t = e.type;
    if (e.isMeshPhysicalNodeMaterial ? t = "MeshPhysicalNodeMaterial" : e.isMeshStandardNodeMaterial ? t = "MeshStandardNodeMaterial" : e.isMeshPhongNodeMaterial ? t = "MeshPhongNodeMaterial" : e.isMeshBasicNodeMaterial ? t = "MeshBasicNodeMaterial" : e.isPointsNodeMaterial ? t = "PointsNodeMaterial" : e.isLineBasicNodeMaterial && (t = "LineBasicNodeMaterial"), Di[t] !== void 0) {
      const s = Di[t], n = this.shader;
      n.vertexShader = s.vertexShader, n.fragmentShader = s.fragmentShader, n.uniforms = li.merge([s.uniforms, Un.lights]);
    }
  }
  _parseObject() {
    const { material: e, renderer: t } = this;
    this.addSlot("fragment", new Ce({
      node: la,
      nodeType: "vec3",
      source: "void main() {",
      target: "vec3 TransformedNormalView = %RESULT%;",
      inclusionType: "append"
    })), t.toneMappingNode && t.toneMappingNode.isNode === !0 && this.addSlot("fragment", new Ce({
      node: e.colorNode,
      nodeType: "vec4",
      source: Ot("tonemapping_fragment"),
      target: ""
    })), e.colorNode && e.colorNode.isNode && this.addSlot("fragment", new Ce({
      node: e.colorNode,
      nodeType: "vec4",
      source: "vec4 diffuseColor = vec4( diffuse, opacity );",
      target: "vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;"
    })), e.opacityNode && e.opacityNode.isNode && this.addSlot("fragment", new Ce({
      node: e.opacityNode,
      nodeType: "float",
      source: Ot("alphatest_fragment"),
      target: "diffuseColor.a = %RESULT%;",
      inclusionType: "append"
    })), e.normalNode && e.normalNode.isNode && this.addSlot("fragment", new Ce({
      node: e.normalNode,
      nodeType: "vec3",
      source: Ot("normal_fragment_begin"),
      target: "normal = %RESULT%;",
      inclusionType: "append"
    })), e.emissiveNode && e.emissiveNode.isNode && this.addSlot("fragment", new Ce({
      node: e.emissiveNode,
      nodeType: "vec3",
      source: Ot("emissivemap_fragment"),
      target: "totalEmissiveRadiance = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshStandardNodeMaterial && (e.metalnessNode && e.metalnessNode.isNode && this.addSlot("fragment", new Ce({
      node: e.metalnessNode,
      nodeType: "float",
      source: Ot("metalnessmap_fragment"),
      target: "metalnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.roughnessNode && e.roughnessNode.isNode && this.addSlot("fragment", new Ce({
      node: e.roughnessNode,
      nodeType: "float",
      source: Ot("roughnessmap_fragment"),
      target: "roughnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshPhysicalNodeMaterial && (e.clearcoatNode && e.clearcoatNode.isNode ? (this.addSlot("fragment", new Ce({
      node: e.clearcoatNode,
      nodeType: "float",
      source: "material.clearcoat = clearcoat;",
      target: "material.clearcoat = %RESULT%;"
    })), e.clearcoatRoughnessNode && e.clearcoatRoughnessNode.isNode && this.addSlot("fragment", new Ce({
      node: e.clearcoatRoughnessNode,
      nodeType: "float",
      source: "material.clearcoatRoughness = clearcoatRoughness;",
      target: "material.clearcoatRoughness = %RESULT%;"
    })), e.clearcoatNormalNode && e.clearcoatNormalNode.isNode && this.addSlot("fragment", new Ce({
      node: e.clearcoatNormalNode,
      nodeType: "vec3",
      source: "vec3 clearcoatNormal = nonPerturbedNormal;",
      target: "vec3 clearcoatNormal = %RESULT%;"
    })), e.defines.USE_CLEARCOAT = "") : delete e.defines.USE_CLEARCOAT, e.sheenNode && e.sheenNode.isNode ? (this.addSlot("fragment", new Ce({
      node: e.sheenNode,
      nodeType: "vec3",
      source: "material.sheenColor = sheenColor;",
      target: "material.sheenColor = %RESULT%;"
    })), e.sheenRoughnessNode && e.sheenRoughnessNode.isNode && this.addSlot("fragment", new Ce({
      node: e.sheenRoughnessNode,
      nodeType: "float",
      source: "material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",
      target: "material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"
    })), e.defines.USE_SHEEN = "") : delete e.defines.USE_SHEEN, e.iridescenceNode && e.iridescenceNode.isNode ? (this.addSlot("fragment", new Ce({
      node: e.iridescenceNode,
      nodeType: "float",
      source: "material.iridescence = iridescence;",
      target: "material.iridescence = %RESULT%;"
    })), e.iridescenceIORNode && e.iridescenceIORNode.isNode && this.addSlot("fragment", new Ce({
      node: e.iridescenceIORNode,
      nodeType: "float",
      source: "material.iridescenceIOR = iridescenceIOR;",
      target: "material.iridescenceIOR = %RESULT%;"
    })), e.iridescenceThicknessNode && e.iridescenceThicknessNode.isNode && this.addSlot("fragment", new Ce({
      node: e.iridescenceThicknessNode,
      nodeType: "float",
      source: "material.iridescenceThickness = iridescenceThicknessMaximum;",
      target: "material.iridescenceThickness = %RESULT%;"
    })), e.defines.USE_IRIDESCENCE = "") : delete e.defines.USE_IRIDESCENCE, e.iorNode && e.iorNode.isNode && this.addSlot("fragment", new Ce({
      node: e.iorNode,
      nodeType: "float",
      source: "material.ior = ior;",
      target: "material.ior = %RESULT%;"
    })), e.specularColorNode && e.specularColorNode.isNode && this.addSlot("fragment", new Ce({
      node: e.specularColorNode,
      nodeType: "vec3",
      source: "vec3 specularColorFactor = specularColor;",
      target: "vec3 specularColorFactor = %RESULT%;"
    })), e.specularIntensityNode && e.specularIntensityNode.isNode && this.addSlot("fragment", new Ce({
      node: e.specularIntensityNode,
      nodeType: "float",
      source: "float specularIntensityFactor = specularIntensity;",
      target: "float specularIntensityFactor = %RESULT%;"
    })), e.transmissionNode && e.transmissionNode.isNode ? (this.addSlot("fragment", new Ce({
      node: e.transmissionNode,
      nodeType: "float",
      source: "material.transmission = transmission;",
      target: "material.transmission = %RESULT%;"
    })), e.thicknessNode && e.thicknessNode.isNode && this.addSlot("fragment", new Ce({
      node: e.thicknessNode,
      nodeType: "float",
      source: "material.thickness = thickness;",
      target: "material.thickness = %RESULT%;"
    })), e.attenuationDistanceNode && e.attenuationDistanceNode.isNode && this.addSlot("fragment", new Ce({
      node: e.attenuationDistanceNode,
      nodeType: "float",
      source: "material.attenuationDistance = attenuationDistance;",
      target: "material.attenuationDistance = %RESULT%;"
    })), e.attenuationColorNode && e.attenuationColorNode.isNode && this.addSlot("fragment", new Ce({
      node: e.attenuationColorNode,
      nodeType: "vec3",
      source: "material.attenuationColor = attenuationColor;",
      target: "material.attenuationColor = %RESULT%;"
    })), e.transmission = 1, e.defines.USE_TRANSMISSION = "") : (e.transmission = 0, delete e.defines.USE_TRANSMISSION))), e.positionNode && e.positionNode.isNode && this.addSlot("vertex", new Ce({
      node: e.positionNode,
      nodeType: "vec3",
      source: Ot("begin_vertex"),
      target: "transformed = %RESULT%;",
      inclusionType: "append"
    })), e.sizeNode && e.sizeNode.isNode && this.addSlot("vertex", new Ce({
      node: e.sizeNode,
      nodeType: "float",
      source: "gl_PointSize = size;",
      target: "gl_PointSize = %RESULT%;"
    }));
  }
  generateTexture(e, t, s) {
    return e.isTextureCube ? `textureCube( ${t}, ${s} )` : `texture2D( ${t}, ${s} )`;
  }
  generateTextureLevel(e, t, s, n) {
    return `textureLod( ${t}, ${s}, ${n} )`;
  }
  buildFunctionCode(e) {
    const t = e.layout, s = this.flowShaderNode(e), n = [];
    for (const o of t.inputs)
      n.push(this.getType(o.type) + " " + o.name);
    return `${this.getType(t.type)} ${t.name}( ${n.join(", ")} ) {

	${s.vars}

${s.code}
	return ${s.result};

}`;
  }
  getUniforms(e) {
    const t = this.uniforms[e];
    let s = "";
    for (const n of t) {
      if (/^(modelViewMatrix|projectionMatrix)$/.test(n.name))
        continue;
      let i = null;
      n.type === "texture" ? i = `sampler2D ${n.name}; ` : n.type === "cubeTexture" ? i = `samplerCube ${n.name}; ` : i = `${this.getVectorType(n.type)} ${n.name}; `;
      const o = n.node.precision;
      o !== null ? i = "uniform " + eA[o] + " " + i : i = "uniform " + i, s += i;
    }
    return s;
  }
  getAttributes(e) {
    let t = "";
    if (e === "vertex") {
      const s = this.attributes;
      for (const n of s)
        /^(position|normal|uv[1-3]?)$/.test(n.name) || (t += `attribute ${n.type} ${n.name}; `);
    }
    return t;
  }
  getVaryings(e) {
    let t = "";
    const s = this.varyings;
    if (e === "vertex")
      for (const n of s)
        t += `${n.needsInterpolation ? "varying" : "/*varying*/"} ${n.type} ${n.name}; `;
    else if (e === "fragment")
      for (const n of s)
        n.needsInterpolation && (t += `varying ${n.type} ${n.name}; `);
    return t;
  }
  addCode(e, t, s, n = this) {
    const i = Bn(e);
    let o = n[i];
    const r = o.indexOf(t);
    if (r !== -1) {
      const a = o.substring(0, r + t.length), c = o.substring(r + t.length);
      o = `${a}
${s}
${c}`;
    }
    n[i] = o;
  }
  replaceCode(e, t, s, n = this) {
    const i = Bn(e);
    n[i] = n[i].replaceAll(t, s);
  }
  getVertexIndex() {
    return "gl_VertexID";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  isFlipY() {
    return !0;
  }
  buildCode() {
    const e = {};
    for (const t of Kn) {
      const s = this.getUniforms(t), n = this.getAttributes(t), i = this.getVaryings(t), o = this.getVars(t), r = this.getCodes(t);
      e[t] = `${this.getSignature()}
// <node_builder>

// uniforms
${s}

// attributes
${n}

// varyings
${i}

// vars
${o}

// codes
${r}

// </node_builder>

${this.shader[Bn(t)]}
`;
    }
    this.vertexShader = e.vertex, this.fragmentShader = e.fragment;
  }
  build() {
    return super.build(!1), this._addSnippets(), this._addUniforms(), this._updateUniforms(), this.shader.vertexShader = this.vertexShader, this.shader.fragmentShader = this.fragmentShader, this;
  }
  _parseInclude(e, ...t) {
    for (const s of t) {
      const n = Ot(s), i = ha[s], o = Bn(e);
      this.shader[o] = this.shader[o].replaceAll(n, i);
    }
  }
  _sortSlotsToFlow() {
    for (const e of Kn) {
      const t = this.shader[Bn(e)], s = this.slots[e].sort((n, i) => t.indexOf(n.source) > t.indexOf(i.source) ? 1 : -1);
      for (const n of s)
        this.addFlow(e, n);
    }
  }
  _addSnippets() {
    for (const e of Kn) {
      for (const t of this.slots[e]) {
        const s = this.getFlowData(
          t
          /*, shaderStage*/
        ), n = t.inclusionType, i = t.source, o = s.code + `
	` + t.target.replace("%RESULT%", s.result);
        n === "append" ? this.addCode(e, i, o) : n === "replace" ? this.replaceCode(e, i, o) : console.warn(`Inclusion type "${n}" not compatible.`);
      }
      this.addCode(
        e,
        "main() {",
        `
	` + this.flowCode[e]
      );
    }
  }
  _addUniforms() {
    for (const e of Kn)
      for (const t of this.uniforms[e])
        this.shader.uniforms[t.name] = t;
  }
  _updateUniforms() {
    tt.object = this.object, tt.renderer = this.renderer, tt.material = this.material, tt.scene = this.scene;
    for (const e of this.updateNodes)
      tt.updateNode(e);
  }
}
const qo = /* @__PURE__ */ new WeakMap();
tn.prototype.onBuild = function(A, e, t) {
  const s = this;
  if (s.isNodeMaterial === !0) {
    let n;
    try {
      n = new tA(A, t, e, s).build(), qo.set(s, n);
    } catch (i) {
      console.error("Material.prototype.onBuild: ", i);
    }
  }
};
tn.prototype.onBeforeRender = function(A, e, t, s, n) {
  const i = qo.get(this);
  if (i !== void 0) {
    tt.material = this, tt.camera = t, tt.object = n, tt.renderer = A, tt.scene = e, tt.geometry = s;
    const o = i.updateNodes;
    if (o.length > 0) {
      A.state.useProgram(null);
      for (const r of o)
        tt.updateNode(r);
    }
  }
};
var os = function() {
  var A = 0, e = document.createElement("div");
  e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function(l) {
    l.preventDefault(), s(++A % e.children.length);
  }, !1);
  function t(l) {
    return e.appendChild(l.dom), l;
  }
  function s(l) {
    for (var h = 0; h < e.children.length; h++)
      e.children[h].style.display = h === l ? "block" : "none";
    A = l;
  }
  var n = (performance || Date).now(), i = n, o = 0, r = t(new os.Panel("FPS", "#0ff", "#002")), a = t(new os.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory)
    var c = t(new os.Panel("MB", "#f08", "#201"));
  return s(0), {
    REVISION: 16,
    dom: e,
    addPanel: t,
    showPanel: s,
    begin: function() {
      n = (performance || Date).now();
    },
    end: function() {
      o++;
      var l = (performance || Date).now();
      if (a.update(l - n, 200), l >= i + 1e3 && (r.update(o * 1e3 / (l - i), 100), i = l, o = 0, c)) {
        var h = performance.memory;
        c.update(h.usedJSHeapSize / 1048576, h.jsHeapSizeLimit / 1048576);
      }
      return l;
    },
    update: function() {
      n = this.end();
    },
    // Backwards Compatibility
    domElement: e,
    setMode: s
  };
};
os.Panel = function(A, e, t) {
  var s = 1 / 0, n = 0, i = Math.round, o = i(window.devicePixelRatio || 1), r = 80 * o, a = 48 * o, c = 3 * o, l = 2 * o, h = 3 * o, g = 15 * o, d = 74 * o, p = 30 * o, m = document.createElement("canvas");
  m.width = r, m.height = a, m.style.cssText = "width:80px;height:48px";
  var I = m.getContext("2d");
  return I.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif", I.textBaseline = "top", I.fillStyle = t, I.fillRect(0, 0, r, a), I.fillStyle = e, I.fillText(A, c, l), I.fillRect(h, g, d, p), I.fillStyle = t, I.globalAlpha = 0.9, I.fillRect(h, g, d, p), {
    dom: m,
    update: function(b, B) {
      s = Math.min(s, b), n = Math.max(n, b), I.fillStyle = t, I.globalAlpha = 1, I.fillRect(0, 0, r, g), I.fillStyle = e, I.fillText(i(b) + " " + A + " (" + i(s) + "-" + i(n) + ")", c, l), I.drawImage(m, h + o, g, d - o, p, h, g, d - o, p), I.fillRect(h + d - o, g, o, p), I.fillStyle = t, I.globalAlpha = 0.9, I.fillRect(h + d - o, g, o, i((1 - b / B) * p));
    }
  };
};
function nh(A, e = 1e-4) {
  e = Math.max(e, Number.EPSILON);
  const t = {}, s = A.getIndex(), n = A.getAttribute("position"), i = s ? s.count : n.count;
  let o = 0;
  const r = Object.keys(A.attributes), a = {}, c = {}, l = [], h = ["getX", "getY", "getZ", "getW"], g = ["setX", "setY", "setZ", "setW"];
  for (let B = 0, E = r.length; B < E; B++) {
    const w = r[B], Q = A.attributes[w];
    a[w] = new Q.constructor(
      new Q.array.constructor(Q.count * Q.itemSize),
      Q.itemSize,
      Q.normalized
    );
    const R = A.morphAttributes[w];
    R && (c[w] || (c[w] = []), R.forEach((_, x) => {
      const T = new _.array.constructor(_.count * _.itemSize);
      c[w][x] = new _.constructor(T, _.itemSize, _.normalized);
    }));
  }
  const d = e * 0.5, p = Math.log10(1 / e), m = Math.pow(10, p), I = d * m;
  for (let B = 0; B < i; B++) {
    const E = s ? s.getX(B) : B;
    let w = "";
    for (let Q = 0, R = r.length; Q < R; Q++) {
      const _ = r[Q], x = A.getAttribute(_), T = x.itemSize;
      for (let L = 0; L < T; L++)
        w += `${~~(x[h[L]](E) * m + I)},`;
    }
    if (w in t)
      l.push(t[w]);
    else {
      for (let Q = 0, R = r.length; Q < R; Q++) {
        const _ = r[Q], x = A.getAttribute(_), T = A.morphAttributes[_], L = x.itemSize, N = a[_], O = c[_];
        for (let Z = 0; Z < L; Z++) {
          const U = h[Z], q = g[Z];
          if (N[q](o, x[U](E)), T)
            for (let H = 0, K = T.length; H < K; H++)
              O[H][q](o, T[H][U](E));
        }
      }
      t[w] = o, l.push(o), o++;
    }
  }
  const b = A.clone();
  for (const B in A.attributes) {
    const E = a[B];
    if (b.setAttribute(B, new E.constructor(
      E.array.slice(0, o * E.itemSize),
      E.itemSize,
      E.normalized
    )), B in c)
      for (let w = 0; w < c[B].length; w++) {
        const Q = c[B][w];
        b.morphAttributes[B][w] = new Q.constructor(
          Q.array.slice(0, o * Q.itemSize),
          Q.itemSize,
          Q.normalized
        );
      }
  }
  return b.setIndex(l), b;
}
function Mi(A, e) {
  if (e === ua)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), A;
  if (e === Js || e === So) {
    let t = A.getIndex();
    if (t === null) {
      const o = [], r = A.getAttribute("position");
      if (r !== void 0) {
        for (let a = 0; a < r.count; a++)
          o.push(a);
        A.setIndex(o), t = A.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), A;
    }
    const s = t.count - 2, n = [];
    if (e === Js)
      for (let o = 1; o <= s; o++)
        n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
    else
      for (let o = 0; o < s; o++)
        o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== s && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = A.clone();
    return i.setIndex(n), i.clearGroups(), i;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), A;
}
class zo extends Nt {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new rA(t);
    }), this.register(function(t) {
      return new aA(t);
    }), this.register(function(t) {
      return new fA(t);
    }), this.register(function(t) {
      return new mA(t);
    }), this.register(function(t) {
      return new IA(t);
    }), this.register(function(t) {
      return new cA(t);
    }), this.register(function(t) {
      return new lA(t);
    }), this.register(function(t) {
      return new hA(t);
    }), this.register(function(t) {
      return new uA(t);
    }), this.register(function(t) {
      return new oA(t);
    }), this.register(function(t) {
      return new gA(t);
    }), this.register(function(t) {
      return new AA(t);
    }), this.register(function(t) {
      return new pA(t);
    }), this.register(function(t) {
      return new dA(t);
    }), this.register(function(t) {
      return new sA(t);
    }), this.register(function(t) {
      return new bA(t);
    }), this.register(function(t) {
      return new EA(t);
    });
  }
  load(e, t, s, n) {
    const i = this;
    let o;
    if (this.resourcePath !== "")
      o = this.resourcePath;
    else if (this.path !== "") {
      const c = nn.extractUrlBase(e);
      o = nn.resolveURL(c, this.path);
    } else
      o = nn.extractUrlBase(e);
    this.manager.itemStart(e);
    const r = function(c) {
      n ? n(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
    }, a = new ft(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(c) {
      try {
        i.parse(c, o, function(l) {
          t(l), i.manager.itemEnd(e);
        }, r);
      } catch (l) {
        r(l);
      }
    }, s, r);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, s, n) {
    let i, o;
    const r = {}, a = {}, c = new TextDecoder();
    if (typeof e == "string")
      try {
        i = JSON.parse(e);
      } catch (h) {
        o = e, n && n(h);
        return;
      }
    else if (e instanceof ArrayBuffer)
      if (c.decode(new Uint8Array(e, 0, 4)) === Ko) {
        try {
          r[oe.KHR_BINARY_GLTF] = new CA(e);
        } catch (g) {
          n && n(g);
          return;
        }
        try {
          i = JSON.parse(r[oe.KHR_BINARY_GLTF].content);
        } catch (g) {
          o = r[oe.KHR_BINARY_GLTF].content, n && n(g);
          return;
        }
      } else
        try {
          i = JSON.parse(c.decode(e));
        } catch (g) {
          o = c.decode(e), n && n(g);
          return;
        }
    else
      i = e;
    if (i.asset === void 0 || i.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    this.json = i, this.jsonErrorData = o;
    const l = new kA(i, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const g = this.pluginCallbacks[h](l);
      g.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[g.name] = g, r[g.name] = !0;
    }
    if (i.extensionsUsed)
      for (let h = 0; h < i.extensionsUsed.length; ++h) {
        const g = i.extensionsUsed[h], d = i.extensionsRequired || [];
        switch (g) {
          case oe.KHR_MATERIALS_UNLIT:
            r[g] = new iA();
            break;
          case oe.KHR_DRACO_MESH_COMPRESSION:
            r[g] = new BA(i, this.dracoLoader);
            break;
          case oe.KHR_TEXTURE_TRANSFORM:
            r[g] = new wA();
            break;
          case oe.KHR_MESH_QUANTIZATION:
            r[g] = new yA();
            break;
          default:
            d.indexOf(g) >= 0 && a[g] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + g + '".');
        }
      }
    l.setExtensions(r), l.setPlugins(a), l.parse(s, n);
  }
  parseAsync(e, t) {
    const s = this;
    return new Promise(function(n, i) {
      s.parse(e, t, n, i);
    });
  }
}
function nA() {
  let A = {};
  return {
    get: function(e) {
      return A[e];
    },
    add: function(e, t) {
      A[e] = t;
    },
    remove: function(e) {
      delete A[e];
    },
    removeAll: function() {
      A = {};
    }
  };
}
const oe = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class sA {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let s = 0, n = t.length; s < n; s++) {
      const i = t[s];
      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, s = "light:" + e;
    let n = t.cache.get(s);
    if (n)
      return n;
    const i = t.json, a = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
    let c;
    const l = new Se(16777215);
    a.color !== void 0 && l.setRGB(a.color[0], a.color[1], a.color[2], We);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        c = new vo(l), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new Vs(l), c.distance = h;
        break;
      case "spot":
        c = new To(l), c.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, c.angle = a.spot.outerConeAngle, c.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, kt(c, a), a.intensity !== void 0 && (c.intensity = a.intensity), c.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(c), t.cache.add(s, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, s = this.parser, i = s.json.nodes[e], r = (i.extensions && i.extensions[this.name] || {}).light;
    return r === void 0 ? null : this._loadLight(r).then(function(a) {
      return s._getNodeRef(t.cache, r, a);
    });
  }
}
let iA = class {
  constructor() {
    this.name = oe.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Qt;
  }
  extendParams(e, t, s) {
    const n = [];
    e.color = new Se(1, 1, 1), e.opacity = 1;
    const i = t.pbrMetallicRoughness;
    if (i) {
      if (Array.isArray(i.baseColorFactor)) {
        const o = i.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], We), e.opacity = o[3];
      }
      i.baseColorTexture !== void 0 && n.push(s.assignTexture(e, "map", i.baseColorTexture, ge));
    }
    return Promise.all(n);
  }
}, oA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
}, rA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && i.push(s.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && i.push(s.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (i.push(s.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const r = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Le(r, r);
    }
    return Promise.all(i);
  }
}, aA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name];
    return t.dispersion = i.dispersion !== void 0 ? i.dispersion : 0, Promise.resolve();
  }
}, AA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && i.push(s.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && i.push(s.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(i);
  }
}, cA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [];
    t.sheenColor = new Se(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const r = o.sheenColorFactor;
      t.sheenColor.setRGB(r[0], r[1], r[2], We);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && i.push(s.assignTexture(t, "sheenColorMap", o.sheenColorTexture, ge)), o.sheenRoughnessTexture !== void 0 && i.push(s.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(i);
  }
}, lA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && i.push(s.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(i);
  }
}, hA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && i.push(s.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const r = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Se().setRGB(r[0], r[1], r[2], We), Promise.all(i);
  }
}, uA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name];
    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
  }
}, gA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && i.push(s.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const r = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Se().setRGB(r[0], r[1], r[2], We), o.specularColorTexture !== void 0 && i.push(s.assignTexture(t, "specularColorMap", o.specularColorTexture, ge)), Promise.all(i);
  }
}, dA = class {
  constructor(e) {
    this.parser = e, this.name = oe.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && i.push(s.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(i);
  }
}, pA = class {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : vt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && i.push(s.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(i);
  }
};
class fA {
  constructor(e) {
    this.parser = e, this.name = oe.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, s = t.json, n = s.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const i = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, i.source, o);
  }
}
class mA {
  constructor(e) {
    this.parser = e, this.name = oe.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], r = n.images[o.source];
    let a = s.textureLoader;
    if (r.uri) {
      const c = s.options.manager.getHandler(r.uri);
      c !== null && (a = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return s.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return s.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class IA {
  constructor(e) {
    this.parser = e, this.name = oe.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], r = n.images[o.source];
    let a = s.textureLoader;
    if (r.uri) {
      const c = s.options.manager.getHandler(r.uri);
      c !== null && (a = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return s.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return s.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class bA {
  constructor(e) {
    this.name = oe.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, s = t.bufferViews[e];
    if (s.extensions && s.extensions[this.name]) {
      const n = s.extensions[this.name], i = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return i.then(function(r) {
        const a = n.byteOffset || 0, c = n.byteLength || 0, l = n.count, h = n.byteStride, g = new Uint8Array(r, a, c);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(l, h, g, n.mode, n.filter).then(function(d) {
          return d.buffer;
        }) : o.ready.then(function() {
          const d = new ArrayBuffer(l * h);
          return o.decodeGltfBuffer(new Uint8Array(d), l, h, g, n.mode, n.filter), d;
        });
      });
    } else
      return null;
  }
}
let EA = class {
  constructor(e) {
    this.name = oe.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, s = t.nodes[e];
    if (!s.extensions || !s.extensions[this.name] || s.mesh === void 0)
      return null;
    const n = t.meshes[s.mesh];
    for (const c of n.primitives)
      if (c.mode !== ht.TRIANGLES && c.mode !== ht.TRIANGLE_STRIP && c.mode !== ht.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const o = s.extensions[this.name].attributes, r = [], a = {};
    for (const c in o)
      r.push(this.parser.getDependency("accessor", o[c]).then((l) => (a[c] = l, a[c])));
    return r.length < 1 ? null : (r.push(this.parser.createNodeMesh(e)), Promise.all(r).then((c) => {
      const l = c.pop(), h = l.isGroup ? l.children : [l], g = c[0].count, d = [];
      for (const p of h) {
        const m = new ue(), I = new P(), b = new Te(), B = new P(1, 1, 1), E = new ga(p.geometry, p.material, g);
        for (let w = 0; w < g; w++)
          a.TRANSLATION && I.fromBufferAttribute(a.TRANSLATION, w), a.ROTATION && b.fromBufferAttribute(a.ROTATION, w), a.SCALE && B.fromBufferAttribute(a.SCALE, w), E.setMatrixAt(w, m.compose(I, b, B));
        for (const w in a)
          if (w === "_COLOR_0") {
            const Q = a[w];
            E.instanceColor = new da(Q.array, Q.itemSize, Q.normalized);
          } else
            w !== "TRANSLATION" && w !== "ROTATION" && w !== "SCALE" && p.geometry.setAttribute(w, a[w]);
        xt.prototype.copy.call(E, p), this.parser.assignFinalMaterial(E), d.push(E);
      }
      return l.isGroup ? (l.clear(), l.add(...d), l) : d[0];
    }));
  }
};
const Ko = "glTF", wn = 12, ki = { JSON: 1313821514, BIN: 5130562 };
class CA {
  constructor(e) {
    this.name = oe.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, wn), s = new TextDecoder();
    if (this.header = {
      magic: s.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Ko)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - wn, i = new DataView(e, wn);
    let o = 0;
    for (; o < n; ) {
      const r = i.getUint32(o, !0);
      o += 4;
      const a = i.getUint32(o, !0);
      if (o += 4, a === ki.JSON) {
        const c = new Uint8Array(e, wn + o, r);
        this.content = s.decode(c);
      } else if (a === ki.BIN) {
        const c = wn + o;
        this.body = e.slice(c, c + r);
      }
      o += r;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class BA {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = oe.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const s = this.json, n = this.dracoLoader, i = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, r = {}, a = {}, c = {};
    for (const l in o) {
      const h = ei[l] || l.toLowerCase();
      r[h] = o[l];
    }
    for (const l in e.attributes) {
      const h = ei[l] || l.toLowerCase();
      if (o[l] !== void 0) {
        const g = s.accessors[e.attributes[l]], d = In[g.componentType];
        c[h] = d.name, a[h] = g.normalized === !0;
      }
    }
    return t.getDependency("bufferView", i).then(function(l) {
      return new Promise(function(h, g) {
        n.decodeDracoFile(l, function(d) {
          for (const p in d.attributes) {
            const m = d.attributes[p], I = a[p];
            I !== void 0 && (m.normalized = I);
          }
          h(d);
        }, r, c, We, g);
      });
    });
  }
}
class wA {
  constructor() {
    this.name = oe.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class yA {
  constructor() {
    this.name = oe.KHR_MESH_QUANTIZATION;
  }
}
class Yo extends Ia {
  constructor(e, t, s, n) {
    super(e, t, s, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, s = this.sampleValues, n = this.valueSize, i = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = s[i + o];
    return t;
  }
  interpolate_(e, t, s, n) {
    const i = this.resultBuffer, o = this.sampleValues, r = this.valueSize, a = r * 2, c = r * 3, l = n - t, h = (s - t) / l, g = h * h, d = g * h, p = e * c, m = p - c, I = -2 * d + 3 * g, b = d - g, B = 1 - I, E = b - g + h;
    for (let w = 0; w !== r; w++) {
      const Q = o[m + w + r], R = o[m + w + a] * l, _ = o[p + w + r], x = o[p + w] * l;
      i[w] = B * Q + E * R + I * _ + b * x;
    }
    return i;
  }
}
const QA = new Te();
class xA extends Yo {
  interpolate_(e, t, s, n) {
    const i = super.interpolate_(e, t, s, n);
    return QA.fromArray(i).normalize().toArray(i), i;
  }
}
const ht = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, In = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Fi = {
  9728: Do,
  9729: mt,
  9984: Mo,
  9985: ko,
  9986: Fo,
  9987: ps
}, Li = {
  33071: cs,
  33648: Lo,
  10497: rn
}, Cs = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, ei = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, Ht = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, SA = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: jn,
  STEP: fi
}, Bs = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function TA(A) {
  return A.DefaultMaterial === void 0 && (A.DefaultMaterial = new ui({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: No
  })), A.DefaultMaterial;
}
function Wt(A, e, t) {
  for (const s in t.extensions)
    A[s] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[s] = t.extensions[s]);
}
function kt(A, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(A.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function vA(A, e, t) {
  let s = !1, n = !1, i = !1;
  for (let c = 0, l = e.length; c < l; c++) {
    const h = e[c];
    if (h.POSITION !== void 0 && (s = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (i = !0), s && n && i)
      break;
  }
  if (!s && !n && !i)
    return Promise.resolve(A);
  const o = [], r = [], a = [];
  for (let c = 0, l = e.length; c < l; c++) {
    const h = e[c];
    if (s) {
      const g = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : A.attributes.position;
      o.push(g);
    }
    if (n) {
      const g = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : A.attributes.normal;
      r.push(g);
    }
    if (i) {
      const g = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : A.attributes.color;
      a.push(g);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(r),
    Promise.all(a)
  ]).then(function(c) {
    const l = c[0], h = c[1], g = c[2];
    return s && (A.morphAttributes.position = l), n && (A.morphAttributes.normal = h), i && (A.morphAttributes.color = g), A.morphTargetsRelative = !0, A;
  });
}
function RA(A, e) {
  if (A.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, s = e.weights.length; t < s; t++)
      A.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (A.morphTargetInfluences.length === t.length) {
      A.morphTargetDictionary = {};
      for (let s = 0, n = t.length; s < n; s++)
        A.morphTargetDictionary[t[s]] = s;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function _A(A) {
  let e;
  const t = A.extensions && A.extensions[oe.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + ws(t.attributes) : e = A.indices + ":" + ws(A.attributes) + ":" + A.mode, A.targets !== void 0)
    for (let s = 0, n = A.targets.length; s < n; s++)
      e += ":" + ws(A.targets[s]);
  return e;
}
function ws(A) {
  let e = "";
  const t = Object.keys(A).sort();
  for (let s = 0, n = t.length; s < n; s++)
    e += t[s] + ":" + A[t[s]] + ";";
  return e;
}
function ti(A) {
  switch (A) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function DA(A) {
  return A.search(/\.jpe?g($|\?)/i) > 0 || A.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : A.search(/\.webp($|\?)/i) > 0 || A.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const MA = new ue();
class kA {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new nA(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let s = !1, n = -1, i = !1, o = -1;
    if (typeof navigator < "u") {
      const r = navigator.userAgent;
      s = /^((?!chrome|android).)*safari/i.test(r) === !0;
      const a = r.match(/Version\/(\d+)/);
      n = s && a ? parseInt(a[1], 10) : -1, i = r.indexOf("Firefox") > -1, o = i ? r.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    typeof createImageBitmap > "u" || s && n < 17 || i && o < 98 ? this.textureLoader = new hi(this.options.manager) : this.textureLoader = new pa(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ft(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const s = this, n = this.json, i = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(this._invokeAll(function(o) {
      return o.beforeRoot && o.beforeRoot();
    })).then(function() {
      return Promise.all([
        s.getDependencies("scene"),
        s.getDependencies("animation"),
        s.getDependencies("camera")
      ]);
    }).then(function(o) {
      const r = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: s,
        userData: {}
      };
      return Wt(i, r, n), kt(r, n), Promise.all(s._invokeAll(function(a) {
        return a.afterRoot && a.afterRoot(r);
      })).then(function() {
        for (const a of r.scenes)
          a.updateMatrixWorld();
        e(r);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], s = this.json.meshes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const o = t[n].joints;
      for (let r = 0, a = o.length; r < a; r++)
        e[o[r]].isBone = !0;
    }
    for (let n = 0, i = e.length; n < i; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (s[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, s) {
    if (e.refs[t] <= 1)
      return s;
    const n = s.clone(), i = (o, r) => {
      const a = this.associations.get(o);
      a != null && this.associations.set(r, a);
      for (const [c, l] of o.children.entries())
        i(l, r.children[c]);
    };
    return i(s, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let s = 0; s < t.length; s++) {
      const n = e(t[s]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const s = [];
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      i && s.push(i);
    }
    return s;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const s = e + ":" + t;
    let n = this.cache.get(s);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(i) {
            return i.loadNode && i.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(i) {
            return i.loadMesh && i.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(i) {
            return i.loadBufferView && i.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(i) {
            return i.loadMaterial && i.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(i) {
            return i.loadTexture && i.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(i) {
            return i.loadAnimation && i.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(i) {
            return i != this && i.getDependency && i.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(s, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const s = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(i, o) {
        return s.getDependency(e, o);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], s = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[oe.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(i, o) {
      s.load(nn.resolveURL(t.uri, n.path), i, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(s) {
      const n = t.byteLength || 0, i = t.byteOffset || 0;
      return s.slice(i, i + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, s = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = Cs[n.type], r = In[n.componentType], a = n.normalized === !0, c = new r(n.count * o);
      return Promise.resolve(new nt(c, o, a));
    }
    const i = [];
    return n.bufferView !== void 0 ? i.push(this.getDependency("bufferView", n.bufferView)) : i.push(null), n.sparse !== void 0 && (i.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(i).then(function(o) {
      const r = o[0], a = Cs[n.type], c = In[n.componentType], l = c.BYTES_PER_ELEMENT, h = l * a, g = n.byteOffset || 0, d = n.bufferView !== void 0 ? s.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === !0;
      let m, I;
      if (d && d !== h) {
        const b = Math.floor(g / d), B = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + b + ":" + n.count;
        let E = t.cache.get(B);
        E || (m = new c(r, b * d, n.count * d / l), E = new fa(m, d / l), t.cache.add(B, E)), I = new en(E, a, g % d / l, p);
      } else
        r === null ? m = new c(n.count * a) : m = new c(r, g, n.count * a), I = new nt(m, a, p);
      if (n.sparse !== void 0) {
        const b = Cs.SCALAR, B = In[n.sparse.indices.componentType], E = n.sparse.indices.byteOffset || 0, w = n.sparse.values.byteOffset || 0, Q = new B(o[1], E, n.sparse.count * b), R = new c(o[2], w, n.sparse.count * a);
        r !== null && (I = new nt(I.array.slice(), I.itemSize, I.normalized)), I.normalized = !1;
        for (let _ = 0, x = Q.length; _ < x; _++) {
          const T = Q[_];
          if (I.setX(T, R[_ * a]), a >= 2 && I.setY(T, R[_ * a + 1]), a >= 3 && I.setZ(T, R[_ * a + 2]), a >= 4 && I.setW(T, R[_ * a + 3]), a >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        I.normalized = p;
      }
      return I;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, s = this.options, i = t.textures[e].source, o = t.images[i];
    let r = this.textureLoader;
    if (o.uri) {
      const a = s.manager.getHandler(o.uri);
      a !== null && (r = a);
    }
    return this.loadTextureImage(e, i, r);
  }
  loadTextureImage(e, t, s) {
    const n = this, i = this.json, o = i.textures[e], r = i.images[t], a = (r.uri || r.bufferView) + ":" + o.sampler;
    if (this.textureCache[a])
      return this.textureCache[a];
    const c = this.loadImageSource(t, s).then(function(l) {
      l.flipY = !1, l.name = o.name || r.name || "", l.name === "" && typeof r.uri == "string" && r.uri.startsWith("data:image/") === !1 && (l.name = r.uri);
      const g = (i.samplers || {})[o.sampler] || {};
      return l.magFilter = Fi[g.magFilter] || mt, l.minFilter = Fi[g.minFilter] || ps, l.wrapS = Li[g.wrapS] || rn, l.wrapT = Li[g.wrapT] || rn, l.anisotropy = 4, n.associations.set(l, { textures: e }), l;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a] = c, c;
  }
  loadImageSource(e, t) {
    const s = this, n = this.json, i = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], r = self.URL || self.webkitURL;
    let a = o.uri || "", c = !1;
    if (o.bufferView !== void 0)
      a = s.getDependency("bufferView", o.bufferView).then(function(h) {
        c = !0;
        const g = new Blob([h], { type: o.mimeType });
        return a = r.createObjectURL(g), a;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const l = Promise.resolve(a).then(function(h) {
      return new Promise(function(g, d) {
        let p = g;
        t.isImageBitmapLoader === !0 && (p = function(m) {
          const I = new Xs(m);
          I.needsUpdate = !0, g(I);
        }), t.load(nn.resolveURL(h, i.path), p, void 0, d);
      });
    }).then(function(h) {
      return c === !0 && r.revokeObjectURL(a), kt(h, o), h.userData.mimeType = o.mimeType || DA(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a), h;
    });
    return this.sourceCache[e] = l, l;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, s, n) {
    const i = this;
    return this.getDependency("texture", s.index).then(function(o) {
      if (!o)
        return null;
      if (s.texCoord !== void 0 && s.texCoord > 0 && (o = o.clone(), o.channel = s.texCoord), i.extensions[oe.KHR_TEXTURE_TRANSFORM]) {
        const r = s.extensions !== void 0 ? s.extensions[oe.KHR_TEXTURE_TRANSFORM] : void 0;
        if (r) {
          const a = i.associations.get(o);
          o = i.extensions[oe.KHR_TEXTURE_TRANSFORM].extendTexture(o, r), i.associations.set(o, a);
        }
      }
      return n !== void 0 && (o.colorSpace = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let s = e.material;
    const n = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const r = "PointsMaterial:" + s.uuid;
      let a = this.cache.get(r);
      a || (a = new Dn(), tn.prototype.copy.call(a, s), a.color.copy(s.color), a.map = s.map, a.sizeAttenuation = !1, this.cache.add(r, a)), s = a;
    } else if (e.isLine) {
      const r = "LineBasicMaterial:" + s.uuid;
      let a = this.cache.get(r);
      a || (a = new Lt(), tn.prototype.copy.call(a, s), a.color.copy(s.color), a.map = s.map, this.cache.add(r, a)), s = a;
    }
    if (n || i || o) {
      let r = "ClonedMaterial:" + s.uuid + ":";
      n && (r += "derivative-tangents:"), i && (r += "vertex-colors:"), o && (r += "flat-shading:");
      let a = this.cache.get(r);
      a || (a = s.clone(), i && (a.vertexColors = !0), o && (a.flatShading = !0), n && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(r, a), this.associations.set(a, this.associations.get(s))), s = a;
    }
    e.material = s;
  }
  getMaterialType() {
    return ui;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, s = this.json, n = this.extensions, i = s.materials[e];
    let o;
    const r = {}, a = i.extensions || {}, c = [];
    if (a[oe.KHR_MATERIALS_UNLIT]) {
      const h = n[oe.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), c.push(h.extendParams(r, i, t));
    } else {
      const h = i.pbrMetallicRoughness || {};
      if (r.color = new Se(1, 1, 1), r.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const g = h.baseColorFactor;
        r.color.setRGB(g[0], g[1], g[2], We), r.opacity = g[3];
      }
      h.baseColorTexture !== void 0 && c.push(t.assignTexture(r, "map", h.baseColorTexture, ge)), r.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, r.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(r, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(r, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(g) {
        return g.getMaterialType && g.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(g) {
        return g.extendMaterialParams && g.extendMaterialParams(e, r);
      })));
    }
    i.doubleSided === !0 && (r.side = gi);
    const l = i.alphaMode || Bs.OPAQUE;
    if (l === Bs.BLEND ? (r.transparent = !0, r.depthWrite = !1) : (r.transparent = !1, l === Bs.MASK && (r.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && o !== Qt && (c.push(t.assignTexture(r, "normalMap", i.normalTexture)), r.normalScale = new Le(1, 1), i.normalTexture.scale !== void 0)) {
      const h = i.normalTexture.scale;
      r.normalScale.set(h, h);
    }
    if (i.occlusionTexture !== void 0 && o !== Qt && (c.push(t.assignTexture(r, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (r.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && o !== Qt) {
      const h = i.emissiveFactor;
      r.emissive = new Se().setRGB(h[0], h[1], h[2], We);
    }
    return i.emissiveTexture !== void 0 && o !== Qt && c.push(t.assignTexture(r, "emissiveMap", i.emissiveTexture, ge)), Promise.all(c).then(function() {
      const h = new o(r);
      return i.name && (h.name = i.name), kt(h, i), t.associations.set(h, { materials: e }), i.extensions && Wt(n, h, i), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = It.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, s = this.extensions, n = this.primitiveCache;
    function i(r) {
      return s[oe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r, t).then(function(a) {
        return Ni(a, r, t);
      });
    }
    const o = [];
    for (let r = 0, a = e.length; r < a; r++) {
      const c = e[r], l = _A(c), h = n[l];
      if (h)
        o.push(h.promise);
      else {
        let g;
        c.extensions && c.extensions[oe.KHR_DRACO_MESH_COMPRESSION] ? g = i(c) : g = Ni(new ut(), c, t), n[l] = { primitive: c, promise: g }, o.push(g);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, s = this.json, n = this.extensions, i = s.meshes[e], o = i.primitives, r = [];
    for (let a = 0, c = o.length; a < c; a++) {
      const l = o[a].material === void 0 ? TA(this.cache) : this.getDependency("material", o[a].material);
      r.push(l);
    }
    return r.push(t.loadGeometries(o)), Promise.all(r).then(function(a) {
      const c = a.slice(0, a.length - 1), l = a[a.length - 1], h = [];
      for (let d = 0, p = l.length; d < p; d++) {
        const m = l[d], I = o[d];
        let b;
        const B = c[d];
        if (I.mode === ht.TRIANGLES || I.mode === ht.TRIANGLE_STRIP || I.mode === ht.TRIANGLE_FAN || I.mode === void 0)
          b = i.isSkinnedMesh === !0 ? new di(m, B) : new z(m, B), b.isSkinnedMesh === !0 && b.normalizeSkinWeights(), I.mode === ht.TRIANGLE_STRIP ? b.geometry = Mi(b.geometry, So) : I.mode === ht.TRIANGLE_FAN && (b.geometry = Mi(b.geometry, Js));
        else if (I.mode === ht.LINES)
          b = new As(m, B);
        else if (I.mode === ht.LINE_STRIP)
          b = new dt(m, B);
        else if (I.mode === ht.LINE_LOOP)
          b = new ma(m, B);
        else if (I.mode === ht.POINTS)
          b = new is(m, B);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + I.mode);
        Object.keys(b.geometry.morphAttributes).length > 0 && RA(b, i), b.name = t.createUniqueName(i.name || "mesh_" + e), kt(b, i), I.extensions && Wt(n, b, I), t.assignFinalMaterial(b), h.push(b);
      }
      for (let d = 0, p = h.length; d < p; d++)
        t.associations.set(h[d], {
          meshes: e,
          primitives: d
        });
      if (h.length === 1)
        return i.extensions && Wt(n, h[0], i), h[0];
      const g = new sn();
      i.extensions && Wt(n, g, i), t.associations.set(g, { meshes: e });
      for (let d = 0, p = h.length; d < p; d++)
        g.add(h[d]);
      return g;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const s = this.json.cameras[e], n = s[s.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return s.type === "perspective" ? t = new ds(ye.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : s.type === "orthographic" && (t = new Ro(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), s.name && (t.name = this.createUniqueName(s.name)), kt(t, s), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], s = [];
    for (let n = 0, i = t.joints.length; n < i; n++)
      s.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? s.push(this.getDependency("accessor", t.inverseBindMatrices)) : s.push(null), Promise.all(s).then(function(n) {
      const i = n.pop(), o = n, r = [], a = [];
      for (let c = 0, l = o.length; c < l; c++) {
        const h = o[c];
        if (h) {
          r.push(h);
          const g = new ue();
          i !== null && g.fromArray(i.array, c * 16), a.push(g);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new _o(r, a);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, s = this, n = t.animations[e], i = n.name ? n.name : "animation_" + e, o = [], r = [], a = [], c = [], l = [];
    let h = 0, g = n.channels.length;
    for (h = 0, g = n.channels.length; h < g; h++) {
      const d = n.channels[h], p = n.samplers[d.sampler], m = d.target, I = m.node, b = n.parameters !== void 0 ? n.parameters[p.input] : p.input, B = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      m.node !== void 0 && (o.push(this.getDependency("node", I)), r.push(this.getDependency("accessor", b)), a.push(this.getDependency("accessor", B)), c.push(p), l.push(m));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(r),
      Promise.all(a),
      Promise.all(c),
      Promise.all(l)
    ]).then(function(d) {
      const p = d[0], m = d[1], I = d[2], b = d[3], B = d[4], E = [];
      for (h = 0, g = p.length; h < g; h++) {
        const w = p[h], Q = m[h], R = I[h], _ = b[h], x = B[h];
        if (w === void 0)
          continue;
        w.updateMatrix && w.updateMatrix();
        const T = s._createAnimationTracks(w, Q, R, _, x);
        if (T)
          for (let L = 0; L < T.length; L++)
            E.push(T[L]);
      }
      return new pi(i, void 0, E);
    });
  }
  createNodeMesh(e) {
    const t = this.json, s = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : s.getDependency("mesh", n.mesh).then(function(i) {
      const o = s._getNodeRef(s.meshCache, n.mesh, i);
      return n.weights !== void 0 && o.traverse(function(r) {
        if (r.isMesh)
          for (let a = 0, c = n.weights.length; a < c; a++)
            r.morphTargetInfluences[a] = n.weights[a];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, s = this, n = t.nodes[e], i = s._loadNodeShallow(e), o = [], r = n.children || [];
    for (let c = 0, l = r.length; c < l; c++)
      o.push(s.getDependency("node", r[c]));
    const a = n.skin === void 0 ? Promise.resolve(null) : s.getDependency("skin", n.skin);
    return Promise.all([
      i,
      Promise.all(o),
      a
    ]).then(function(c) {
      const l = c[0], h = c[1], g = c[2];
      g !== null && l.traverse(function(d) {
        d.isSkinnedMesh && d.bind(g, MA);
      });
      for (let d = 0, p = h.length; d < p; d++)
        l.add(h[d]);
      return l;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, s = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const i = t.nodes[e], o = i.name ? n.createUniqueName(i.name) : "", r = [], a = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return a && r.push(a), i.camera !== void 0 && r.push(n.getDependency("camera", i.camera).then(function(c) {
      return n._getNodeRef(n.cameraCache, i.camera, c);
    })), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      r.push(c);
    }), this.nodeCache[e] = Promise.all(r).then(function(c) {
      let l;
      if (i.isBone === !0 ? l = new Ws() : c.length > 1 ? l = new sn() : c.length === 1 ? l = c[0] : l = new xt(), l !== c[0])
        for (let h = 0, g = c.length; h < g; h++)
          l.add(c[h]);
      if (i.name && (l.userData.name = i.name, l.name = o), kt(l, i), i.extensions && Wt(s, l, i), i.matrix !== void 0) {
        const h = new ue();
        h.fromArray(i.matrix), l.applyMatrix4(h);
      } else
        i.translation !== void 0 && l.position.fromArray(i.translation), i.rotation !== void 0 && l.quaternion.fromArray(i.rotation), i.scale !== void 0 && l.scale.fromArray(i.scale);
      return n.associations.has(l) || n.associations.set(l, {}), n.associations.get(l).nodes = e, l;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, s = this.json.scenes[e], n = this, i = new sn();
    s.name && (i.name = n.createUniqueName(s.name)), kt(i, s), s.extensions && Wt(t, i, s);
    const o = s.nodes || [], r = [];
    for (let a = 0, c = o.length; a < c; a++)
      r.push(n.getDependency("node", o[a]));
    return Promise.all(r).then(function(a) {
      for (let l = 0, h = a.length; l < h; l++)
        i.add(a[l]);
      const c = (l) => {
        const h = /* @__PURE__ */ new Map();
        for (const [g, d] of n.associations)
          (g instanceof tn || g instanceof Xs) && h.set(g, d);
        return l.traverse((g) => {
          const d = n.associations.get(g);
          d != null && h.set(g, d);
        }), h;
      };
      return n.associations = c(i), i;
    });
  }
  _createAnimationTracks(e, t, s, n, i) {
    const o = [], r = e.name ? e.name : e.uuid, a = [];
    Ht[i.path] === Ht.weights ? e.traverse(function(g) {
      g.morphTargetInfluences && a.push(g.name ? g.name : g.uuid);
    }) : a.push(r);
    let c;
    switch (Ht[i.path]) {
      case Ht.weights:
        c = hs;
        break;
      case Ht.rotation:
        c = us;
        break;
      case Ht.position:
      case Ht.scale:
        c = ls;
        break;
      default:
        switch (s.itemSize) {
          case 1:
            c = hs;
            break;
          case 2:
          case 3:
          default:
            c = ls;
            break;
        }
        break;
    }
    const l = n.interpolation !== void 0 ? SA[n.interpolation] : jn, h = this._getArrayFromAccessor(s);
    for (let g = 0, d = a.length; g < d; g++) {
      const p = new c(
        a[g] + "." + Ht[i.path],
        t.array,
        h,
        l
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), o.push(p);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const s = ti(t.constructor), n = new Float32Array(t.length);
      for (let i = 0, o = t.length; i < o; i++)
        n[i] = t[i] * s;
      t = n;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(s) {
      const n = this instanceof us ? xA : Yo;
      return new n(this.times, this.values, this.getValueSize() / 3, s);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function FA(A, e, t) {
  const s = e.attributes, n = new fs();
  if (s.POSITION !== void 0) {
    const r = t.json.accessors[s.POSITION], a = r.min, c = r.max;
    if (a !== void 0 && c !== void 0) {
      if (n.set(
        new P(a[0], a[1], a[2]),
        new P(c[0], c[1], c[2])
      ), r.normalized) {
        const l = ti(In[r.componentType]);
        n.min.multiplyScalar(l), n.max.multiplyScalar(l);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const i = e.targets;
  if (i !== void 0) {
    const r = new P(), a = new P();
    for (let c = 0, l = i.length; c < l; c++) {
      const h = i[c];
      if (h.POSITION !== void 0) {
        const g = t.json.accessors[h.POSITION], d = g.min, p = g.max;
        if (d !== void 0 && p !== void 0) {
          if (a.setX(Math.max(Math.abs(d[0]), Math.abs(p[0]))), a.setY(Math.max(Math.abs(d[1]), Math.abs(p[1]))), a.setZ(Math.max(Math.abs(d[2]), Math.abs(p[2]))), g.normalized) {
            const m = ti(In[g.componentType]);
            a.multiplyScalar(m);
          }
          r.max(a);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(r);
  }
  A.boundingBox = n;
  const o = new mi();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, A.boundingSphere = o;
}
function Ni(A, e, t) {
  const s = e.attributes, n = [];
  function i(o, r) {
    return t.getDependency("accessor", o).then(function(a) {
      A.setAttribute(r, a);
    });
  }
  for (const o in s) {
    const r = ei[o] || o.toLowerCase();
    r in A.attributes || n.push(i(s[o], r));
  }
  if (e.indices !== void 0 && !A.index) {
    const o = t.getDependency("accessor", e.indices).then(function(r) {
      A.setIndex(r);
    });
    n.push(o);
  }
  return Ve.workingColorSpace !== We && "COLOR_0" in s && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ve.workingColorSpace}" not supported.`), kt(A, e), FA(A, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? vA(A, e.targets, t) : A;
  });
}
var fh = function() {
  var A = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), s = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  var n = WebAssembly.validate(t) ? e : A, i, o = WebAssembly.instantiate(r(n), {}).then(function(b) {
    i = b.instance, i.exports.__wasm_call_ctors();
  });
  function r(b) {
    for (var B = new Uint8Array(b.length), E = 0; E < b.length; ++E) {
      var w = b.charCodeAt(E);
      B[E] = w > 96 ? w - 97 : w > 64 ? w - 39 : w + 4;
    }
    for (var Q = 0, E = 0; E < b.length; ++E)
      B[Q++] = B[E] < 60 ? s[B[E]] : (B[E] - 60) * 64 + B[++E];
    return B.buffer.slice(0, Q);
  }
  function a(b, B, E, w, Q, R) {
    var _ = i.exports.sbrk, x = E + 3 & -4, T = _(x * w), L = _(Q.length), N = new Uint8Array(i.exports.memory.buffer);
    N.set(Q, L);
    var O = b(T, E, w, L, Q.length);
    if (O == 0 && R && R(T, x, w), B.set(N.subarray(T, T + E * w)), _(T - _(0)), O != 0)
      throw new Error("Malformed buffer data: " + O);
  }
  var c = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, l = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  }, h = [], g = 0;
  function d(b) {
    var B = {
      object: new Worker(b),
      pending: 0,
      requests: {}
    };
    return B.object.onmessage = function(E) {
      var w = E.data;
      B.pending -= w.count, B.requests[w.id][w.action](w.value), delete B.requests[w.id];
    }, B;
  }
  function p(b) {
    for (var B = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(r(n)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + a.toString() + I.toString(), E = new Blob([B], { type: "text/javascript" }), w = URL.createObjectURL(E), Q = 0; Q < b; ++Q)
      h[Q] = d(w);
    URL.revokeObjectURL(w);
  }
  function m(b, B, E, w, Q) {
    for (var R = h[0], _ = 1; _ < h.length; ++_)
      h[_].pending < R.pending && (R = h[_]);
    return new Promise(function(x, T) {
      var L = new Uint8Array(E), N = g++;
      R.pending += b, R.requests[N] = { resolve: x, reject: T }, R.object.postMessage({ id: N, count: b, size: B, source: L, mode: w, filter: Q }, [L.buffer]);
    });
  }
  function I(b) {
    o.then(function() {
      var B = b.data;
      try {
        var E = new Uint8Array(B.count * B.size);
        a(i.exports[B.mode], E, B.count, B.size, B.source, i.exports[B.filter]), self.postMessage({ id: B.id, count: B.count, action: "resolve", value: E }, [E.buffer]);
      } catch (w) {
        self.postMessage({ id: B.id, count: B.count, action: "reject", value: w });
      }
    });
  }
  return {
    ready: o,
    supported: !0,
    useWorkers: function(b) {
      p(b);
    },
    decodeVertexBuffer: function(b, B, E, w, Q) {
      a(i.exports.meshopt_decodeVertexBuffer, b, B, E, w, i.exports[c[Q]]);
    },
    decodeIndexBuffer: function(b, B, E, w) {
      a(i.exports.meshopt_decodeIndexBuffer, b, B, E, w);
    },
    decodeIndexSequence: function(b, B, E, w) {
      a(i.exports.meshopt_decodeIndexSequence, b, B, E, w);
    },
    decodeGltfBuffer: function(b, B, E, w, Q, R) {
      a(i.exports[l[Q]], b, B, E, w, i.exports[c[R]]);
    },
    decodeGltfBufferAsync: function(b, B, E, w, Q) {
      return h.length > 0 ? m(b, B, E, l[w], c[Q]) : o.then(function() {
        var R = new Uint8Array(b * B);
        return a(i.exports[l[w]], R, b, B, E, i.exports[c[Q]]), R;
      });
    }
  };
}();
const ys = /* @__PURE__ */ new WeakMap();
class mh extends Nt {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, s, n) {
    const i = new ft(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, (o) => {
      this.parse(o, t, n);
    }, s, n);
  }
  parse(e, t, s = () => {
  }) {
    this.decodeDracoFile(e, t, null, null, ge, s).catch(s);
  }
  decodeDracoFile(e, t, s, n, i = We, o = () => {
  }) {
    const r = {
      attributeIDs: s || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!s,
      vertexColorSpace: i
    };
    return this.decodeGeometry(e, r).then(t).catch(o);
  }
  decodeGeometry(e, t) {
    const s = JSON.stringify(t);
    if (ys.has(e)) {
      const a = ys.get(e);
      if (a.key === s)
        return a.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const i = this.workerNextTaskID++, o = e.byteLength, r = this._getWorker(i, o).then((a) => (n = a, new Promise((c, l) => {
      n._callbacks[i] = { resolve: c, reject: l }, n.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]);
    }))).then((a) => this._createGeometry(a.geometry));
    return r.catch(() => !0).then(() => {
      n && i && this._releaseTask(n, i);
    }), ys.set(e, {
      key: s,
      promise: r
    }), r;
  }
  _createGeometry(e) {
    const t = new ut();
    e.index && t.setIndex(new nt(e.index.array, 1));
    for (let s = 0; s < e.attributes.length; s++) {
      const n = e.attributes[s], i = n.name, o = n.array, r = n.itemSize, a = new nt(o, r);
      i === "color" && (this._assignVertexColorSpace(a, n.vertexColorSpace), a.normalized = !(o instanceof Float32Array)), t.setAttribute(i, a);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== ge)
      return;
    const s = new Se();
    for (let n = 0, i = e.count; n < i; n++)
      s.fromBufferAttribute(e, n), Ve.toWorkingColorSpace(s, ge), e.setXYZ(n, s.r, s.g, s.b);
  }
  _loadLibrary(e, t) {
    const s = new ft(this.manager);
    return s.setPath(this.decoderPath), s.setResponseType(t), s.setWithCredentials(this.withCredentials), new Promise((n, i) => {
      s.load(e, n, void 0, i);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((s) => {
      const n = s[0];
      e || (this.decoderConfig.wasmBinary = s[1]);
      const i = LA.toString(), o = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(i) {
          const o = i.data;
          switch (o.type) {
            case "decode":
              n._callbacks[o.id].resolve(o);
              break;
            case "error":
              n._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, i) {
          return n._taskLoad > i._taskLoad ? -1 : 1;
        });
      const s = this.workerPool[this.workerPool.length - 1];
      return s._taskCosts[e] = t, s._taskLoad += t, s;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function LA() {
  let A, e;
  onmessage = function(o) {
    const r = o.data;
    switch (r.type) {
      case "init":
        A = r.decoderConfig, e = new Promise(function(l) {
          A.onModuleLoaded = function(h) {
            l({ draco: h });
          }, DracoDecoderModule(A);
        });
        break;
      case "decode":
        const a = r.buffer, c = r.taskConfig;
        e.then((l) => {
          const h = l.draco, g = new h.Decoder();
          try {
            const d = t(h, g, new Int8Array(a), c), p = d.attributes.map((m) => m.array.buffer);
            d.index && p.push(d.index.array.buffer), self.postMessage({ type: "decode", id: r.id, geometry: d }, p);
          } catch (d) {
            console.error(d), self.postMessage({ type: "error", id: r.id, error: d.message });
          } finally {
            h.destroy(g);
          }
        });
        break;
    }
  };
  function t(o, r, a, c) {
    const l = c.attributeIDs, h = c.attributeTypes;
    let g, d;
    const p = r.GetEncodedGeometryType(a);
    if (p === o.TRIANGULAR_MESH)
      g = new o.Mesh(), d = r.DecodeArrayToMesh(a, a.byteLength, g);
    else if (p === o.POINT_CLOUD)
      g = new o.PointCloud(), d = r.DecodeArrayToPointCloud(a, a.byteLength, g);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!d.ok() || g.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + d.error_msg());
    const m = { index: null, attributes: [] };
    for (const I in l) {
      const b = self[h[I]];
      let B, E;
      if (c.useUniqueIDs)
        E = l[I], B = r.GetAttributeByUniqueId(g, E);
      else {
        if (E = r.GetAttributeId(g, o[l[I]]), E === -1)
          continue;
        B = r.GetAttribute(g, E);
      }
      const w = n(o, r, g, I, b, B);
      I === "color" && (w.vertexColorSpace = c.vertexColorSpace), m.attributes.push(w);
    }
    return p === o.TRIANGULAR_MESH && (m.index = s(o, r, g)), o.destroy(g), m;
  }
  function s(o, r, a) {
    const l = a.num_faces() * 3, h = l * 4, g = o._malloc(h);
    r.GetTrianglesUInt32Array(a, h, g);
    const d = new Uint32Array(o.HEAPF32.buffer, g, l).slice();
    return o._free(g), { array: d, itemSize: 1 };
  }
  function n(o, r, a, c, l, h) {
    const g = h.num_components(), p = a.num_points() * g, m = p * l.BYTES_PER_ELEMENT, I = i(o, l), b = o._malloc(m);
    r.GetAttributeDataArrayForAllPoints(a, h, I, m, b);
    const B = new l(o.HEAPF32.buffer, b, p).slice();
    return o._free(b), {
      name: c,
      array: B,
      itemSize: g
    };
  }
  function i(o, r) {
    switch (r) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
class NA {
  constructor(e = 4) {
    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++)
      if (!(this.workerStatus & 1 << e))
        return e;
    return -1;
  }
  _onMessage(e, t) {
    const s = this.workersResolve[e];
    if (s && s(t), this.queue.length) {
      const { resolve: n, msg: i, transfer: o } = this.queue.shift();
      this.workersResolve[e] = n, this.workers[e].postMessage(i, o);
    } else
      this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((s) => {
      const n = this._getIdleWorker();
      n !== -1 ? (this._initWorker(n), this.workerStatus |= 1 << n, this.workersResolve[n] = s, this.workers[n].postMessage(e, t)) : this.queue.push({ resolve: s, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
const UA = 0, Ui = 2, GA = 1, Gi = 2, PA = 0, OA = 1, HA = 10, jA = 0, Jo = 9, Vo = 15, Wo = 16, Xo = 22, Zo = 37, $o = 43, er = 76, tr = 83, nr = 97, sr = 100, ir = 103, or = 109, rr = 165, ar = 166, Ar = 1000066e3;
class qA {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
}
class yn {
  constructor(e, t, s, n) {
    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, s), this._littleEndian = n, this._offset = 0;
  }
  _nextUint8() {
    const e = this._dataView.getUint8(this._offset);
    return this._offset += 1, e;
  }
  _nextUint16() {
    const e = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, e;
  }
  _nextUint32() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint64() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, e;
  }
  _nextInt32() {
    const e = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint8Array(e) {
    const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
    return this._offset += e, t;
  }
  _skip(e) {
    return this._offset += e, this;
  }
  _scan(e, t) {
    t === void 0 && (t = 0);
    const s = this._offset;
    let n = 0;
    for (; this._dataView.getUint8(this._offset) !== t && n < e; )
      n++, this._offset++;
    return n < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + s, n);
  }
}
const qe = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Pi(A) {
  return new TextDecoder().decode(A);
}
function zA(A) {
  const e = new Uint8Array(A.buffer, A.byteOffset, qe.length);
  if (e[0] !== qe[0] || e[1] !== qe[1] || e[2] !== qe[2] || e[3] !== qe[3] || e[4] !== qe[4] || e[5] !== qe[5] || e[6] !== qe[6] || e[7] !== qe[7] || e[8] !== qe[8] || e[9] !== qe[9] || e[10] !== qe[10] || e[11] !== qe[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const t = new qA(), s = 17 * Uint32Array.BYTES_PER_ELEMENT, n = new yn(A, qe.length, s, !0);
  t.vkFormat = n._nextUint32(), t.typeSize = n._nextUint32(), t.pixelWidth = n._nextUint32(), t.pixelHeight = n._nextUint32(), t.pixelDepth = n._nextUint32(), t.layerCount = n._nextUint32(), t.faceCount = n._nextUint32();
  const i = n._nextUint32();
  t.supercompressionScheme = n._nextUint32();
  const o = n._nextUint32(), r = n._nextUint32(), a = n._nextUint32(), c = n._nextUint32(), l = n._nextUint64(), h = n._nextUint64(), g = new yn(A, qe.length + s, 3 * i * 8, !0);
  for (let K = 0; K < i; K++)
    t.levels.push({ levelData: new Uint8Array(A.buffer, A.byteOffset + g._nextUint64(), g._nextUint64()), uncompressedByteLength: g._nextUint64() });
  const d = new yn(A, o, r, !0), p = { vendorId: d._skip(4)._nextUint16(), descriptorType: d._nextUint16(), versionNumber: d._nextUint16(), descriptorBlockSize: d._nextUint16(), colorModel: d._nextUint8(), colorPrimaries: d._nextUint8(), transferFunction: d._nextUint8(), flags: d._nextUint8(), texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], samples: [] }, m = (p.descriptorBlockSize / 4 - 6) / 4;
  for (let K = 0; K < m; K++) {
    const ee = { bitOffset: d._nextUint16(), bitLength: d._nextUint8(), channelType: d._nextUint8(), samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
    64 & ee.channelType ? (ee.sampleLower = d._nextInt32(), ee.sampleUpper = d._nextInt32()) : (ee.sampleLower = d._nextUint32(), ee.sampleUpper = d._nextUint32()), p.samples[K] = ee;
  }
  t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(p);
  const I = new yn(A, a, c, !0);
  for (; I._offset < c; ) {
    const K = I._nextUint32(), ee = I._scan(K), te = Pi(ee);
    if (t.keyValue[te] = I._nextUint8Array(K - ee.byteLength - 1), te.match(/^ktx/i)) {
      const ie = Pi(t.keyValue[te]);
      t.keyValue[te] = ie.substring(0, ie.lastIndexOf("\0"));
    }
    I._skip(K % 4 ? 4 - K % 4 : 0);
  }
  if (h <= 0)
    return t;
  const b = new yn(A, l, h, !0), B = b._nextUint16(), E = b._nextUint16(), w = b._nextUint32(), Q = b._nextUint32(), R = b._nextUint32(), _ = b._nextUint32(), x = [];
  for (let K = 0; K < i; K++)
    x.push({ imageFlags: b._nextUint32(), rgbSliceByteOffset: b._nextUint32(), rgbSliceByteLength: b._nextUint32(), alphaSliceByteOffset: b._nextUint32(), alphaSliceByteLength: b._nextUint32() });
  const T = l + b._offset, L = T + w, N = L + Q, O = N + R, Z = new Uint8Array(A.buffer, A.byteOffset + T, w), U = new Uint8Array(A.buffer, A.byteOffset + L, Q), q = new Uint8Array(A.buffer, A.byteOffset + N, R), H = new Uint8Array(A.buffer, A.byteOffset + O, _);
  return t.globalData = { endpointCount: B, selectorCount: E, imageDescs: x, endpointsData: Z, selectorsData: U, tablesData: q, extendedData: H }, t;
}
let Qs, Mt, ni;
const xs = { env: { emscripten_notify_memory_growth: function(A) {
  ni = new Uint8Array(Mt.exports.memory.buffer);
} } };
class KA {
  init() {
    return Qs || (Qs = typeof fetch < "u" ? fetch("data:application/wasm;base64," + Oi).then((e) => e.arrayBuffer()).then((e) => WebAssembly.instantiate(e, xs)).then(this._init) : WebAssembly.instantiate(Buffer.from(Oi, "base64"), xs).then(this._init), Qs);
  }
  _init(e) {
    Mt = e.instance, xs.env.emscripten_notify_memory_growth(0);
  }
  decode(e, t = 0) {
    if (!Mt)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const s = e.byteLength, n = Mt.exports.malloc(s);
    ni.set(e, n), t = t || Number(Mt.exports.ZSTD_findDecompressedSize(n, s));
    const i = Mt.exports.malloc(t), o = Mt.exports.ZSTD_decompress(i, t, n, s), r = ni.slice(i, i + o);
    return Mt.exports.free(n), Mt.exports.free(i), r;
  }
}
const Oi = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", Ss = /* @__PURE__ */ new WeakMap();
let Ts = 0, vs;
class Ft extends Nt {
  constructor(e) {
    super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new NA(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn(
      'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
    );
  }
  setTranscoderPath(e) {
    return this.transcoderPath = e, this;
  }
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  async detectSupportAsync(e) {
    return this.workerConfig = {
      astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
      etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
    }, this;
  }
  detectSupport(e) {
    return e.isWebGPURenderer === !0 ? this.workerConfig = {
      astcSupported: e.hasFeature("texture-compression-astc"),
      etc1Supported: e.hasFeature("texture-compression-etc1"),
      etc2Supported: e.hasFeature("texture-compression-etc2"),
      dxtSupported: e.hasFeature("texture-compression-bc"),
      bptcSupported: e.hasFeature("texture-compression-bptc"),
      pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
    } : this.workerConfig = {
      astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    }, this;
  }
  init() {
    if (!this.transcoderPending) {
      const e = new ft(this.manager);
      e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"), s = new ft(this.manager);
      s.setPath(this.transcoderPath), s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials);
      const n = s.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([t, n]).then(([i, o]) => {
        const r = Ft.BasisWorker.toString(), a = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(Ft.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(Ft.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(Ft.BasisFormat),
          "/* basis_transcoder.js */",
          i,
          "/* worker */",
          r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([a])), this.transcoderBinary = o, this.workerPool.setWorkerCreator(() => {
          const c = new Worker(this.workerSourceURL), l = this.transcoderBinary.slice(0);
          return c.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: l }, [l]), c;
        });
      }), Ts > 0 && console.warn(
        "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
      ), Ts++;
    }
    return this.transcoderPending;
  }
  load(e, t, s, n) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const i = new ft(this.manager);
    i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials), i.load(e, (o) => {
      this.parse(o, t, n);
    }, s, n);
  }
  parse(e, t, s) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    if (Ss.has(e))
      return Ss.get(e).promise.then(t).catch(s);
    this._createTexture(e).then((n) => t ? t(n) : null).catch(s);
  }
  _createTextureFrom(e, t) {
    const { faces: s, width: n, height: i, format: o, type: r, error: a, dfdFlags: c } = e;
    if (r === "error")
      return Promise.reject(a);
    let l;
    if (t.faceCount === 6)
      l = new ba(s, o, pt);
    else {
      const h = s[0].mipmaps;
      l = t.layerCount > 1 ? new Ea(h, n, i, t.layerCount, o, pt) : new Gn(h, n, i, o, pt);
    }
    return l.minFilter = s[0].mipmaps.length === 1 ? mt : ps, l.magFilter = mt, l.generateMipmaps = !1, l.needsUpdate = !0, l.colorSpace = cr(t), l.premultiplyAlpha = !!(c & GA), l;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(e, t = {}) {
    const s = zA(new Uint8Array(e));
    if (s.vkFormat !== jA)
      return JA(s);
    const n = t, i = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: n }, [e])).then((o) => this._createTextureFrom(o.data, s));
    return Ss.set(e, { promise: i }), i;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Ts--, this;
  }
}
Ft.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
Ft.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
Ft.EngineFormat = {
  RGBAFormat: Kt,
  RGBA_ASTC_4x4_Format: Uo,
  RGBA_BPTC_Format: Ca,
  RGBA_ETC2_EAC_Format: Ba,
  RGBA_PVRTC_4BPPV1_Format: wa,
  RGBA_S3TC_DXT5_Format: ya,
  RGB_ETC1_Format: Qa,
  RGB_ETC2_Format: xa,
  RGB_PVRTC_4BPPV1_Format: Sa,
  RGBA_S3TC_DXT1_Format: Ta
};
Ft.BasisWorker = function() {
  let A, e, t;
  const s = _EngineFormat, n = _TranscoderFormat, i = _BasisFormat;
  self.addEventListener("message", function(p) {
    const m = p.data;
    switch (m.type) {
      case "init":
        A = m.config, o(m.transcoderBinary);
        break;
      case "transcode":
        e.then(() => {
          try {
            const { faces: I, buffers: b, width: B, height: E, hasAlpha: w, format: Q, dfdFlags: R } = r(m.buffer);
            self.postMessage({ type: "transcode", id: m.id, faces: I, width: B, height: E, hasAlpha: w, format: Q, dfdFlags: R }, b);
          } catch (I) {
            console.error(I), self.postMessage({ type: "error", id: m.id, error: I.message });
          }
        });
        break;
    }
  });
  function o(p) {
    e = new Promise((m) => {
      t = { wasmBinary: p, onRuntimeInitialized: m }, BASIS(t);
    }).then(() => {
      t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
    });
  }
  function r(p) {
    const m = new t.KTX2File(new Uint8Array(p));
    function I() {
      m.close(), m.delete();
    }
    if (!m.isValid())
      throw I(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    const b = m.isUASTC() ? i.UASTC_4x4 : i.ETC1S, B = m.getWidth(), E = m.getHeight(), w = m.getLayers() || 1, Q = m.getLevels(), R = m.getFaces(), _ = m.getHasAlpha(), x = m.getDFDFlags(), { transcoderFormat: T, engineFormat: L } = h(b, B, E, _);
    if (!B || !E || !Q)
      throw I(), new Error("THREE.KTX2Loader:	Invalid texture");
    if (!m.startTranscoding())
      throw I(), new Error("THREE.KTX2Loader: .startTranscoding failed");
    const N = [], O = [];
    for (let Z = 0; Z < R; Z++) {
      const U = [];
      for (let q = 0; q < Q; q++) {
        const H = [];
        let K, ee;
        for (let ie = 0; ie < w; ie++) {
          const le = m.getImageLevelInfo(q, ie, Z);
          Z === 0 && q === 0 && ie === 0 && (le.origWidth % 4 !== 0 || le.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), Q > 1 ? (K = le.origWidth, ee = le.origHeight) : (K = le.width, ee = le.height);
          const ae = new Uint8Array(m.getImageTranscodedSizeInBytes(q, ie, 0, T));
          if (!m.transcodeImage(ae, q, ie, Z, T, 0, -1, -1))
            throw I(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
          H.push(ae);
        }
        const te = d(H);
        U.push({ data: te, width: K, height: ee }), O.push(te.buffer);
      }
      N.push({ mipmaps: U, width: B, height: E, format: L });
    }
    return I(), { faces: N, buffers: O, width: B, height: E, hasAlpha: _, format: L, dfdFlags: x };
  }
  const a = [
    {
      if: "astcSupported",
      basisFormat: [i.UASTC_4x4],
      transcoderFormat: [n.ASTC_4x4, n.ASTC_4x4],
      engineFormat: [s.RGBA_ASTC_4x4_Format, s.RGBA_ASTC_4x4_Format],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    },
    {
      if: "bptcSupported",
      basisFormat: [i.ETC1S, i.UASTC_4x4],
      transcoderFormat: [n.BC7_M5, n.BC7_M5],
      engineFormat: [s.RGBA_BPTC_Format, s.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    },
    {
      if: "dxtSupported",
      basisFormat: [i.ETC1S, i.UASTC_4x4],
      transcoderFormat: [n.BC1, n.BC3],
      engineFormat: [s.RGBA_S3TC_DXT1_Format, s.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    },
    {
      if: "etc2Supported",
      basisFormat: [i.ETC1S, i.UASTC_4x4],
      transcoderFormat: [n.ETC1, n.ETC2],
      engineFormat: [s.RGB_ETC2_Format, s.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    },
    {
      if: "etc1Supported",
      basisFormat: [i.ETC1S, i.UASTC_4x4],
      transcoderFormat: [n.ETC1],
      engineFormat: [s.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    },
    {
      if: "pvrtcSupported",
      basisFormat: [i.ETC1S, i.UASTC_4x4],
      transcoderFormat: [n.PVRTC1_4_RGB, n.PVRTC1_4_RGBA],
      engineFormat: [s.RGB_PVRTC_4BPPV1_Format, s.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    }
  ], c = a.sort(function(p, m) {
    return p.priorityETC1S - m.priorityETC1S;
  }), l = a.sort(function(p, m) {
    return p.priorityUASTC - m.priorityUASTC;
  });
  function h(p, m, I, b) {
    let B, E;
    const w = p === i.ETC1S ? c : l;
    for (let Q = 0; Q < w.length; Q++) {
      const R = w[Q];
      if (A[R.if] && R.basisFormat.includes(p) && !(b && R.transcoderFormat.length < 2) && !(R.needsPowerOfTwo && !(g(m) && g(I))))
        return B = R.transcoderFormat[b ? 1 : 0], E = R.engineFormat[b ? 1 : 0], { transcoderFormat: B, engineFormat: E };
    }
    return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), B = n.RGBA32, E = s.RGBAFormat, { transcoderFormat: B, engineFormat: E };
  }
  function g(p) {
    return p <= 2 ? !0 : (p & p - 1) === 0 && p !== 0;
  }
  function d(p) {
    if (p.length === 1)
      return p[0];
    let m = 0;
    for (let B = 0; B < p.length; B++) {
      const E = p[B];
      m += E.byteLength;
    }
    const I = new Uint8Array(m);
    let b = 0;
    for (let B = 0; B < p.length; B++) {
      const E = p[B];
      I.set(E, b), b += E.byteLength;
    }
    return I;
  }
};
const YA = /* @__PURE__ */ new Set([Kt, Mn, dn]), Rs = {
  [or]: Kt,
  [nr]: Kt,
  [Zo]: Kt,
  [$o]: Kt,
  [ir]: Mn,
  [tr]: Mn,
  [Wo]: Mn,
  [Xo]: Mn,
  [sr]: dn,
  [er]: dn,
  [Vo]: dn,
  [Jo]: dn,
  [Ar]: Uo,
  [ar]: Ri,
  [rr]: Ri
}, _s = {
  [or]: St,
  [nr]: st,
  [Zo]: pt,
  [$o]: pt,
  [ir]: St,
  [tr]: st,
  [Wo]: pt,
  [Xo]: pt,
  [sr]: St,
  [er]: st,
  [Vo]: pt,
  [Jo]: pt,
  [Ar]: st,
  [ar]: pt,
  [rr]: pt
};
async function JA(A) {
  const { vkFormat: e } = A;
  if (Rs[e] === void 0)
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  let t;
  A.supercompressionScheme === Ui && (vs || (vs = new Promise(async (i) => {
    const o = new KA();
    await o.init(), i(o);
  })), t = await vs);
  const s = [];
  for (let i = 0; i < A.levels.length; i++) {
    const o = Math.max(1, A.pixelWidth >> i), r = Math.max(1, A.pixelHeight >> i), a = A.pixelDepth ? Math.max(1, A.pixelDepth >> i) : 0, c = A.levels[i];
    let l;
    if (A.supercompressionScheme === UA)
      l = c.levelData;
    else if (A.supercompressionScheme === Ui)
      l = t.decode(c.levelData, c.uncompressedByteLength);
    else
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    let h;
    _s[e] === St ? h = new Float32Array(
      l.buffer,
      l.byteOffset,
      l.byteLength / Float32Array.BYTES_PER_ELEMENT
    ) : _s[e] === st ? h = new Uint16Array(
      l.buffer,
      l.byteOffset,
      l.byteLength / Uint16Array.BYTES_PER_ELEMENT
    ) : h = l, s.push({
      data: h,
      width: o,
      height: r,
      depth: a
    });
  }
  let n;
  if (YA.has(Rs[e]))
    n = A.pixelDepth === 0 ? new va(s[0].data, A.pixelWidth, A.pixelHeight) : new Ra(s[0].data, A.pixelWidth, A.pixelHeight, A.pixelDepth);
  else {
    if (A.pixelDepth > 0)
      throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    n = new Gn(s, A.pixelWidth, A.pixelHeight);
  }
  return n.mipmaps = s, n.type = _s[e], n.format = Rs[e], n.colorSpace = cr(A), n.needsUpdate = !0, Promise.resolve(n);
}
function cr(A) {
  const e = A.dataFormatDescriptor[0];
  return e.colorPrimaries === OA ? e.transferFunction === Gi ? ge : We : e.colorPrimaries === HA ? e.transferFunction === Gi ? _a : Da : e.colorPrimaries === PA ? gs : (console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), gs);
}
class Ih extends Ma {
  constructor(e, t = {}) {
    const s = t.font;
    if (s === void 0)
      super();
    else {
      const n = s.generateShapes(e, t.size);
      t.depth === void 0 && t.height !== void 0 && console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead"), t.depth = t.depth !== void 0 ? t.depth : t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(n, t);
    }
    this.type = "TextGeometry";
  }
}
class bh extends Nt {
  constructor(e) {
    super(e);
  }
  load(e, t, s, n) {
    const i = this, o = new ft(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(r) {
      const a = i.parse(JSON.parse(r));
      t && t(a);
    }, s, n);
  }
  parse(e) {
    return new VA(e);
  }
}
class VA {
  constructor(e) {
    this.isFont = !0, this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100) {
    const s = [], n = WA(e, t, this.data);
    for (let i = 0, o = n.length; i < o; i++)
      s.push(...n[i].toShapes());
    return s;
  }
}
function WA(A, e, t) {
  const s = Array.from(A), n = e / t.resolution, i = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n, o = [];
  let r = 0, a = 0;
  for (let c = 0; c < s.length; c++) {
    const l = s[c];
    if (l === `
`)
      r = 0, a -= i;
    else {
      const h = XA(l, n, r, a, t);
      r += h.offsetX, o.push(h.path);
    }
  }
  return o;
}
function XA(A, e, t, s, n) {
  const i = n.glyphs[A] || n.glyphs["?"];
  if (!i) {
    console.error('THREE.Font: character "' + A + '" does not exists in font family ' + n.familyName + ".");
    return;
  }
  const o = new ka();
  let r, a, c, l, h, g, d, p;
  if (i.o) {
    const m = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let I = 0, b = m.length; I < b; )
      switch (m[I++]) {
        case "m":
          r = m[I++] * e + t, a = m[I++] * e + s, o.moveTo(r, a);
          break;
        case "l":
          r = m[I++] * e + t, a = m[I++] * e + s, o.lineTo(r, a);
          break;
        case "q":
          c = m[I++] * e + t, l = m[I++] * e + s, h = m[I++] * e + t, g = m[I++] * e + s, o.quadraticCurveTo(h, g, c, l);
          break;
        case "b":
          c = m[I++] * e + t, l = m[I++] * e + s, h = m[I++] * e + t, g = m[I++] * e + s, d = m[I++] * e + t, p = m[I++] * e + s, o.bezierCurveTo(h, g, d, p, c, l);
          break;
      }
  }
  return { offsetX: i.ha * e, path: o };
}
const Xt = new Ii(), He = new P(), jt = new P(), we = new Te(), Hi = {
  X: new P(1, 0, 0),
  Y: new P(0, 1, 0),
  Z: new P(0, 0, 1)
}, Ds = { type: "change" }, ji = { type: "mouseDown", mode: null }, qi = { type: "mouseUp", mode: null }, zi = { type: "objectChange" };
class Eh extends Go {
  constructor(e, t = null) {
    super(void 0, t);
    const s = new sc(this);
    this._root = s;
    const n = new ic();
    this._gizmo = n, s.add(n);
    const i = new oc();
    this._plane = i, s.add(i);
    const o = this;
    function r(E, w) {
      let Q = w;
      Object.defineProperty(o, E, {
        get: function() {
          return Q !== void 0 ? Q : w;
        },
        set: function(R) {
          Q !== R && (Q = R, i[E] = R, n[E] = R, o.dispatchEvent({ type: E + "-changed", value: R }), o.dispatchEvent(Ds));
        }
      }), o[E] = w, i[E] = w, n[E] = w;
    }
    r("camera", e), r("object", void 0), r("enabled", !0), r("axis", null), r("mode", "translate"), r("translationSnap", null), r("rotationSnap", null), r("scaleSnap", null), r("space", "world"), r("size", 1), r("dragging", !1), r("showX", !0), r("showY", !0), r("showZ", !0);
    const a = new P(), c = new P(), l = new Te(), h = new Te(), g = new P(), d = new Te(), p = new P(), m = new P(), I = new P(), b = 0, B = new P();
    r("worldPosition", a), r("worldPositionStart", c), r("worldQuaternion", l), r("worldQuaternionStart", h), r("cameraPosition", g), r("cameraQuaternion", d), r("pointStart", p), r("pointEnd", m), r("rotationAxis", I), r("rotationAngle", b), r("eye", B), this._offset = new P(), this._startNorm = new P(), this._endNorm = new P(), this._cameraScale = new P(), this._parentPosition = new P(), this._parentQuaternion = new Te(), this._parentQuaternionInv = new Te(), this._parentScale = new P(), this._worldScaleStart = new P(), this._worldQuaternionInv = new Te(), this._worldScale = new P(), this._positionStart = new P(), this._quaternionStart = new Te(), this._scaleStart = new P(), this._getPointer = ZA.bind(this), this._onPointerDown = ec.bind(this), this._onPointerHover = $A.bind(this), this._onPointerMove = tc.bind(this), this._onPointerUp = nc.bind(this), t !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    e !== null && Xt.setFromCamera(e, this.camera);
    const t = Ms(this._gizmo.picker[this.mode], Xt);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && Xt.setFromCamera(e, this.camera);
      const t = Ms(this._plane, Xt, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, ji.mode = this.mode, this.dispatchEvent(ji);
    }
  }
  pointerMove(e) {
    const t = this.axis, s = this.mode, n = this.object;
    let i = this.space;
    if (s === "scale" ? i = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (i = "world"), n === void 0 || t === null || this.dragging === !1 || e !== null && e.button !== -1)
      return;
    e !== null && Xt.setFromCamera(e, this.camera);
    const o = Ms(this._plane, Xt, !0);
    if (o) {
      if (this.pointEnd.copy(o.point).sub(this.worldPositionStart), s === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), i === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), i === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), n.position.copy(this._offset).add(this._positionStart), this.translationSnap && (i === "local" && (n.position.applyQuaternion(we.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.position.applyQuaternion(this._quaternionStart)), i === "world" && (n.parent && n.position.add(He.setFromMatrixPosition(n.parent.matrixWorld)), t.search("X") !== -1 && (n.position.x = Math.round(n.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (n.position.y = Math.round(n.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (n.position.z = Math.round(n.position.z / this.translationSnap) * this.translationSnap), n.parent && n.position.sub(He.setFromMatrixPosition(n.parent.matrixWorld))));
      else if (s === "scale") {
        if (t.search("XYZ") !== -1) {
          let r = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (r *= -1), jt.set(r, r, r);
        } else
          He.copy(this.pointStart), jt.copy(this.pointEnd), He.applyQuaternion(this._worldQuaternionInv), jt.applyQuaternion(this._worldQuaternionInv), jt.divide(He), t.search("X") === -1 && (jt.x = 1), t.search("Y") === -1 && (jt.y = 1), t.search("Z") === -1 && (jt.z = 1);
        n.scale.copy(this._scaleStart).multiply(jt), this.scaleSnap && (t.search("X") !== -1 && (n.scale.x = Math.round(n.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (n.scale.y = Math.round(n.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (n.scale.z = Math.round(n.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (s === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const r = 20 / this.worldPosition.distanceTo(He.setFromMatrixPosition(this.camera.matrixWorld));
        let a = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(He.copy(this.rotationAxis).cross(this.eye)) * r) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(Hi[t]), He.copy(Hi[t]), i === "local" && He.applyQuaternion(this.worldQuaternion), He.cross(this.eye), He.length() === 0 ? a = !0 : this.rotationAngle = this._offset.dot(He.normalize()) * r), (t === "E" || a) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), i === "local" && t !== "E" && t !== "XYZE" ? (n.quaternion.copy(this._quaternionStart), n.quaternion.multiply(we.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), n.quaternion.copy(we.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), n.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Ds), this.dispatchEvent(zi);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (qi.mode = this.mode, this.dispatchEvent(qi)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  // Set current object
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Ds), this.dispatchEvent(zi), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Xt;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function ZA(A) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: A.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (A.clientX - e.left) / e.width * 2 - 1,
      y: -(A.clientY - e.top) / e.height * 2 + 1,
      button: A.button
    };
  }
}
function $A(A) {
  if (this.enabled)
    switch (A.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(A));
        break;
    }
}
function ec(A) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(A.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(A)), this.pointerDown(this._getPointer(A)));
}
function tc(A) {
  this.enabled && this.pointerMove(this._getPointer(A));
}
function nc(A) {
  this.enabled && (this.domElement.releasePointerCapture(A.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(A)));
}
function Ms(A, e, t) {
  const s = e.intersectObject(A, !0);
  for (let n = 0; n < s.length; n++)
    if (s[n].object.visible || t)
      return s[n];
  return !1;
}
const Jn = new zt(), me = new P(0, 1, 0), Ki = new P(0, 0, 0), Yi = new ue(), Vn = new Te(), rs = new Te(), Et = new P(), Ji = new ue(), kn = new P(1, 0, 0), $t = new P(0, 1, 0), Fn = new P(0, 0, 1), Wn = new P(), Qn = new P(), xn = new P();
class sc extends xt {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const t = this.controls;
    t.object !== void 0 && (t.object.updateMatrixWorld(), t.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : t.object.parent.matrixWorld.decompose(t._parentPosition, t._parentQuaternion, t._parentScale), t.object.matrixWorld.decompose(t.worldPosition, t.worldQuaternion, t._worldScale), t._parentQuaternionInv.copy(t._parentQuaternion).invert(), t._worldQuaternionInv.copy(t.worldQuaternion).invert()), t.camera.updateMatrixWorld(), t.camera.matrixWorld.decompose(t.cameraPosition, t.cameraQuaternion, t._cameraScale), t.camera.isOrthographicCamera ? t.camera.getWorldDirection(t.eye).negate() : t.eye.copy(t.cameraPosition).sub(t.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
}
class ic extends xt {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new Qt({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new Lt({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), s = e.clone();
    s.opacity = 0.15;
    const n = t.clone();
    n.opacity = 0.5;
    const i = e.clone();
    i.color.setHex(16711680);
    const o = e.clone();
    o.color.setHex(65280);
    const r = e.clone();
    r.color.setHex(255);
    const a = e.clone();
    a.color.setHex(16711680), a.opacity = 0.5;
    const c = e.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const l = e.clone();
    l.color.setHex(255), l.opacity = 0.5;
    const h = e.clone();
    h.opacity = 0.25;
    const g = e.clone();
    g.color.setHex(16776960), g.opacity = 0.25, e.clone().color.setHex(16776960);
    const p = e.clone();
    p.color.setHex(7895160);
    const m = new Ke(0, 0.04, 0.1, 12);
    m.translate(0, 0.05, 0);
    const I = new je(0.08, 0.08, 0.08);
    I.translate(0, 0.04, 0);
    const b = new ut();
    b.setAttribute("position", new ke([0, 0, 0, 1, 0, 0], 3));
    const B = new Ke(75e-4, 75e-4, 0.5, 3);
    B.translate(0, 0.25, 0);
    function E(q, H) {
      const K = new Cn(q, 75e-4, 3, 64, H * Math.PI * 2);
      return K.rotateY(Math.PI / 2), K.rotateX(Math.PI / 2), K;
    }
    function w() {
      const q = new ut();
      return q.setAttribute("position", new ke([0, 0, 0, 1, 1, 1], 3)), q;
    }
    const Q = {
      X: [
        [new z(m, i), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new z(m, i), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new z(B, i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new z(m, o), [0, 0.5, 0]],
        [new z(m, o), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new z(B, o)]
      ],
      Z: [
        [new z(m, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new z(m, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new z(B, r), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new z(new Yn(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new z(new je(0.15, 0.15, 0.01), l.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new z(new je(0.15, 0.15, 0.01), a.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new z(new je(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, R = {
      X: [
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new z(new Ke(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new z(new Yn(0.2, 0), s)]
      ],
      XY: [
        [new z(new je(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new z(new je(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new z(new je(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, _ = {
      START: [
        [new z(new Yn(0.01, 2), n), null, null, null, "helper"]
      ],
      END: [
        [new z(new Yn(0.01, 2), n), null, null, null, "helper"]
      ],
      DELTA: [
        [new dt(w(), n), null, null, null, "helper"]
      ],
      X: [
        [new dt(b, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new dt(b, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new dt(b, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, x = {
      XYZE: [
        [new z(E(0.5, 1), p), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new z(E(0.5, 0.5), i)]
      ],
      Y: [
        [new z(E(0.5, 0.5), o), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new z(E(0.5, 0.5), r), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new z(E(0.75, 1), g), null, [0, Math.PI / 2, 0]]
      ]
    }, T = {
      AXIS: [
        [new dt(b, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, L = {
      XYZE: [
        [new z(new ci(0.25, 10, 8), s)]
      ],
      X: [
        [new z(new Cn(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new z(new Cn(0.5, 0.1, 4, 24), s), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new z(new Cn(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new z(new Cn(0.75, 0.1, 2, 24), s)]
      ]
    }, N = {
      X: [
        [new z(I, i), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new z(B, i), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new z(I, i), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new z(I, o), [0, 0.5, 0]],
        [new z(B, o)],
        [new z(I, o), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new z(I, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new z(B, r), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new z(I, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new z(new je(0.15, 0.15, 0.01), l), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new z(new je(0.15, 0.15, 0.01), a), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new z(new je(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new z(new je(0.1, 0.1, 0.1), h.clone())]
      ]
    }, O = {
      X: [
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new z(new Ke(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new z(new Ke(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new z(new je(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new z(new je(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new z(new je(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new z(new je(0.2, 0.2, 0.2), s), [0, 0, 0]]
      ]
    }, Z = {
      X: [
        [new dt(b, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new dt(b, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new dt(b, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function U(q) {
      const H = new xt();
      for (const K in q)
        for (let ee = q[K].length; ee--; ) {
          const te = q[K][ee][0].clone(), ie = q[K][ee][1], le = q[K][ee][2], ae = q[K][ee][3], he = q[K][ee][4];
          te.name = K, te.tag = he, ie && te.position.set(ie[0], ie[1], ie[2]), le && te.rotation.set(le[0], le[1], le[2]), ae && te.scale.set(ae[0], ae[1], ae[2]), te.updateMatrix();
          const Qe = te.geometry.clone();
          Qe.applyMatrix4(te.matrix), te.geometry = Qe, te.renderOrder = 1 / 0, te.position.set(0, 0, 0), te.rotation.set(0, 0, 0), te.scale.set(1, 1, 1), H.add(te);
        }
      return H;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = U(Q)), this.add(this.gizmo.rotate = U(x)), this.add(this.gizmo.scale = U(N)), this.add(this.picker.translate = U(R)), this.add(this.picker.rotate = U(L)), this.add(this.picker.scale = U(O)), this.add(this.helper.translate = U(_)), this.add(this.helper.rotate = U(T)), this.add(this.helper.scale = U(Z)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const s = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : rs;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let n = [];
    n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      o.visible = !0, o.rotation.set(0, 0, 0), o.position.copy(this.worldPosition);
      let r;
      if (this.camera.isOrthographicCamera ? r = (this.camera.top - this.camera.bottom) / this.camera.zoom : r = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), o.scale.set(1, 1, 1).multiplyScalar(r * this.size / 4), o.tag === "helper") {
        o.visible = !1, o.name === "AXIS" ? (o.visible = !!this.axis, this.axis === "X" && (we.setFromEuler(Jn.set(0, 0, 0)), o.quaternion.copy(s).multiply(we), Math.abs(me.copy(kn).applyQuaternion(s).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "Y" && (we.setFromEuler(Jn.set(0, 0, Math.PI / 2)), o.quaternion.copy(s).multiply(we), Math.abs(me.copy($t).applyQuaternion(s).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "Z" && (we.setFromEuler(Jn.set(0, Math.PI / 2, 0)), o.quaternion.copy(s).multiply(we), Math.abs(me.copy(Fn).applyQuaternion(s).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "XYZE" && (we.setFromEuler(Jn.set(0, Math.PI / 2, 0)), me.copy(this.rotationAxis), o.quaternion.setFromRotationMatrix(Yi.lookAt(Ki, me, $t)), o.quaternion.multiply(we), o.visible = this.dragging), this.axis === "E" && (o.visible = !1)) : o.name === "START" ? (o.position.copy(this.worldPositionStart), o.visible = this.dragging) : o.name === "END" ? (o.position.copy(this.worldPosition), o.visible = this.dragging) : o.name === "DELTA" ? (o.position.copy(this.worldPositionStart), o.quaternion.copy(this.worldQuaternionStart), He.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), He.applyQuaternion(this.worldQuaternionStart.clone().invert()), o.scale.copy(He), o.visible = this.dragging) : (o.quaternion.copy(s), this.dragging ? o.position.copy(this.worldPositionStart) : o.position.copy(this.worldPosition), this.axis && (o.visible = this.axis.search(o.name) !== -1));
        continue;
      }
      o.quaternion.copy(s), this.mode === "translate" || this.mode === "scale" ? (o.name === "X" && Math.abs(me.copy(kn).applyQuaternion(s).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "Y" && Math.abs(me.copy($t).applyQuaternion(s).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "Z" && Math.abs(me.copy(Fn).applyQuaternion(s).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "XY" && Math.abs(me.copy(Fn).applyQuaternion(s).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "YZ" && Math.abs(me.copy(kn).applyQuaternion(s).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "XZ" && Math.abs(me.copy($t).applyQuaternion(s).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1)) : this.mode === "rotate" && (Vn.copy(s), me.copy(this.eye).applyQuaternion(we.copy(s).invert()), o.name.search("E") !== -1 && o.quaternion.setFromRotationMatrix(Yi.lookAt(this.eye, Ki, $t)), o.name === "X" && (we.setFromAxisAngle(kn, Math.atan2(-me.y, me.z)), we.multiplyQuaternions(Vn, we), o.quaternion.copy(we)), o.name === "Y" && (we.setFromAxisAngle($t, Math.atan2(me.x, me.z)), we.multiplyQuaternions(Vn, we), o.quaternion.copy(we)), o.name === "Z" && (we.setFromAxisAngle(Fn, Math.atan2(me.y, me.x)), we.multiplyQuaternions(Vn, we), o.quaternion.copy(we))), o.visible = o.visible && (o.name.indexOf("X") === -1 || this.showX), o.visible = o.visible && (o.name.indexOf("Y") === -1 || this.showY), o.visible = o.visible && (o.name.indexOf("Z") === -1 || this.showZ), o.visible = o.visible && (o.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), o.material._color = o.material._color || o.material.color.clone(), o.material._opacity = o.material._opacity || o.material.opacity, o.material.color.copy(o.material._color), o.material.opacity = o.material._opacity, this.enabled && this.axis && (o.name === this.axis || this.axis.split("").some(function(a) {
        return o.name === a;
      })) && (o.material.color.setHex(16776960), o.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class oc extends z {
  constructor() {
    super(
      new bi(1e5, 1e5, 2, 2),
      new Qt({ visible: !1, wireframe: !0, side: gi, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), Wn.copy(kn).applyQuaternion(t === "local" ? this.worldQuaternion : rs), Qn.copy($t).applyQuaternion(t === "local" ? this.worldQuaternion : rs), xn.copy(Fn).applyQuaternion(t === "local" ? this.worldQuaternion : rs), me.copy(Qn), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            me.copy(this.eye).cross(Wn), Et.copy(Wn).cross(me);
            break;
          case "Y":
            me.copy(this.eye).cross(Qn), Et.copy(Qn).cross(me);
            break;
          case "Z":
            me.copy(this.eye).cross(xn), Et.copy(xn).cross(me);
            break;
          case "XY":
            Et.copy(xn);
            break;
          case "YZ":
            Et.copy(Wn);
            break;
          case "XZ":
            me.copy(xn), Et.copy(Qn);
            break;
          case "XYZ":
          case "E":
            Et.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Et.set(0, 0, 0);
    }
    Et.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (Ji.lookAt(He.set(0, 0, 0), Et, me), this.quaternion.setFromRotationMatrix(Ji)), super.updateMatrixWorld(e);
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/
var Re = Uint8Array, it = Uint16Array, Ei = Int32Array, ms = new Re([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Is = new Re([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), si = new Re([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), lr = function(A, e) {
  for (var t = new it(31), s = 0; s < 31; ++s)
    t[s] = e += 1 << A[s - 1];
  for (var n = new Ei(t[30]), s = 1; s < 30; ++s)
    for (var i = t[s]; i < t[s + 1]; ++i)
      n[i] = i - t[s] << 5 | s;
  return { b: t, r: n };
}, hr = lr(ms, 2), ur = hr.b, ii = hr.r;
ur[28] = 258, ii[258] = 28;
var gr = lr(Is, 0), rc = gr.b, Vi = gr.r, oi = new it(32768);
for (var Be = 0; Be < 32768; ++Be) {
  var qt = (Be & 43690) >> 1 | (Be & 21845) << 1;
  qt = (qt & 52428) >> 2 | (qt & 13107) << 2, qt = (qt & 61680) >> 4 | (qt & 3855) << 4, oi[Be] = ((qt & 65280) >> 8 | (qt & 255) << 8) >> 1;
}
var Tt = function(A, e, t) {
  for (var s = A.length, n = 0, i = new it(e); n < s; ++n)
    A[n] && ++i[A[n] - 1];
  var o = new it(e);
  for (n = 1; n < e; ++n)
    o[n] = o[n - 1] + i[n - 1] << 1;
  var r;
  if (t) {
    r = new it(1 << e);
    var a = 15 - e;
    for (n = 0; n < s; ++n)
      if (A[n])
        for (var c = n << 4 | A[n], l = e - A[n], h = o[A[n] - 1]++ << l, g = h | (1 << l) - 1; h <= g; ++h)
          r[oi[h] >> a] = c;
  } else
    for (r = new it(s), n = 0; n < s; ++n)
      A[n] && (r[n] = oi[o[A[n] - 1]++] >> 15 - A[n]);
  return r;
}, Yt = new Re(288);
for (var Be = 0; Be < 144; ++Be)
  Yt[Be] = 8;
for (var Be = 144; Be < 256; ++Be)
  Yt[Be] = 9;
for (var Be = 256; Be < 280; ++Be)
  Yt[Be] = 7;
for (var Be = 280; Be < 288; ++Be)
  Yt[Be] = 8;
var On = new Re(32);
for (var Be = 0; Be < 32; ++Be)
  On[Be] = 5;
var ac = /* @__PURE__ */ Tt(Yt, 9, 0), Ac = /* @__PURE__ */ Tt(Yt, 9, 1), cc = /* @__PURE__ */ Tt(On, 5, 0), lc = /* @__PURE__ */ Tt(On, 5, 1), ks = function(A) {
  for (var e = A[0], t = 1; t < A.length; ++t)
    A[t] > e && (e = A[t]);
  return e;
}, gt = function(A, e, t) {
  var s = e / 8 | 0;
  return (A[s] | A[s + 1] << 8) >> (e & 7) & t;
}, Fs = function(A, e) {
  var t = e / 8 | 0;
  return (A[t] | A[t + 1] << 8 | A[t + 2] << 16) >> (e & 7);
}, Ci = function(A) {
  return (A + 7) / 8 | 0;
}, Bi = function(A, e, t) {
  return (e == null || e < 0) && (e = 0), (t == null || t > A.length) && (t = A.length), new Re(A.subarray(e, t));
}, hc = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], Je = function(A, e, t) {
  var s = new Error(e || hc[A]);
  if (s.code = A, Error.captureStackTrace && Error.captureStackTrace(s, Je), !t)
    throw s;
  return s;
}, uc = function(A, e, t, s) {
  var n = A.length, i = s ? s.length : 0;
  if (!n || e.f && !e.l)
    return t || new Re(0);
  var o = !t, r = o || e.i != 2, a = e.i;
  o && (t = new Re(n * 3));
  var c = function(Gt) {
    var Jt = t.length;
    if (Gt > Jt) {
      var Rt = new Re(Math.max(Jt * 2, Gt));
      Rt.set(t), t = Rt;
    }
  }, l = e.f || 0, h = e.p || 0, g = e.b || 0, d = e.l, p = e.d, m = e.m, I = e.n, b = n * 8;
  do {
    if (!d) {
      l = gt(A, h, 1);
      var B = gt(A, h + 1, 3);
      if (h += 3, B)
        if (B == 1)
          d = Ac, p = lc, m = 9, I = 5;
        else if (B == 2) {
          var R = gt(A, h, 31) + 257, _ = gt(A, h + 10, 15) + 4, x = R + gt(A, h + 5, 31) + 1;
          h += 14;
          for (var T = new Re(x), L = new Re(19), N = 0; N < _; ++N)
            L[si[N]] = gt(A, h + N * 3, 7);
          h += _ * 3;
          for (var O = ks(L), Z = (1 << O) - 1, U = Tt(L, O, 1), N = 0; N < x; ) {
            var q = U[gt(A, h, Z)];
            h += q & 15;
            var E = q >> 4;
            if (E < 16)
              T[N++] = E;
            else {
              var H = 0, K = 0;
              for (E == 16 ? (K = 3 + gt(A, h, 3), h += 2, H = T[N - 1]) : E == 17 ? (K = 3 + gt(A, h, 7), h += 3) : E == 18 && (K = 11 + gt(A, h, 127), h += 7); K--; )
                T[N++] = H;
            }
          }
          var ee = T.subarray(0, R), te = T.subarray(R);
          m = ks(ee), I = ks(te), d = Tt(ee, m, 1), p = Tt(te, I, 1);
        } else
          Je(1);
      else {
        var E = Ci(h) + 4, w = A[E - 4] | A[E - 3] << 8, Q = E + w;
        if (Q > n) {
          a && Je(0);
          break;
        }
        r && c(g + w), t.set(A.subarray(E, Q), g), e.b = g += w, e.p = h = Q * 8, e.f = l;
        continue;
      }
      if (h > b) {
        a && Je(0);
        break;
      }
    }
    r && c(g + 131072);
    for (var ie = (1 << m) - 1, le = (1 << I) - 1, ae = h; ; ae = h) {
      var H = d[Fs(A, h) & ie], he = H >> 4;
      if (h += H & 15, h > b) {
        a && Je(0);
        break;
      }
      if (H || Je(2), he < 256)
        t[g++] = he;
      else if (he == 256) {
        ae = h, d = null;
        break;
      } else {
        var Qe = he - 254;
        if (he > 264) {
          var N = he - 257, be = ms[N];
          Qe = gt(A, h, (1 << be) - 1) + ur[N], h += be;
        }
        var Ae = p[Fs(A, h) & le], Xe = Ae >> 4;
        Ae || Je(3), h += Ae & 15;
        var te = rc[Xe];
        if (Xe > 3) {
          var be = Is[Xe];
          te += Fs(A, h) & (1 << be) - 1, h += be;
        }
        if (h > b) {
          a && Je(0);
          break;
        }
        r && c(g + 131072);
        var Ze = g + Qe;
        if (g < te) {
          var an = i - te, An = Math.min(te, Ze);
          for (an + g < 0 && Je(3); g < An; ++g)
            t[g] = s[an + g];
        }
        for (; g < Ze; ++g)
          t[g] = t[g - te];
      }
    }
    e.l = d, e.p = ae, e.b = g, e.f = l, d && (l = 1, e.m = m, e.d = p, e.n = I);
  } while (!l);
  return g != t.length && o ? Bi(t, 0, g) : t.subarray(0, g);
}, Dt = function(A, e, t) {
  t <<= e & 7;
  var s = e / 8 | 0;
  A[s] |= t, A[s + 1] |= t >> 8;
}, Sn = function(A, e, t) {
  t <<= e & 7;
  var s = e / 8 | 0;
  A[s] |= t, A[s + 1] |= t >> 8, A[s + 2] |= t >> 16;
}, Ls = function(A, e) {
  for (var t = [], s = 0; s < A.length; ++s)
    A[s] && t.push({ s, f: A[s] });
  var n = t.length, i = t.slice();
  if (!n)
    return { t: pr, l: 0 };
  if (n == 1) {
    var o = new Re(t[0].s + 1);
    return o[t[0].s] = 1, { t: o, l: 1 };
  }
  t.sort(function(Q, R) {
    return Q.f - R.f;
  }), t.push({ s: -1, f: 25001 });
  var r = t[0], a = t[1], c = 0, l = 1, h = 2;
  for (t[0] = { s: -1, f: r.f + a.f, l: r, r: a }; l != n - 1; )
    r = t[t[c].f < t[h].f ? c++ : h++], a = t[c != l && t[c].f < t[h].f ? c++ : h++], t[l++] = { s: -1, f: r.f + a.f, l: r, r: a };
  for (var g = i[0].s, s = 1; s < n; ++s)
    i[s].s > g && (g = i[s].s);
  var d = new it(g + 1), p = ri(t[l - 1], d, 0);
  if (p > e) {
    var s = 0, m = 0, I = p - e, b = 1 << I;
    for (i.sort(function(R, _) {
      return d[_.s] - d[R.s] || R.f - _.f;
    }); s < n; ++s) {
      var B = i[s].s;
      if (d[B] > e)
        m += b - (1 << p - d[B]), d[B] = e;
      else
        break;
    }
    for (m >>= I; m > 0; ) {
      var E = i[s].s;
      d[E] < e ? m -= 1 << e - d[E]++ - 1 : ++s;
    }
    for (; s >= 0 && m; --s) {
      var w = i[s].s;
      d[w] == e && (--d[w], ++m);
    }
    p = e;
  }
  return { t: new Re(d), l: p };
}, ri = function(A, e, t) {
  return A.s == -1 ? Math.max(ri(A.l, e, t + 1), ri(A.r, e, t + 1)) : e[A.s] = t;
}, Wi = function(A) {
  for (var e = A.length; e && !A[--e]; )
    ;
  for (var t = new it(++e), s = 0, n = A[0], i = 1, o = function(a) {
    t[s++] = a;
  }, r = 1; r <= e; ++r)
    if (A[r] == n && r != e)
      ++i;
    else {
      if (!n && i > 2) {
        for (; i > 138; i -= 138)
          o(32754);
        i > 2 && (o(i > 10 ? i - 11 << 5 | 28690 : i - 3 << 5 | 12305), i = 0);
      } else if (i > 3) {
        for (o(n), --i; i > 6; i -= 6)
          o(8304);
        i > 2 && (o(i - 3 << 5 | 8208), i = 0);
      }
      for (; i--; )
        o(n);
      i = 1, n = A[r];
    }
  return { c: t.subarray(0, s), n: e };
}, Tn = function(A, e) {
  for (var t = 0, s = 0; s < e.length; ++s)
    t += A[s] * e[s];
  return t;
}, dr = function(A, e, t) {
  var s = t.length, n = Ci(e + 2);
  A[n] = s & 255, A[n + 1] = s >> 8, A[n + 2] = A[n] ^ 255, A[n + 3] = A[n + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    A[n + i + 4] = t[i];
  return (n + 4 + s) * 8;
}, Xi = function(A, e, t, s, n, i, o, r, a, c, l) {
  Dt(e, l++, t), ++n[256];
  for (var h = Ls(n, 15), g = h.t, d = h.l, p = Ls(i, 15), m = p.t, I = p.l, b = Wi(g), B = b.c, E = b.n, w = Wi(m), Q = w.c, R = w.n, _ = new it(19), x = 0; x < B.length; ++x)
    ++_[B[x] & 31];
  for (var x = 0; x < Q.length; ++x)
    ++_[Q[x] & 31];
  for (var T = Ls(_, 7), L = T.t, N = T.l, O = 19; O > 4 && !L[si[O - 1]]; --O)
    ;
  var Z = c + 5 << 3, U = Tn(n, Yt) + Tn(i, On) + o, q = Tn(n, g) + Tn(i, m) + o + 14 + 3 * O + Tn(_, L) + 2 * _[16] + 3 * _[17] + 7 * _[18];
  if (a >= 0 && Z <= U && Z <= q)
    return dr(e, l, A.subarray(a, a + c));
  var H, K, ee, te;
  if (Dt(e, l, 1 + (q < U)), l += 2, q < U) {
    H = Tt(g, d, 0), K = g, ee = Tt(m, I, 0), te = m;
    var ie = Tt(L, N, 0);
    Dt(e, l, E - 257), Dt(e, l + 5, R - 1), Dt(e, l + 10, O - 4), l += 14;
    for (var x = 0; x < O; ++x)
      Dt(e, l + 3 * x, L[si[x]]);
    l += 3 * O;
    for (var le = [B, Q], ae = 0; ae < 2; ++ae)
      for (var he = le[ae], x = 0; x < he.length; ++x) {
        var Qe = he[x] & 31;
        Dt(e, l, ie[Qe]), l += L[Qe], Qe > 15 && (Dt(e, l, he[x] >> 5 & 127), l += he[x] >> 12);
      }
  } else
    H = ac, K = Yt, ee = cc, te = On;
  for (var x = 0; x < r; ++x) {
    var be = s[x];
    if (be > 255) {
      var Qe = be >> 18 & 31;
      Sn(e, l, H[Qe + 257]), l += K[Qe + 257], Qe > 7 && (Dt(e, l, be >> 23 & 31), l += ms[Qe]);
      var Ae = be & 31;
      Sn(e, l, ee[Ae]), l += te[Ae], Ae > 3 && (Sn(e, l, be >> 5 & 8191), l += Is[Ae]);
    } else
      Sn(e, l, H[be]), l += K[be];
  }
  return Sn(e, l, H[256]), l + K[256];
}, gc = /* @__PURE__ */ new Ei([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), pr = /* @__PURE__ */ new Re(0), dc = function(A, e, t, s, n, i) {
  var o = i.z || A.length, r = new Re(s + o + 5 * (1 + Math.ceil(o / 7e3)) + n), a = r.subarray(s, r.length - n), c = i.l, l = (i.r || 0) & 7;
  if (e) {
    l && (a[0] = i.r >> 3);
    for (var h = gc[e - 1], g = h >> 13, d = h & 8191, p = (1 << t) - 1, m = i.p || new it(32768), I = i.h || new it(p + 1), b = Math.ceil(t / 3), B = 2 * b, E = function(cn) {
      return (A[cn] ^ A[cn + 1] << b ^ A[cn + 2] << B) & p;
    }, w = new Ei(25e3), Q = new it(288), R = new it(32), _ = 0, x = 0, T = i.i || 0, L = 0, N = i.w || 0, O = 0; T + 2 < o; ++T) {
      var Z = E(T), U = T & 32767, q = I[Z];
      if (m[U] = q, I[Z] = U, N <= T) {
        var H = o - T;
        if ((_ > 7e3 || L > 24576) && (H > 423 || !c)) {
          l = Xi(A, a, 0, w, Q, R, x, L, O, T - O, l), L = _ = x = 0, O = T;
          for (var K = 0; K < 286; ++K)
            Q[K] = 0;
          for (var K = 0; K < 30; ++K)
            R[K] = 0;
        }
        var ee = 2, te = 0, ie = d, le = U - q & 32767;
        if (H > 2 && Z == E(T - le))
          for (var ae = Math.min(g, H) - 1, he = Math.min(32767, T), Qe = Math.min(258, H); le <= he && --ie && U != q; ) {
            if (A[T + ee] == A[T + ee - le]) {
              for (var be = 0; be < Qe && A[T + be] == A[T + be - le]; ++be)
                ;
              if (be > ee) {
                if (ee = be, te = le, be > ae)
                  break;
                for (var Ae = Math.min(le, be - 2), Xe = 0, K = 0; K < Ae; ++K) {
                  var Ze = T - le + K & 32767, an = m[Ze], An = Ze - an & 32767;
                  An > Xe && (Xe = An, q = Ze);
                }
              }
            }
            U = q, q = m[U], le += U - q & 32767;
          }
        if (te) {
          w[L++] = 268435456 | ii[ee] << 18 | Vi[te];
          var Gt = ii[ee] & 31, Jt = Vi[te] & 31;
          x += ms[Gt] + Is[Jt], ++Q[257 + Gt], ++R[Jt], N = T + ee, ++_;
        } else
          w[L++] = A[T], ++Q[A[T]];
      }
    }
    for (T = Math.max(T, N); T < o; ++T)
      w[L++] = A[T], ++Q[A[T]];
    l = Xi(A, a, c, w, Q, R, x, L, O, T - O, l), c || (i.r = l & 7 | a[l / 8 | 0] << 3, l -= 7, i.h = I, i.p = m, i.i = T, i.w = N);
  } else {
    for (var T = i.w || 0; T < o + c; T += 65535) {
      var Rt = T + 65535;
      Rt >= o && (a[l / 8 | 0] = c, Rt = o), l = dr(a, l + 1, A.subarray(T, Rt));
    }
    i.i = o;
  }
  return Bi(r, 0, s + Ci(l) + n);
}, pc = /* @__PURE__ */ function() {
  for (var A = new Int32Array(256), e = 0; e < 256; ++e) {
    for (var t = e, s = 9; --s; )
      t = (t & 1 && -306674912) ^ t >>> 1;
    A[e] = t;
  }
  return A;
}(), fc = function() {
  var A = -1;
  return {
    p: function(e) {
      for (var t = A, s = 0; s < e.length; ++s)
        t = pc[t & 255 ^ e[s]] ^ t >>> 8;
      A = t;
    },
    d: function() {
      return ~A;
    }
  };
}, mc = function(A, e, t, s, n) {
  if (!n && (n = { l: 1 }, e.dictionary)) {
    var i = e.dictionary.subarray(-32768), o = new Re(i.length + A.length);
    o.set(i), o.set(A, i.length), A = o, n.w = i.length;
  }
  return dc(A, e.level == null ? 6 : e.level, e.mem == null ? n.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(A.length))) * 1.5) : 20 : 12 + e.mem, t, s, n);
}, fr = function(A, e) {
  var t = {};
  for (var s in A)
    t[s] = A[s];
  for (var s in e)
    t[s] = e[s];
  return t;
}, Ge = function(A, e, t) {
  for (; t; ++e)
    A[e] = t, t >>>= 8;
}, Ic = function(A, e) {
  return ((A[0] & 15) != 8 || A[0] >> 4 > 7 || (A[0] << 8 | A[1]) % 31) && Je(6, "invalid zlib data"), (A[1] >> 5 & 1) == +!e && Je(6, "invalid zlib data: " + (A[1] & 32 ? "need" : "unexpected") + " dictionary"), (A[1] >> 3 & 4) + 2;
};
function bc(A, e) {
  return mc(A, e || {}, 0, 0);
}
function Ln(A, e) {
  return uc(A.subarray(Ic(A, e && e.dictionary), -4), { i: 2 }, e && e.out, e && e.dictionary);
}
var mr = function(A, e, t, s) {
  for (var n in A) {
    var i = A[n], o = e + n, r = s;
    Array.isArray(i) && (r = fr(s, i[1]), i = i[0]), i instanceof Re ? t[o] = [i, r] : (t[o += "/"] = [new Re(0), r], mr(i, o, t, s));
  }
}, Zi = typeof TextEncoder < "u" && /* @__PURE__ */ new TextEncoder(), Ec = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Cc = 0;
try {
  Ec.decode(pr, { stream: !0 }), Cc = 1;
} catch {
}
function $i(A, e) {
  if (e) {
    for (var t = new Re(A.length), s = 0; s < A.length; ++s)
      t[s] = A.charCodeAt(s);
    return t;
  }
  if (Zi)
    return Zi.encode(A);
  for (var n = A.length, i = new Re(A.length + (A.length >> 1)), o = 0, r = function(l) {
    i[o++] = l;
  }, s = 0; s < n; ++s) {
    if (o + 5 > i.length) {
      var a = new Re(o + 8 + (n - s << 1));
      a.set(i), i = a;
    }
    var c = A.charCodeAt(s);
    c < 128 || e ? r(c) : c < 2048 ? (r(192 | c >> 6), r(128 | c & 63)) : c > 55295 && c < 57344 ? (c = 65536 + (c & 1047552) | A.charCodeAt(++s) & 1023, r(240 | c >> 18), r(128 | c >> 12 & 63), r(128 | c >> 6 & 63), r(128 | c & 63)) : (r(224 | c >> 12), r(128 | c >> 6 & 63), r(128 | c & 63));
  }
  return Bi(i, 0, o);
}
var ai = function(A) {
  var e = 0;
  if (A)
    for (var t in A) {
      var s = A[t].length;
      s > 65535 && Je(9), e += s + 4;
    }
  return e;
}, eo = function(A, e, t, s, n, i, o, r) {
  var a = s.length, c = t.extra, l = r && r.length, h = ai(c);
  Ge(A, e, o != null ? 33639248 : 67324752), e += 4, o != null && (A[e++] = 20, A[e++] = t.os), A[e] = 20, e += 2, A[e++] = t.flag << 1 | (i < 0 && 8), A[e++] = n && 8, A[e++] = t.compression & 255, A[e++] = t.compression >> 8;
  var g = new Date(t.mtime == null ? Date.now() : t.mtime), d = g.getFullYear() - 1980;
  if ((d < 0 || d > 119) && Je(10), Ge(A, e, d << 25 | g.getMonth() + 1 << 21 | g.getDate() << 16 | g.getHours() << 11 | g.getMinutes() << 5 | g.getSeconds() >> 1), e += 4, i != -1 && (Ge(A, e, t.crc), Ge(A, e + 4, i < 0 ? -i - 2 : i), Ge(A, e + 8, t.size)), Ge(A, e + 12, a), Ge(A, e + 14, h), e += 16, o != null && (Ge(A, e, l), Ge(A, e + 6, t.attrs), Ge(A, e + 10, o), e += 14), A.set(s, e), e += a, h)
    for (var p in c) {
      var m = c[p], I = m.length;
      Ge(A, e, +p), Ge(A, e + 2, I), A.set(m, e + 4), e += 4 + I;
    }
  return l && (A.set(r, e), e += l), e;
}, Bc = function(A, e, t, s, n) {
  Ge(A, e, 101010256), Ge(A, e + 8, t), Ge(A, e + 10, t), Ge(A, e + 12, s), Ge(A, e + 16, n);
};
function Ch(A, e) {
  e || (e = {});
  var t = {}, s = [];
  mr(A, "", t, e);
  var n = 0, i = 0;
  for (var o in t) {
    var r = t[o], a = r[0], c = r[1], l = c.level == 0 ? 0 : 8, h = $i(o), g = h.length, d = c.comment, p = d && $i(d), m = p && p.length, I = ai(c.extra);
    g > 65535 && Je(11);
    var b = l ? bc(a, c) : a, B = b.length, E = fc();
    E.p(a), s.push(fr(c, {
      size: a.length,
      crc: E.d(),
      c: b,
      f: h,
      m: p,
      u: g != o.length || p && d.length != m,
      o: n,
      compression: l
    })), n += 30 + g + I + B, i += 76 + 2 * (g + I) + (m || 0) + B;
  }
  for (var w = new Re(i + 22), Q = n, R = i - n, _ = 0; _ < s.length; ++_) {
    var h = s[_];
    eo(w, h.o, h, h.f, h.u, h.c.length);
    var x = 30 + h.f.length + ai(h.extra);
    w.set(h.c, h.o + x), eo(w, n, h, h.f, h.u, h.c.length, h.o, h.m), n += 16 + x + (h.m ? h.m.length : 0);
  }
  return Bc(w, n, s.length, R, Q), w;
}
class wc extends Po {
  constructor(e) {
    super(e), this.type = st;
  }
  parse(e) {
    const T = Math.pow(2.7182818, 2.2);
    function L(u, f) {
      let C = 0;
      for (let v = 0; v < 65536; ++v)
        (v == 0 || u[v >> 3] & 1 << (v & 7)) && (f[C++] = v);
      const y = C - 1;
      for (; C < 65536; )
        f[C++] = 0;
      return y;
    }
    function N(u) {
      for (let f = 0; f < 16384; f++)
        u[f] = {}, u[f].len = 0, u[f].lit = 0, u[f].p = null;
    }
    const O = { l: 0, c: 0, lc: 0 };
    function Z(u, f, C, y, v) {
      for (; C < u; )
        f = f << 8 | xi(y, v), C += 8;
      C -= u, O.l = f >> C & (1 << u) - 1, O.c = f, O.lc = C;
    }
    const U = new Array(59);
    function q(u) {
      for (let C = 0; C <= 58; ++C)
        U[C] = 0;
      for (let C = 0; C < 65537; ++C)
        U[u[C]] += 1;
      let f = 0;
      for (let C = 58; C > 0; --C) {
        const y = f + U[C] >> 1;
        U[C] = f, f = y;
      }
      for (let C = 0; C < 65537; ++C) {
        const y = u[C];
        y > 0 && (u[C] = y | U[y]++ << 6);
      }
    }
    function H(u, f, C, y, v, S) {
      const k = f;
      let G = 0, F = 0;
      for (; y <= v; y++) {
        if (k.value - f.value > C)
          return !1;
        Z(6, G, F, u, k);
        const M = O.l;
        if (G = O.c, F = O.lc, S[y] = M, M == 63) {
          if (k.value - f.value > C)
            throw new Error("Something wrong with hufUnpackEncTable");
          Z(8, G, F, u, k);
          let D = O.l + 6;
          if (G = O.c, F = O.lc, y + D > v + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; D--; )
            S[y++] = 0;
          y--;
        } else if (M >= 59) {
          let D = M - 59 + 2;
          if (y + D > v + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; D--; )
            S[y++] = 0;
          y--;
        }
      }
      q(S);
    }
    function K(u) {
      return u & 63;
    }
    function ee(u) {
      return u >> 6;
    }
    function te(u, f, C, y) {
      for (; f <= C; f++) {
        const v = ee(u[f]), S = K(u[f]);
        if (v >> S)
          throw new Error("Invalid table entry");
        if (S > 14) {
          const k = y[v >> S - 14];
          if (k.len)
            throw new Error("Invalid table entry");
          if (k.lit++, k.p) {
            const G = k.p;
            k.p = new Array(k.lit);
            for (let F = 0; F < k.lit - 1; ++F)
              k.p[F] = G[F];
          } else
            k.p = new Array(1);
          k.p[k.lit - 1] = f;
        } else if (S) {
          let k = 0;
          for (let G = 1 << 14 - S; G > 0; G--) {
            const F = y[(v << 14 - S) + k];
            if (F.len || F.p)
              throw new Error("Invalid table entry");
            F.len = S, F.lit = f, k++;
          }
        }
      }
      return !0;
    }
    const ie = { c: 0, lc: 0 };
    function le(u, f, C, y) {
      u = u << 8 | xi(C, y), f += 8, ie.c = u, ie.lc = f;
    }
    const ae = { c: 0, lc: 0 };
    function he(u, f, C, y, v, S, k, G, F) {
      if (u == f) {
        y < 8 && (le(C, y, v, S), C = ie.c, y = ie.lc), y -= 8;
        let M = C >> y;
        if (M = new Uint8Array([M])[0], G.value + M > F)
          return !1;
        const D = k[G.value - 1];
        for (; M-- > 0; )
          k[G.value++] = D;
      } else if (G.value < F)
        k[G.value++] = u;
      else
        return !1;
      ae.c = C, ae.lc = y;
    }
    function Qe(u) {
      return u & 65535;
    }
    function be(u) {
      const f = Qe(u);
      return f > 32767 ? f - 65536 : f;
    }
    const Ae = { a: 0, b: 0 };
    function Xe(u, f) {
      const C = be(u), v = be(f), S = C + (v & 1) + (v >> 1), k = S, G = S - v;
      Ae.a = k, Ae.b = G;
    }
    function Ze(u, f) {
      const C = Qe(u), y = Qe(f), v = C - (y >> 1) & 65535, S = y + v - 32768 & 65535;
      Ae.a = S, Ae.b = v;
    }
    function an(u, f, C, y, v, S, k) {
      const G = k < 16384, F = C > v ? v : C;
      let M = 1, D, j;
      for (; M <= F; )
        M <<= 1;
      for (M >>= 1, D = M, M >>= 1; M >= 1; ) {
        j = 0;
        const W = j + S * (v - D), Y = S * M, $ = S * D, J = y * M, X = y * D;
        let ne, pe, xe, et;
        for (; j <= W; j += $) {
          let Ee = j;
          const ce = j + y * (C - D);
          for (; Ee <= ce; Ee += X) {
            const De = Ee + J, At = Ee + Y, Fe = At + J;
            G ? (Xe(u[Ee + f], u[At + f]), ne = Ae.a, xe = Ae.b, Xe(u[De + f], u[Fe + f]), pe = Ae.a, et = Ae.b, Xe(ne, pe), u[Ee + f] = Ae.a, u[De + f] = Ae.b, Xe(xe, et), u[At + f] = Ae.a, u[Fe + f] = Ae.b) : (Ze(u[Ee + f], u[At + f]), ne = Ae.a, xe = Ae.b, Ze(u[De + f], u[Fe + f]), pe = Ae.a, et = Ae.b, Ze(ne, pe), u[Ee + f] = Ae.a, u[De + f] = Ae.b, Ze(xe, et), u[At + f] = Ae.a, u[Fe + f] = Ae.b);
          }
          if (C & M) {
            const De = Ee + Y;
            G ? Xe(u[Ee + f], u[De + f]) : Ze(u[Ee + f], u[De + f]), ne = Ae.a, u[De + f] = Ae.b, u[Ee + f] = ne;
          }
        }
        if (v & M) {
          let Ee = j;
          const ce = j + y * (C - D);
          for (; Ee <= ce; Ee += X) {
            const De = Ee + J;
            G ? Xe(u[Ee + f], u[De + f]) : Ze(u[Ee + f], u[De + f]), ne = Ae.a, u[De + f] = Ae.b, u[Ee + f] = ne;
          }
        }
        D = M, M >>= 1;
      }
      return j;
    }
    function An(u, f, C, y, v, S, k, G, F) {
      let M = 0, D = 0;
      const j = k, W = Math.trunc(y.value + (v + 7) / 8);
      for (; y.value < W; )
        for (le(M, D, C, y), M = ie.c, D = ie.lc; D >= 14; ) {
          const $ = M >> D - 14 & 16383, J = f[$];
          if (J.len)
            D -= J.len, he(J.lit, S, M, D, C, y, G, F, j), M = ae.c, D = ae.lc;
          else {
            if (!J.p)
              throw new Error("hufDecode issues");
            let X;
            for (X = 0; X < J.lit; X++) {
              const ne = K(u[J.p[X]]);
              for (; D < ne && y.value < W; )
                le(M, D, C, y), M = ie.c, D = ie.lc;
              if (D >= ne && ee(u[J.p[X]]) == (M >> D - ne & (1 << ne) - 1)) {
                D -= ne, he(J.p[X], S, M, D, C, y, G, F, j), M = ae.c, D = ae.lc;
                break;
              }
            }
            if (X == J.lit)
              throw new Error("hufDecode issues");
          }
        }
      const Y = 8 - v & 7;
      for (M >>= Y, D -= Y; D > 0; ) {
        const $ = f[M << 14 - D & 16383];
        if ($.len)
          D -= $.len, he($.lit, S, M, D, C, y, G, F, j), M = ae.c, D = ae.lc;
        else
          throw new Error("hufDecode issues");
      }
      return !0;
    }
    function Gt(u, f, C, y, v, S) {
      const k = { value: 0 }, G = C.value, F = at(f, C), M = at(f, C);
      C.value += 4;
      const D = at(f, C);
      if (C.value += 4, F < 0 || F >= 65537 || M < 0 || M >= 65537)
        throw new Error("Something wrong with HUF_ENCSIZE");
      const j = new Array(65537), W = new Array(16384);
      N(W);
      const Y = y - (C.value - G);
      if (H(u, C, Y, F, M, j), D > 8 * (y - (C.value - G)))
        throw new Error("Something wrong with hufUncompress");
      te(j, F, M, W), An(j, W, u, C, D, M, S, v, k);
    }
    function Jt(u, f, C) {
      for (let y = 0; y < C; ++y)
        f[y] = u[f[y]];
    }
    function Rt(u) {
      for (let f = 1; f < u.length; f++) {
        const C = u[f - 1] + u[f] - 128;
        u[f] = C;
      }
    }
    function cn(u, f) {
      let C = 0, y = Math.floor((u.length + 1) / 2), v = 0;
      const S = u.length - 1;
      for (; !(v > S || (f[v++] = u[C++], v > S)); )
        f[v++] = u[y++];
    }
    function yi(u) {
      let f = u.byteLength;
      const C = new Array();
      let y = 0;
      const v = new DataView(u);
      for (; f > 0; ) {
        const S = v.getInt8(y++);
        if (S < 0) {
          const k = -S;
          f -= k + 1;
          for (let G = 0; G < k; G++)
            C.push(v.getUint8(y++));
        } else {
          const k = S;
          f -= 2;
          const G = v.getUint8(y++);
          for (let F = 0; F < k + 1; F++)
            C.push(G);
        }
      }
      return C;
    }
    function Tr(u, f, C, y, v, S) {
      let k = new DataView(S.buffer);
      const G = C[u.idx[0]].width, F = C[u.idx[0]].height, M = 3, D = Math.floor(G / 8), j = Math.ceil(G / 8), W = Math.ceil(F / 8), Y = G - (j - 1) * 8, $ = F - (W - 1) * 8, J = { value: 0 }, X = new Array(M), ne = new Array(M), pe = new Array(M), xe = new Array(M), et = new Array(M);
      for (let ce = 0; ce < M; ++ce)
        et[ce] = f[u.idx[ce]], X[ce] = ce < 1 ? 0 : X[ce - 1] + j * W, ne[ce] = new Float32Array(64), pe[ce] = new Uint16Array(64), xe[ce] = new Uint16Array(j * 64);
      for (let ce = 0; ce < W; ++ce) {
        let De = 8;
        ce == W - 1 && (De = $);
        let At = 8;
        for (let de = 0; de < j; ++de) {
          de == j - 1 && (At = Y);
          for (let Ie = 0; Ie < M; ++Ie)
            pe[Ie].fill(0), pe[Ie][0] = v[X[Ie]++], vr(J, y, pe[Ie]), Rr(pe[Ie], ne[Ie]), _r(ne[Ie]);
          Dr(ne);
          for (let Ie = 0; Ie < M; ++Ie)
            Mr(ne[Ie], xe[Ie], de * 64);
        }
        let Fe = 0;
        for (let de = 0; de < M; ++de) {
          const Ie = C[u.idx[de]].type;
          for (let _t = 8 * ce; _t < 8 * ce + De; ++_t) {
            Fe = et[de][_t];
            for (let En = 0; En < D; ++En) {
              const bt = En * 64 + (_t & 7) * 8;
              k.setUint16(Fe + 0 * 2 * Ie, xe[de][bt + 0], !0), k.setUint16(Fe + 1 * 2 * Ie, xe[de][bt + 1], !0), k.setUint16(Fe + 2 * 2 * Ie, xe[de][bt + 2], !0), k.setUint16(Fe + 3 * 2 * Ie, xe[de][bt + 3], !0), k.setUint16(Fe + 4 * 2 * Ie, xe[de][bt + 4], !0), k.setUint16(Fe + 5 * 2 * Ie, xe[de][bt + 5], !0), k.setUint16(Fe + 6 * 2 * Ie, xe[de][bt + 6], !0), k.setUint16(Fe + 7 * 2 * Ie, xe[de][bt + 7], !0), Fe += 8 * 2 * Ie;
            }
          }
          if (D != j)
            for (let _t = 8 * ce; _t < 8 * ce + De; ++_t) {
              const En = et[de][_t] + 8 * D * 2 * Ie, bt = D * 64 + (_t & 7) * 8;
              for (let zn = 0; zn < At; ++zn)
                k.setUint16(En + zn * 2 * Ie, xe[de][bt + zn], !0);
            }
        }
      }
      const Ee = new Uint16Array(G);
      k = new DataView(S.buffer);
      for (let ce = 0; ce < M; ++ce) {
        C[u.idx[ce]].decoded = !0;
        const De = C[u.idx[ce]].type;
        if (C[ce].type == 2)
          for (let At = 0; At < F; ++At) {
            const Fe = et[ce][At];
            for (let de = 0; de < G; ++de)
              Ee[de] = k.getUint16(Fe + de * 2 * De, !0);
            for (let de = 0; de < G; ++de)
              k.setFloat32(Fe + de * 2 * De, V(Ee[de]), !0);
          }
      }
    }
    function vr(u, f, C) {
      let y, v = 1;
      for (; v < 64; )
        y = f[u.value], y == 65280 ? v = 64 : y >> 8 == 255 ? v += y & 255 : (C[v] = y, v++), u.value++;
    }
    function Rr(u, f) {
      f[0] = V(u[0]), f[1] = V(u[1]), f[2] = V(u[5]), f[3] = V(u[6]), f[4] = V(u[14]), f[5] = V(u[15]), f[6] = V(u[27]), f[7] = V(u[28]), f[8] = V(u[2]), f[9] = V(u[4]), f[10] = V(u[7]), f[11] = V(u[13]), f[12] = V(u[16]), f[13] = V(u[26]), f[14] = V(u[29]), f[15] = V(u[42]), f[16] = V(u[3]), f[17] = V(u[8]), f[18] = V(u[12]), f[19] = V(u[17]), f[20] = V(u[25]), f[21] = V(u[30]), f[22] = V(u[41]), f[23] = V(u[43]), f[24] = V(u[9]), f[25] = V(u[11]), f[26] = V(u[18]), f[27] = V(u[24]), f[28] = V(u[31]), f[29] = V(u[40]), f[30] = V(u[44]), f[31] = V(u[53]), f[32] = V(u[10]), f[33] = V(u[19]), f[34] = V(u[23]), f[35] = V(u[32]), f[36] = V(u[39]), f[37] = V(u[45]), f[38] = V(u[52]), f[39] = V(u[54]), f[40] = V(u[20]), f[41] = V(u[22]), f[42] = V(u[33]), f[43] = V(u[38]), f[44] = V(u[46]), f[45] = V(u[51]), f[46] = V(u[55]), f[47] = V(u[60]), f[48] = V(u[21]), f[49] = V(u[34]), f[50] = V(u[37]), f[51] = V(u[47]), f[52] = V(u[50]), f[53] = V(u[56]), f[54] = V(u[59]), f[55] = V(u[61]), f[56] = V(u[35]), f[57] = V(u[36]), f[58] = V(u[48]), f[59] = V(u[49]), f[60] = V(u[57]), f[61] = V(u[58]), f[62] = V(u[62]), f[63] = V(u[63]);
    }
    function _r(u) {
      const f = 0.5 * Math.cos(0.7853975), C = 0.5 * Math.cos(3.14159 / 16), y = 0.5 * Math.cos(3.14159 / 8), v = 0.5 * Math.cos(3 * 3.14159 / 16), S = 0.5 * Math.cos(5 * 3.14159 / 16), k = 0.5 * Math.cos(3 * 3.14159 / 8), G = 0.5 * Math.cos(7 * 3.14159 / 16), F = new Array(4), M = new Array(4), D = new Array(4), j = new Array(4);
      for (let W = 0; W < 8; ++W) {
        const Y = W * 8;
        F[0] = y * u[Y + 2], F[1] = k * u[Y + 2], F[2] = y * u[Y + 6], F[3] = k * u[Y + 6], M[0] = C * u[Y + 1] + v * u[Y + 3] + S * u[Y + 5] + G * u[Y + 7], M[1] = v * u[Y + 1] - G * u[Y + 3] - C * u[Y + 5] - S * u[Y + 7], M[2] = S * u[Y + 1] - C * u[Y + 3] + G * u[Y + 5] + v * u[Y + 7], M[3] = G * u[Y + 1] - S * u[Y + 3] + v * u[Y + 5] - C * u[Y + 7], D[0] = f * (u[Y + 0] + u[Y + 4]), D[3] = f * (u[Y + 0] - u[Y + 4]), D[1] = F[0] + F[3], D[2] = F[1] - F[2], j[0] = D[0] + D[1], j[1] = D[3] + D[2], j[2] = D[3] - D[2], j[3] = D[0] - D[1], u[Y + 0] = j[0] + M[0], u[Y + 1] = j[1] + M[1], u[Y + 2] = j[2] + M[2], u[Y + 3] = j[3] + M[3], u[Y + 4] = j[3] - M[3], u[Y + 5] = j[2] - M[2], u[Y + 6] = j[1] - M[1], u[Y + 7] = j[0] - M[0];
      }
      for (let W = 0; W < 8; ++W)
        F[0] = y * u[16 + W], F[1] = k * u[16 + W], F[2] = y * u[48 + W], F[3] = k * u[48 + W], M[0] = C * u[8 + W] + v * u[24 + W] + S * u[40 + W] + G * u[56 + W], M[1] = v * u[8 + W] - G * u[24 + W] - C * u[40 + W] - S * u[56 + W], M[2] = S * u[8 + W] - C * u[24 + W] + G * u[40 + W] + v * u[56 + W], M[3] = G * u[8 + W] - S * u[24 + W] + v * u[40 + W] - C * u[56 + W], D[0] = f * (u[W] + u[32 + W]), D[3] = f * (u[W] - u[32 + W]), D[1] = F[0] + F[3], D[2] = F[1] - F[2], j[0] = D[0] + D[1], j[1] = D[3] + D[2], j[2] = D[3] - D[2], j[3] = D[0] - D[1], u[0 + W] = j[0] + M[0], u[8 + W] = j[1] + M[1], u[16 + W] = j[2] + M[2], u[24 + W] = j[3] + M[3], u[32 + W] = j[3] - M[3], u[40 + W] = j[2] - M[2], u[48 + W] = j[1] - M[1], u[56 + W] = j[0] - M[0];
    }
    function Dr(u) {
      for (let f = 0; f < 64; ++f) {
        const C = u[0][f], y = u[1][f], v = u[2][f];
        u[0][f] = C + 1.5747 * v, u[1][f] = C - 0.1873 * y - 0.4682 * v, u[2][f] = C + 1.8556 * y;
      }
    }
    function Mr(u, f, C) {
      for (let y = 0; y < 64; ++y)
        f[C + y] = pn.toHalfFloat(kr(u[y]));
    }
    function kr(u) {
      return u <= 1 ? Math.sign(u) * Math.pow(Math.abs(u), 2.2) : Math.sign(u) * Math.pow(T, Math.abs(u) - 1);
    }
    function bs(u) {
      return new DataView(u.array.buffer, u.offset.value, u.size);
    }
    function Fr(u) {
      const f = u.viewer.buffer.slice(u.offset.value, u.offset.value + u.size), C = new Uint8Array(yi(f)), y = new Uint8Array(C.length);
      return Rt(C), cn(C, y), new DataView(y.buffer);
    }
    function Es(u) {
      const f = u.array.slice(u.offset.value, u.offset.value + u.size), C = Ln(f), y = new Uint8Array(C.length);
      return Rt(C), cn(C, y), new DataView(y.buffer);
    }
    function Lr(u) {
      const f = u.viewer, C = { value: u.offset.value }, y = new Uint16Array(u.columns * u.lines * (u.inputChannels.length * u.type)), v = new Uint8Array(8192);
      let S = 0;
      const k = new Array(u.inputChannels.length);
      for (let $ = 0, J = u.inputChannels.length; $ < J; $++)
        k[$] = {}, k[$].start = S, k[$].end = k[$].start, k[$].nx = u.columns, k[$].ny = u.lines, k[$].size = u.type, S += k[$].nx * k[$].ny * k[$].size;
      const G = bn(f, C), F = bn(f, C);
      if (F >= 8192)
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      if (G <= F)
        for (let $ = 0; $ < F - G + 1; $++)
          v[$ + G] = Pt(f, C);
      const M = new Uint16Array(65536), D = L(v, M), j = at(f, C);
      Gt(u.array, f, C, j, y, S);
      for (let $ = 0; $ < u.inputChannels.length; ++$) {
        const J = k[$];
        for (let X = 0; X < k[$].size; ++X)
          an(
            y,
            J.start + X,
            J.nx,
            J.size,
            J.ny,
            J.nx * J.size,
            D
          );
      }
      Jt(M, y, S);
      let W = 0;
      const Y = new Uint8Array(y.buffer.byteLength);
      for (let $ = 0; $ < u.lines; $++)
        for (let J = 0; J < u.inputChannels.length; J++) {
          const X = k[J], ne = X.nx * X.size, pe = new Uint8Array(y.buffer, X.end * 2, ne * 2);
          Y.set(pe, W), W += ne * 2, X.end += ne;
        }
      return new DataView(Y.buffer);
    }
    function Nr(u) {
      const f = u.array.slice(u.offset.value, u.offset.value + u.size), C = Ln(f), y = u.inputChannels.length * u.lines * u.columns * u.totalBytes, v = new ArrayBuffer(y), S = new DataView(v);
      let k = 0, G = 0;
      const F = new Array(4);
      for (let M = 0; M < u.lines; M++)
        for (let D = 0; D < u.inputChannels.length; D++) {
          let j = 0;
          switch (u.inputChannels[D].pixelType) {
            case 1:
              F[0] = k, F[1] = F[0] + u.columns, k = F[1] + u.columns;
              for (let Y = 0; Y < u.columns; ++Y) {
                const $ = C[F[0]++] << 8 | C[F[1]++];
                j += $, S.setUint16(G, j, !0), G += 2;
              }
              break;
            case 2:
              F[0] = k, F[1] = F[0] + u.columns, F[2] = F[1] + u.columns, k = F[2] + u.columns;
              for (let Y = 0; Y < u.columns; ++Y) {
                const $ = C[F[0]++] << 24 | C[F[1]++] << 16 | C[F[2]++] << 8;
                j += $, S.setUint32(G, j, !0), G += 4;
              }
              break;
          }
        }
      return S;
    }
    function Qi(u) {
      const f = u.viewer, C = { value: u.offset.value }, y = new Uint8Array(u.columns * u.lines * (u.inputChannels.length * u.type * 2)), v = {
        version: $e(f, C),
        unknownUncompressedSize: $e(f, C),
        unknownCompressedSize: $e(f, C),
        acCompressedSize: $e(f, C),
        dcCompressedSize: $e(f, C),
        rleCompressedSize: $e(f, C),
        rleUncompressedSize: $e(f, C),
        rleRawSize: $e(f, C),
        totalAcUncompressedCount: $e(f, C),
        totalDcUncompressedCount: $e(f, C),
        acCompression: $e(f, C)
      };
      if (v.version < 2)
        throw new Error("EXRLoader.parse: " + Vt.compression + " version " + v.version + " is unsupported");
      const S = new Array();
      let k = bn(f, C) - 2;
      for (; k > 0; ) {
        const J = qn(f.buffer, C), X = Pt(f, C), ne = X >> 2 & 3, pe = (X >> 4) - 1, xe = new Int8Array([pe])[0], et = Pt(f, C);
        S.push({
          name: J,
          index: xe,
          type: et,
          compression: ne
        }), k -= J.length + 3;
      }
      const G = Vt.channels, F = new Array(u.inputChannels.length);
      for (let J = 0; J < u.inputChannels.length; ++J) {
        const X = F[J] = {}, ne = G[J];
        X.name = ne.name, X.compression = 0, X.decoded = !1, X.type = ne.pixelType, X.pLinear = ne.pLinear, X.width = u.columns, X.height = u.lines;
      }
      const M = {
        idx: new Array(3)
      };
      for (let J = 0; J < u.inputChannels.length; ++J) {
        const X = F[J];
        for (let ne = 0; ne < S.length; ++ne) {
          const pe = S[ne];
          X.name == pe.name && (X.compression = pe.compression, pe.index >= 0 && (M.idx[pe.index] = J), X.offset = J);
        }
      }
      let D, j, W;
      if (v.acCompressedSize > 0)
        switch (v.acCompression) {
          case 0:
            D = new Uint16Array(v.totalAcUncompressedCount), Gt(u.array, f, C, v.acCompressedSize, D, v.totalAcUncompressedCount);
            break;
          case 1:
            const J = u.array.slice(C.value, C.value + v.totalAcUncompressedCount), X = Ln(J);
            D = new Uint16Array(X.buffer), C.value += v.totalAcUncompressedCount;
            break;
        }
      if (v.dcCompressedSize > 0) {
        const J = {
          array: u.array,
          offset: C,
          size: v.dcCompressedSize
        };
        j = new Uint16Array(Es(J).buffer), C.value += v.dcCompressedSize;
      }
      if (v.rleRawSize > 0) {
        const J = u.array.slice(C.value, C.value + v.rleCompressedSize), X = Ln(J);
        W = yi(X.buffer), C.value += v.rleCompressedSize;
      }
      let Y = 0;
      const $ = new Array(F.length);
      for (let J = 0; J < $.length; ++J)
        $[J] = new Array();
      for (let J = 0; J < u.lines; ++J)
        for (let X = 0; X < F.length; ++X)
          $[X].push(Y), Y += F[X].width * u.type * 2;
      Tr(M, $, F, D, j, y);
      for (let J = 0; J < F.length; ++J) {
        const X = F[J];
        if (!X.decoded)
          switch (X.compression) {
            case 2:
              let ne = 0, pe = 0;
              for (let xe = 0; xe < u.lines; ++xe) {
                let et = $[J][ne];
                for (let Ee = 0; Ee < X.width; ++Ee) {
                  for (let ce = 0; ce < 2 * X.type; ++ce)
                    y[et++] = W[pe + ce * X.width * X.height];
                  pe++;
                }
                ne++;
              }
              break;
            case 1:
            default:
              throw new Error("EXRLoader.parse: unsupported channel compression");
          }
      }
      return new DataView(y.buffer);
    }
    function qn(u, f) {
      const C = new Uint8Array(u);
      let y = 0;
      for (; C[f.value + y] != 0; )
        y += 1;
      const v = new TextDecoder().decode(
        C.slice(f.value, f.value + y)
      );
      return f.value = f.value + y + 1, v;
    }
    function Ur(u, f, C) {
      const y = new TextDecoder().decode(
        new Uint8Array(u).slice(f.value, f.value + C)
      );
      return f.value = f.value + C, y;
    }
    function Gr(u, f) {
      const C = rt(u, f), y = at(u, f);
      return [C, y];
    }
    function Pr(u, f) {
      const C = at(u, f), y = at(u, f);
      return [C, y];
    }
    function rt(u, f) {
      const C = u.getInt32(f.value, !0);
      return f.value = f.value + 4, C;
    }
    function at(u, f) {
      const C = u.getUint32(f.value, !0);
      return f.value = f.value + 4, C;
    }
    function xi(u, f) {
      const C = u[f.value];
      return f.value = f.value + 1, C;
    }
    function Pt(u, f) {
      const C = u.getUint8(f.value);
      return f.value = f.value + 1, C;
    }
    const $e = function(u, f) {
      let C;
      return "getBigInt64" in DataView.prototype ? C = Number(u.getBigInt64(f.value, !0)) : C = u.getUint32(f.value + 4, !0) + Number(u.getUint32(f.value, !0) << 32), f.value += 8, C;
    };
    function Oe(u, f) {
      const C = u.getFloat32(f.value, !0);
      return f.value += 4, C;
    }
    function Or(u, f) {
      return pn.toHalfFloat(Oe(u, f));
    }
    function V(u) {
      const f = (u & 31744) >> 10, C = u & 1023;
      return (u >> 15 ? -1 : 1) * (f ? f === 31 ? C ? NaN : 1 / 0 : Math.pow(2, f - 15) * (1 + C / 1024) : 6103515625e-14 * (C / 1024));
    }
    function bn(u, f) {
      const C = u.getUint16(f.value, !0);
      return f.value += 2, C;
    }
    function Hr(u, f) {
      return V(bn(u, f));
    }
    function jr(u, f, C, y) {
      const v = C.value, S = [];
      for (; C.value < v + y - 1; ) {
        const k = qn(f, C), G = rt(u, C), F = Pt(u, C);
        C.value += 3;
        const M = rt(u, C), D = rt(u, C);
        S.push({
          name: k,
          pixelType: G,
          pLinear: F,
          xSampling: M,
          ySampling: D
        });
      }
      return C.value += 1, S;
    }
    function qr(u, f) {
      const C = Oe(u, f), y = Oe(u, f), v = Oe(u, f), S = Oe(u, f), k = Oe(u, f), G = Oe(u, f), F = Oe(u, f), M = Oe(u, f);
      return { redX: C, redY: y, greenX: v, greenY: S, blueX: k, blueY: G, whiteX: F, whiteY: M };
    }
    function zr(u, f) {
      const C = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], y = Pt(u, f);
      return C[y];
    }
    function Kr(u, f) {
      const C = rt(u, f), y = rt(u, f), v = rt(u, f), S = rt(u, f);
      return { xMin: C, yMin: y, xMax: v, yMax: S };
    }
    function Yr(u, f) {
      const C = [
        "INCREASING_Y",
        "DECREASING_Y",
        "RANDOM_Y"
      ], y = Pt(u, f);
      return C[y];
    }
    function Jr(u, f) {
      const C = [
        "ENVMAP_LATLONG",
        "ENVMAP_CUBE"
      ], y = Pt(u, f);
      return C[y];
    }
    function Vr(u, f) {
      const C = [
        "ONE_LEVEL",
        "MIPMAP_LEVELS",
        "RIPMAP_LEVELS"
      ], y = [
        "ROUND_DOWN",
        "ROUND_UP"
      ], v = at(u, f), S = at(u, f), k = Pt(u, f);
      return {
        xSize: v,
        ySize: S,
        levelMode: C[k & 15],
        roundingMode: y[k >> 4]
      };
    }
    function Wr(u, f) {
      const C = Oe(u, f), y = Oe(u, f);
      return [C, y];
    }
    function Xr(u, f) {
      const C = Oe(u, f), y = Oe(u, f), v = Oe(u, f);
      return [C, y, v];
    }
    function Zr(u, f, C, y, v) {
      if (y === "string" || y === "stringvector" || y === "iccProfile")
        return Ur(f, C, v);
      if (y === "chlist")
        return jr(u, f, C, v);
      if (y === "chromaticities")
        return qr(u, C);
      if (y === "compression")
        return zr(u, C);
      if (y === "box2i")
        return Kr(u, C);
      if (y === "envmap")
        return Jr(u, C);
      if (y === "tiledesc")
        return Vr(u, C);
      if (y === "lineOrder")
        return Yr(u, C);
      if (y === "float")
        return Oe(u, C);
      if (y === "v2f")
        return Wr(u, C);
      if (y === "v3f")
        return Xr(u, C);
      if (y === "int")
        return rt(u, C);
      if (y === "rational")
        return Gr(u, C);
      if (y === "timecode")
        return Pr(u, C);
      if (y === "preview")
        return C.value += v, "skipped";
      C.value += v;
    }
    function $r(u, f) {
      const C = Math.log2(u);
      return f == "ROUND_DOWN" ? Math.floor(C) : Math.ceil(C);
    }
    function ea(u, f, C) {
      let y = 0;
      switch (u.levelMode) {
        case "ONE_LEVEL":
          y = 1;
          break;
        case "MIPMAP_LEVELS":
          y = $r(Math.max(f, C), u.roundingMode) + 1;
          break;
        case "RIPMAP_LEVELS":
          throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.");
      }
      return y;
    }
    function Si(u, f, C, y) {
      const v = new Array(u);
      for (let S = 0; S < u; S++) {
        const k = 1 << S;
        let G = f / k | 0;
        y == "ROUND_UP" && G * k < f && (G += 1);
        const F = Math.max(G, 1);
        v[S] = (F + C - 1) / C | 0;
      }
      return v;
    }
    function ta() {
      const u = this, f = u.offset, C = { value: 0 };
      for (let y = 0; y < u.tileCount; y++) {
        const v = rt(u.viewer, f), S = rt(u.viewer, f);
        f.value += 8, u.size = at(u.viewer, f);
        const k = v * u.blockWidth, G = S * u.blockHeight;
        u.columns = k + u.blockWidth > u.width ? u.width - k : u.blockWidth, u.lines = G + u.blockHeight > u.height ? u.height - G : u.blockHeight;
        const F = u.columns * u.totalBytes, D = u.size < u.lines * F ? u.uncompress(u) : bs(u);
        f.value += u.size;
        for (let j = 0; j < u.lines; j++) {
          const W = j * u.columns * u.totalBytes;
          for (let Y = 0; Y < u.inputChannels.length; Y++) {
            const $ = Vt.channels[Y].name, J = u.channelByteOffsets[$] * u.columns, X = u.decodeChannels[$];
            if (X === void 0)
              continue;
            C.value = W + J;
            const ne = (u.height - (1 + G + j)) * u.outLineWidth;
            for (let pe = 0; pe < u.columns; pe++) {
              const xe = ne + (pe + k) * u.outputChannels + X;
              u.byteArray[xe] = u.getter(D, C);
            }
          }
        }
      }
    }
    function na() {
      const u = this, f = u.offset, C = { value: 0 };
      for (let y = 0; y < u.height / u.blockHeight; y++) {
        const v = rt(u.viewer, f) - Vt.dataWindow.yMin;
        u.size = at(u.viewer, f), u.lines = v + u.blockHeight > u.height ? u.height - v : u.blockHeight;
        const S = u.columns * u.totalBytes, G = u.size < u.lines * S ? u.uncompress(u) : bs(u);
        f.value += u.size;
        for (let F = 0; F < u.blockHeight; F++) {
          const M = y * u.blockHeight, D = F + u.scanOrder(M);
          if (D >= u.height)
            continue;
          const j = F * S, W = (u.height - 1 - D) * u.outLineWidth;
          for (let Y = 0; Y < u.inputChannels.length; Y++) {
            const $ = Vt.channels[Y].name, J = u.channelByteOffsets[$] * u.columns, X = u.decodeChannels[$];
            if (X !== void 0) {
              C.value = j + J;
              for (let ne = 0; ne < u.columns; ne++) {
                const pe = W + ne * u.outputChannels + X;
                u.byteArray[pe] = u.getter(G, C);
              }
            }
          }
        }
      }
    }
    function sa(u, f, C) {
      const y = {};
      if (u.getUint32(0, !0) != 20000630)
        throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
      y.version = u.getUint8(4);
      const v = u.getUint8(5);
      y.spec = {
        singleTile: !!(v & 2),
        longName: !!(v & 4),
        deepFormat: !!(v & 8),
        multiPart: !!(v & 16)
      }, C.value = 8;
      let S = !0;
      for (; S; ) {
        const k = qn(f, C);
        if (k == 0)
          S = !1;
        else {
          const G = qn(f, C), F = at(u, C), M = Zr(u, f, C, G, F);
          M === void 0 ? console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${G}'.`) : y[k] = M;
        }
      }
      if (v & -7)
        throw console.error("THREE.EXRHeader:", y), new Error("THREE.EXRLoader: Provided file is currently unsupported.");
      return y;
    }
    function ia(u, f, C, y, v) {
      const S = {
        size: 0,
        viewer: f,
        array: C,
        offset: y,
        width: u.dataWindow.xMax - u.dataWindow.xMin + 1,
        height: u.dataWindow.yMax - u.dataWindow.yMin + 1,
        inputChannels: u.channels,
        channelByteOffsets: {},
        scanOrder: null,
        totalBytes: null,
        columns: null,
        lines: null,
        type: null,
        uncompress: null,
        getter: null,
        format: null,
        colorSpace: We
      };
      switch (u.compression) {
        case "NO_COMPRESSION":
          S.blockHeight = 1, S.uncompress = bs;
          break;
        case "RLE_COMPRESSION":
          S.blockHeight = 1, S.uncompress = Fr;
          break;
        case "ZIPS_COMPRESSION":
          S.blockHeight = 1, S.uncompress = Es;
          break;
        case "ZIP_COMPRESSION":
          S.blockHeight = 16, S.uncompress = Es;
          break;
        case "PIZ_COMPRESSION":
          S.blockHeight = 32, S.uncompress = Lr;
          break;
        case "PXR24_COMPRESSION":
          S.blockHeight = 16, S.uncompress = Nr;
          break;
        case "DWAA_COMPRESSION":
          S.blockHeight = 32, S.uncompress = Qi;
          break;
        case "DWAB_COMPRESSION":
          S.blockHeight = 256, S.uncompress = Qi;
          break;
        default:
          throw new Error("EXRLoader.parse: " + u.compression + " is unsupported");
      }
      const k = {};
      for (const D of u.channels)
        switch (D.name) {
          case "Y":
          case "R":
          case "G":
          case "B":
          case "A":
            k[D.name] = !0, S.type = D.pixelType;
        }
      let G = !1;
      if (k.R && k.G && k.B)
        G = !k.A, S.outputChannels = 4, S.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };
      else if (k.Y)
        S.outputChannels = 1, S.decodeChannels = { Y: 0 };
      else
        throw new Error("EXRLoader.parse: file contains unsupported data channels.");
      if (S.type == 1)
        switch (v) {
          case St:
            S.getter = Hr;
            break;
          case st:
            S.getter = bn;
            break;
        }
      else if (S.type == 2)
        switch (v) {
          case St:
            S.getter = Oe;
            break;
          case st:
            S.getter = Or;
        }
      else
        throw new Error("EXRLoader.parse: unsupported pixelType " + S.type + " for " + u.compression + ".");
      S.columns = S.width;
      const F = S.width * S.height * S.outputChannels;
      switch (v) {
        case St:
          S.byteArray = new Float32Array(F), G && S.byteArray.fill(1, 0, F);
          break;
        case st:
          S.byteArray = new Uint16Array(F), G && S.byteArray.fill(15360, 0, F);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", v);
          break;
      }
      let M = 0;
      for (const D of u.channels)
        S.decodeChannels[D.name] !== void 0 && (S.channelByteOffsets[D.name] = M), M += D.pixelType * 2;
      if (S.totalBytes = M, S.outLineWidth = S.width * S.outputChannels, u.lineOrder === "INCREASING_Y" ? S.scanOrder = (D) => D : S.scanOrder = (D) => S.height - 1 - D, S.outputChannels == 4 ? (S.format = Kt, S.colorSpace = We) : (S.format = dn, S.colorSpace = gs), u.spec.singleTile) {
        S.blockHeight = u.tiles.ySize, S.blockWidth = u.tiles.xSize;
        const D = ea(u.tiles, S.width, S.height), j = Si(D, S.width, u.tiles.xSize, u.tiles.roundingMode), W = Si(D, S.height, u.tiles.ySize, u.tiles.roundingMode);
        S.tileCount = j[0] * W[0];
        for (let Y = 0; Y < D; Y++)
          for (let $ = 0; $ < W[Y]; $++)
            for (let J = 0; J < j[Y]; J++)
              $e(f, y);
        S.decode = ta.bind(S);
      } else {
        S.blockWidth = S.width;
        const D = Math.ceil(S.height / S.blockHeight);
        for (let j = 0; j < D; j++)
          $e(f, y);
        S.decode = na.bind(S);
      }
      return S;
    }
    const Ti = { value: 0 }, vi = new DataView(e), oa = new Uint8Array(e), Vt = sa(vi, e, Ti), ln = ia(Vt, vi, oa, Ti, this.type);
    return ln.decode(), {
      header: Vt,
      width: ln.width,
      height: ln.height,
      data: ln.byteArray,
      format: ln.format,
      colorSpace: ln.colorSpace,
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, s, n) {
    function i(o, r) {
      o.colorSpace = r.colorSpace, o.minFilter = mt, o.magFilter = mt, o.generateMipmaps = !1, o.flipY = !1, t && t(o, r);
    }
    return super.load(e, i, s, n);
  }
}
const Bh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EXRLoader: wc
}, Symbol.toStringTag, { value: "Module" }));
class yc extends Po {
  constructor(e) {
    super(e), this.type = st;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const o = function(x, T) {
      switch (x) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (T || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (T || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (T || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (T || ""));
      }
    }, l = `
`, h = function(x, T, L) {
      T = T || 1024;
      let O = x.pos, Z = -1, U = 0, q = "", H = String.fromCharCode.apply(null, new Uint16Array(x.subarray(O, O + 128)));
      for (; 0 > (Z = H.indexOf(l)) && U < T && O < x.byteLength; )
        q += H, U += H.length, O += 128, H += String.fromCharCode.apply(null, new Uint16Array(x.subarray(O, O + 128)));
      return -1 < Z ? (L !== !1 && (x.pos += U + Z + 1), q + H.slice(0, Z)) : !1;
    }, g = function(x) {
      const T = /^#\?(\S+)/, L = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, N = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, O = /^\s*FORMAT=(\S+)\s*$/, Z = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, U = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let q, H;
      for ((x.pos >= x.byteLength || !(q = h(x))) && o(1, "no header found"), (H = q.match(T)) || o(3, "bad initial token"), U.valid |= 1, U.programtype = H[1], U.string += q + `
`; q = h(x), q !== !1; ) {
        if (U.string += q + `
`, q.charAt(0) === "#") {
          U.comments += q + `
`;
          continue;
        }
        if ((H = q.match(L)) && (U.gamma = parseFloat(H[1])), (H = q.match(N)) && (U.exposure = parseFloat(H[1])), (H = q.match(O)) && (U.valid |= 2, U.format = H[1]), (H = q.match(Z)) && (U.valid |= 4, U.height = parseInt(H[1], 10), U.width = parseInt(H[2], 10)), U.valid & 2 && U.valid & 4)
          break;
      }
      return U.valid & 2 || o(3, "missing format specifier"), U.valid & 4 || o(3, "missing image size specifier"), U;
    }, d = function(x, T, L) {
      const N = T;
      if (
        // run length encoding is not allowed so read flat
        N < 8 || N > 32767 || // this file is not run length encoded
        x[0] !== 2 || x[1] !== 2 || x[2] & 128
      )
        return new Uint8Array(x);
      N !== (x[2] << 8 | x[3]) && o(3, "wrong scanline width");
      const O = new Uint8Array(4 * T * L);
      O.length || o(4, "unable to allocate buffer space");
      let Z = 0, U = 0;
      const q = 4 * N, H = new Uint8Array(4), K = new Uint8Array(q);
      let ee = L;
      for (; ee > 0 && U < x.byteLength; ) {
        U + 4 > x.byteLength && o(1), H[0] = x[U++], H[1] = x[U++], H[2] = x[U++], H[3] = x[U++], (H[0] != 2 || H[1] != 2 || (H[2] << 8 | H[3]) != N) && o(3, "bad rgbe scanline format");
        let te = 0, ie;
        for (; te < q && U < x.byteLength; ) {
          ie = x[U++];
          const ae = ie > 128;
          if (ae && (ie -= 128), (ie === 0 || te + ie > q) && o(3, "bad scanline data"), ae) {
            const he = x[U++];
            for (let Qe = 0; Qe < ie; Qe++)
              K[te++] = he;
          } else
            K.set(x.subarray(U, U + ie), te), te += ie, U += ie;
        }
        const le = N;
        for (let ae = 0; ae < le; ae++) {
          let he = 0;
          O[Z] = K[ae + he], he += N, O[Z + 1] = K[ae + he], he += N, O[Z + 2] = K[ae + he], he += N, O[Z + 3] = K[ae + he], Z += 4;
        }
        ee--;
      }
      return O;
    }, p = function(x, T, L, N) {
      const O = x[T + 3], Z = Math.pow(2, O - 128) / 255;
      L[N + 0] = x[T + 0] * Z, L[N + 1] = x[T + 1] * Z, L[N + 2] = x[T + 2] * Z, L[N + 3] = 1;
    }, m = function(x, T, L, N) {
      const O = x[T + 3], Z = Math.pow(2, O - 128) / 255;
      L[N + 0] = pn.toHalfFloat(Math.min(x[T + 0] * Z, 65504)), L[N + 1] = pn.toHalfFloat(Math.min(x[T + 1] * Z, 65504)), L[N + 2] = pn.toHalfFloat(Math.min(x[T + 2] * Z, 65504)), L[N + 3] = pn.toHalfFloat(1);
    }, I = new Uint8Array(e);
    I.pos = 0;
    const b = g(I), B = b.width, E = b.height, w = d(I.subarray(I.pos), B, E);
    let Q, R, _;
    switch (this.type) {
      case St:
        _ = w.length / 4;
        const x = new Float32Array(_ * 4);
        for (let L = 0; L < _; L++)
          p(w, L * 4, x, L * 4);
        Q = x, R = St;
        break;
      case st:
        _ = w.length / 4;
        const T = new Uint16Array(_ * 4);
        for (let L = 0; L < _; L++)
          m(w, L * 4, T, L * 4);
        Q = T, R = st;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: B,
      height: E,
      data: Q,
      header: b.string,
      gamma: b.gamma,
      exposure: b.exposure,
      type: R
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, s, n) {
    function i(o, r) {
      switch (o.type) {
        case St:
        case st:
          o.colorSpace = We, o.minFilter = mt, o.magFilter = mt, o.generateMipmaps = !1, o.flipY = !0;
          break;
      }
      t && t(o, r);
    }
    return super.load(e, i, s, n);
  }
}
const wh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RGBELoader: yc
}, Symbol.toStringTag, { value: "Module" }));
function Ir(A, e, t) {
  const s = t.length - A - 1;
  if (e >= t[s])
    return s - 1;
  if (e <= t[A])
    return A;
  let n = A, i = s, o = Math.floor((n + i) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? i = o : n = o, o = Math.floor((n + i) / 2);
  return o;
}
function Qc(A, e, t, s) {
  const n = [], i = [], o = [];
  n[0] = 1;
  for (let r = 1; r <= t; ++r) {
    i[r] = e - s[A + 1 - r], o[r] = s[A + r] - e;
    let a = 0;
    for (let c = 0; c < r; ++c) {
      const l = o[c + 1], h = i[r - c], g = n[c] / (l + h);
      n[c] = a + l * g, a = h * g;
    }
    n[r] = a;
  }
  return n;
}
function xc(A, e, t, s) {
  const n = Ir(A, s, e), i = Qc(n, s, A, e), o = new Ut(0, 0, 0, 0);
  for (let r = 0; r <= A; ++r) {
    const a = t[n - A + r], c = i[r], l = a.w * c;
    o.x += a.x * l, o.y += a.y * l, o.z += a.z * l, o.w += a.w * c;
  }
  return o;
}
function Sc(A, e, t, s, n) {
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = 0;
  const o = [];
  for (let h = 0; h <= s; ++h)
    o[h] = i.slice(0);
  const r = [];
  for (let h = 0; h <= t; ++h)
    r[h] = i.slice(0);
  r[0][0] = 1;
  const a = i.slice(0), c = i.slice(0);
  for (let h = 1; h <= t; ++h) {
    a[h] = e - n[A + 1 - h], c[h] = n[A + h] - e;
    let g = 0;
    for (let d = 0; d < h; ++d) {
      const p = c[d + 1], m = a[h - d];
      r[h][d] = p + m;
      const I = r[d][h - 1] / r[h][d];
      r[d][h] = g + p * I, g = m * I;
    }
    r[h][h] = g;
  }
  for (let h = 0; h <= t; ++h)
    o[0][h] = r[h][t];
  for (let h = 0; h <= t; ++h) {
    let g = 0, d = 1;
    const p = [];
    for (let m = 0; m <= t; ++m)
      p[m] = i.slice(0);
    p[0][0] = 1;
    for (let m = 1; m <= s; ++m) {
      let I = 0;
      const b = h - m, B = t - m;
      h >= m && (p[d][0] = p[g][0] / r[B + 1][b], I = p[d][0] * r[b][B]);
      const E = b >= -1 ? 1 : -b, w = h - 1 <= B ? m - 1 : t - h;
      for (let R = E; R <= w; ++R)
        p[d][R] = (p[g][R] - p[g][R - 1]) / r[B + 1][b + R], I += p[d][R] * r[b + R][B];
      h <= B && (p[d][m] = -p[g][m - 1] / r[B + 1][h], I += p[d][m] * r[h][B]), o[m][h] = I;
      const Q = g;
      g = d, d = Q;
    }
  }
  let l = t;
  for (let h = 1; h <= s; ++h) {
    for (let g = 0; g <= t; ++g)
      o[h][g] *= l;
    l *= t - h;
  }
  return o;
}
function Tc(A, e, t, s, n) {
  const i = n < A ? n : A, o = [], r = Ir(A, s, e), a = Sc(r, s, A, i, e), c = [];
  for (let l = 0; l < t.length; ++l) {
    const h = t[l].clone(), g = h.w;
    h.x *= g, h.y *= g, h.z *= g, c[l] = h;
  }
  for (let l = 0; l <= i; ++l) {
    const h = c[r - A].clone().multiplyScalar(a[l][0]);
    for (let g = 1; g <= A; ++g)
      h.add(c[r - A + g].clone().multiplyScalar(a[l][g]));
    o[l] = h;
  }
  for (let l = i + 1; l <= n + 1; ++l)
    o[l] = new Ut(0, 0, 0);
  return o;
}
function vc(A, e) {
  let t = 1;
  for (let n = 2; n <= A; ++n)
    t *= n;
  let s = 1;
  for (let n = 2; n <= e; ++n)
    s *= n;
  for (let n = 2; n <= A - e; ++n)
    s *= n;
  return t / s;
}
function Rc(A) {
  const e = A.length, t = [], s = [];
  for (let i = 0; i < e; ++i) {
    const o = A[i];
    t[i] = new P(o.x, o.y, o.z), s[i] = o.w;
  }
  const n = [];
  for (let i = 0; i < e; ++i) {
    const o = t[i].clone();
    for (let r = 1; r <= i; ++r)
      o.sub(n[i - r].clone().multiplyScalar(vc(i, r) * s[r]));
    n[i] = o.divideScalar(s[0]);
  }
  return n;
}
function _c(A, e, t, s, n) {
  const i = Tc(A, e, t, s, n);
  return Rc(i);
}
class Dc extends Fa {
  constructor(e, t, s, n, i) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = i || this.knots.length - 1;
    for (let o = 0; o < s.length; ++o) {
      const r = s[o];
      this.controlPoints[o] = new Ut(r.x, r.y, r.z, r.w);
    }
  }
  getPoint(e, t = new P()) {
    const s = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = xc(this.degree, this.knots, this.controlPoints, n);
    return i.w !== 1 && i.divideScalar(i.w), s.set(i.x, i.y, i.z);
  }
  getTangent(e, t = new P()) {
    const s = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = _c(this.degree, this.knots, this.controlPoints, n, 1);
    return s.copy(i[1]).normalize(), s;
  }
}
let se, _e, ze;
class yh extends Nt {
  constructor(e) {
    super(e);
  }
  load(e, t, s, n) {
    const i = this, o = i.path === "" ? nn.extractUrlBase(e) : i.path, r = new ft(this.manager);
    r.setPath(i.path), r.setResponseType("arraybuffer"), r.setRequestHeader(i.requestHeader), r.setWithCredentials(i.withCredentials), r.load(e, function(a) {
      try {
        t(i.parse(a, o));
      } catch (c) {
        n ? n(c) : console.error(c), i.manager.itemError(e);
      }
    }, s, n);
  }
  parse(e, t) {
    if (Uc(e))
      se = new Nc().parse(e);
    else {
      const n = Cr(e);
      if (!Gc(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (no(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + no(n));
      se = new Lc().parse(n);
    }
    const s = new hi(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new Mc(s, this.manager).parse(se);
  }
  getFbxTree() {
    return se;
  }
}
class Mc {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    _e = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), s = this.parseMaterials(t), n = this.parseDeformers(), i = new kc().parse(n);
    return this.parseScene(n, i, s), ze;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in se && se.Connections.connections.forEach(function(s) {
      const n = s[0], i = s[1], o = s[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const r = { ID: i, relationship: o };
      e.get(n).parents.push(r), e.has(i) || e.set(i, {
        parents: [],
        children: []
      });
      const a = { ID: n, relationship: o };
      e.get(i).children.push(a);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in se.Objects) {
      const s = se.Objects.Video;
      for (const n in s) {
        const i = s[n], o = parseInt(n);
        if (e[o] = i.RelativeFilename || i.Filename, "Content" in i) {
          const r = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, a = typeof i.Content == "string" && i.Content !== "";
          if (r || a) {
            const c = this.parseImage(s[n]);
            t[i.RelativeFilename || i.Filename] = c;
          }
        }
      }
    }
    for (const s in e) {
      const n = e[s];
      t[n] !== void 0 ? e[s] = t[n] : e[s] = e[s].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, s = e.RelativeFilename || e.Filename, n = s.slice(s.lastIndexOf(".") + 1).toLowerCase();
    let i;
    switch (n) {
      case "bmp":
        i = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        i = "image/jpeg";
        break;
      case "png":
        i = "image/png";
        break;
      case "tif":
        i = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", s), i = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + i + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: i }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in se.Objects) {
      const s = se.Objects.Texture;
      for (const n in s) {
        const i = this.parseTexture(s[n], e);
        t.set(parseInt(n), i);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const s = this.loadTexture(e, t);
    s.ID = e.id, s.name = e.attrName;
    const n = e.WrapModeU, i = e.WrapModeV, o = n !== void 0 ? n.value : 0, r = i !== void 0 ? i.value : 0;
    if (s.wrapS = o === 0 ? rn : cs, s.wrapT = r === 0 ? rn : cs, "Scaling" in e) {
      const a = e.Scaling.value;
      s.repeat.x = a[0], s.repeat.y = a[1];
    }
    if ("Translation" in e) {
      const a = e.Translation.value;
      s.offset.x = a[0], s.offset.y = a[1];
    }
    return s;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    const s = /* @__PURE__ */ new Set(["tga", "tif", "tiff", "exr", "dds", "hdr", "ktx2"]), n = e.FileName.split(".").pop().toLowerCase(), i = s.has(n) ? this.manager.getHandler(`.${n}`) : this.textureLoader;
    if (!i)
      return console.warn(
        `FBXLoader: ${n.toUpperCase()} loader not found, creating placeholder texture for`,
        e.RelativeFilename
      ), new Xs();
    const o = i.path;
    o || i.setPath(this.textureLoader.path);
    const r = _e.get(e.id).children;
    let a;
    r !== void 0 && r.length > 0 && t[r[0].ID] !== void 0 && (a = t[r[0].ID], (a.indexOf("blob:") === 0 || a.indexOf("data:") === 0) && i.setPath(void 0));
    const c = i.load(a);
    return i.setPath(o), c;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in se.Objects) {
      const s = se.Objects.Material;
      for (const n in s) {
        const i = this.parseMaterial(s[n], e);
        i !== null && t.set(parseInt(n), i);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const s = e.id, n = e.attrName;
    let i = e.ShadingModel;
    if (typeof i == "object" && (i = i.value), !_e.has(s))
      return null;
    const o = this.parseParameters(e, t, s);
    let r;
    switch (i.toLowerCase()) {
      case "phong":
        r = new Pn();
        break;
      case "lambert":
        r = new La();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), r = new Pn();
        break;
    }
    return r.setValues(o), r.name = n, r;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, s) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = Ve.toWorkingColorSpace(new Se().fromArray(e.Diffuse.value), ge) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = Ve.toWorkingColorSpace(new Se().fromArray(e.DiffuseColor.value), ge)), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = Ve.toWorkingColorSpace(new Se().fromArray(e.Emissive.value), ge) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = Ve.toWorkingColorSpace(new Se().fromArray(e.EmissiveColor.value), ge)), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = Ve.toWorkingColorSpace(new Se().fromArray(e.Specular.value), ge) : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = Ve.toWorkingColorSpace(new Se().fromArray(e.SpecularColor.value), ge));
    const i = this;
    return _e.get(s).children.forEach(function(o) {
      const r = o.relationship;
      switch (r) {
        case "Bump":
          n.bumpMap = i.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = i.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = i.getTexture(t, o.ID), n.map !== void 0 && (n.map.colorSpace = ge);
          break;
        case "DisplacementColor":
          n.displacementMap = i.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = i.getTexture(t, o.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = ge);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = i.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          n.envMap = i.getTexture(t, o.ID), n.envMap !== void 0 && (n.envMap.mapping = Na, n.envMap.colorSpace = ge);
          break;
        case "SpecularColor":
          n.specularMap = i.getTexture(t, o.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = ge);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = i.getTexture(t, o.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", r);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in se.Objects && t in se.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = _e.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in se.Objects) {
      const s = se.Objects.Deformer;
      for (const n in s) {
        const i = s[n], o = _e.get(parseInt(n));
        if (i.attrType === "Skin") {
          const r = this.parseSkeleton(o, s);
          r.ID = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), r.geometryID = o.parents[0].ID, e[n] = r;
        } else if (i.attrType === "BlendShape") {
          const r = {
            id: n
          };
          r.rawTargets = this.parseMorphTargets(o, s), r.id = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = r;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const s = [];
    return e.children.forEach(function(n) {
      const i = t[n.ID];
      if (i.attrType !== "Cluster")
        return;
      const o = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new ue().fromArray(i.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in i && (o.indices = i.Indexes.a, o.weights = i.Weights.a), s.push(o);
    }), {
      rawBones: s,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const s = [];
    for (let n = 0; n < e.children.length; n++) {
      const i = e.children[n], o = t[i.ID], r = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel")
        return;
      r.geoID = _e.get(parseInt(i.ID)).children.filter(function(a) {
        return a.relationship === void 0;
      })[0].ID, s.push(r);
    }
    return s;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, s) {
    ze = new sn();
    const n = this.parseModels(e.skeletons, t, s), i = se.Objects.Model, o = this;
    n.forEach(function(a) {
      var h;
      const c = i[a.ID];
      o.setLookAtProperties(a, c);
      const l = (h = _e.get(a.ID)) == null ? void 0 : h.parents;
      l == null || l.forEach(function(g) {
        const d = n.get(g.ID);
        d !== void 0 && d.add(a);
      }), a.parent === null && ze.add(a);
    }), this.bindSkeleton(e.skeletons, t, n), this.addGlobalSceneSettings(), ze.traverse(function(a) {
      if (a.userData.transformData) {
        a.parent && (a.userData.transformData.parentMatrix = a.parent.matrix, a.userData.transformData.parentMatrixWorld = a.parent.matrixWorld);
        const c = Er(a.userData.transformData);
        a.applyMatrix4(c), a.updateWorldMatrix();
      }
      a.isSkinnedMesh && (a.computeBoundingBox(), a.computeBoundingSphere(), a.boundingBox.expandByScalar(3), a.boundingSphere.radius *= 3);
    });
    const r = new Fc().parse();
    ze.children.length === 1 && ze.children[0].isGroup && (ze.children[0].animations = r, ze = ze.children[0]), ze.animations = r;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, s) {
    const n = /* @__PURE__ */ new Map(), i = se.Objects.Model;
    for (const o in i) {
      const r = parseInt(o), a = i[o], c = _e.get(r);
      let l = this.buildSkeleton(c, e, r, a.attrName);
      if (!l) {
        switch (a.attrType) {
          case "Camera":
            l = this.createCamera(c);
            break;
          case "Light":
            l = this.createLight(c);
            break;
          case "Mesh":
            l = this.createMesh(c, t, s);
            break;
          case "NurbsCurve":
            l = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            l = new Ws();
            break;
          case "Null":
          default:
            l = new sn();
            break;
        }
        l.name = a.attrName ? It.sanitizeNodeName(a.attrName) : "", l.userData.originalName = a.attrName, l.ID = r;
      }
      this.getTransformData(l, a), n.set(r, l);
    }
    return n;
  }
  buildSkeleton(e, t, s, n) {
    let i = null;
    return e == null || e.parents.forEach(function(o) {
      for (const r in t) {
        const a = t[r];
        a.rawBones.forEach(function(c, l) {
          if (c.ID === o.ID) {
            const h = i;
            i = new Ws(), i.matrixWorld.copy(c.transformLink), i.name = n ? It.sanitizeNodeName(n) : "", i.userData.originalName = n, i.ID = s, a.bones[l] = i, h !== null && i.add(h);
          }
        });
      }
    }), i;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, s;
    if (e.children.forEach(function(n) {
      const i = se.Objects.NodeAttribute[n.ID];
      i !== void 0 && (s = i);
    }), s === void 0)
      t = new xt();
    else {
      let n = 0;
      s.CameraProjectionType !== void 0 && s.CameraProjectionType.value === 1 && (n = 1);
      let i = 1;
      s.NearPlane !== void 0 && (i = s.NearPlane.value / 1e3);
      let o = 1e3;
      s.FarPlane !== void 0 && (o = s.FarPlane.value / 1e3);
      let r = window.innerWidth, a = window.innerHeight;
      s.AspectWidth !== void 0 && s.AspectHeight !== void 0 && (r = s.AspectWidth.value, a = s.AspectHeight.value);
      const c = r / a;
      let l = 45;
      s.FieldOfView !== void 0 && (l = s.FieldOfView.value);
      const h = s.FocalLength ? s.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new ds(l, c, i, o), h !== null && t.setFocalLength(h);
          break;
        case 1:
          console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."), t = new xt();
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new xt();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, s;
    if (e.children.forEach(function(n) {
      const i = se.Objects.NodeAttribute[n.ID];
      i !== void 0 && (s = i);
    }), s === void 0)
      t = new xt();
    else {
      let n;
      s.LightType === void 0 ? n = 0 : n = s.LightType.value;
      let i = 16777215;
      s.Color !== void 0 && (i = Ve.toWorkingColorSpace(new Se().fromArray(s.Color.value), ge));
      let o = s.Intensity === void 0 ? 1 : s.Intensity.value / 100;
      s.CastLightOnObject !== void 0 && s.CastLightOnObject.value === 0 && (o = 0);
      let r = 0;
      s.FarAttenuationEnd !== void 0 && (s.EnableFarAttenuation !== void 0 && s.EnableFarAttenuation.value === 0 ? r = 0 : r = s.FarAttenuationEnd.value);
      const a = 1;
      switch (n) {
        case 0:
          t = new Vs(i, o, r, a);
          break;
        case 1:
          t = new vo(i, o);
          break;
        case 2:
          let c = Math.PI / 3;
          s.InnerAngle !== void 0 && (c = ye.degToRad(s.InnerAngle.value));
          let l = 0;
          s.OuterAngle !== void 0 && (l = ye.degToRad(s.OuterAngle.value), l = Math.max(l, 1)), t = new To(i, o, r, c, l, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + s.LightType.value + ", defaulting to a PointLight."), t = new Vs(i, o);
          break;
      }
      s.CastShadows !== void 0 && s.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, s) {
    let n, i = null, o = null;
    const r = [];
    if (e.children.forEach(function(a) {
      t.has(a.ID) && (i = t.get(a.ID)), s.has(a.ID) && r.push(s.get(a.ID));
    }), r.length > 1 ? o = r : r.length > 0 ? o = r[0] : (o = new Pn({
      name: Nt.DEFAULT_MATERIAL_NAME,
      color: 13421772
    }), r.push(o)), "color" in i.attributes && r.forEach(function(a) {
      a.vertexColors = !0;
    }), i.groups.length > 0) {
      let a = !1;
      for (let c = 0, l = i.groups.length; c < l; c++) {
        const h = i.groups[c];
        (h.materialIndex < 0 || h.materialIndex >= r.length) && (h.materialIndex = r.length, a = !0);
      }
      if (a) {
        const c = new ui();
        r.push(c);
      }
    }
    return i.FBX_Deformer ? (n = new di(i, o), n.normalizeSkinWeights()) : n = new z(i, o), n;
  }
  createCurve(e, t) {
    const s = e.children.reduce(function(i, o) {
      return t.has(o.ID) && (i = t.get(o.ID)), i;
    }, null), n = new Lt({
      name: Nt.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new dt(s, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const s = {};
    "InheritType" in t && (s.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? s.eulerOrder = Hn(t.RotationOrder.value) : s.eulerOrder = Hn(0), "Lcl_Translation" in t && (s.translation = t.Lcl_Translation.value), "PreRotation" in t && (s.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (s.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (s.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (s.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (s.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (s.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (s.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (s.rotationPivot = t.RotationPivot.value), e.userData.transformData = s;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && _e.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const i = se.Objects.Model[n.ID];
        if ("Lcl_Translation" in i) {
          const o = i.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), ze.add(e.target)) : e.lookAt(new P().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, s) {
    const n = this.parsePoseNodes();
    for (const i in e) {
      const o = e[i];
      _e.get(parseInt(o.ID)).parents.forEach(function(a) {
        if (t.has(a.ID)) {
          const c = a.ID;
          _e.get(c).parents.forEach(function(h) {
            s.has(h.ID) && s.get(h.ID).bind(new _o(o.bones), n[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in se.Objects) {
      const t = se.Objects.Pose;
      for (const s in t)
        if (t[s].attrType === "BindPose" && t[s].NbPoseNodes > 0) {
          const n = t[s].PoseNode;
          Array.isArray(n) ? n.forEach(function(i) {
            e[i.Node] = new ue().fromArray(i.Matrix.a);
          }) : e[n.Node] = new ue().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  addGlobalSceneSettings() {
    if ("GlobalSettings" in se) {
      if ("AmbientColor" in se.GlobalSettings) {
        const e = se.GlobalSettings.AmbientColor.value, t = e[0], s = e[1], n = e[2];
        if (t !== 0 || s !== 0 || n !== 0) {
          const i = new Se().setRGB(t, s, n, ge);
          ze.add(new Ua(i, 1));
        }
      }
      "UnitScaleFactor" in se.GlobalSettings && (ze.userData.unitScaleFactor = se.GlobalSettings.UnitScaleFactor.value);
    }
  }
}
class kc {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in se.Objects) {
      const s = se.Objects.Geometry;
      for (const n in s) {
        const i = _e.get(parseInt(n)), o = this.parseGeometry(i, s[n], e);
        t.set(parseInt(n), o);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, s) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, s);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, s) {
    const n = s.skeletons, i = [], o = e.parents.map(function(h) {
      return se.Objects.Model[h.ID];
    });
    if (o.length === 0)
      return;
    const r = e.children.reduce(function(h, g) {
      return n[g.ID] !== void 0 && (h = n[g.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      s.morphTargets[h.ID] !== void 0 && i.push(s.morphTargets[h.ID]);
    });
    const a = o[0], c = {};
    "RotationOrder" in a && (c.eulerOrder = Hn(a.RotationOrder.value)), "InheritType" in a && (c.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (c.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (c.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (c.scale = a.GeometricScaling.value);
    const l = Er(c);
    return this.genGeometry(t, r, i, l);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, s, n) {
    const i = new ut();
    e.attrName && (i.name = e.attrName);
    const o = this.parseGeoNode(e, t), r = this.genBuffers(o), a = new ke(r.vertex, 3);
    if (a.applyMatrix4(n), i.setAttribute("position", a), r.colors.length > 0 && i.setAttribute("color", new ke(r.colors, 3)), t && (i.setAttribute("skinIndex", new Ga(r.weightsIndices, 4)), i.setAttribute("skinWeight", new ke(r.vertexWeights, 4)), i.FBX_Deformer = t), r.normal.length > 0) {
      const c = new Oo().getNormalMatrix(n), l = new ke(r.normal, 3);
      l.applyNormalMatrix(c), i.setAttribute("normal", l);
    }
    if (r.uvs.forEach(function(c, l) {
      const h = l === 0 ? "uv" : `uv${l}`;
      i.setAttribute(h, new ke(r.uvs[l], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let c = r.materialIndex[0], l = 0;
      if (r.materialIndex.forEach(function(h, g) {
        h !== c && (i.addGroup(l, g - l, c), c = h, l = g);
      }), i.groups.length > 0) {
        const h = i.groups[i.groups.length - 1], g = h.start + h.count;
        g !== r.materialIndex.length && i.addGroup(g, r.materialIndex.length - g, c);
      }
      i.groups.length === 0 && i.addGroup(0, r.materialIndex.length, r.materialIndex[0]);
    }
    return this.addMorphTargets(i, e, s, n), i;
  }
  parseGeoNode(e, t) {
    const s = {};
    if (s.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], s.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (s.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (s.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (s.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      s.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && s.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return s.weightTable = {}, t !== null && (s.skeleton = t, t.rawBones.forEach(function(n, i) {
      n.indices.forEach(function(o, r) {
        s.weightTable[o] === void 0 && (s.weightTable[o] = []), s.weightTable[o].push({
          id: i,
          weight: n.weights[r]
        });
      });
    })), s;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let s = 0, n = 0, i = !1, o = [], r = [], a = [], c = [], l = [], h = [];
    const g = this;
    return e.vertexIndices.forEach(function(d, p) {
      let m, I = !1;
      d < 0 && (d = d ^ -1, I = !0);
      let b = [], B = [];
      if (o.push(d * 3, d * 3 + 1, d * 3 + 2), e.color) {
        const E = Xn(p, s, d, e.color);
        a.push(E[0], E[1], E[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[d] !== void 0 && e.weightTable[d].forEach(function(E) {
          B.push(E.weight), b.push(E.id);
        }), B.length > 4) {
          i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0);
          const E = [0, 0, 0, 0], w = [0, 0, 0, 0];
          B.forEach(function(Q, R) {
            let _ = Q, x = b[R];
            w.forEach(function(T, L, N) {
              if (_ > T) {
                N[L] = _, _ = T;
                const O = E[L];
                E[L] = x, x = O;
              }
            });
          }), b = E, B = w;
        }
        for (; B.length < 4; )
          B.push(0), b.push(0);
        for (let E = 0; E < 4; ++E)
          l.push(B[E]), h.push(b[E]);
      }
      if (e.normal) {
        const E = Xn(p, s, d, e.normal);
        r.push(E[0], E[1], E[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (m = Xn(p, s, d, e.material)[0], m < 0 && (g.negativeMaterialIndices = !0, m = 0)), e.uv && e.uv.forEach(function(E, w) {
        const Q = Xn(p, s, d, E);
        c[w] === void 0 && (c[w] = []), c[w].push(Q[0]), c[w].push(Q[1]);
      }), n++, I && (g.genFace(t, e, o, m, r, a, c, l, h, n), s++, n = 0, o = [], r = [], a = [], c = [], l = [], h = []);
    }), t;
  }
  // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
  getNormalNewell(e) {
    const t = new P(0, 0, 0);
    for (let s = 0; s < e.length; s++) {
      const n = e[s], i = e[(s + 1) % e.length];
      t.x += (n.y - i.y) * (n.z + i.z), t.y += (n.z - i.z) * (n.x + i.x), t.z += (n.x - i.x) * (n.y + i.y);
    }
    return t.normalize(), t;
  }
  getNormalTangentAndBitangent(e) {
    const t = this.getNormalNewell(e), n = (Math.abs(t.z) > 0.5 ? new P(0, 1, 0) : new P(0, 0, 1)).cross(t).normalize(), i = t.clone().cross(n).normalize();
    return {
      normal: t,
      tangent: n,
      bitangent: i
    };
  }
  flattenVertex(e, t, s) {
    return new Le(
      e.dot(t),
      e.dot(s)
    );
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, s, n, i, o, r, a, c, l) {
    let h;
    if (l > 3) {
      const g = [], d = t.baseVertexPositions || t.vertexPositions;
      for (let b = 0; b < s.length; b += 3)
        g.push(
          new P(
            d[s[b]],
            d[s[b + 1]],
            d[s[b + 2]]
          )
        );
      const { tangent: p, bitangent: m } = this.getNormalTangentAndBitangent(g), I = [];
      for (const b of g)
        I.push(this.flattenVertex(b, p, m));
      h = Pa.triangulateShape(I, []);
    } else
      h = [[0, 1, 2]];
    for (const [g, d, p] of h)
      e.vertex.push(t.vertexPositions[s[g * 3]]), e.vertex.push(t.vertexPositions[s[g * 3 + 1]]), e.vertex.push(t.vertexPositions[s[g * 3 + 2]]), e.vertex.push(t.vertexPositions[s[d * 3]]), e.vertex.push(t.vertexPositions[s[d * 3 + 1]]), e.vertex.push(t.vertexPositions[s[d * 3 + 2]]), e.vertex.push(t.vertexPositions[s[p * 3]]), e.vertex.push(t.vertexPositions[s[p * 3 + 1]]), e.vertex.push(t.vertexPositions[s[p * 3 + 2]]), t.skeleton && (e.vertexWeights.push(a[g * 4]), e.vertexWeights.push(a[g * 4 + 1]), e.vertexWeights.push(a[g * 4 + 2]), e.vertexWeights.push(a[g * 4 + 3]), e.vertexWeights.push(a[d * 4]), e.vertexWeights.push(a[d * 4 + 1]), e.vertexWeights.push(a[d * 4 + 2]), e.vertexWeights.push(a[d * 4 + 3]), e.vertexWeights.push(a[p * 4]), e.vertexWeights.push(a[p * 4 + 1]), e.vertexWeights.push(a[p * 4 + 2]), e.vertexWeights.push(a[p * 4 + 3]), e.weightsIndices.push(c[g * 4]), e.weightsIndices.push(c[g * 4 + 1]), e.weightsIndices.push(c[g * 4 + 2]), e.weightsIndices.push(c[g * 4 + 3]), e.weightsIndices.push(c[d * 4]), e.weightsIndices.push(c[d * 4 + 1]), e.weightsIndices.push(c[d * 4 + 2]), e.weightsIndices.push(c[d * 4 + 3]), e.weightsIndices.push(c[p * 4]), e.weightsIndices.push(c[p * 4 + 1]), e.weightsIndices.push(c[p * 4 + 2]), e.weightsIndices.push(c[p * 4 + 3])), t.color && (e.colors.push(o[g * 3]), e.colors.push(o[g * 3 + 1]), e.colors.push(o[g * 3 + 2]), e.colors.push(o[d * 3]), e.colors.push(o[d * 3 + 1]), e.colors.push(o[d * 3 + 2]), e.colors.push(o[p * 3]), e.colors.push(o[p * 3 + 1]), e.colors.push(o[p * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(i[g * 3]), e.normal.push(i[g * 3 + 1]), e.normal.push(i[g * 3 + 2]), e.normal.push(i[d * 3]), e.normal.push(i[d * 3 + 1]), e.normal.push(i[d * 3 + 2]), e.normal.push(i[p * 3]), e.normal.push(i[p * 3 + 1]), e.normal.push(i[p * 3 + 2])), t.uv && t.uv.forEach(function(m, I) {
        e.uvs[I] === void 0 && (e.uvs[I] = []), e.uvs[I].push(r[I][g * 2]), e.uvs[I].push(r[I][g * 2 + 1]), e.uvs[I].push(r[I][d * 2]), e.uvs[I].push(r[I][d * 2 + 1]), e.uvs[I].push(r[I][p * 2]), e.uvs[I].push(r[I][p * 2 + 1]);
      });
  }
  addMorphTargets(e, t, s, n) {
    if (s.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const i = this;
    s.forEach(function(o) {
      o.rawTargets.forEach(function(r) {
        const a = se.Objects.Geometry[r.geoID];
        a !== void 0 && i.genMorphGeometry(e, t, a, n, r.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, s, n, i) {
    const o = t.Vertices !== void 0 ? t.Vertices.a : [], r = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = s.Vertices !== void 0 ? s.Vertices.a : [], c = s.Indexes !== void 0 ? s.Indexes.a : [], l = e.attributes.position.count * 3, h = new Float32Array(l);
    for (let m = 0; m < c.length; m++) {
      const I = c[m] * 3;
      h[I] = a[m * 3], h[I + 1] = a[m * 3 + 1], h[I + 2] = a[m * 3 + 2];
    }
    const g = {
      vertexIndices: r,
      vertexPositions: h,
      baseVertexPositions: o
    }, d = this.genBuffers(g), p = new ke(d.vertex, 3);
    p.name = i || s.attrName, p.applyMatrix4(n), e.morphAttributes.position.push(p);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.Normals.a;
    let i = [];
    return s === "IndexToDirect" && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.UV.a;
    let i = [];
    return s === "IndexToDirect" && (i = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    if (!e.Colors)
      return;
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.Colors.a;
    let i = [];
    s === "IndexToDirect" && (i = e.ColorIndex.a);
    for (let o = 0, r = new Se(); o < n.length; o += 4)
      r.fromArray(n, o), Ve.toWorkingColorSpace(r, ge), r.toArray(n, o);
    return {
      dataSize: 4,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: s
      };
    const n = e.Materials.a, i = [];
    for (let o = 0; o < n.length; ++o)
      i.push(o);
    return {
      dataSize: 1,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new ut();
    const s = t - 1, n = e.KnotVector.a, i = [], o = e.Points.a;
    for (let h = 0, g = o.length; h < g; h += 4)
      i.push(new Ut().fromArray(o, h));
    let r, a;
    if (e.Form === "Closed")
      i.push(i[0]);
    else if (e.Form === "Periodic") {
      r = s, a = n.length - 1 - r;
      for (let h = 0; h < s; ++h)
        i.push(i[h]);
    }
    const l = new Dc(s, n, i, r, a).getPoints(i.length * 12);
    return new ut().setFromPoints(l);
  }
}
class Fc {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const s in t) {
        const n = t[s], i = this.addClip(n);
        e.push(i);
      }
    return e;
  }
  parseClips() {
    if (se.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = se.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const s in e) {
      const n = e[s];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const i = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(i.id, i);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = se.Objects.AnimationCurve;
    for (const s in t) {
      const n = {
        id: t[s].id,
        times: t[s].KeyTime.a.map(Pc),
        values: t[s].KeyValueFloat.a
      }, i = _e.get(n.id);
      if (i !== void 0) {
        const o = i.parents[0].ID, r = i.parents[0].relationship;
        r.match(/X/) ? e.get(o).curves.x = n : r.match(/Y/) ? e.get(o).curves.y = n : r.match(/Z/) ? e.get(o).curves.z = n : r.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = se.Objects.AnimationLayer, s = /* @__PURE__ */ new Map();
    for (const n in t) {
      const i = [], o = _e.get(parseInt(n));
      o !== void 0 && (o.children.forEach(function(a, c) {
        if (e.has(a.ID)) {
          const l = e.get(a.ID);
          if (l.curves.x !== void 0 || l.curves.y !== void 0 || l.curves.z !== void 0) {
            if (i[c] === void 0) {
              const h = _e.get(a.ID).parents.filter(function(g) {
                return g.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const g = se.Objects.Model[h.toString()];
                if (g === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", a);
                  return;
                }
                const d = {
                  modelName: g.attrName ? It.sanitizeNodeName(g.attrName) : "",
                  ID: g.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                ze.traverse(function(p) {
                  p.ID === g.id && (d.transform = p.matrix, p.userData.transformData && (d.eulerOrder = p.userData.transformData.eulerOrder));
                }), d.transform || (d.transform = new ue()), "PreRotation" in g && (d.preRotation = g.PreRotation.value), "PostRotation" in g && (d.postRotation = g.PostRotation.value), i[c] = d;
              }
            }
            i[c] && (i[c][l.attr] = l);
          } else if (l.curves.morph !== void 0) {
            if (i[c] === void 0) {
              const h = _e.get(a.ID).parents.filter(function(b) {
                return b.relationship !== void 0;
              })[0].ID, g = _e.get(h).parents[0].ID, d = _e.get(g).parents[0].ID, p = _e.get(d).parents[0].ID, m = se.Objects.Model[p], I = {
                modelName: m.attrName ? It.sanitizeNodeName(m.attrName) : "",
                morphName: se.Objects.Deformer[h].attrName
              };
              i[c] = I;
            }
            i[c][l.attr] = l;
          }
        }
      }), s.set(parseInt(n), i));
    }
    return s;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = se.Objects.AnimationStack, s = {};
    for (const n in t) {
      const i = _e.get(parseInt(n)).children;
      i.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const o = e.get(i[0].ID);
      s[n] = {
        name: t[n].attrName,
        layer: o
      };
    }
    return s;
  }
  addClip(e) {
    let t = [];
    const s = this;
    return e.layer.forEach(function(n) {
      t = t.concat(s.generateTracks(n));
    }), new pi(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let s = new P(), n = new P();
    if (e.transform && e.transform.decompose(s, new Te(), n), s = s.toArray(), n = n.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const i = this.generateVectorTrack(e.modelName, e.T.curves, s, "position");
      i !== void 0 && t.push(i);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const i = this.generateRotationTrack(e.modelName, e.R.curves, e.preRotation, e.postRotation, e.eulerOrder);
      i !== void 0 && t.push(i);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const i = this.generateVectorTrack(e.modelName, e.S.curves, n, "scale");
      i !== void 0 && t.push(i);
    }
    if (e.DeformPercent !== void 0) {
      const i = this.generateMorphTrack(e);
      i !== void 0 && t.push(i);
    }
    return t;
  }
  generateVectorTrack(e, t, s, n) {
    const i = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(i, t, s);
    return new ls(e + "." + n, i, o);
  }
  generateRotationTrack(e, t, s, n, i) {
    let o, r;
    if (t.x === void 0 || t.y === void 0 || t.z === void 0) {
      console.warn("THREE.FBXLoader: Missing rotation curves " + (t.x === void 0 ? "x " : "") + (t.y === void 0 ? "y " : "") + (t.z === void 0 ? "z " : "") + " for animation of " + e + ". This is currently not supported.");
      return;
    }
    if (t.x !== void 0 && t.y !== void 0 && t.z !== void 0) {
      const g = this.interpolateRotations(t.x, t.y, t.z, i);
      o = g[0], r = g[1];
    }
    const a = Hn(0);
    s !== void 0 && (s = s.map(ye.degToRad), s.push(a), s = new zt().fromArray(s), s = new Te().setFromEuler(s)), n !== void 0 && (n = n.map(ye.degToRad), n.push(a), n = new zt().fromArray(n), n = new Te().setFromEuler(n).invert());
    const c = new Te(), l = new zt(), h = [];
    if (!(!r || !o)) {
      for (let g = 0; g < r.length; g += 3)
        l.set(r[g], r[g + 1], r[g + 2], i), c.setFromEuler(l), s !== void 0 && c.premultiply(s), n !== void 0 && c.multiply(n), g > 2 && new Te().fromArray(
          h,
          (g - 3) / 3 * 4
        ).dot(c) < 0 && c.set(-c.x, -c.y, -c.z, -c.w), c.toArray(h, g / 3 * 4);
      return new us(e + ".quaternion", o, h);
    }
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, s = t.values.map(function(i) {
      return i / 100;
    }), n = ze.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new hs(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, s);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(s, n) {
      return s - n;
    }), t.length > 1) {
      let s = 1, n = t[0];
      for (let i = 1; i < t.length; i++) {
        const o = t[i];
        o !== n && (t[s] = o, n = o, s++);
      }
      t = t.slice(0, s);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, s) {
    const n = s, i = [];
    let o = -1, r = -1, a = -1;
    return e.forEach(function(c) {
      if (t.x && (o = t.x.times.indexOf(c)), t.y && (r = t.y.times.indexOf(c)), t.z && (a = t.z.times.indexOf(c)), o !== -1) {
        const l = t.x.values[o];
        i.push(l), n[0] = l;
      } else
        i.push(n[0]);
      if (r !== -1) {
        const l = t.y.values[r];
        i.push(l), n[1] = l;
      } else
        i.push(n[1]);
      if (a !== -1) {
        const l = t.z.values[a];
        i.push(l), n[2] = l;
      } else
        i.push(n[2]);
    }), i;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e, t, s, n) {
    const i = [], o = [];
    i.push(e.times[0]), o.push(ye.degToRad(e.values[0])), o.push(ye.degToRad(t.values[0])), o.push(ye.degToRad(s.values[0]));
    for (let r = 1; r < e.values.length; r++) {
      const a = [
        e.values[r - 1],
        t.values[r - 1],
        s.values[r - 1]
      ];
      if (isNaN(a[0]) || isNaN(a[1]) || isNaN(a[2]))
        continue;
      const c = a.map(ye.degToRad), l = [
        e.values[r],
        t.values[r],
        s.values[r]
      ];
      if (isNaN(l[0]) || isNaN(l[1]) || isNaN(l[2]))
        continue;
      const h = l.map(ye.degToRad), g = [
        l[0] - a[0],
        l[1] - a[1],
        l[2] - a[2]
      ], d = [
        Math.abs(g[0]),
        Math.abs(g[1]),
        Math.abs(g[2])
      ];
      if (d[0] >= 180 || d[1] >= 180 || d[2] >= 180) {
        const m = Math.max(...d) / 180, I = new zt(...c, n), b = new zt(...h, n), B = new Te().setFromEuler(I), E = new Te().setFromEuler(b);
        B.dot(E) && E.set(-E.x, -E.y, -E.z, -E.w);
        const w = e.times[r - 1], Q = e.times[r] - w, R = new Te(), _ = new zt();
        for (let x = 0; x < 1; x += 1 / m)
          R.copy(B.clone().slerp(E.clone(), x)), i.push(w + x * Q), _.setFromQuaternion(R, n), o.push(_.x), o.push(_.y), o.push(_.z);
      } else
        i.push(e.times[r]), o.push(ye.degToRad(e.values[r])), o.push(ye.degToRad(t.values[r])), o.push(ye.degToRad(s.values[r]));
    }
    return [i, o];
  }
}
class Lc {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new br(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, s = e.split(/[\r\n]+/);
    return s.forEach(function(n, i) {
      const o = n.match(/^[\s\t]*;/), r = n.match(/^[\s\t]*$/);
      if (o || r)
        return;
      const a = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), l = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      a ? t.parseNodeBegin(n, a) : c ? t.parseNodeProperty(n, c, s[++i]) : l ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const s = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(a) {
      return a.trim().replace(/^"/, "").replace(/"$/, "");
    }), i = { name: s }, o = this.parseNodeAttr(n), r = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(s, i) : s in r ? (s === "PoseNode" ? r.PoseNode.push(i) : r[s].id !== void 0 && (r[s] = {}, r[s][r[s].id] = r[s]), o.id !== "" && (r[s][o.id] = i)) : typeof o.id == "number" ? (r[s] = {}, r[s][o.id] = i) : s !== "Properties70" && (s === "PoseNode" ? r[s] = [i] : r[s] = i), typeof o.id == "number" && (i.id = o.id), o.name !== "" && (i.attrName = o.name), o.type !== "" && (i.attrType = o.type), this.pushStack(i);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let s = "", n = "";
    return e.length > 1 && (s = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: s, type: n };
  }
  parseNodeProperty(e, t, s) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && i === "," && (i = s.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, i);
      return;
    }
    if (n === "C") {
      const a = i.split(",").slice(1), c = parseInt(a[0]), l = parseInt(a[1]);
      let h = i.split(",").slice(3);
      h = h.map(function(g) {
        return g.trim().replace(/^"/, "");
      }), n = "connections", i = [c, l], Hc(i, h), o[n] === void 0 && (o[n] = []);
    }
    n === "Node" && (o.id = i), n in o && Array.isArray(o[n]) ? o[n].push(i) : n !== "a" ? o[n] = i : o.a = i, this.setCurrentProp(o, n), n === "a" && i.slice(-1) !== "," && (o.a = Us(i));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = Us(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, s) {
    const n = s.split('",').map(function(l) {
      return l.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), i = n[0], o = n[1], r = n[2], a = n[3];
    let c = n[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = Us(c);
        break;
    }
    this.getPrevNode()[i] = {
      type: o,
      type2: r,
      flag: a,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), i);
  }
}
class Nc {
  parse(e) {
    const t = new to(e);
    t.skip(23);
    const s = t.getUint32();
    if (s < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + s);
    const n = new br();
    for (; !this.endOfContent(t); ) {
      const i = this.parseNode(t, s);
      i !== null && n.add(i.name, i);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const s = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), r = e.getString(o);
    if (n === 0)
      return null;
    const a = [];
    for (let g = 0; g < i; g++)
      a.push(this.parseProperty(e));
    const c = a.length > 0 ? a[0] : "", l = a.length > 1 ? a[1] : "", h = a.length > 2 ? a[2] : "";
    for (s.singleProperty = i === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const g = this.parseNode(e, t);
      g !== null && this.parseSubNode(r, s, g);
    }
    return s.propertyList = a, typeof c == "number" && (s.id = c), l !== "" && (s.attrName = l), h !== "" && (s.attrType = h), r !== "" && (s.name = r), s;
  }
  parseSubNode(e, t, s) {
    if (s.singleProperty === !0) {
      const n = s.propertyList[0];
      Array.isArray(n) ? (t[s.name] = s, s.a = n) : t[s.name] = n;
    } else if (e === "Connections" && s.name === "C") {
      const n = [];
      s.propertyList.forEach(function(i, o) {
        o !== 0 && n.push(i);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (s.name === "Properties70")
      Object.keys(s).forEach(function(i) {
        t[i] = s[i];
      });
    else if (e === "Properties70" && s.name === "P") {
      let n = s.propertyList[0], i = s.propertyList[1];
      const o = s.propertyList[2], r = s.propertyList[3];
      let a;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), i === "Color" || i === "ColorRGB" || i === "Vector" || i === "Vector3D" || i.indexOf("Lcl_") === 0 ? a = [
        s.propertyList[4],
        s.propertyList[5],
        s.propertyList[6]
      ] : a = s.propertyList[4], t[n] = {
        type: i,
        type2: o,
        flag: r,
        value: a
      };
    } else
      t[s.name] === void 0 ? typeof s.id == "number" ? (t[s.name] = {}, t[s.name][s.id] = s) : t[s.name] = s : s.name === "PoseNode" ? (Array.isArray(t[s.name]) || (t[s.name] = [t[s.name]]), t[s.name].push(s)) : t[s.name][s.id] === void 0 && (t[s.name][s.id] = s);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let s;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return s = e.getUint32(), e.getArrayBuffer(s);
      case "S":
        return s = e.getUint32(), e.getString(s);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), i = e.getUint32(), o = e.getUint32();
        if (i === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const r = Ln(new Uint8Array(e.getArrayBuffer(o))), a = new to(r.buffer);
        switch (t) {
          case "b":
          case "c":
            return a.getBooleanArray(n);
          case "d":
            return a.getFloat64Array(n);
          case "f":
            return a.getFloat32Array(n);
          case "i":
            return a.getInt32Array(n);
          case "l":
            return a.getInt64Array(n);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class to {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let s = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const n = s.indexOf(0);
    return n >= 0 && (s = new Uint8Array(this.dv.buffer, t, n)), this._textDecoder.decode(s);
  }
}
class br {
  add(e, t) {
    this[e] = t;
  }
}
function Uc(A) {
  const e = "Kaydara FBX Binary  \0";
  return A.byteLength >= e.length && e === Cr(A, 0, e.length);
}
function Gc(A) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function s(n) {
    const i = A[n - 1];
    return A = A.slice(t + n), t++, i;
  }
  for (let n = 0; n < e.length; ++n)
    if (s(1) === e[n])
      return !1;
  return !0;
}
function no(A) {
  const e = /FBXVersion: (\d+)/, t = A.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function Pc(A) {
  return A / 46186158e3;
}
const Oc = [];
function Xn(A, e, t, s) {
  let n;
  switch (s.mappingType) {
    case "ByPolygonVertex":
      n = A;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = s.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + s.mappingType);
  }
  s.referenceType === "IndexToDirect" && (n = s.indices[n]);
  const i = n * s.dataSize, o = i + s.dataSize;
  return jc(Oc, s.buffer, i, o);
}
const Ns = new zt(), hn = new P();
function Er(A) {
  const e = new ue(), t = new ue(), s = new ue(), n = new ue(), i = new ue(), o = new ue(), r = new ue(), a = new ue(), c = new ue(), l = new ue(), h = new ue(), g = new ue(), d = A.inheritType ? A.inheritType : 0;
  A.translation && e.setPosition(hn.fromArray(A.translation));
  const p = Hn(0);
  if (A.preRotation) {
    const N = A.preRotation.map(ye.degToRad);
    N.push(p), t.makeRotationFromEuler(Ns.fromArray(N));
  }
  if (A.rotation) {
    const N = A.rotation.map(ye.degToRad);
    N.push(A.eulerOrder || p), s.makeRotationFromEuler(Ns.fromArray(N));
  }
  if (A.postRotation) {
    const N = A.postRotation.map(ye.degToRad);
    N.push(p), n.makeRotationFromEuler(Ns.fromArray(N)), n.invert();
  }
  A.scale && i.scale(hn.fromArray(A.scale)), A.scalingOffset && r.setPosition(hn.fromArray(A.scalingOffset)), A.scalingPivot && o.setPosition(hn.fromArray(A.scalingPivot)), A.rotationOffset && a.setPosition(hn.fromArray(A.rotationOffset)), A.rotationPivot && c.setPosition(hn.fromArray(A.rotationPivot)), A.parentMatrixWorld && (h.copy(A.parentMatrix), l.copy(A.parentMatrixWorld));
  const m = t.clone().multiply(s).multiply(n), I = new ue();
  I.extractRotation(l);
  const b = new ue();
  b.copyPosition(l);
  const B = b.clone().invert().multiply(l), E = I.clone().invert().multiply(B), w = i, Q = new ue();
  if (d === 0)
    Q.copy(I).multiply(m).multiply(E).multiply(w);
  else if (d === 1)
    Q.copy(I).multiply(E).multiply(m).multiply(w);
  else {
    const O = new ue().scale(new P().setFromMatrixScale(h)).clone().invert(), Z = E.clone().multiply(O);
    Q.copy(I).multiply(m).multiply(Z).multiply(w);
  }
  const R = c.clone().invert(), _ = o.clone().invert();
  let x = e.clone().multiply(a).multiply(c).multiply(t).multiply(s).multiply(n).multiply(R).multiply(r).multiply(o).multiply(i).multiply(_);
  const T = new ue().copyPosition(x), L = l.clone().multiply(T);
  return g.copyPosition(L), x = g.clone().multiply(Q), x.premultiply(l.invert()), x;
}
function Hn(A) {
  A = A || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return A === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[A];
}
function Us(A) {
  return A.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Cr(A, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = A.byteLength), new TextDecoder().decode(new Uint8Array(A, e, t));
}
function Hc(A, e) {
  for (let t = 0, s = A.length, n = e.length; t < n; t++, s++)
    A[s] = e[t];
}
function jc(A, e, t, s) {
  for (let n = t, i = 0; n < s; n++, i++)
    A[i] = e[n];
  return A;
}
class qc extends Nt {
  constructor(e) {
    super(e);
  }
  /**
   * Loads and parses a MTL asset from a URL.
   *
   * @param {String} url - URL to the MTL file.
   * @param {Function} [onLoad] - Callback invoked with the loaded object.
   * @param {Function} [onProgress] - Callback for download progress.
   * @param {Function} [onError] - Callback for download errors.
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to load.
   */
  load(e, t, s, n) {
    const i = this, o = this.path === "" ? nn.extractUrlBase(e) : this.path, r = new ft(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, function(a) {
      try {
        t(i.parse(a, o));
      } catch (c) {
        n ? n(c) : console.error(c), i.manager.itemError(e);
      }
    }, s, n);
  }
  setMaterialOptions(e) {
    return this.materialOptions = e, this;
  }
  /**
   * Parses a MTL file.
   *
   * @param {String} text - Content of MTL file
   * @return {MaterialCreator}
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to parse.
   */
  parse(e, t) {
    const s = e.split(`
`);
    let n = {};
    const i = /\s+/, o = {};
    for (let a = 0; a < s.length; a++) {
      let c = s[a];
      if (c = c.trim(), c.length === 0 || c.charAt(0) === "#")
        continue;
      const l = c.indexOf(" ");
      let h = l >= 0 ? c.substring(0, l) : c;
      h = h.toLowerCase();
      let g = l >= 0 ? c.substring(l + 1) : "";
      if (g = g.trim(), h === "newmtl")
        n = { name: g }, o[g] = n;
      else if (h === "ka" || h === "kd" || h === "ks" || h === "ke") {
        const d = g.split(i, 3);
        n[h] = [parseFloat(d[0]), parseFloat(d[1]), parseFloat(d[2])];
      } else
        n[h] = g;
    }
    const r = new zc(this.resourcePath || t, this.materialOptions);
    return r.setCrossOrigin(this.crossOrigin), r.setManager(this.manager), r.setMaterials(o), r;
  }
}
class zc {
  constructor(e = "", t = {}) {
    this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : No, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : rn;
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setManager(e) {
    this.manager = e;
  }
  setMaterials(e) {
    this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
  }
  convert(e) {
    if (!this.options)
      return e;
    const t = {};
    for (const s in e) {
      const n = e[s], i = {};
      t[s] = i;
      for (const o in n) {
        let r = !0, a = n[o];
        const c = o.toLowerCase();
        switch (c) {
          case "kd":
          case "ka":
          case "ks":
            this.options && this.options.normalizeRGB && (a = [a[0] / 255, a[1] / 255, a[2] / 255]), this.options && this.options.ignoreZeroRGBs && a[0] === 0 && a[1] === 0 && a[2] === 0 && (r = !1);
            break;
        }
        r && (i[c] = a);
      }
    }
    return t;
  }
  preload() {
    for (const e in this.materialsInfo)
      this.create(e);
  }
  getIndex(e) {
    return this.nameLookup[e];
  }
  getAsArray() {
    let e = 0;
    for (const t in this.materialsInfo)
      this.materialsArray[e] = this.create(t), this.nameLookup[t] = e, e++;
    return this.materialsArray;
  }
  create(e) {
    return this.materials[e] === void 0 && this.createMaterial_(e), this.materials[e];
  }
  createMaterial_(e) {
    const t = this, s = this.materialsInfo[e], n = {
      name: e,
      side: this.side
    };
    function i(r, a) {
      return typeof a != "string" || a === "" ? "" : /^https?:\/\//i.test(a) ? a : r + a;
    }
    function o(r, a) {
      if (n[r])
        return;
      const c = t.getTextureParams(a, n), l = t.loadTexture(i(t.baseUrl, c.url));
      l.repeat.copy(c.scale), l.offset.copy(c.offset), l.wrapS = t.wrap, l.wrapT = t.wrap, (r === "map" || r === "emissiveMap") && (l.colorSpace = ge), n[r] = l;
    }
    for (const r in s) {
      const a = s[r];
      let c;
      if (a !== "")
        switch (r.toLowerCase()) {
          case "kd":
            n.color = Ve.toWorkingColorSpace(new Se().fromArray(a), ge);
            break;
          case "ks":
            n.specular = Ve.toWorkingColorSpace(new Se().fromArray(a), ge);
            break;
          case "ke":
            n.emissive = Ve.toWorkingColorSpace(new Se().fromArray(a), ge);
            break;
          case "map_kd":
            o("map", a);
            break;
          case "map_ks":
            o("specularMap", a);
            break;
          case "map_ke":
            o("emissiveMap", a);
            break;
          case "norm":
            o("normalMap", a);
            break;
          case "map_bump":
          case "bump":
            o("bumpMap", a);
            break;
          case "map_d":
            o("alphaMap", a), n.transparent = !0;
            break;
          case "ns":
            n.shininess = parseFloat(a);
            break;
          case "d":
            c = parseFloat(a), c < 1 && (n.opacity = c, n.transparent = !0);
            break;
          case "tr":
            c = parseFloat(a), this.options && this.options.invertTrProperty && (c = 1 - c), c > 0 && (n.opacity = 1 - c, n.transparent = !0);
            break;
        }
    }
    return this.materials[e] = new Pn(n), this.materials[e];
  }
  getTextureParams(e, t) {
    const s = {
      scale: new Le(1, 1),
      offset: new Le(0, 0)
    }, n = e.split(/\s+/);
    let i;
    return i = n.indexOf("-bm"), i >= 0 && (t.bumpScale = parseFloat(n[i + 1]), n.splice(i, 2)), i = n.indexOf("-s"), i >= 0 && (s.scale.set(parseFloat(n[i + 1]), parseFloat(n[i + 2])), n.splice(i, 4)), i = n.indexOf("-o"), i >= 0 && (s.offset.set(parseFloat(n[i + 1]), parseFloat(n[i + 2])), n.splice(i, 4)), s.url = n.join(" ").trim(), s;
  }
  loadTexture(e, t, s, n, i) {
    const o = this.manager !== void 0 ? this.manager : Oa;
    let r = o.getHandler(e);
    r === null && (r = new hi(o)), r.setCrossOrigin && r.setCrossOrigin(this.crossOrigin);
    const a = r.load(e, s, n, i);
    return t !== void 0 && (a.mapping = t), a;
  }
}
const Kc = /^[og]\s*(.+)?/, Yc = /^mtllib /, Jc = /^usemtl /, Vc = /^usemap /, so = /\s+/, io = new P(), Gs = new P(), oo = new P(), ro = new P(), ct = new P(), Zn = new Se();
function Wc() {
  const A = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(e, t) {
      if (this.object && this.object.fromDeclaration === !1) {
        this.object.name = e, this.object.fromDeclaration = t !== !1;
        return;
      }
      const s = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
        name: e || "",
        fromDeclaration: t !== !1,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: !1
        },
        materials: [],
        smooth: !0,
        startMaterial: function(n, i) {
          const o = this._finalize(!1);
          o && (o.inherited || o.groupCount <= 0) && this.materials.splice(o.index, 1);
          const r = {
            index: this.materials.length,
            name: n || "",
            mtllib: Array.isArray(i) && i.length > 0 ? i[i.length - 1] : "",
            smooth: o !== void 0 ? o.smooth : this.smooth,
            groupStart: o !== void 0 ? o.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: !1,
            clone: function(a) {
              const c = {
                index: typeof a == "number" ? a : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: !1
              };
              return c.clone = this.clone.bind(c), c;
            }
          };
          return this.materials.push(r), r;
        },
        currentMaterial: function() {
          if (this.materials.length > 0)
            return this.materials[this.materials.length - 1];
        },
        _finalize: function(n) {
          const i = this.currentMaterial();
          if (i && i.groupEnd === -1 && (i.groupEnd = this.geometry.vertices.length / 3, i.groupCount = i.groupEnd - i.groupStart, i.inherited = !1), n && this.materials.length > 1)
            for (let o = this.materials.length - 1; o >= 0; o--)
              this.materials[o].groupCount <= 0 && this.materials.splice(o, 1);
          return n && this.materials.length === 0 && this.materials.push({
            name: "",
            smooth: this.smooth
          }), i;
        }
      }, s && s.name && typeof s.clone == "function") {
        const n = s.clone(0);
        n.inherited = !0, this.object.materials.push(n);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
    },
    parseVertexIndex: function(e, t) {
      const s = parseInt(e, 10);
      return (s >= 0 ? s - 1 : s + t / 3) * 3;
    },
    parseNormalIndex: function(e, t) {
      const s = parseInt(e, 10);
      return (s >= 0 ? s - 1 : s + t / 3) * 3;
    },
    parseUVIndex: function(e, t) {
      const s = parseInt(e, 10);
      return (s >= 0 ? s - 1 : s + t / 2) * 2;
    },
    addVertex: function(e, t, s) {
      const n = this.vertices, i = this.object.geometry.vertices;
      i.push(n[e + 0], n[e + 1], n[e + 2]), i.push(n[t + 0], n[t + 1], n[t + 2]), i.push(n[s + 0], n[s + 1], n[s + 2]);
    },
    addVertexPoint: function(e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addVertexLine: function(e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addNormal: function(e, t, s) {
      const n = this.normals, i = this.object.geometry.normals;
      i.push(n[e + 0], n[e + 1], n[e + 2]), i.push(n[t + 0], n[t + 1], n[t + 2]), i.push(n[s + 0], n[s + 1], n[s + 2]);
    },
    addFaceNormal: function(e, t, s) {
      const n = this.vertices, i = this.object.geometry.normals;
      io.fromArray(n, e), Gs.fromArray(n, t), oo.fromArray(n, s), ct.subVectors(oo, Gs), ro.subVectors(io, Gs), ct.cross(ro), ct.normalize(), i.push(ct.x, ct.y, ct.z), i.push(ct.x, ct.y, ct.z), i.push(ct.x, ct.y, ct.z);
    },
    addColor: function(e, t, s) {
      const n = this.colors, i = this.object.geometry.colors;
      n[e] !== void 0 && i.push(n[e + 0], n[e + 1], n[e + 2]), n[t] !== void 0 && i.push(n[t + 0], n[t + 1], n[t + 2]), n[s] !== void 0 && i.push(n[s + 0], n[s + 1], n[s + 2]);
    },
    addUV: function(e, t, s) {
      const n = this.uvs, i = this.object.geometry.uvs;
      i.push(n[e + 0], n[e + 1]), i.push(n[t + 0], n[t + 1]), i.push(n[s + 0], n[s + 1]);
    },
    addDefaultUV: function() {
      const e = this.object.geometry.uvs;
      e.push(0, 0), e.push(0, 0), e.push(0, 0);
    },
    addUVLine: function(e) {
      const t = this.uvs;
      this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
    },
    addFace: function(e, t, s, n, i, o, r, a, c) {
      const l = this.vertices.length;
      let h = this.parseVertexIndex(e, l), g = this.parseVertexIndex(t, l), d = this.parseVertexIndex(s, l);
      if (this.addVertex(h, g, d), this.addColor(h, g, d), r !== void 0 && r !== "") {
        const p = this.normals.length;
        h = this.parseNormalIndex(r, p), g = this.parseNormalIndex(a, p), d = this.parseNormalIndex(c, p), this.addNormal(h, g, d);
      } else
        this.addFaceNormal(h, g, d);
      if (n !== void 0 && n !== "") {
        const p = this.uvs.length;
        h = this.parseUVIndex(n, p), g = this.parseUVIndex(i, p), d = this.parseUVIndex(o, p), this.addUV(h, g, d), this.object.geometry.hasUVIndices = !0;
      } else
        this.addDefaultUV();
    },
    addPointGeometry: function(e) {
      this.object.geometry.type = "Points";
      const t = this.vertices.length;
      for (let s = 0, n = e.length; s < n; s++) {
        const i = this.parseVertexIndex(e[s], t);
        this.addVertexPoint(i), this.addColor(i);
      }
    },
    addLineGeometry: function(e, t) {
      this.object.geometry.type = "Line";
      const s = this.vertices.length, n = this.uvs.length;
      for (let i = 0, o = e.length; i < o; i++)
        this.addVertexLine(this.parseVertexIndex(e[i], s));
      for (let i = 0, o = t.length; i < o; i++)
        this.addUVLine(this.parseUVIndex(t[i], n));
    }
  };
  return A.startObject("", !1), A;
}
class Qh extends Nt {
  constructor(e) {
    super(e), this.materials = null, this.materialsLoader = new qc(e);
  }
  load(e, t, s, n) {
    const i = this, o = new ft(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, async function(r) {
      try {
        const a = i.parse(r, !0);
        for (let c = 0, l = a.materialLibraries.length; c < l; c++) {
          const h = a.materialLibraries[c], g = e.startsWith("blob:") ? e + "/" + h : new URL(h, e);
          console.debug("Loading MTL file: " + g), await new Promise((d, p) => {
            i.materialsLoader.load(g.toString(), (m) => {
              i.setMaterials(m), d();
            }, null, p);
          });
        }
        t(i.createObjects(a));
      } catch (a) {
        n ? n(a) : console.error(a), i.manager.itemError(e);
      }
    }, s, n);
  }
  setMTLLoader(e) {
    return this.materialsLoader = e, this;
  }
  setMaterials(e) {
    return this.materials = e, this;
  }
  parse(e, t = !1) {
    const s = new Wc();
    e.indexOf(`\r
`) !== -1 && (e = e.replace(/\r\n/g, `
`)), e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
    const n = e.split(`
`);
    let i = [];
    for (let o = 0, r = n.length; o < r; o++) {
      const a = n[o].trimStart();
      if (a.length === 0)
        continue;
      const c = a.charAt(0);
      if (c !== "#")
        if (c === "v") {
          const l = a.split(so);
          switch (l[0]) {
            case "v":
              s.vertices.push(
                parseFloat(l[1]),
                parseFloat(l[2]),
                parseFloat(l[3])
              ), l.length >= 7 ? (Zn.setRGB(
                parseFloat(l[4]),
                parseFloat(l[5]),
                parseFloat(l[6]),
                ge
              ), s.colors.push(Zn.r, Zn.g, Zn.b)) : s.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              s.normals.push(
                parseFloat(l[1]),
                parseFloat(l[2]),
                parseFloat(l[3])
              );
              break;
            case "vt":
              s.uvs.push(
                parseFloat(l[1]),
                parseFloat(l[2])
              );
              break;
          }
        } else if (c === "f") {
          const h = a.slice(1).trim().split(so), g = [];
          for (let p = 0, m = h.length; p < m; p++) {
            const I = h[p];
            if (I.length > 0) {
              const b = I.split("/");
              g.push(b);
            }
          }
          const d = g[0];
          for (let p = 1, m = g.length - 1; p < m; p++) {
            const I = g[p], b = g[p + 1];
            s.addFace(
              d[0],
              I[0],
              b[0],
              d[1],
              I[1],
              b[1],
              d[2],
              I[2],
              b[2]
            );
          }
        } else if (c === "l") {
          const l = a.substring(1).trim().split(" ");
          let h = [];
          const g = [];
          if (a.indexOf("/") === -1)
            h = l;
          else
            for (let d = 0, p = l.length; d < p; d++) {
              const m = l[d].split("/");
              m[0] !== "" && h.push(m[0]), m[1] !== "" && g.push(m[1]);
            }
          s.addLineGeometry(h, g);
        } else if (c === "p") {
          const h = a.slice(1).trim().split(" ");
          s.addPointGeometry(h);
        } else if ((i = Kc.exec(a)) !== null) {
          const l = (" " + i[0].slice(1).trim()).slice(1);
          s.startObject(l);
        } else if (Jc.test(a))
          s.object.startMaterial(a.substring(7).trim(), s.materialLibraries);
        else if (Yc.test(a))
          s.materialLibraries.push(a.substring(7).trim());
        else if (Vc.test(a))
          console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
        else if (c === "s") {
          if (i = a.split(" "), i.length > 1) {
            const h = i[1].trim().toLowerCase();
            s.object.smooth = h !== "0" && h !== "off";
          } else
            s.object.smooth = !0;
          const l = s.object.currentMaterial();
          l && (l.smooth = s.object.smooth);
        } else {
          if (a === "\0")
            continue;
          console.warn('THREE.OBJLoader: Unexpected line: "' + a + '"');
        }
    }
    return s.finalize(), t ? s : this.createObjects(s);
  }
  createObjects(e) {
    const t = new sn();
    if (t.materialLibraries = [].concat(e.materialLibraries), !(e.objects.length === 1 && e.objects[0].geometry.vertices.length === 0) === !0)
      for (let n = 0, i = e.objects.length; n < i; n++) {
        const o = e.objects[n], r = o.geometry, a = o.materials, c = r.type === "Line", l = r.type === "Points";
        let h = !1;
        if (r.vertices.length === 0)
          continue;
        const g = new ut();
        g.setAttribute("position", new ke(r.vertices, 3)), r.normals.length > 0 && g.setAttribute("normal", new ke(r.normals, 3)), r.colors.length > 0 && (h = !0, g.setAttribute("color", new ke(r.colors, 3))), r.hasUVIndices === !0 && g.setAttribute("uv", new ke(r.uvs, 2));
        const d = [];
        for (let m = 0, I = a.length; m < I; m++) {
          const b = a[m], B = b.name + "_" + b.smooth + "_" + h;
          let E = e.materials[B];
          if (this.materials !== null) {
            if (E = this.materials.create(b.name), c && E && !(E instanceof Lt)) {
              const w = new Lt();
              tn.prototype.copy.call(w, E), w.color.copy(E.color), E = w;
            } else if (l && E && !(E instanceof Dn)) {
              const w = new Dn({ size: 10, sizeAttenuation: !1 });
              tn.prototype.copy.call(w, E), w.color.copy(E.color), w.map = E.map, E = w;
            }
          }
          E === void 0 && (c ? E = new Lt() : l ? E = new Dn({ size: 1, sizeAttenuation: !1 }) : E = new Pn(), E.name = b.name, E.flatShading = !b.smooth, E.vertexColors = h, e.materials[B] = E), d.push(E);
        }
        let p;
        if (d.length > 1) {
          for (let m = 0, I = a.length; m < I; m++) {
            const b = a[m];
            g.addGroup(b.groupStart, b.groupCount, m);
          }
          c ? p = new As(g, d) : l ? p = new is(g, d) : p = new z(g, d);
        } else
          c ? p = new As(g, d[0]) : l ? p = new is(g, d[0]) : p = new z(g, d[0]);
        p.name = o.name, t.add(p);
      }
    else if (e.vertices.length > 0) {
      const n = new Dn({ size: 1, sizeAttenuation: !1 }), i = new ut();
      i.setAttribute("position", new ke(e.vertices, 3)), e.colors.length > 0 && e.colors[0] !== void 0 && (i.setAttribute("color", new ke(e.colors, 3)), n.vertexColors = !0);
      const o = new is(i, n);
      t.add(o);
    }
    return t;
  }
}
const ao = { type: "change" }, wi = { type: "start" }, Br = { type: "end" }, $n = new Ha(), Ao = new ja(), Xc = Math.cos(70 * ye.DEG2RAD), Me = new P();
new P();
const Ye = 2 * Math.PI, fe = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, Ps = 1e-6;
let xh = class extends Go {
  constructor(e, t = null) {
    super(e, t), this.state = fe.NONE, this.enabled = !0, this.target = new P(), this.cursor = new P(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: mn.ROTATE, MIDDLE: mn.DOLLY, RIGHT: mn.PAN }, this.touches = { ONE: fn.ROTATE, TWO: fn.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new P(), this._lastQuaternion = new Te(), this._lastTargetPosition = new P(), this._quat = new Te().setFromUnitVectors(e.up, new P(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new _i(), this._sphericalDelta = new _i(), this._scale = 1, this._currentScale = 1, this._panOffset = new P(), this._rotateStart = new Le(), this._rotateEnd = new Le(), this._rotateDelta = new Le(), this._panStart = new Le(), this._panEnd = new Le(), this._panDelta = new Le(), this._dollyStart = new Le(), this._dollyEnd = new Le(), this._dollyDelta = new Le(), this._dollyDirection = new P(), this._mouse = new Le(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = $c.bind(this), this._onPointerDown = Zc.bind(this), this._onPointerUp = el.bind(this), this._onContextMenu = al.bind(this), this._onMouseWheel = sl.bind(this), this._onKeyDown = il.bind(this), this._onTouchStart = ol.bind(this), this._onTouchMove = rl.bind(this), this._onMouseDown = tl.bind(this), this._onMouseMove = nl.bind(this), this._interceptControlDown = Al.bind(this), this._interceptControlUp = cl.bind(this), this.domElement !== null && this.connect(), this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(ao), this.update(), this.state = fe.NONE;
  }
  update(e = null) {
    const t = this.object.getWorldPosition(this.object.position);
    Me.copy(t).sub(this.target), Me.applyQuaternion(this._quat), this._spherical.setFromVector3(Me), this.autoRotate && this.state === fe.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let s = this.minAzimuthAngle, n = this.maxAzimuthAngle;
    isFinite(s) && isFinite(n) && (s < -Math.PI ? s += Ye : s > Math.PI && (s -= Ye), n < -Math.PI ? n += Ye : n > Math.PI && (n -= Ye), s <= n ? this._spherical.theta = Math.max(s, Math.min(n, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (s + n) / 2 ? Math.max(s, this._spherical.theta) : Math.min(n, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let i = !1;
    if (this.enableDamping ? this._currentScale = ye.lerp(this._currentScale, this._scale, this.dampingFactor) : this._currentScale = this._scale, this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._currentScale), i = o != this._spherical.radius;
    }
    if (Me.setFromSpherical(this._spherical), Me.applyQuaternion(this._quatInverse), t.copy(this.target).add(Me), this.object.parent ? this.object.parent.worldToLocal(t) : this.object.position.copy(t), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const r = Me.length();
        o = this._clampDistance(r * this._currentScale);
        const a = r - o;
        this.object.position.addScaledVector(this._dollyDirection, a), this.object.updateMatrixWorld(), i = !!a;
      } else if (this.object.isOrthographicCamera) {
        const r = new P(this._mouse.x, this._mouse.y, 0);
        r.unproject(this.object);
        const a = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._currentScale)), this.object.updateProjectionMatrix(), i = a !== this.object.zoom;
        const c = new P(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object), this.object.position.sub(c).add(r), this.object.updateMatrixWorld(), o = Me.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : ($n.origin.copy(this.object.position), $n.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot($n.direction)) < Xc ? this.object.lookAt(this.target) : (Ao.setFromNormalAndCoplanarPoint(this.object.up, this.target), $n.intersectPlane(Ao, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), i = !0);
    }
    return this._scale = 1, i || this._lastPosition.distanceToSquared(this.object.position) > Ps || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Ps || this._lastTargetPosition.distanceToSquared(this.target) > Ps ? (this.dispatchEvent(ao), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) : (this._performCursorZoom = !1, !1);
  }
  _getAutoRotationAngle(e) {
    return e !== null ? Ye / 60 * this.autoRotateSpeed * e : Ye / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const t = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * t);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, t) {
    Me.setFromMatrixColumn(t, 0), Me.multiplyScalar(-e), this._panOffset.add(Me);
  }
  _panUp(e, t) {
    this.screenSpacePanning === !0 ? Me.setFromMatrixColumn(t, 1) : (Me.setFromMatrixColumn(t, 0), Me.crossVectors(this.object.up, Me)), Me.multiplyScalar(e), this._panOffset.add(Me);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, t) {
    const s = this.domElement;
    if (this.object.isPerspectiveCamera) {
      this.object.getWorldPosition(Me).sub(this.target);
      let n = Me.length();
      n *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * n / s.clientHeight, this.object.matrixWorld), this._panUp(2 * t * n / s.clientHeight, this.object.matrixWorld);
    } else
      this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / s.clientWidth, this.object.matrixWorld), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / s.clientHeight, this.object.matrixWorld)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, t) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const s = this.domElement.getBoundingClientRect(), n = e - s.left, i = t - s.top, o = s.width, r = s.height;
    this._mouse.x = n / o * 2 - 1, this._mouse.y = -(i / r) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(Ye * this._rotateDelta.x / t.clientHeight), this._rotateUp(Ye * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let t = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Ye * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed), t = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Ye * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed), t = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Ye * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0), t = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Ye * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0), t = !0;
        break;
    }
    t && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._rotateStart.set(s, n);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._panStart.set(s, n);
    }
  }
  _handleTouchStartDolly(e) {
    const t = this._getSecondPointerPosition(e), s = e.pageX - t.x, n = e.pageY - t.y, i = Math.sqrt(s * s + n * n);
    this._dollyStart.set(0, i);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const s = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + s.x), i = 0.5 * (e.pageY + s.y);
      this._rotateEnd.set(n, i);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(Ye * this._rotateDelta.x / t.clientHeight), this._rotateUp(Ye * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._panEnd.set(s, n);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const t = this._getSecondPointerPosition(e), s = e.pageX - t.x, n = e.pageY - t.y, i = Math.sqrt(s * s + n * n);
    this._dollyEnd.set(0, i), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + t.x) * 0.5, r = (e.pageY + t.y) * 0.5;
    this._updateZoomParameters(o, r);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) {
        this._pointers.splice(t, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId)
        return !0;
    return !1;
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && (t = new Le(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t];
  }
  //
  _customWheelEvent(e) {
    const t = e.deltaMode, s = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (t) {
      case 1:
        s.deltaY *= 16;
        break;
      case 2:
        s.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (s.deltaY *= 10), s;
  }
};
function Zc(A) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(A.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), window.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(A) && (this._addPointer(A), A.pointerType === "touch" ? this._onTouchStart(A) : this._onMouseDown(A)));
}
function $c(A) {
  this.enabled !== !1 && (A.pointerType === "touch" ? this._onTouchMove(A) : this._onMouseMove(A));
}
function el(A) {
  switch (this._removePointer(A), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(A.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), window.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(Br), this.state = fe.NONE;
      break;
    case 1:
      const e = this._pointers[0], t = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: t.x, pageY: t.y });
      break;
  }
}
function tl(A) {
  let e;
  switch (A.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case mn.DOLLY:
      if (this.enableZoom === !1)
        return;
      this._handleMouseDownDolly(A), this.state = fe.DOLLY;
      break;
    case mn.ROTATE:
      if (A.ctrlKey || A.metaKey || A.shiftKey) {
        if (this.enablePan === !1)
          return;
        this._handleMouseDownPan(A), this.state = fe.PAN;
      } else {
        if (this.enableRotate === !1)
          return;
        this._handleMouseDownRotate(A), this.state = fe.ROTATE;
      }
      break;
    case mn.PAN:
      if (A.ctrlKey || A.metaKey || A.shiftKey) {
        if (this.enableRotate === !1)
          return;
        this._handleMouseDownRotate(A), this.state = fe.ROTATE;
      } else {
        if (this.enablePan === !1)
          return;
        this._handleMouseDownPan(A), this.state = fe.PAN;
      }
      break;
    default:
      this.state = fe.NONE;
  }
  this.state !== fe.NONE && this.dispatchEvent(wi);
}
function nl(A) {
  switch (this.state) {
    case fe.ROTATE:
      if (this.enableRotate === !1)
        return;
      this._handleMouseMoveRotate(A);
      break;
    case fe.DOLLY:
      if (this.enableZoom === !1)
        return;
      this._handleMouseMoveDolly(A);
      break;
    case fe.PAN:
      if (this.enablePan === !1)
        return;
      this._handleMouseMovePan(A);
      break;
  }
}
function sl(A) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== fe.NONE || (A.preventDefault(), this.dispatchEvent(wi), this._handleMouseWheel(this._customWheelEvent(A)), this.dispatchEvent(Br));
}
function il(A) {
  this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(A);
}
function ol(A) {
  switch (this._trackPointer(A), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case fn.ROTATE:
          if (this.enableRotate === !1)
            return;
          this._handleTouchStartRotate(A), this.state = fe.TOUCH_ROTATE;
          break;
        case fn.PAN:
          if (this.enablePan === !1)
            return;
          this._handleTouchStartPan(A), this.state = fe.TOUCH_PAN;
          break;
        default:
          this.state = fe.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case fn.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1)
            return;
          this._handleTouchStartDollyPan(A), this.state = fe.TOUCH_DOLLY_PAN;
          break;
        case fn.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1)
            return;
          this._handleTouchStartDollyRotate(A), this.state = fe.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = fe.NONE;
      }
      break;
    default:
      this.state = fe.NONE;
  }
  this.state !== fe.NONE && this.dispatchEvent(wi);
}
function rl(A) {
  switch (this._trackPointer(A), this.state) {
    case fe.TOUCH_ROTATE:
      if (this.enableRotate === !1)
        return;
      this._handleTouchMoveRotate(A), this.update();
      break;
    case fe.TOUCH_PAN:
      if (this.enablePan === !1)
        return;
      this._handleTouchMovePan(A), this.update();
      break;
    case fe.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1)
        return;
      this._handleTouchMoveDollyPan(A), this.update();
      break;
    case fe.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1)
        return;
      this._handleTouchMoveDollyRotate(A), this.update();
      break;
    default:
      this.state = fe.NONE;
  }
}
function al(A) {
  this.enabled !== !1 && A.preventDefault();
}
function Al(A) {
  A.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function cl(A) {
  A.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
class Th extends dt {
  constructor(e, t = 1, s = 16, n = 2) {
    const i = new ut(), o = s + n * 2, r = new Float32Array((o * 3 + 3) * 3);
    i.setAttribute("position", new nt(r, 3));
    const a = new Lt({ color: 65280 }), c = new Lt({ color: 16776960 });
    super(i, [c, a]), this.audio = e, this.range = t, this.divisionsInnerAngle = s, this.divisionsOuterAngle = n, this.type = "PositionalAudioHelper", this.update();
  }
  update() {
    const e = this.audio, t = this.range, s = this.divisionsInnerAngle, n = this.divisionsOuterAngle, i = ye.degToRad(e.panner.coneInnerAngle), o = ye.degToRad(e.panner.coneOuterAngle), r = i / 2, a = o / 2;
    let c = 0, l = 0, h, g;
    const d = this.geometry, p = d.attributes.position;
    d.clearGroups();
    function m(I, b, B, E) {
      const w = (b - I) / B;
      for (p.setXYZ(c, 0, 0, 0), l++, h = I; h < b; h += w)
        g = c + l, p.setXYZ(g, Math.sin(h) * t, 0, Math.cos(h) * t), p.setXYZ(g + 1, Math.sin(Math.min(h + w, b)) * t, 0, Math.cos(Math.min(h + w, b)) * t), p.setXYZ(g + 2, 0, 0, 0), l += 3;
      d.addGroup(c, l, E), c += l, l = 0;
    }
    m(-a, -r, n, 0), m(-r, r, s, 1), m(r, a, n, 0), p.needsUpdate = !0, i === o && (this.material[0].visible = !1);
  }
  dispose() {
    this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose();
  }
}
const vh = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, Rh = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};
let vn, Os, un, es;
function Hs(A, e = 1 / 0, t = null) {
  Os || (Os = new bi(2, 2, 1, 1)), un || (un = new Ho({
    uniforms: { blitTexture: new qa(A) },
    vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
    fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
  })), un.uniforms.blitTexture.value = A, un.defines.IS_SRGB = A.colorSpace == ge, un.needsUpdate = !0, es || (es = new z(Os, un), es.frustumCulled = !1);
  const s = new ds(), n = new Zs();
  n.add(es), t === null && (t = vn = new za({ antialias: !1 }));
  const i = Math.min(A.image.width, e), o = Math.min(A.image.height, e);
  t.setSize(i, o), t.clear(), t.render(n, s);
  const r = document.createElement("canvas"), a = r.getContext("2d");
  r.width = i, r.height = o, a.drawImage(t.domElement, 0, 0, i, o);
  const c = new jo(r);
  return c.minFilter = A.minFilter, c.magFilter = A.magFilter, c.wrapS = A.wrapS, c.wrapT = A.wrapT, c.colorSpace = A.colorSpace, c.name = A.name, vn && (vn.forceContextLoss(), vn.dispose(), vn = null), c;
}
const co = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: [
    "byte normalized",
    "short normalized"
  ],
  TANGENT: [
    "byte normalized",
    "short normalized"
  ],
  TEXCOORD: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "short",
    "short normalized",
    "unsigned short"
  ]
};
class wr {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new bl(e);
    }), this.register(function(e) {
      return new El(e);
    }), this.register(function(e) {
      return new yl(e);
    }), this.register(function(e) {
      return new Ql(e);
    }), this.register(function(e) {
      return new xl(e);
    }), this.register(function(e) {
      return new Sl(e);
    }), this.register(function(e) {
      return new Cl(e);
    }), this.register(function(e) {
      return new Bl(e);
    }), this.register(function(e) {
      return new wl(e);
    }), this.register(function(e) {
      return new Tl(e);
    }), this.register(function(e) {
      return new vl(e);
    }), this.register(function(e) {
      return new Rl(e);
    }), this.register(function(e) {
      return new _l(e);
    }), this.register(function(e) {
      return new Dl(e);
    });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(e, t, s, n) {
    const i = new Il(), o = [];
    for (let r = 0, a = this.pluginCallbacks.length; r < a; r++)
      o.push(this.pluginCallbacks[r](i));
    i.setPlugins(o), i.write(e, t, n).catch(s);
  }
  parseAsync(e, t) {
    const s = this;
    return new Promise(function(n, i) {
      s.parse(e, n, i, t);
    });
  }
}
const re = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, js = "KHR_mesh_quantization", ot = {};
ot[Do] = re.NEAREST;
ot[Mo] = re.NEAREST_MIPMAP_NEAREST;
ot[Fo] = re.NEAREST_MIPMAP_LINEAR;
ot[mt] = re.LINEAR;
ot[ko] = re.LINEAR_MIPMAP_NEAREST;
ot[ps] = re.LINEAR_MIPMAP_LINEAR;
ot[cs] = re.CLAMP_TO_EDGE;
ot[rn] = re.REPEAT;
ot[Lo] = re.MIRRORED_REPEAT;
const lo = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, ll = new Se(), ho = 12, hl = 1179937895, ul = 2, uo = 8, gl = 1313821514, dl = 5130562;
function Nn(A, e) {
  return A.length === e.length && A.every(function(t, s) {
    return t === e[s];
  });
}
function pl(A) {
  return new TextEncoder().encode(A).buffer;
}
function fl(A) {
  return Nn(A.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function ml(A, e, t) {
  const s = {
    min: new Array(A.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(A.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let n = e; n < e + t; n++)
    for (let i = 0; i < A.itemSize; i++) {
      let o;
      A.itemSize > 4 ? o = A.array[n * A.itemSize + i] : (i === 0 ? o = A.getX(n) : i === 1 ? o = A.getY(n) : i === 2 ? o = A.getZ(n) : i === 3 && (o = A.getW(n)), A.normalized === !0 && (o = ye.normalize(o, A.array))), s.min[i] = Math.min(s.min[i], o), s.max[i] = Math.max(s.max[i], o);
    }
  return s;
}
function yr(A) {
  return Math.ceil(A / 4) * 4;
}
function qs(A, e = 0) {
  const t = yr(A.byteLength);
  if (t !== A.byteLength) {
    const s = new Uint8Array(t);
    if (s.set(new Uint8Array(A)), e !== 0)
      for (let n = A.byteLength; n < t; n++)
        s[n] = e;
    return s.buffer;
  }
  return A;
}
function go() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function po(A, e) {
  if (A.toBlob !== void 0)
    return new Promise((s) => A.toBlob(s, e));
  let t;
  return e === "image/jpeg" ? t = 0.92 : e === "image/webp" && (t = 0.8), A.convertToBlob({
    type: e,
    quality: t
  });
}
class Il {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter r" + Ka
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(e, t, s = {}) {
    this.options = Object.assign({
      // default options
      binary: !1,
      trs: !1,
      onlyVisible: !0,
      maxTextureSize: 1 / 0,
      animations: [],
      includeCustomExtensions: !1
    }, s), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
    const n = this, i = n.buffers, o = n.json;
    s = n.options;
    const r = n.extensionsUsed, a = n.extensionsRequired, c = new Blob(i, { type: "application/octet-stream" }), l = Object.keys(r), h = Object.keys(a);
    if (l.length > 0 && (o.extensionsUsed = l), h.length > 0 && (o.extensionsRequired = h), o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = c.size), s.binary === !0) {
      const g = new FileReader();
      g.readAsArrayBuffer(c), g.onloadend = function() {
        const d = qs(g.result), p = new DataView(new ArrayBuffer(uo));
        p.setUint32(0, d.byteLength, !0), p.setUint32(4, dl, !0);
        const m = qs(pl(JSON.stringify(o)), 32), I = new DataView(new ArrayBuffer(uo));
        I.setUint32(0, m.byteLength, !0), I.setUint32(4, gl, !0);
        const b = new ArrayBuffer(ho), B = new DataView(b);
        B.setUint32(0, hl, !0), B.setUint32(4, ul, !0);
        const E = ho + I.byteLength + m.byteLength + p.byteLength + d.byteLength;
        B.setUint32(8, E, !0);
        const w = new Blob([
          b,
          I,
          m,
          p,
          d
        ], { type: "application/octet-stream" }), Q = new FileReader();
        Q.readAsArrayBuffer(w), Q.onloadend = function() {
          t(Q.result);
        };
      };
    } else if (o.buffers && o.buffers.length > 0) {
      const g = new FileReader();
      g.readAsDataURL(c), g.onloadend = function() {
        const d = g.result;
        o.buffers[0].uri = d, t(o);
      };
    } else
      t(o);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(e, t) {
    if (Object.keys(e.userData).length === 0)
      return;
    const s = this.options, n = this.extensionsUsed;
    try {
      const i = JSON.parse(JSON.stringify(e.userData));
      if (s.includeCustomExtensions && i.gltfExtensions) {
        t.extensions === void 0 && (t.extensions = {});
        for (const o in i.gltfExtensions)
          t.extensions[o] = i.gltfExtensions[o], n[o] = !0;
        delete i.gltfExtensions;
      }
      Object.keys(i).length > 0 && (t.extras = i);
    } catch (i) {
      console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + i.message);
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(e, t = !1) {
    if (this.uids.has(e) === !1) {
      const n = /* @__PURE__ */ new Map();
      n.set(!0, this.uid++), n.set(!1, this.uid++), this.uids.set(e, n);
    }
    return this.uids.get(e).get(t);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e))
      return !1;
    const s = new P();
    for (let n = 0, i = e.count; n < i; n++)
      if (Math.abs(s.fromBufferAttribute(e, n).length() - 1) > 5e-4)
        return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(e) {
    const t = this.cache;
    if (t.attributesNormalized.has(e))
      return t.attributesNormalized.get(e);
    const s = e.clone(), n = new P();
    for (let i = 0, o = s.count; i < o; i++)
      n.fromBufferAttribute(s, i), n.x === 0 && n.y === 0 && n.z === 0 ? n.setX(1) : n.normalize(), s.setXYZ(i, n.x, n.y, n.z);
    return t.attributesNormalized.set(e, s), s;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(e, t) {
    let s = !1;
    const n = {};
    (t.offset.x !== 0 || t.offset.y !== 0) && (n.offset = t.offset.toArray(), s = !0), t.rotation !== 0 && (n.rotation = t.rotation, s = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (n.scale = t.repeat.toArray(), s = !0), s && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = n, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(e, t) {
    if (e === t)
      return e;
    function s(d) {
      return d.colorSpace === ge ? function(m) {
        return m < 0.04045 ? m * 0.0773993808 : Math.pow(m * 0.9478672986 + 0.0521327014, 2.4);
      } : function(m) {
        return m;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof Gn && (e = Hs(e)), t instanceof Gn && (t = Hs(t));
    const n = e ? e.image : null, i = t ? t.image : null, o = Math.max(n ? n.width : 0, i ? i.width : 0), r = Math.max(n ? n.height : 0, i ? i.height : 0), a = go();
    a.width = o, a.height = r;
    const c = a.getContext("2d", {
      willReadFrequently: !0
    });
    c.fillStyle = "#00ffff", c.fillRect(0, 0, o, r);
    const l = c.getImageData(0, 0, o, r);
    if (n) {
      c.drawImage(n, 0, 0, o, r);
      const d = s(e), p = c.getImageData(0, 0, o, r).data;
      for (let m = 2; m < p.length; m += 4)
        l.data[m] = d(p[m] / 256) * 256;
    }
    if (i) {
      c.drawImage(i, 0, 0, o, r);
      const d = s(t), p = c.getImageData(0, 0, o, r).data;
      for (let m = 1; m < p.length; m += 4)
        l.data[m] = d(p[m] / 256) * 256;
    }
    c.putImageData(l, 0, 0);
    const g = (e || t).clone();
    return g.source = new Ya(a), g.colorSpace = gs, g.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), g;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(e) {
    const t = this.json, s = this.buffers;
    return t.buffers || (t.buffers = [{ byteLength: 0 }]), s.push(e), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(e, t, s, n, i) {
    const o = this.json;
    o.bufferViews || (o.bufferViews = []);
    let r;
    switch (t) {
      case re.BYTE:
      case re.UNSIGNED_BYTE:
        r = 1;
        break;
      case re.SHORT:
      case re.UNSIGNED_SHORT:
        r = 2;
        break;
      default:
        r = 4;
    }
    let a = e.itemSize * r;
    i === re.ARRAY_BUFFER && (a = Math.ceil(a / 4) * 4);
    const c = yr(n * a), l = new DataView(new ArrayBuffer(c));
    let h = 0;
    for (let p = s; p < s + n; p++) {
      for (let m = 0; m < e.itemSize; m++) {
        let I;
        e.itemSize > 4 ? I = e.array[p * e.itemSize + m] : (m === 0 ? I = e.getX(p) : m === 1 ? I = e.getY(p) : m === 2 ? I = e.getZ(p) : m === 3 && (I = e.getW(p)), e.normalized === !0 && (I = ye.normalize(I, e.array))), t === re.FLOAT ? l.setFloat32(h, I, !0) : t === re.INT ? l.setInt32(h, I, !0) : t === re.UNSIGNED_INT ? l.setUint32(h, I, !0) : t === re.SHORT ? l.setInt16(h, I, !0) : t === re.UNSIGNED_SHORT ? l.setUint16(h, I, !0) : t === re.BYTE ? l.setInt8(h, I) : t === re.UNSIGNED_BYTE && l.setUint8(h, I), h += r;
      }
      h % a !== 0 && (h += a - h % a);
    }
    const g = {
      buffer: this.processBuffer(l.buffer),
      byteOffset: this.byteOffset,
      byteLength: c
    };
    return i !== void 0 && (g.target = i), i === re.ARRAY_BUFFER && (g.byteStride = a), this.byteOffset += c, o.bufferViews.push(g), {
      id: o.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(e) {
    const t = this, s = t.json;
    return s.bufferViews || (s.bufferViews = []), new Promise(function(n) {
      const i = new FileReader();
      i.readAsArrayBuffer(e), i.onloadend = function() {
        const o = qs(i.result), r = {
          buffer: t.processBuffer(o),
          byteOffset: t.byteOffset,
          byteLength: o.byteLength
        };
        t.byteOffset += o.byteLength, n(s.bufferViews.push(r) - 1);
      };
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(e, t, s, n) {
    const i = this.json, o = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let r;
    if (e.array.constructor === Float32Array)
      r = re.FLOAT;
    else if (e.array.constructor === Int32Array)
      r = re.INT;
    else if (e.array.constructor === Uint32Array)
      r = re.UNSIGNED_INT;
    else if (e.array.constructor === Int16Array)
      r = re.SHORT;
    else if (e.array.constructor === Uint16Array)
      r = re.UNSIGNED_SHORT;
    else if (e.array.constructor === Int8Array)
      r = re.BYTE;
    else if (e.array.constructor === Uint8Array)
      r = re.UNSIGNED_BYTE;
    else
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name);
    if (s === void 0 && (s = 0), (n === void 0 || n === 1 / 0) && (n = e.count), n === 0)
      return null;
    const a = ml(e, s, n);
    let c;
    t !== void 0 && (c = e === t.index ? re.ELEMENT_ARRAY_BUFFER : re.ARRAY_BUFFER);
    const l = this.processBufferView(e, r, s, n, c), h = {
      bufferView: l.id,
      byteOffset: l.byteOffset,
      componentType: r,
      count: n,
      max: a.max,
      min: a.min,
      type: o[e.itemSize]
    };
    return e.normalized === !0 && (h.normalized = !0), i.accessors || (i.accessors = []), i.accessors.push(h) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(e, t, s, n = "image/png") {
    if (e !== null) {
      const i = this, o = i.cache, r = i.json, a = i.options, c = i.pending;
      o.images.has(e) || o.images.set(e, {});
      const l = o.images.get(e), h = n + ":flipY/" + s.toString();
      if (l[h] !== void 0)
        return l[h];
      r.images || (r.images = []);
      const g = { mimeType: n }, d = go();
      d.width = Math.min(e.width, a.maxTextureSize), d.height = Math.min(e.height, a.maxTextureSize);
      const p = d.getContext("2d", {
        willReadFrequently: !0
      });
      if (s === !0 && (p.translate(0, d.height), p.scale(1, -1)), e.data !== void 0) {
        t !== Kt && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > a.maxTextureSize || e.height > a.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const I = new Uint8ClampedArray(e.height * e.width * 4);
        for (let b = 0; b < I.length; b += 4)
          I[b + 0] = e.data[b + 0], I[b + 1] = e.data[b + 1], I[b + 2] = e.data[b + 2], I[b + 3] = e.data[b + 3];
        p.putImageData(new ImageData(I, e.width, e.height), 0, 0);
      } else if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas)
        p.drawImage(e, 0, 0, d.width, d.height);
      else
        throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");
      a.binary === !0 ? c.push(
        po(d, n).then((I) => i.processBufferViewImage(I)).then((I) => {
          g.bufferView = I;
        })
      ) : d.toDataURL !== void 0 ? g.uri = d.toDataURL(n) : c.push(
        po(d, n).then((I) => new FileReader().readAsDataURL(I)).then((I) => {
          g.uri = I;
        })
      );
      const m = r.images.push(g) - 1;
      return l[h] = m, m;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(e) {
    const t = this.json;
    t.samplers || (t.samplers = []);
    const s = {
      magFilter: ot[e.magFilter],
      minFilter: ot[e.minFilter],
      wrapS: ot[e.wrapS],
      wrapT: ot[e.wrapT]
    };
    return t.samplers.push(s) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(e) {
    const s = this.options, n = this.cache, i = this.json;
    if (n.textures.has(e))
      return n.textures.get(e);
    const o = { keep: !0, newTexture: null };
    if (this._invokeAll(function(l) {
      l.beforeWriteTexture && l.beforeWriteTexture(e, o);
    }), o.keep === !1)
      return null;
    o.newTexture != null && (e = o.newTexture), i.textures || (i.textures = []), e instanceof Gn && (e = Hs(e, s.maxTextureSize));
    let r = e.userData.mimeType;
    r === "image/webp" && (r = "image/png");
    const a = {
      sampler: this.processSampler(e),
      source: this.processImage(e.image, e.format, e.flipY, r)
    };
    e.name && (a.name = e.name), this._invokeAll(function(l) {
      l.writeTexture && l.writeTexture(e, a);
    });
    const c = i.textures.push(a) - 1;
    return n.textures.set(e, c), c;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(e) {
    var c, l, h, g, d;
    const t = this.cache, s = this.json;
    if (t.materials.has(e))
      return t.materials.get(e);
    if (e.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    s.materials || (s.materials = []);
    const n = { pbrMetallicRoughness: {} };
    e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const i = e.color.toArray().concat([e.opacity]);
    Nn(i, [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (n.pbrMetallicRoughness.metallicFactor = e.metalness, n.pbrMetallicRoughness.roughnessFactor = e.roughness) : (n.pbrMetallicRoughness.metallicFactor = 0.5, n.pbrMetallicRoughness.roughnessFactor = 0.5);
    const o = (c = e.metalnessMap) != null && c.image ? e.metalnessMap : void 0, r = (l = e.roughnessMap) != null && l.image ? e.roughnessMap : void 0;
    if (o || r) {
      const p = this.buildMetalRoughTexture(o, r), m = {
        index: this.processTexture(p),
        channel: p.channel
      };
      this.applyTextureTransform(m, p), n.pbrMetallicRoughness.metallicRoughnessTexture = m;
    }
    if (e.map) {
      const p = {
        index: this.processTexture(e.map),
        texCoord: e.map.channel
      };
      this.applyTextureTransform(p, e.map), n.pbrMetallicRoughness.baseColorTexture = p;
    }
    if (e.emissive) {
      const p = e.emissive;
      if (Math.max(p.r, p.g, p.b) > 0 && (n.emissiveFactor = e.emissive.toArray()), (h = e.emissiveMap) != null && h.image) {
        const I = {
          index: this.processTexture(e.emissiveMap),
          texCoord: e.emissiveMap.channel
        };
        this.applyTextureTransform(I, e.emissiveMap), n.emissiveTexture = I;
      }
    }
    if ((g = e.normalMap) != null && g.image) {
      const p = {
        index: this.processTexture(e.normalMap),
        texCoord: e.normalMap.channel
      };
      e.normalScale && e.normalScale.x !== 1 && (p.scale = e.normalScale.x), this.applyTextureTransform(p, e.normalMap), n.normalTexture = p;
    }
    if ((d = e.aoMap) != null && d.image) {
      const p = {
        index: this.processTexture(e.aoMap),
        texCoord: e.aoMap.channel
      };
      e.aoMapIntensity !== 1 && (p.strength = e.aoMapIntensity), this.applyTextureTransform(p, e.aoMap), n.occlusionTexture = p;
    }
    e.transparent ? n.alphaMode = "BLEND" : e.alphaTest > 0 && (n.alphaMode = "MASK", n.alphaCutoff = e.alphaTest), e.side === gi && (n.doubleSided = !0), e.name !== "" && (n.name = e.name), this.serializeUserData(e, n), this._invokeAll(function(p) {
      p.writeMaterial && p.writeMaterial(e, n);
    });
    const a = s.materials.push(n) - 1;
    return t.materials.set(e, a), a;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(e) {
    const t = { keep: !0 };
    if (this._invokeAll(function(Q) {
      Q.beforeWriteMesh && Q.beforeWriteMesh(e, t);
    }), t.keep != !0)
      return null;
    const s = this.cache, n = this.json, i = [e.geometry.uuid];
    if (Array.isArray(e.material))
      for (let Q = 0, R = e.material.length; Q < R; Q++)
        i.push(e.material[Q].uuid);
    else
      i.push(e.material.uuid);
    const o = i.join(":");
    if (s.meshes.has(o))
      return s.meshes.get(o);
    const r = e.geometry;
    let a;
    e.isLineSegments ? a = re.LINES : e.isLineLoop ? a = re.LINE_LOOP : e.isLine ? a = re.LINE_STRIP : e.isPoints ? a = re.POINTS : a = e.material.wireframe ? re.LINES : re.TRIANGLES;
    const c = {}, l = {}, h = [], g = [], d = {
      uv: "TEXCOORD_0",
      uv1: "TEXCOORD_1",
      uv2: "TEXCOORD_2",
      uv3: "TEXCOORD_3",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, p = r.getAttribute("normal");
    p !== void 0 && !this.isNormalizedNormalAttribute(p) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r.setAttribute("normal", this.createNormalizedNormalAttribute(p)));
    let m = null;
    for (let Q in r.attributes) {
      if (Q.slice(0, 5) === "morph")
        continue;
      const R = r.attributes[Q];
      if (Q = d[Q] || Q.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(Q) || (Q = "_" + Q), s.attributes.has(this.getUID(R))) {
        l[Q] = s.attributes.get(this.getUID(R));
        continue;
      }
      m = null;
      const x = R.array;
      Q === "JOINTS_0" && !(x instanceof Uint16Array) && !(x instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), m = new nt(new Uint16Array(x), R.itemSize, R.normalized));
      const T = this.processAccessor(m || R, r);
      T !== null && (Q.startsWith("_") || this.detectMeshQuantization(Q, R), l[Q] = T, s.attributes.set(this.getUID(R), T));
    }
    if (p !== void 0 && r.setAttribute("normal", p), Object.keys(l).length === 0)
      return null;
    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
      const Q = [], R = [], _ = {};
      if (e.morphTargetDictionary !== void 0)
        for (const x in e.morphTargetDictionary)
          _[e.morphTargetDictionary[x]] = x;
      for (let x = 0; x < e.morphTargetInfluences.length; ++x) {
        const T = {};
        let L = !1;
        for (const N in r.morphAttributes) {
          if (N !== "position" && N !== "normal") {
            L || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), L = !0);
            continue;
          }
          const O = r.morphAttributes[N][x], Z = N.toUpperCase(), U = r.attributes[N];
          if (s.attributes.has(this.getUID(O, !0))) {
            T[Z] = s.attributes.get(this.getUID(O, !0));
            continue;
          }
          const q = O.clone();
          if (!r.morphTargetsRelative)
            for (let H = 0, K = O.count; H < K; H++)
              for (let ee = 0; ee < O.itemSize; ee++)
                ee === 0 && q.setX(H, O.getX(H) - U.getX(H)), ee === 1 && q.setY(H, O.getY(H) - U.getY(H)), ee === 2 && q.setZ(H, O.getZ(H) - U.getZ(H)), ee === 3 && q.setW(H, O.getW(H) - U.getW(H));
          T[Z] = this.processAccessor(q, r), s.attributes.set(this.getUID(U, !0), T[Z]);
        }
        g.push(T), Q.push(e.morphTargetInfluences[x]), e.morphTargetDictionary !== void 0 && R.push(_[x]);
      }
      c.weights = Q, R.length > 0 && (c.extras = {}, c.extras.targetNames = R);
    }
    const I = Array.isArray(e.material);
    if (I && r.groups.length === 0)
      return null;
    let b = !1;
    if (I && r.index === null) {
      const Q = [];
      for (let R = 0, _ = r.attributes.position.count; R < _; R++)
        Q[R] = R;
      r.setIndex(Q), b = !0;
    }
    const B = I ? e.material : [e.material], E = I ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let Q = 0, R = E.length; Q < R; Q++) {
      const _ = {
        mode: a,
        attributes: l
      };
      if (this.serializeUserData(r, _), g.length > 0 && (_.targets = g), r.index !== null) {
        let T = this.getUID(r.index);
        (E[Q].start !== void 0 || E[Q].count !== void 0) && (T += ":" + E[Q].start + ":" + E[Q].count), s.attributes.has(T) ? _.indices = s.attributes.get(T) : (_.indices = this.processAccessor(r.index, r, E[Q].start, E[Q].count), s.attributes.set(T, _.indices)), _.indices === null && delete _.indices;
      }
      const x = this.processMaterial(B[E[Q].materialIndex]);
      x !== null && (_.material = x), h.push(_);
    }
    b === !0 && r.setIndex(null), c.primitives = h, n.meshes || (n.meshes = []), this._invokeAll(function(Q) {
      Q.writeMesh && Q.writeMesh(e, c);
    });
    const w = n.meshes.push(c) - 1;
    return s.meshes.set(o, w), w;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(e, t) {
    if (this.extensionsUsed[js])
      return;
    let s;
    switch (t.array.constructor) {
      case Int8Array:
        s = "byte";
        break;
      case Uint8Array:
        s = "unsigned byte";
        break;
      case Int16Array:
        s = "short";
        break;
      case Uint16Array:
        s = "unsigned short";
        break;
      default:
        return;
    }
    t.normalized && (s += " normalized");
    const n = e.split("_", 1)[0];
    co[n] && co[n].includes(s) && (this.extensionsUsed[js] = !0, this.extensionsRequired[js] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(e) {
    const t = this.json;
    t.cameras || (t.cameras = []);
    const s = e.isOrthographicCamera, n = {
      type: s ? "orthographic" : "perspective"
    };
    return s ? n.orthographic = {
      xmag: e.right * 2,
      ymag: e.top * 2,
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    } : n.perspective = {
      aspectRatio: e.aspect,
      yfov: ye.degToRad(e.fov),
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    }, e.name !== "" && (n.name = e.type), t.cameras.push(n) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(e, t) {
    const s = this.json, n = this.nodeMap;
    s.animations || (s.animations = []), e = wr.Utils.mergeMorphTargetTracks(e.clone(), t);
    const i = e.tracks, o = [], r = [];
    for (let a = 0; a < i.length; ++a) {
      const c = i[a], l = It.parseTrackName(c.name);
      let h = It.findNode(t, l.nodeName);
      const g = lo[l.propertyName];
      if (l.objectName === "bones" && (h.isSkinnedMesh === !0 ? h = h.skeleton.getBoneByName(l.objectIndex) : h = void 0), !h || !g) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name);
        continue;
      }
      const d = 1;
      let p = c.values.length / c.times.length;
      g === lo.morphTargetInfluences && (p /= h.morphTargetInfluences.length);
      let m;
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (m = "CUBICSPLINE", p /= 3) : c.getInterpolation() === fi ? m = "STEP" : m = "LINEAR", r.push({
        input: this.processAccessor(new nt(c.times, d)),
        output: this.processAccessor(new nt(c.values, p)),
        interpolation: m
      }), o.push({
        sampler: r.length - 1,
        target: {
          node: n.get(h),
          path: g
        }
      });
    }
    return s.animations.push({
      name: e.name || "clip_" + s.animations.length,
      samplers: r,
      channels: o
    }), s.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(e) {
    const t = this.json, s = this.nodeMap, n = t.nodes[s.get(e)], i = e.skeleton;
    if (i === void 0)
      return null;
    const o = e.skeleton.bones[0];
    if (o === void 0)
      return null;
    const r = [], a = new Float32Array(i.bones.length * 16), c = new ue();
    for (let h = 0; h < i.bones.length; ++h)
      r.push(s.get(i.bones[h])), c.copy(i.boneInverses[h]), c.multiply(e.bindMatrix).toArray(a, h * 16);
    return t.skins === void 0 && (t.skins = []), t.skins.push({
      inverseBindMatrices: this.processAccessor(new nt(a, 16)),
      joints: r,
      skeleton: s.get(o)
    }), n.skin = t.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(e) {
    const t = { keep: !0 };
    if (this._invokeAll(function(a) {
      a.beforeWriteNode && a.beforeWriteNode(e, t);
    }), t.keep != !0)
      return null;
    const s = this.json, n = this.options, i = this.nodeMap;
    s.nodes || (s.nodes = []);
    const o = {};
    if (n.trs) {
      const a = e.quaternion.toArray(), c = e.position.toArray(), l = e.scale.toArray();
      Nn(a, [0, 0, 0, 1]) || (o.rotation = a), Nn(c, [0, 0, 0]) || (o.translation = c), Nn(l, [1, 1, 1]) || (o.scale = l);
    } else
      e.matrixAutoUpdate && e.updateMatrix(), fl(e.matrix) === !1 && (o.matrix = e.matrix.elements);
    if (e.name !== "" && (o.name = String(e.name)), this.serializeUserData(e, o), e.isMesh || e.isLine || e.isPoints) {
      const a = this.processMesh(e);
      a !== null && (o.mesh = a);
    } else
      e.isCamera && (o.camera = this.processCamera(e));
    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
      const a = [];
      for (let c = 0, l = e.children.length; c < l; c++) {
        const h = e.children[c];
        if (h.visible || n.onlyVisible === !1) {
          const g = this.processNode(h);
          g !== null && a.push(g);
        }
      }
      a.length > 0 && (o.children = a);
    }
    this._invokeAll(function(a) {
      a.writeNode && a.writeNode(e, o);
    });
    const r = s.nodes.push(o) - 1;
    return i.set(e, r), r;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(e) {
    const t = this.json, s = this.options;
    t.scenes || (t.scenes = [], t.scene = 0);
    const n = {};
    e.name !== "" && (n.name = e.name), t.scenes.push(n);
    const i = [];
    for (let o = 0, r = e.children.length; o < r; o++) {
      const a = e.children[o];
      if (a.visible || s.onlyVisible === !1) {
        const c = this.processNode(a);
        c !== null && i.push(c);
      }
    }
    i.length > 0 && (n.nodes = i), this.serializeUserData(e, n);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(e) {
    const t = new Zs();
    t.name = "AuxScene";
    for (let s = 0; s < e.length; s++)
      t.children.push(e[s]);
    this.processScene(t);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(e) {
    const t = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(n) {
      n.beforeParse && n.beforeParse(e);
    });
    const s = [];
    for (let n = 0; n < e.length; n++)
      e[n] instanceof Zs ? this.processScene(e[n]) : s.push(e[n]);
    s.length > 0 && this.processObjects(s);
    for (let n = 0; n < this.skins.length; ++n)
      this.processSkin(this.skins[n]);
    for (let n = 0; n < t.animations.length; ++n)
      this.processAnimation(t.animations[n], e[0]);
    this._invokeAll(function(n) {
      n.afterParse && n.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let t = 0, s = this.plugins.length; t < s; t++)
      e(this.plugins[t]);
  }
}
class bl {
  constructor(e) {
    this.writer = e, this.name = "KHR_lights_punctual";
  }
  writeNode(e, t) {
    if (!e.isLight)
      return;
    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      return;
    }
    const s = this.writer, n = s.json, i = s.extensionsUsed, o = {};
    e.name && (o.name = e.name), o.color = e.color.toArray(), o.intensity = e.intensity, e.isDirectionalLight ? o.type = "directional" : e.isPointLight ? (o.type = "point", e.distance > 0 && (o.range = e.distance)) : e.isSpotLight && (o.type = "spot", e.distance > 0 && (o.range = e.distance), o.spot = {}, o.spot.innerConeAngle = (1 - e.penumbra) * e.angle, o.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i[this.name] || (n.extensions = n.extensions || {}, n.extensions[this.name] = { lights: [] }, i[this.name] = !0);
    const r = n.extensions[this.name].lights;
    r.push(o), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: r.length - 1 };
  }
}
class El {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, t) {
    if (!e.isMeshBasicMaterial)
      return;
    const n = this.writer.extensionsUsed;
    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, n[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}
class Cl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0)
      return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
      const o = {
        index: s.processTexture(e.clearcoatMap),
        texCoord: e.clearcoatMap.channel
      };
      s.applyTextureTransform(o, e.clearcoatMap), i.clearcoatTexture = o;
    }
    if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
      const o = {
        index: s.processTexture(e.clearcoatRoughnessMap),
        texCoord: e.clearcoatRoughnessMap.channel
      };
      s.applyTextureTransform(o, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = o;
    }
    if (e.clearcoatNormalMap) {
      const o = {
        index: s.processTexture(e.clearcoatNormalMap),
        texCoord: e.clearcoatNormalMap.channel
      };
      e.clearcoatNormalScale.x !== 1 && (o.scale = e.clearcoatNormalScale.x), s.applyTextureTransform(o, e.clearcoatNormalMap), i.clearcoatNormalTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Bl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_dispersion";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.dispersion === 0)
      return;
    const n = this.writer.extensionsUsed, i = {};
    i.dispersion = e.dispersion, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class wl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.iridescence === 0)
      return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
      const o = {
        index: s.processTexture(e.iridescenceMap),
        texCoord: e.iridescenceMap.channel
      };
      s.applyTextureTransform(o, e.iridescenceMap), i.iridescenceTexture = o;
    }
    if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
      const o = {
        index: s.processTexture(e.iridescenceThicknessMap),
        texCoord: e.iridescenceThicknessMap.channel
      };
      s.applyTextureTransform(o, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class yl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (i.transmissionFactor = e.transmission, e.transmissionMap) {
      const o = {
        index: s.processTexture(e.transmissionMap),
        texCoord: e.transmissionMap.channel
      };
      s.applyTextureTransform(o, e.transmissionMap), i.transmissionTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Ql {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_volume";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (i.thicknessFactor = e.thickness, e.thicknessMap) {
      const o = {
        index: s.processTexture(e.thicknessMap),
        texCoord: e.thicknessMap.channel
      };
      s.applyTextureTransform(o, e.thicknessMap), i.thicknessTexture = o;
    }
    e.attenuationDistance !== 1 / 0 && (i.attenuationDistance = e.attenuationDistance), i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class xl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_ior";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.ior === 1.5)
      return;
    const n = this.writer.extensionsUsed, i = {};
    i.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Sl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_specular";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(ll) && !e.specularIntensityMap && !e.specularColorMap)
      return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (e.specularIntensityMap) {
      const o = {
        index: s.processTexture(e.specularIntensityMap),
        texCoord: e.specularIntensityMap.channel
      };
      s.applyTextureTransform(o, e.specularIntensityMap), i.specularTexture = o;
    }
    if (e.specularColorMap) {
      const o = {
        index: s.processTexture(e.specularColorMap),
        texCoord: e.specularColorMap.channel
      };
      s.applyTextureTransform(o, e.specularColorMap), i.specularColorTexture = o;
    }
    i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Tl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.sheen == 0)
      return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (e.sheenRoughnessMap) {
      const o = {
        index: s.processTexture(e.sheenRoughnessMap),
        texCoord: e.sheenRoughnessMap.channel
      };
      s.applyTextureTransform(o, e.sheenRoughnessMap), i.sheenRoughnessTexture = o;
    }
    if (e.sheenColorMap) {
      const o = {
        index: s.processTexture(e.sheenColorMap),
        texCoord: e.sheenColorMap.channel
      };
      s.applyTextureTransform(o, e.sheenColorMap), i.sheenColorTexture = o;
    }
    i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class vl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0)
      return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (e.anisotropyMap) {
      const o = { index: s.processTexture(e.anisotropyMap) };
      s.applyTextureTransform(o, e.anisotropyMap), i.anisotropyTexture = o;
    }
    i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Rl {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1)
      return;
    const n = this.writer.extensionsUsed, i = {};
    i.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class _l {
  constructor(e) {
    this.writer = e, this.name = "EXT_materials_bump";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.bumpScale === 1 && !e.bumpMap)
      return;
    const s = this.writer, n = s.extensionsUsed, i = {};
    if (e.bumpMap) {
      const o = {
        index: s.processTexture(e.bumpMap),
        texCoord: e.bumpMap.channel
      };
      s.applyTextureTransform(o, e.bumpMap), i.bumpTexture = o;
    }
    i.bumpFactor = e.bumpScale, t.extensions = t.extensions || {}, t.extensions[this.name] = i, n[this.name] = !0;
  }
}
class Dl {
  constructor(e) {
    this.writer = e, this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(e, t) {
    if (!e.isInstancedMesh)
      return;
    const s = this.writer, n = e, i = new Float32Array(n.count * 3), o = new Float32Array(n.count * 4), r = new Float32Array(n.count * 3), a = new ue(), c = new P(), l = new Te(), h = new P();
    for (let d = 0; d < n.count; d++)
      n.getMatrixAt(d, a), a.decompose(c, l, h), c.toArray(i, d * 3), l.toArray(o, d * 4), h.toArray(r, d * 3);
    const g = {
      TRANSLATION: s.processAccessor(new nt(i, 3)),
      ROTATION: s.processAccessor(new nt(o, 4)),
      SCALE: s.processAccessor(new nt(r, 3))
    };
    n.instanceColor && (g._COLOR_0 = s.processAccessor(n.instanceColor)), t.extensions = t.extensions || {}, t.extensions[this.name] = { attributes: g }, s.extensionsUsed[this.name] = !0, s.extensionsRequired[this.name] = !0;
  }
}
wr.Utils = {
  insertKeyframe: function(A, e) {
    const s = A.getValueSize(), n = new A.TimeBufferType(A.times.length + 1), i = new A.ValueBufferType(A.values.length + s), o = A.createInterpolant(new A.ValueBufferType(s));
    let r;
    if (A.times.length === 0) {
      n[0] = e;
      for (let a = 0; a < s; a++)
        i[a] = 0;
      r = 0;
    } else if (e < A.times[0]) {
      if (Math.abs(A.times[0] - e) < 1e-3)
        return 0;
      n[0] = e, n.set(A.times, 1), i.set(o.evaluate(e), 0), i.set(A.values, s), r = 0;
    } else if (e > A.times[A.times.length - 1]) {
      if (Math.abs(A.times[A.times.length - 1] - e) < 1e-3)
        return A.times.length - 1;
      n[n.length - 1] = e, n.set(A.times, 0), i.set(A.values, 0), i.set(o.evaluate(e), A.values.length), r = n.length - 1;
    } else
      for (let a = 0; a < A.times.length; a++) {
        if (Math.abs(A.times[a] - e) < 1e-3)
          return a;
        if (A.times[a] < e && A.times[a + 1] > e) {
          n.set(A.times.slice(0, a + 1), 0), n[a + 1] = e, n.set(A.times.slice(a + 1), a + 2), i.set(A.values.slice(0, (a + 1) * s), 0), i.set(o.evaluate(e), (a + 1) * s), i.set(A.values.slice((a + 1) * s), (a + 2) * s), r = a + 1;
          break;
        }
      }
    return A.times = n, A.values = i, r;
  },
  mergeMorphTargetTracks: function(A, e) {
    const t = [], s = {}, n = A.tracks;
    for (let i = 0; i < n.length; ++i) {
      let o = n[i];
      const r = It.parseTrackName(o.name), a = It.findNode(e, r.nodeName);
      if (r.propertyName !== "morphTargetInfluences" || r.propertyIndex === void 0) {
        t.push(o);
        continue;
      }
      if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
        if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(jn);
      }
      const c = a.morphTargetInfluences.length, l = a.morphTargetDictionary[r.propertyIndex];
      if (l === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + r.propertyIndex);
      let h;
      if (s[a.uuid] === void 0) {
        h = o.clone();
        const d = new h.ValueBufferType(c * h.times.length);
        for (let p = 0; p < h.times.length; p++)
          d[p * c + l] = h.values[p];
        h.name = (r.nodeName || "") + ".morphTargetInfluences", h.values = d, s[a.uuid] = h, t.push(h);
        continue;
      }
      const g = o.createInterpolant(new o.ValueBufferType(1));
      h = s[a.uuid];
      for (let d = 0; d < h.times.length; d++)
        h.values[d * c + l] = g.evaluate(h.times[d]);
      for (let d = 0; d < o.times.length; d++) {
        const p = this.insertKeyframe(h, o.times[d]);
        h.values[p * c + l] = o.values[d];
      }
    }
    return A.tracks = t, A;
  }
};
const ve = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function Qr(A) {
  const e = await fetch(A);
  if (e.ok)
    return e.json();
  throw new Error(e.statusText);
}
async function Ml(A) {
  if (!A)
    throw new Error("No basePath supplied");
  return await Qr(`${A}/profilesList.json`);
}
async function kl(A, e, t = null, s = !0) {
  if (!A)
    throw new Error("No xrInputSource supplied");
  if (!e)
    throw new Error("No basePath supplied");
  const n = await Ml(e);
  let i;
  if (A.profiles.some((a) => {
    const c = n[a];
    return c && (i = {
      profileId: a,
      profilePath: `${e}/${c.path}`,
      deprecated: !!c.deprecated
    }), !!i;
  }), !i) {
    if (!t)
      throw new Error("No matching profile name found");
    const a = n[t];
    if (!a)
      throw new Error(`No matching profile name found and default profile "${t}" missing.`);
    i = {
      profileId: t,
      profilePath: `${e}/${a.path}`,
      deprecated: !!a.deprecated
    };
  }
  const o = await Qr(i.profilePath);
  let r;
  if (s) {
    let a;
    if (A.handedness === "any" ? a = o.layouts[Object.keys(o.layouts)[0]] : a = o.layouts[A.handedness], !a)
      throw new Error(
        `No matching handedness, ${A.handedness}, in profile ${i.profileId}`
      );
    a.assetPath && (r = i.profilePath.replace("profile.json", a.assetPath));
  }
  return { profile: o, assetPath: r };
}
const Fl = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: ve.ComponentState.DEFAULT
};
function Ll(A = 0, e = 0) {
  let t = A, s = e;
  if (Math.sqrt(A * A + e * e) > 1) {
    const o = Math.atan2(e, A);
    t = Math.cos(o), s = Math.sin(o);
  }
  return {
    normalizedXAxis: t * 0.5 + 0.5,
    normalizedYAxis: s * 0.5 + 0.5
  };
}
class Nl {
  constructor(e) {
    this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === ve.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(Fl);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: e,
    yAxis: t,
    button: s,
    state: n
  }) {
    const { normalizedXAxis: i, normalizedYAxis: o } = Ll(e, t);
    switch (this.componentProperty) {
      case ve.ComponentProperty.X_AXIS:
        this.value = this.states.includes(n) ? i : 0.5;
        break;
      case ve.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(n) ? o : 0.5;
        break;
      case ve.ComponentProperty.BUTTON:
        this.value = this.states.includes(n) ? s : 0;
        break;
      case ve.ComponentProperty.STATE:
        this.valueNodeProperty === ve.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(n) : this.value = this.states.includes(n) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class Ul {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(e, t) {
    if (!e || !t || !t.visualResponses || !t.gamepadIndices || Object.keys(t.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = e, this.type = t.type, this.rootNodeName = t.rootNodeName, this.touchPointNodeName = t.touchPointNodeName, this.visualResponses = {}, Object.keys(t.visualResponses).forEach((s) => {
      const n = new Nl(t.visualResponses[s]);
      this.visualResponses[s] = n;
    }), this.gamepadIndices = Object.assign({}, t.gamepadIndices), this.values = {
      state: ve.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(e) {
    if (this.values.state = ve.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) {
      const t = e.buttons[this.gamepadIndices.button];
      this.values.button = t.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, t.pressed || this.values.button === 1 ? this.values.state = ve.ComponentState.PRESSED : (t.touched || this.values.button > ve.ButtonTouchThreshold) && (this.values.state = ve.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === ve.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > ve.AxisTouchThreshold && (this.values.state = ve.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === ve.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > ve.AxisTouchThreshold && (this.values.state = ve.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((t) => {
      t.updateFromComponent(this.values);
    });
  }
}
class Gl {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(e, t, s) {
    if (!e)
      throw new Error("No xrInputSource supplied");
    if (!t)
      throw new Error("No profile supplied");
    this.xrInputSource = e, this.assetUrl = s, this.id = t.profileId, this.layoutDescription = t.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((n) => {
      const i = this.layoutDescription.components[n];
      this.components[n] = new Ul(n, i);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const e = [];
    return Object.values(this.components).forEach((t) => {
      e.push(t.data);
    }), e;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((e) => {
      e.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const Pl = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", Ol = "generic-trigger";
class Hl extends xt {
  constructor() {
    super(), this.motionController = null, this.envMap = null;
  }
  setEnvironmentMap(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((t) => {
      t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
    }), this);
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t) => {
      Object.values(t.visualResponses).forEach((s) => {
        const { valueNode: n, minNode: i, maxNode: o, value: r, valueNodeProperty: a } = s;
        n && (a === ve.VisualResponseProperty.VISIBILITY ? n.visible = r : a === ve.VisualResponseProperty.TRANSFORM && (n.quaternion.slerpQuaternions(
          i.quaternion,
          o.quaternion,
          r
        ), n.position.lerpVectors(
          i.position,
          o.position,
          r
        )));
      });
    }));
  }
}
function jl(A, e) {
  Object.values(A.components).forEach((t) => {
    const { type: s, touchPointNodeName: n, visualResponses: i } = t;
    if (s === ve.ComponentType.TOUCHPAD)
      if (t.touchPointNode = e.getObjectByName(n), t.touchPointNode) {
        const o = new ci(1e-3), r = new Qt({ color: 255 }), a = new z(o, r);
        t.touchPointNode.add(a);
      } else
        console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);
    Object.values(i).forEach((o) => {
      const { valueNodeName: r, minNodeName: a, maxNodeName: c, valueNodeProperty: l } = o;
      if (l === ve.VisualResponseProperty.TRANSFORM) {
        if (o.minNode = e.getObjectByName(a), o.maxNode = e.getObjectByName(c), !o.minNode) {
          console.warn(`Could not find ${a} in the model`);
          return;
        }
        if (!o.maxNode) {
          console.warn(`Could not find ${c} in the model`);
          return;
        }
      }
      o.valueNode = e.getObjectByName(r), o.valueNode || console.warn(`Could not find ${r} in the model`);
    });
  });
}
function fo(A, e) {
  jl(A.motionController, e), A.envMap && e.traverse((t) => {
    t.isMesh && (t.material.envMap = A.envMap, t.material.needsUpdate = !0);
  }), A.layers.mask != 0 && e.traverse((t) => {
    t.layers.mask = A.layers.mask;
  }), A.add(e);
}
class _h {
  constructor(e = null, t = null) {
    this.gltfLoader = e, this.path = Pl, this._assetCache = {}, this.onLoad = t, this.gltfLoader || (this.gltfLoader = new zo());
  }
  setPath(e) {
    return this.path = e, this;
  }
  createControllerModel(e) {
    const t = new Hl();
    let s = null;
    return e.addEventListener("connected", (n) => {
      const i = n.data;
      i.targetRayMode !== "tracked-pointer" || !i.gamepad || i.hand || kl(i, this.path, Ol).then(({ profile: o, assetPath: r }) => {
        t.motionController = new Gl(
          i,
          o,
          r
        );
        const a = this._assetCache[t.motionController.assetUrl];
        if (a)
          s = a.scene.clone(), fo(t, s), this.onLoad && this.onLoad(s);
        else {
          if (!this.gltfLoader)
            throw new Error("GLTFLoader not set.");
          this.gltfLoader.setPath(""), this.gltfLoader.load(
            t.motionController.assetUrl,
            (c) => {
              this._assetCache[t.motionController.assetUrl] = c, s = c.scene.clone(), fo(t, s), this.onLoad && this.onLoad(s);
            },
            null,
            () => {
              throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((o) => {
        console.warn(o);
      });
    }), e.addEventListener("disconnected", () => {
      t.motionController = null, t.remove(s), s = null;
    }), t;
  }
}
const ql = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
class Dh {
  constructor(e, t, s, n, i = null, o = null) {
    this.controller = t, this.handModel = e, this.bones = [], i === null && (i = new zo(), i.setPath(s || ql)), i.load(`${n}.glb`, (r) => {
      const a = r.scene.children[0];
      this.handModel.add(a), a.layers.mask = this.handModel.layers.mask;
      const c = a.getObjectByProperty("type", "SkinnedMesh");
      c.frustumCulled = !1, c.castShadow = !0, c.receiveShadow = !0, [
        "wrist",
        "thumb-metacarpal",
        "thumb-phalanx-proximal",
        "thumb-phalanx-distal",
        "thumb-tip",
        "index-finger-metacarpal",
        "index-finger-phalanx-proximal",
        "index-finger-phalanx-intermediate",
        "index-finger-phalanx-distal",
        "index-finger-tip",
        "middle-finger-metacarpal",
        "middle-finger-phalanx-proximal",
        "middle-finger-phalanx-intermediate",
        "middle-finger-phalanx-distal",
        "middle-finger-tip",
        "ring-finger-metacarpal",
        "ring-finger-phalanx-proximal",
        "ring-finger-phalanx-intermediate",
        "ring-finger-phalanx-distal",
        "ring-finger-tip",
        "pinky-finger-metacarpal",
        "pinky-finger-phalanx-proximal",
        "pinky-finger-phalanx-intermediate",
        "pinky-finger-phalanx-distal",
        "pinky-finger-tip"
      ].forEach((h) => {
        const g = a.getObjectByName(h);
        g !== void 0 ? g.jointName = h : console.warn(`Couldn't find ${h} in ${n} hand mesh`), this.bones.push(g);
      }), o && o(a);
    });
  }
  updateMesh() {
    const e = this.controller.joints;
    for (let t = 0; t < this.bones.length; t++) {
      const s = this.bones[t];
      if (s) {
        const n = e[s.jointName];
        if (n.visible) {
          const i = n.position;
          s.position.copy(i), s.quaternion.copy(n.quaternion);
        }
      }
    }
  }
}
const mo = new fs(), ts = new P();
class xr extends Ja {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], s = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(s), this.setAttribute("position", new ke(e, 3)), this.setAttribute("uv", new ke(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, s = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), s.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const s = new $s(t, 6, 1);
    return this.setAttribute("instanceStart", new en(s, 3, 0)), this.setAttribute("instanceEnd", new en(s, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const s = new $s(t, 6, 1);
    return this.setAttribute("instanceColorStart", new en(s, 3, 0)), this.setAttribute("instanceColorEnd", new en(s, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new Va(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new fs());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), mo.setFromBufferAttribute(t), this.boundingBox.union(mo));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mi()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const s = this.boundingSphere.center;
      this.boundingBox.getCenter(s);
      let n = 0;
      for (let i = 0, o = e.count; i < o; i++)
        ts.fromBufferAttribute(e, i), n = Math.max(n, s.distanceToSquared(ts)), ts.fromBufferAttribute(t, i), n = Math.max(n, s.distanceToSquared(ts));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
Un.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Le(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
wt.line = {
  uniforms: li.merge([
    Un.common,
    Un.fog,
    Un.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class Sr extends Ho {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: li.clone(wt.line.uniforms),
      vertexShader: wt.line.vertexShader,
      fragmentShader: wt.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const zs = new Ut(), Io = new P(), bo = new P(), Ne = new Ut(), Ue = new Ut(), Ct = new Ut(), Ks = new P(), Ys = new ue(), Pe = new Wa(), Eo = new P(), ns = new fs(), ss = new mi(), Bt = new Ut();
let yt, on;
function Co(A, e, t) {
  return Bt.set(0, 0, -e, 1).applyMatrix4(A.projectionMatrix), Bt.multiplyScalar(1 / Bt.w), Bt.x = on / t.width, Bt.y = on / t.height, Bt.applyMatrix4(A.projectionMatrixInverse), Bt.multiplyScalar(1 / Bt.w), Math.abs(Math.max(Bt.x, Bt.y));
}
function zl(A, e) {
  const t = A.matrixWorld, s = A.geometry, n = s.attributes.instanceStart, i = s.attributes.instanceEnd, o = Math.min(s.instanceCount, n.count);
  for (let r = 0, a = o; r < a; r++) {
    Pe.start.fromBufferAttribute(n, r), Pe.end.fromBufferAttribute(i, r), Pe.applyMatrix4(t);
    const c = new P(), l = new P();
    yt.distanceSqToSegment(Pe.start, Pe.end, l, c), l.distanceTo(c) < on * 0.5 && e.push({
      point: l,
      pointOnLine: c,
      distance: yt.origin.distanceTo(l),
      object: A,
      face: null,
      faceIndex: r,
      uv: null,
      uv1: null
    });
  }
}
function Kl(A, e, t) {
  const s = e.projectionMatrix, i = A.material.resolution, o = A.matrixWorld, r = A.geometry, a = r.attributes.instanceStart, c = r.attributes.instanceEnd, l = Math.min(r.instanceCount, a.count), h = -e.near;
  yt.at(1, Ct), Ct.w = 1, Ct.applyMatrix4(e.matrixWorldInverse), Ct.applyMatrix4(s), Ct.multiplyScalar(1 / Ct.w), Ct.x *= i.x / 2, Ct.y *= i.y / 2, Ct.z = 0, Ks.copy(Ct), Ys.multiplyMatrices(e.matrixWorldInverse, o);
  for (let g = 0, d = l; g < d; g++) {
    if (Ne.fromBufferAttribute(a, g), Ue.fromBufferAttribute(c, g), Ne.w = 1, Ue.w = 1, Ne.applyMatrix4(Ys), Ue.applyMatrix4(Ys), Ne.z > h && Ue.z > h)
      continue;
    if (Ne.z > h) {
      const E = Ne.z - Ue.z, w = (Ne.z - h) / E;
      Ne.lerp(Ue, w);
    } else if (Ue.z > h) {
      const E = Ue.z - Ne.z, w = (Ue.z - h) / E;
      Ue.lerp(Ne, w);
    }
    Ne.applyMatrix4(s), Ue.applyMatrix4(s), Ne.multiplyScalar(1 / Ne.w), Ue.multiplyScalar(1 / Ue.w), Ne.x *= i.x / 2, Ne.y *= i.y / 2, Ue.x *= i.x / 2, Ue.y *= i.y / 2, Pe.start.copy(Ne), Pe.start.z = 0, Pe.end.copy(Ue), Pe.end.z = 0;
    const m = Pe.closestPointToPointParameter(Ks, !0);
    Pe.at(m, Eo);
    const I = ye.lerp(Ne.z, Ue.z, m), b = I >= -1 && I <= 1, B = Ks.distanceTo(Eo) < on * 0.5;
    if (b && B) {
      Pe.start.fromBufferAttribute(a, g), Pe.end.fromBufferAttribute(c, g), Pe.start.applyMatrix4(o), Pe.end.applyMatrix4(o);
      const E = new P(), w = new P();
      yt.distanceSqToSegment(Pe.start, Pe.end, w, E), t.push({
        point: w,
        pointOnLine: E,
        distance: yt.origin.distanceTo(w),
        object: A,
        face: null,
        faceIndex: g,
        uv: null,
        uv1: null
      });
    }
  }
}
class Yl extends z {
  constructor(e = new xr(), t = new Sr({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, s = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let o = 0, r = 0, a = t.count; o < a; o++, r += 2)
      Io.fromBufferAttribute(t, o), bo.fromBufferAttribute(s, o), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + Io.distanceTo(bo);
    const i = new $s(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new en(i, 1, 0)), e.setAttribute("instanceDistanceEnd", new en(i, 1, 1)), this;
  }
  raycast(e, t) {
    const s = this.material.worldUnits, n = e.camera;
    n === null && !s && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    yt = e.ray;
    const o = this.matrixWorld, r = this.geometry, a = this.material;
    on = a.linewidth + i, r.boundingSphere === null && r.computeBoundingSphere(), ss.copy(r.boundingSphere).applyMatrix4(o);
    let c;
    if (s)
      c = on * 0.5;
    else {
      const h = Math.max(n.near, ss.distanceToPoint(yt.origin));
      c = Co(n, h, a.resolution);
    }
    if (ss.radius += c, yt.intersectsSphere(ss) === !1)
      return;
    r.boundingBox === null && r.computeBoundingBox(), ns.copy(r.boundingBox).applyMatrix4(o);
    let l;
    if (s)
      l = on * 0.5;
    else {
      const h = Math.max(n.near, ns.distanceToPoint(yt.origin));
      l = Co(n, h, a.resolution);
    }
    ns.expandByScalar(l), yt.intersectsBox(ns) !== !1 && (s ? zl(this, t) : Kl(this, n, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(zs), this.material.uniforms.resolution.value.set(zs.z, zs.w));
  }
}
class Jl extends xr {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, s = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      s[2 * n] = e[n], s[2 * n + 1] = e[n + 1], s[2 * n + 2] = e[n + 2], s[2 * n + 3] = e[n + 3], s[2 * n + 4] = e[n + 4], s[2 * n + 5] = e[n + 5];
    return super.setPositions(s), this;
  }
  setColors(e) {
    const t = e.length - 3, s = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      s[2 * n] = e[n], s[2 * n + 1] = e[n + 1], s[2 * n + 2] = e[n + 2], s[2 * n + 3] = e[n + 3], s[2 * n + 4] = e[n + 4], s[2 * n + 5] = e[n + 5];
    return super.setColors(s), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class Mh extends Yl {
  constructor(e = new Jl(), t = new Sr({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class kh extends z {
  constructor(e) {
    const t = new Vl(e), s = new bi(t.image.width * 1e-3, t.image.height * 1e-3), n = new Qt({ map: t, toneMapped: !1, transparent: !0 });
    super(s, n);
    function i(o) {
      n.map.dispatchDOMEvent(o);
    }
    this.addEventListener("mousedown", i), this.addEventListener("mousemove", i), this.addEventListener("mouseup", i), this.addEventListener("click", i), this.dispose = function() {
      s.dispose(), n.dispose(), n.map.dispose(), Ai.delete(e), this.removeEventListener("mousedown", i), this.removeEventListener("mousemove", i), this.removeEventListener("mouseup", i), this.removeEventListener("click", i);
    };
  }
}
class Vl extends jo {
  constructor(e) {
    super(Bo(e)), this.dom = e, this.anisotropy = 16, this.colorSpace = ge, this.minFilter = mt, this.magFilter = mt;
    const t = new MutationObserver(() => {
      this.scheduleUpdate || (this.scheduleUpdate = setTimeout(() => this.update(), 16));
    }), s = { attributes: !0, childList: !0, subtree: !0, characterData: !0 };
    t.observe(e, s), this.observer = t;
  }
  dispatchDOMEvent(e) {
    e.data && Wl(this.dom, e.type, e.data.x, e.data.y);
  }
  update() {
    this.image = Bo(this.dom), this.needsUpdate = !0, this.scheduleUpdate = null;
  }
  dispose() {
    this.observer && this.observer.disconnect(), this.scheduleUpdate = clearTimeout(this.scheduleUpdate), super.dispose();
  }
}
const Ai = /* @__PURE__ */ new WeakMap();
function Bo(A) {
  const e = document.createRange(), t = new Se();
  function s(g) {
    const d = [];
    let p = !1;
    function m() {
      if (p && (p = !1, g.restore()), d.length === 0)
        return;
      let I = -1 / 0, b = -1 / 0, B = 1 / 0, E = 1 / 0;
      for (let w = 0; w < d.length; w++) {
        const Q = d[w];
        I = Math.max(I, Q.x), b = Math.max(b, Q.y), B = Math.min(B, Q.x + Q.width), E = Math.min(E, Q.y + Q.height);
      }
      g.save(), g.beginPath(), g.rect(I, b, B - I, E - b), g.clip(), p = !0;
    }
    return {
      add: function(I) {
        d.push(I), m();
      },
      remove: function() {
        d.pop(), m();
      }
    };
  }
  function n(g, d, p, m) {
    m !== "" && (g.textTransform === "uppercase" && (m = m.toUpperCase()), l.font = g.fontWeight + " " + g.fontSize + " " + g.fontFamily, l.textBaseline = "top", l.fillStyle = g.color, l.fillText(m, d, p + parseFloat(g.fontSize) * 0.1));
  }
  function i(g, d, p, m, I) {
    p < 2 * I && (I = p / 2), m < 2 * I && (I = m / 2), l.beginPath(), l.moveTo(g + I, d), l.arcTo(g + p, d, g + p, d + m, I), l.arcTo(g + p, d + m, g, d + m, I), l.arcTo(g, d + m, g, d, I), l.arcTo(g, d, g + p, d, I), l.closePath();
  }
  function o(g, d, p, m, I, b) {
    const B = g[d + "Width"], E = g[d + "Style"], w = g[d + "Color"];
    B !== "0px" && E !== "none" && w !== "transparent" && w !== "rgba(0, 0, 0, 0)" && (l.strokeStyle = w, l.lineWidth = parseFloat(B), l.beginPath(), l.moveTo(p, m), l.lineTo(p + I, m + b), l.stroke());
  }
  function r(g, d) {
    if (g.nodeType === Node.COMMENT_NODE || g.nodeName === "SCRIPT" || g.style && g.style.display === "none")
      return;
    let p = 0, m = 0, I = 0, b = 0;
    if (g.nodeType === Node.TEXT_NODE) {
      e.selectNode(g);
      const E = e.getBoundingClientRect();
      p = E.left - a.left - 0.5, m = E.top - a.top - 0.5, I = E.width, b = E.height, n(d, p, m, g.nodeValue.trim());
    } else if (g instanceof HTMLCanvasElement) {
      const E = g.getBoundingClientRect();
      p = E.left - a.left - 0.5, m = E.top - a.top - 0.5, l.save();
      const w = window.devicePixelRatio;
      l.scale(1 / w, 1 / w), l.drawImage(g, p, m), l.restore();
    } else if (g instanceof HTMLImageElement) {
      const E = g.getBoundingClientRect();
      p = E.left - a.left - 0.5, m = E.top - a.top - 0.5, I = E.width, b = E.height, l.drawImage(g, p, m, I, b);
    } else {
      const E = g.getBoundingClientRect();
      p = E.left - a.left - 0.5, m = E.top - a.top - 0.5, I = E.width, b = E.height, d = window.getComputedStyle(g), i(p, m, I, b, parseFloat(d.borderRadius));
      const w = d.backgroundColor;
      w !== "transparent" && w !== "rgba(0, 0, 0, 0)" && (l.fillStyle = w, l.fill());
      const Q = ["borderTop", "borderLeft", "borderBottom", "borderRight"];
      let R = !0, _ = null;
      for (const x of Q) {
        if (_ !== null && (R = d[x + "Width"] === d[_ + "Width"] && d[x + "Color"] === d[_ + "Color"] && d[x + "Style"] === d[_ + "Style"]), R === !1)
          break;
        _ = x;
      }
      if (R === !0) {
        const x = parseFloat(d.borderTopWidth);
        d.borderTopWidth !== "0px" && d.borderTopStyle !== "none" && d.borderTopColor !== "transparent" && d.borderTopColor !== "rgba(0, 0, 0, 0)" && (l.strokeStyle = d.borderTopColor, l.lineWidth = x, l.stroke());
      } else
        o(d, "borderTop", p, m, I, 0), o(d, "borderLeft", p, m, 0, b), o(d, "borderBottom", p, m + b, I, 0), o(d, "borderRight", p + I, m, 0, b);
      if (g instanceof HTMLInputElement) {
        let x = d.accentColor;
        (x === void 0 || x === "auto") && (x = d.color), t.set(x);
        const L = Math.sqrt(0.299 * t.r ** 2 + 0.587 * t.g ** 2 + 0.114 * t.b ** 2) < 0.5 ? "white" : "#111111";
        if (g.type === "radio" && (i(p, m, I, b, b), l.fillStyle = "white", l.strokeStyle = x, l.lineWidth = 1, l.fill(), l.stroke(), g.checked && (i(p + 2, m + 2, I - 4, b - 4, b), l.fillStyle = x, l.strokeStyle = L, l.lineWidth = 2, l.fill(), l.stroke())), g.type === "checkbox" && (i(p, m, I, b, 2), l.fillStyle = g.checked ? x : "white", l.strokeStyle = g.checked ? L : x, l.lineWidth = 1, l.stroke(), l.fill(), g.checked)) {
          const N = l.textAlign;
          l.textAlign = "center";
          const O = {
            color: L,
            fontFamily: d.fontFamily,
            fontSize: b + "px",
            fontWeight: "bold"
          };
          n(O, p + I / 2, m, ""), l.textAlign = N;
        }
        if (g.type === "range") {
          const [N, O, Z] = ["min", "max", "value"].map((q) => parseFloat(g[q])), U = (Z - N) / (O - N) * (I - b);
          i(p, m + b / 4, I, b / 2, b / 4), l.fillStyle = L, l.strokeStyle = x, l.lineWidth = 1, l.fill(), l.stroke(), i(p, m + b / 4, U + b / 2, b / 2, b / 4), l.fillStyle = x, l.fill(), i(p + U, m, b, b, b / 2), l.fillStyle = x, l.fill();
        }
        (g.type === "color" || g.type === "text" || g.type === "number") && (h.add({ x: p, y: m, width: I, height: b }), n(d, p + parseInt(d.paddingLeft), m + parseInt(d.paddingTop), g.value), h.remove());
      }
    }
    const B = d.overflow === "auto" || d.overflow === "hidden";
    B && h.add({ x: p, y: m, width: I, height: b });
    for (let E = 0; E < g.childNodes.length; E++)
      r(g.childNodes[E], d);
    B && h.remove();
  }
  const a = A.getBoundingClientRect();
  let c = Ai.get(A);
  c === void 0 && (c = document.createElement("canvas"), c.width = a.width, c.height = a.height, Ai.set(A, c));
  const l = c.getContext(
    "2d"
    /*, { alpha: false }*/
  ), h = new s(l);
  return l.clearRect(0, 0, c.width, c.height), r(A), c;
}
function Wl(A, e, t, s) {
  const n = {
    clientX: t * A.offsetWidth + A.offsetLeft,
    clientY: s * A.offsetHeight + A.offsetTop,
    view: A.ownerDocument.defaultView
  };
  window.dispatchEvent(new MouseEvent(e, n));
  const i = A.getBoundingClientRect();
  t = t * i.width + i.left, s = s * i.height + i.top;
  function o(r) {
    if (r.nodeType !== Node.TEXT_NODE && r.nodeType !== Node.COMMENT_NODE) {
      const a = r.getBoundingClientRect();
      if (t > a.left && t < a.right && s > a.top && s < a.bottom && (r.dispatchEvent(new MouseEvent(e, n)), r instanceof HTMLInputElement && r.type === "range" && (e === "mousedown" || e === "click"))) {
        const [c, l] = ["min", "max"].map((p) => parseFloat(r[p])), h = a.width, d = (t - a.x) / h;
        r.value = c + (l - c) * d, r.dispatchEvent(new InputEvent("input", { bubbles: !0 }));
      }
      for (let c = 0; c < r.childNodes.length; c++)
        o(r.childNodes[c]);
    }
  }
  o(A);
}
const as = new Le(), gn = { type: "", data: as }, wo = new Ii();
class Fh extends sn {
  listenToPointerEvents(e, t) {
    const s = this, n = new Ii(), i = e.domElement;
    function o(r) {
      r.stopPropagation();
      const a = e.domElement.getBoundingClientRect();
      as.x = (r.clientX - a.left) / a.width * 2 - 1, as.y = -(r.clientY - a.top) / a.height * 2 + 1, n.setFromCamera(as, t);
      const c = n.intersectObjects(s.children, !1);
      if (c.length > 0) {
        const l = c[0], h = l.object, g = l.uv;
        gn.type = r.type, gn.data.set(g.x, 1 - g.y), h.dispatchEvent(gn);
      }
    }
    i.addEventListener("pointerdown", o), i.addEventListener("pointerup", o), i.addEventListener("pointermove", o), i.addEventListener("mousedown", o), i.addEventListener("mouseup", o), i.addEventListener("mousemove", o), i.addEventListener("click", o);
  }
  listenToXRControllerEvents(e) {
    const t = this, s = {
      move: "mousemove",
      select: "click",
      selectstart: "mousedown",
      selectend: "mouseup"
    };
    function n(i) {
      const o = i.target;
      wo.setFromXRController(o);
      const r = wo.intersectObjects(t.children, !1);
      if (r.length > 0) {
        const a = r[0], c = a.object, l = a.uv;
        gn.type = s[i.type], gn.data.set(l.x, 1 - l.y), c.dispatchEvent(gn);
      }
    }
    e.addEventListener("move", n), e.addEventListener("select", n), e.addEventListener("selectstart", n), e.addEventListener("selectend", n);
  }
}
const Rn = new P(), _n = new P(), yo = new Oo();
class Lh extends As {
  constructor(e, t = 1, s = 16711680) {
    const n = new ut(), i = e.geometry.attributes.normal.count, o = new ke(i * 2 * 3, 3);
    n.setAttribute("position", o), super(n, new Lt({ color: s, toneMapped: !1 })), this.object = e, this.size = t, this.type = "VertexNormalsHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update() {
    this.object.updateMatrixWorld(!0), yo.getNormalMatrix(this.object.matrixWorld);
    const e = this.object.matrixWorld, t = this.geometry.attributes.position, s = this.object.geometry;
    if (s) {
      const n = s.attributes.position, i = s.attributes.normal;
      let o = 0;
      for (let r = 0, a = n.count; r < a; r++)
        Rn.fromBufferAttribute(n, r).applyMatrix4(e), _n.fromBufferAttribute(i, r), _n.applyMatrix3(yo).normalize().multiplyScalar(this.size).add(Rn), t.setXYZ(o, Rn.x, Rn.y, Rn.z), o = o + 1, t.setXYZ(o, _n.x, _n.y, _n.z), o = o + 1;
    }
    t.needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Nh {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
new Ro(-1, 1, 1, -1, 0, 1);
class Xl extends ut {
  constructor() {
    super(), this.setAttribute("position", new ke([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ke([0, 2, 0, 0, 2, 0], 2));
  }
}
new Xl();
const lt = {
  node: "node",
  material: "material",
  camera: "camera",
  light: "light"
}, Zt = "KHR_animation_pointer", Zl = {
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  CUBICSPLINE: void 0,
  LINEAR: jn,
  STEP: fi
}, Qo = It.findNode;
let xo = !1;
class $l {
  constructor(e) {
    this.parser = e, this.name = Zt, this.animationPointerResolver = null;
  }
  setAnimationPointerResolver(e) {
    return this.animationPointerResolver = e, this;
  }
  _patchPropertyBindingFindNode() {
    xo || (xo = !0, It.findNode = function(e, t) {
      if (t.startsWith(".materials.")) {
        const s = t.substring(11).substring(t.indexOf(".")), n = s.indexOf("."), i = n < 0 ? s : s.substring(0, n);
        let o = null;
        return e.traverse((r) => {
          o !== null || r.type !== "Mesh" && r.type !== "SkinnedMesh" || r.material && (r.material.uuid === i || r.material.name === i) && (o = r.material, o !== null && (s.endsWith(".map") ? o = o.map : s.endsWith(".emissiveMap") && (o = o.emissiveMap)));
        }), o;
      } else if (t.startsWith(".nodes.") || t.startsWith(".lights.") || t.startsWith(".cameras.")) {
        const s = t.split(".");
        let n;
        for (let i = 1; i < s.length; i++) {
          const o = s[i];
          if (o.length == 36)
            n = e.getObjectByProperty("uuid", o);
          else if (n && n[o]) {
            const a = Number.parseInt(o);
            let c = o;
            a >= 0 && (c = a), n = n[c];
          } else {
            const a = e.getObjectByName(o);
            a && (n = a);
          }
        }
        if (!n) {
          const i = Qo(e, s[2]);
          return i || console.warn(Zt + ": Property binding not found", t, e, e.name, s), i;
        }
        return n;
      }
      return Qo(e, t);
    });
  }
  /* DUPLICATE of functionality in GLTFLoader */
  loadAnimationTargetFromChannel(e) {
    const t = e.target, s = t.node !== void 0 ? t.node : t.id;
    return this.parser.getDependency("node", s);
  }
  loadAnimationTargetFromChannelWithAnimationPointer(e) {
    this._havePatchedPropertyBindings || this._patchPropertyBindingFindNode();
    const t = e.target, s = t.extensions && t.extensions[Zt] && t.path && t.path === "pointer";
    if (!s)
      return null;
    let n, i = lt.node, o;
    if (s) {
      const a = t.extensions[Zt];
      let c = a.pointer;
      if (!c) {
        console.warn("Invalid path", a, t);
        return;
      }
      if (c.startsWith("/materials/") ? i = lt.material : c.startsWith("/extensions/KHR_lights_punctual/lights/") ? i = lt.light : c.startsWith("/cameras/") && (i = lt.camera), o = this._tryResolveTargetId(c, i), o === null || isNaN(o)) {
        console.warn("Failed resolving animation node id: " + o, c);
        return;
      }
      switch (i) {
        case lt.material:
          const h = ("/materials/" + o.toString() + "/").length, g = c.substring(0, h);
          switch (n = c.substring(h), n) {
            case "pbrMetallicRoughness/baseColorFactor":
              n = "color";
              break;
            case "pbrMetallicRoughness/roughnessFactor":
              n = "roughness";
              break;
            case "pbrMetallicRoughness/metallicFactor":
              n = "metalness";
              break;
            case "emissiveFactor":
              n = "emissive";
              break;
            case "alphaCutoff":
              n = "alphaTest";
              break;
            case "occlusionTexture/strength":
              n = "aoMapIntensity";
              break;
            case "normalTexture/scale":
              n = "normalScale";
              break;
            case "pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale":
              n = "map/repeat";
              break;
            case "pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset":
              n = "map/offset";
              break;
            case "emissiveTexture/extensions/KHR_texture_transform/scale":
              n = "emissiveMap/repeat";
              break;
            case "emissiveTexture/extensions/KHR_texture_transform/offset":
              n = "emissiveMap/offset";
              break;
            case "extensions/KHR_materials_emissive_strength/emissiveStrength":
              n = "emissiveIntensity";
              break;
            case "extensions/KHR_materials_transmission/transmissionFactor":
              n = "transmission";
              break;
            case "extensions/KHR_materials_ior/ior":
              n = "ior";
              break;
            case "extensions/KHR_materials_volume/thicknessFactor":
              n = "thickness";
              break;
            case "extensions/KHR_materials_volume/attenuationColor":
              n = "attenuationColor";
              break;
            case "extensions/KHR_materials_volume/attenuationDistance":
              n = "attenuationDistance";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceFactor":
              n = "iridescence";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceIor":
              n = "iridescenceIOR";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceThicknessMinimum":
              n = "iridescenceThicknessRange[0]";
              break;
            case "extensions/KHR_materials_iridescence/iridescenceThicknessMaximum":
              n = "iridescenceThicknessRange[1]";
              break;
            case "extensions/KHR_materials_clearcoat/clearcoatFactor":
              n = "clearcoat";
              break;
            case "extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor":
              n = "clearcoatRoughness";
              break;
            case "extensions/KHR_materials_sheen/sheenColorFactor":
              n = "sheenColor";
              break;
            case "extensions/KHR_materials_sheen/sheenRoughnessFactor":
              n = "sheenRoughness";
              break;
            case "extensions/KHR_materials_specular/specularFactor":
              n = "specularIntensity";
              break;
            case "extensions/KHR_materials_specular/specularColorFactor":
              n = "specularColor";
              break;
          }
          c = g + n;
          break;
        case lt.node:
          const d = ("/nodes/" + o.toString() + "/").length, p = c.substring(0, d);
          switch (n = c.substring(d), n) {
            case "translation":
              n = "position";
              break;
            case "rotation":
              n = "quaternion";
              break;
            case "scale":
              n = "scale";
              break;
            case "weights":
              n = "morphTargetInfluences";
              break;
          }
          c = p + n;
          break;
        case lt.light:
          const m = ("/extensions/KHR_lights_punctual/lights/" + o.toString() + "/").length;
          switch (n = c.substring(m), n) {
            case "color":
              break;
            case "intensity":
              break;
            case "spot/innerConeAngle":
              n = "penumbra";
              break;
            case "spot/outerConeAngle":
              n = "angle";
              break;
            case "range":
              n = "distance";
              break;
          }
          c = "/lights/" + o.toString() + "/" + n;
          break;
        case lt.camera:
          const I = ("/cameras/" + o.toString() + "/").length, b = c.substring(0, I);
          switch (n = c.substring(I), n) {
            case "perspective/yfov":
              n = "fov";
              break;
            case "perspective/znear":
            case "orthographic/znear":
              n = "near";
              break;
            case "perspective/zfar":
            case "orthographic/zfar":
              n = "far";
              break;
            case "perspective/aspect":
              n = "aspect";
              break;
            case "orthographic/xmag":
              n = "zoom";
              break;
            case "orthographic/ymag":
              n = "zoom";
              break;
          }
          c = b + n;
          break;
      }
      const l = this.animationPointerResolver;
      l && l.resolvePath && (c = l.resolvePath(c)), t.extensions[Zt].pointer = c;
    }
    if (o === null || isNaN(o)) {
      console.warn("Failed resolving animation node id: " + o, t);
      return;
    }
    let r;
    return i === lt.node ? r = this.parser.getDependency("node", o) : i === lt.material ? r = this.parser.getDependency("material", o) : i === lt.light ? r = this.parser.getDependency("light", o) : i === lt.camera ? r = this.parser.getDependency("camera", o) : console.error("Unhandled type", i), r;
  }
  createAnimationTracksWithAnimationPointer(e, t, s, n, i) {
    if (!(i.extensions && i.extensions[Zt] && i.path && i.path === "pointer"))
      return null;
    let r = i.extensions[Zt].pointer;
    if (!r)
      return null;
    const a = [];
    r = r.replaceAll("/", ".");
    const c = r.split(".");
    var h = e.name !== void 0 && e.name !== null ? e.name : e.uuid;
    if (c[2] = h, c[3] === "morphTargetInfluences" && e.type === "Group") {
      for (const d of e.children)
        d instanceof di && d.morphTargetInfluences && (c[3] = d.name, c[4] = "morphTargetInfluences", g(this.parser));
      return a;
    }
    g(this.parser);
    function g(d) {
      r = c.join(".");
      let p;
      switch (s.itemSize) {
        case 1:
          p = hs;
          break;
        case 2:
        case 3:
          p = ls;
          break;
        case 4:
          r.endsWith(".quaternion") ? p = us : p = Xa;
          break;
      }
      const m = n.interpolation !== void 0 ? Zl[n.interpolation] : jn;
      let I = d._getArrayFromAccessor(s);
      r.endsWith(".fov") && (I = I.map((B) => B / Math.PI * 180));
      const b = new p(
        r,
        t.array,
        I,
        m
      );
      if (m === "CUBICSPLINE" && d._createCubicSplineTrackInterpolant(b), a.push(b), r && s.itemSize === 4 && r.startsWith(".materials.") && r.endsWith(".color")) {
        const B = new Float32Array(I.length / 4);
        for (let w = 0, Q = I.length / 4; w < Q; w += 1)
          B[w] = I[w * 4 + 3];
        const E = new p(
          r.replace(".color", ".opacity"),
          t.array,
          B,
          m
        );
        m === "CUBICSPLINE" && d._createCubicSplineTrackInterpolant(b), a.push(E);
      }
    }
    return a;
  }
  _tryResolveTargetId(e, t) {
    let s = "";
    return t === "node" ? s = e.substring(7) : t === "material" ? s = e.substring(11) : t === "light" ? s = e.substring(39) : t === "camera" && (s = e.substring(9)), s = s.substring(0, s.indexOf("/")), Number.parseInt(s);
  }
  /* MOSTLY DUPLICATE of GLTFLoader.loadAnimation, but also tries to resolve KHR_animation_pointer. */
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this, s = this.parser.json, n = this.parser, i = s.animations[e], o = i.name ? i.name : "animation_" + e, r = [], a = [], c = [], l = [], h = [];
    for (let g = 0, d = i.channels.length; g < d; g++) {
      const p = i.channels[g], m = i.samplers[p.sampler], I = p.target, b = i.parameters !== void 0 ? i.parameters[m.input] : m.input, B = i.parameters !== void 0 ? i.parameters[m.output] : m.output;
      let E = t.loadAnimationTargetFromChannelWithAnimationPointer(p);
      E || (E = t.loadAnimationTargetFromChannel(p)), r.push(E), a.push(n.getDependency("accessor", b)), c.push(n.getDependency("accessor", B)), l.push(m), h.push(I);
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(a),
      Promise.all(c),
      Promise.all(l),
      Promise.all(h)
    ]).then(function(g) {
      const d = g[0], p = g[1], m = g[2], I = g[3], b = g[4], B = [];
      for (let E = 0, w = d.length; E < w; E++) {
        const Q = d[E], R = p[E], _ = m[E], x = I[E], T = b[E];
        if (Q === void 0)
          continue;
        Q.updateMatrix && (Q.updateMatrix(), Q.matrixAutoUpdate = !0);
        let L = t.createAnimationTracksWithAnimationPointer(Q, R, _, x, T);
        if (L || (L = n._createAnimationTracks(Q, R, _, x, T)), L)
          for (let N = 0; N < L.length; N++)
            B.push(L[N]);
      }
      return new pi(o, void 0, B);
    });
  }
}
const Uh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GLTFAnimationPointerExtension: $l
}, Symbol.toStringTag, { value: "Module" }));
export {
  mh as DRACOLoader,
  wc as EXRLoader,
  Bh as EXRLoader$1,
  yh as FBXLoader,
  VA as Font,
  bh as FontLoader,
  wr as GLTFExporter,
  zo as GLTFLoader,
  Uh as GLTFLoaderAnimationPointer,
  th as GroundedSkybox,
  kh as HTMLMesh,
  vh as HorizontalBlurShader,
  Fh as InteractiveGroup,
  Ft as KTX2Loader,
  Mh as Line2,
  Jl as LineGeometry,
  Sr as LineMaterial,
  fh as MeshoptDecoder,
  Qh as OBJLoader,
  xh as OrbitControls,
  Nh as Pass,
  Th as PositionalAudioHelper,
  yc as RGBELoader,
  wh as RGBELoader$1,
  os as Stats,
  Ih as TextGeometry,
  Eh as TransformControls,
  ic as TransformControlsGizmo,
  Lh as VertexNormalsHelper,
  Rh as VerticalBlurShader,
  _h as XRControllerModelFactory,
  Dh as XRHandMeshModel,
  nh as mergeVertices,
  tt as nodeFrame,
  $i as strToU8,
  Ch as zipSync
};
