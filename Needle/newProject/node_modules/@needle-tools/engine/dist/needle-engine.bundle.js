var Mx = Object.defineProperty;
var Rx = (s, t, e) => t in s ? Mx(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var r = (s, t, e) => (Rx(s, typeof t != "symbol" ? t + "" : t, e), e), Cf = (s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
};
var ue = (s, t, e) => (Cf(s, t, "read from private field"), e ? e.call(s) : t.get(s)), zi = (s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
}, ln = (s, t, e, i) => (Cf(s, t, "write to private field"), i ? i.call(s, e) : t.set(s, e), e);
var Pl = (s, t, e) => (Cf(s, t, "access private method"), e);
import { Vector2 as oe, Vector3 as v, Vector4 as me, Quaternion as W, PlaneGeometry as Xn, PerspectiveCamera as ye, Scene as Mi, ShaderMaterial as bn, Uniform$1 as co, Mesh as q, WebGLRenderer as kr, Texture as Fe, Euler as jt, Box3 as Pi, MeshStandardMaterial as It, Color as ae, ShadowMaterial as Yb, Box3Helper as Kb, GridHelper as ig, Material as Se, Matrix3 as Zb, Matrix4 as se, Layers as vo, Object3D as L, Ray as wo, MathUtils as Cs, AxesHelper as Oi, MeshBasicMaterial as Me, DoubleSide as Ri, BufferGeometry as Ps, Group as ho, SphereGeometry as vu, BoxGeometry as Da, SpriteMaterial as kx, Sprite as Tx, Shape as Ax, ExtrudeGeometry as Ex, Fog as Jb, DirectionalLight as Yp, PointLight as ng, Line as Ac, BufferAttribute as mt, CylinderGeometry as Ix, EdgesGeometry as Dx, LineSegments as e0, LineBasicMaterial as t0, Sphere as wu, Plane as vr, Raycaster as xu, ArrayCamera as Lx, SkinnedMesh as Os, InterleavedBufferAttribute as i0, Skeleton as jx, Bone as Bx, Source as Fx, WebGLCubeRenderTarget as zx, CubeCamera as Ux, AnimationClip as uo, TextureLoader as wa, PropertyBinding as La, LinearSRGBColorSpace as wr, ShaderChunk as Jt, UniformsLib as Nx, FileLoader as n0, DataTexture as sg, RGBAFormat as Su, EquirectangularReflectionMapping as Ms, SRGBColorSpace as vn, Clock as $x, NoToneMapping as ja, PCFSoftShadowMap$1 as Wx, BasicNodeLibrary as Vx, WebGLRenderTarget as ks, DepthTexture as Hx, NearestFilter as Id, LoopRepeat as Gx, LoopOnce as Kp, AnimationMixer as og, CompressedTexture as qx, FrontSide as xo, Frustum as I_, OrthographicCamera as rg, AudioListener as Xx, PositionalAudio as Qx, AudioLoader as Zp, EventDispatcher as ag, BackSide as Cu, MeshDepthMaterial as Yx, CustomBlending as Kx, MaxEquation as Zx, AmbientLight as Jx, HemisphereLight as e1, InvertStencilOp as t1, DecrementWrapStencilOp as i1, IncrementWrapStencilOp as n1, DecrementStencilOp as s1, IncrementStencilOp as o1, ReplaceStencilOp as r1, ZeroStencilOp as a1, KeepStencilOp as l1, AlwaysStencilFunc as c1, GreaterEqualStencilFunc as h1, NotEqualStencilFunc as d1, GreaterStencilFunc as u1, LessEqualStencilFunc as f1, EqualStencilFunc as p1, LessStencilFunc as m1, NeverStencilFunc as D_, RawShaderMaterial as s0, GLSL3 as g1, AlwaysDepth as _1, GreaterEqualDepth as y1, GreaterDepth as b1, LessEqualDepth as v1, LessDepth as w1, NotEqualDepth as x1, EqualDepth as S1, BatchedMesh as L_, MeshPhysicalMaterial as Jp, UnsignedByteType as C1, LinearFilter as j_, RingGeometry as P1, Line3 as O1, AdditiveBlending as o0, BoxHelper as M1, SpotLight as R1, DirectionalLightHelper as k1, CameraHelper as T1, LOD as A1, Triangle as E1, NormalBlending as I1, NeutralToneMapping as Ec, AgXToneMapping as Pu, ACESFilmicToneMapping as lg, ReinhardToneMapping as cg, LinearToneMapping as Ou, HalfFloatType as D1, VideoTexture as L1, CubeTexture as j1, CompressedCubeTexture as B1, EquirectangularRefractionMapping as F1, VectorKeyframeTrack as z1, QuaternionKeyframeTrack as U1, Audio as N1, MirroredRepeatWrapping as B_, UniformsUtils as r0, ShaderLib as Dd, MeshNormalMaterial as $1, AudioContext as W1, PMREMGenerator$1 as V1 } from "./three.js";
import { createLoaders as hg, getRaycastMesh as a0, LODsManager as Hr, NEEDLE_progressive as Ze, addDracoAndKTX2Loaders as H1, configureLoader as G1, setDracoDecoderLocation as q1, setKTX2TranscoderLocation as X1 } from "./gltf-progressive.js";
import { GroundedSkybox as Ba, Font as Q1, TextGeometry as Y1, FontLoader as K1, GLTFLoader as xr, TransformControlsGizmo as l0, EXRLoader as Ld, RGBELoader as em, Stats as Z1, nodeFrame as J1, OrbitControls as c0, PositionalAudioHelper as eS, HorizontalBlurShader as tS, VerticalBlurShader as iS, GLTFExporter as h0, strToU8 as d0, zipSync as nS, XRControllerModelFactory as sS, XRHandMeshModel as oS, Line2 as rS, LineGeometry as aS, LineMaterial as lS, KTX2Loader as cS, TransformControls as hS, InteractiveGroup as dS, HTMLMesh as uS, VertexNormalsHelper as fS, OBJLoader as dg, FBXLoader as u0, mergeVertices as pS } from "./three-examples.js";
import { fetchProfile as mS, MotionController as gS, $70d766613f57b014$export$2e2bcd8739ae039 as F_, ByteBuffer as _S, v5 as z_, md5 as U_, SIZE_PREFIX_LENGTH as f0, Builder as ug, createNoise4D as yS, Matrix4 as Pf, BatchedParticleRenderer as bS, ParticleSystem as vS, RenderMode as fs, TrailParticle as N_, ConstantColor as wS, Vector4 as xS, ConstantValue as SS, WorkerBase as CS, WorkerWrapper as PS, MeshBVH as OS } from "./vendor.js";
import { __webpack_exports__default as Te, __webpack_exports__Text as p0, __webpack_exports__Block as m0, __webpack_exports__update as MS, SimpleStateBehavior as RS, __webpack_exports__Inline as Of, __webpack_exports__FontLibrary as $_, ThreeMeshUI as W_ } from "./three-mesh-ui.js";
let g0, V_ = null;
function Hn() {
  return g0;
}
function _0(s) {
  if (s == null) {
    console.warn("Oh no: someone tried registering a non-existend gltf-loader. When you see this log it might mean that needle-engine is being imported multiple times. Please check your project setup.");
    return;
  }
  V_ !== s && (V_ = s, g0 = new s());
}
const Mf = /* @__PURE__ */ new Map();
function ui(s = ((t) => (t = globalThis.location) == null ? void 0 : t.hostname)()) {
  if (Mf.has(s))
    return Mf.get(s);
  const e = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|localhost/.test(s);
  return Mf.set(s, e), e === !0;
}
function kS() {
  return window.location.hostname.includes("glitch.me");
}
const H_ = typeof window !== void 0 ? window.location.search.includes("debugcontext") : !1;
var pe = /* @__PURE__ */ ((s) => (s.ContextRegistered = "ContextRegistered", s.ContextCreationStart = "ContextCreationStart", s.ContextCreated = "ContextCreated", s.ContextFirstFrameRendered = "ContextFirstFrameRendered", s.ContextDestroying = "ContextDestroying", s.ContextDestroyed = "ContextDestroyed", s.MissingCamera = "MissingCamera", s.ContextClearing = "ContextClearing", s.ContextCleared = "ContextCleared", s))(pe || {});
class fe {
  /** The currently active (rendering) Needle Engine context */
  static get Current() {
    return globalThis["NeedleEngine.Context.Current"];
  }
  /** @internal */
  static set Current(t) {
    globalThis["NeedleEngine.Context.Current"] = t;
  }
  /** Returns the array of all registered Needle Engine contexts. Do not modify */
  static get All() {
    return this.Registered;
  }
  /** @internal Internal use only */
  static register(t) {
    this.Registered.indexOf(t) === -1 && (H_ && console.warn("Registering context"), this.Registered.push(t), this.dispatchCallback("ContextRegistered", t));
  }
  /** @internal Internal use only */
  static unregister(t) {
    const e = this.Registered.indexOf(t);
    e !== -1 && (H_ && console.warn("Unregistering context"), this.Registered.splice(e, 1));
  }
  /**
   * Register a callback to be called when the given event occurs
   */
  static registerCallback(t, e) {
    this._callbacks[t] || (this._callbacks[t] = []), this._callbacks[t].push(e);
  }
  /** Unregister a callback */
  static unregisterCallback(t, e) {
    if (!this._callbacks[t])
      return;
    const i = this._callbacks[t].indexOf(e);
    i !== -1 && this._callbacks[t].splice(i, 1);
  }
  /** @internal */
  static dispatchCallback(t, e, i) {
    if (!this._callbacks[t])
      return !0;
    const n = { event: t, context: e };
    if (i)
      for (const a in i)
        n[a] = i[a];
    const o = new Array();
    return this._callbacks[t].forEach((a) => {
      const l = a(n);
      l instanceof Promise && o.push(l);
    }), Promise.all(o);
  }
  /**
   * Register a callback to be called when a context is created
   */
  static addContextCreatedCallback(t) {
    this.registerCallback("ContextCreated", t);
  }
  /**
   * Register a callback to be called when a context is registered
   */
  static addContextDestroyedCallback(t) {
    this.registerCallback("ContextDestroyed", t);
  }
}
/** All currently registered Needle Engine contexts. Do not modify */
r(fe, "Registered", []), r(fe, "_callbacks", {});
const TS = () => (s) => s;
function WI(s) {
  return TS()(s);
}
function VI() {
  return !!x("debug");
}
class tn {
  constructor(t, e) {
    r(this, "_factory");
    r(this, "_cache", []);
    r(this, "_maxSize");
    r(this, "_index", 0);
    this._factory = t, this._maxSize = e;
  }
  get() {
    const t = this._index % this._maxSize;
    return this._index++, this._cache.length <= t && (this._cache[t] = this._factory()), this._cache[t];
  }
}
let Xo = !1;
const tm = new Array();
typeof window < "u" && setTimeout(() => {
  if (Xo) {
    const s = {}, t = new URL(window.location.href), e = new URL(t);
    e.searchParams.append("console", "");
    const i = e.toString().replace(/=$|=(?=&)/g, "");
    for (const o of tm) {
      const a = new URL(t);
      a.searchParams.append(o, ""), s[o] = a.toString().replace(/=$|=(?=&)/g, "");
    }
    console.log(
      `🌵 ?help: Debug Options for Needle Engine.
Append any of these parameters to the URL to enable specific debug options.
Example: ${i} will show an onscreen console window.`
    );
    const n = Xo === !0 ? "" : ` (containing "${Xo}")`;
    console.group("Available URL parameters:" + n);
    for (const o of Object.keys(s).sort())
      typeof Xo == "string" && !o.toLowerCase().includes(Xo.toLowerCase()) || (console.groupCollapsed(o), console.log("Reload with this flag enabled:"), console.log(s[o]), console.groupEnd());
    console.groupEnd();
  }
}, 100);
function Mu() {
  var s;
  return new URLSearchParams((s = globalThis.location) == null ? void 0 : s.search);
}
function x(s) {
  Xo && !tm.includes(s) && tm.push(s);
  const t = Mu();
  if (t.has(s)) {
    const e = t.get(s);
    if (e) {
      const i = Number(e);
      return isNaN(i) ? e : i;
    } else
      return !0;
  }
  return !1;
}
Xo = x("help");
function HI(s, t) {
  const e = Mu();
  e.has(s) ? e.set(s, t) : e.append(s, t), document.location.search = e.toString();
}
function jd(s, t, e = !0) {
  const i = Mu();
  i.has(s) ? t === null ? i.delete(s) : i.set(s, t) : t !== null && i.append(s, t), e ? AS(s, i) : y0(s, i);
}
function G_(s, t, e) {
  s.has(t) ? s.set(t, e.toString()) : s.append(t, e.toString());
}
function AS(s, t, e) {
  window.history.pushState(e, s, "?" + t.toString());
}
function y0(s, t, e) {
  window.history.replaceState(e, s, "?" + t.toString());
}
function GI(s) {
  for (var t = "", e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", i = e.length, n = 0; n < s; n++)
    t += e.charAt(Math.floor(Math.random() * i));
  return t;
}
function qI(s, t) {
  return Math.floor(Math.random() * (t - s + 1)) + s;
}
const q_ = ["smol", "tiny", "giant", "interesting", "smart", "bright", "dull", "extreme", "beautiful", "pretty", "dark", "epic", "salty", "silly", "funny", "lame", "lazy", "loud", "lucky", "mad", "mean", "mighty", "mysterious", "nasty", "odd", "old", "powerful", "quiet", "rapid", "scary", "shiny", "shy", "silly", "smooth", "sour", "spicy", "stupid", "sweet", "tasty", "terrible", "ugly", "unusual", "vast", "wet", "wild", "witty", "wrong", "zany", "zealous", "zippy", "zombie", "zorro"], X_ = ["cat", "dog", "mouse", "pig", "cow", "horse", "sheep", "chicken", "duck", "goat", "panda", "tiger", "lion", "elephant", "monkey", "bird", "fish", "snake", "frog", "turtle", "hamster", "penguin", "kangaroo", "whale", "dolphin", "crocodile", "snail", "ant", "bee", "beetle", "butterfly", "dragon", "eagle", "fish", "giraffe", "lizard", "panda", "penguin", "rabbit", "snake", "spider", "tiger", "zebra"];
function ES() {
  const s = q_[Math.floor(Math.random() * q_.length)], t = X_[Math.floor(Math.random() * X_.length)];
  return s + "_" + t;
}
function IS(s) {
  return s = s.replace(/[^a-z0-9áéíóúñü \.,_-]/gim, ""), s.trim();
}
function Ic(s, t, e = !0, i = !1) {
  var n;
  if (t == null)
    return null;
  if (t.userData && t.userData.guid === s)
    return t;
  if (t.guid == s)
    return t;
  if (i && (n = t.userData) != null && n.components) {
    for (const o of t.userData.components)
      if (o.guid === s)
        return o;
  }
  if (e) {
    if (t.scenes)
      for (const o in t.scenes) {
        const a = t.scenes[o], l = Ic(s, a, e, i);
        if (l)
          return l;
      }
    if (t.children)
      for (const o in t.children) {
        const a = t.children[o], l = Ic(s, a, e, i);
        if (l)
          return l;
      }
  }
}
function Ru(s, t) {
  if (s != null && typeof s == "object") {
    let e;
    Array.isArray(s) ? e = [] : (e = Object.create(s), Object.assign(e, s));
    for (const i of Object.keys(s)) {
      const n = s[i];
      t && !t(s, i, n) ? e[i] = n : (n == null ? void 0 : n.clone) !== void 0 && typeof n.clone == "function" ? e[i] = n.clone() : e[i] = Ru(n, t);
    }
    return e;
  }
  return s;
}
function Gn(s) {
  return new Promise((t, e) => {
    setTimeout(t, s);
  });
}
function ku(s, t) {
  if (s <= 0)
    return Promise.resolve();
  if (t || (t = fe.Current), !t)
    return Promise.reject("No context");
  const e = t.time.frameCount + s;
  return new Promise((i, n) => {
    if (!t)
      return n("No context");
    const o = () => {
      t.time.frameCount >= e && (t.pre_update_callbacks.splice(t.pre_update_callbacks.indexOf(o), 1), i());
    };
    t.pre_update_callbacks.push(o);
  });
}
const Mh = x("debugresolveurl"), DS = "rel:";
function XI(s, t) {
  return Tr(s, t);
}
function Tr(s, t) {
  if (t === void 0)
    return Mh && console.warn("getPath: uri is undefined, returning uri", t), t;
  if (t.startsWith("./"))
    return t;
  if (t.startsWith("http"))
    return Mh && console.warn("getPath: uri is absolute, returning uri", t), t;
  if (s === void 0)
    return Mh && console.warn("getPath: source is undefined, returning uri", t), t;
  t.startsWith(DS) && (t = t.substring(4));
  const e = s.lastIndexOf("/");
  if (e >= 0) {
    const i = s.substring(0, e + 1);
    for (; i.endsWith("/") && t.startsWith("/"); )
      t = t.substring(1);
    const n = i + t;
    return Mh && console.log("source:", s, `changed uri 
from`, t, `
to `, n, `
basePath: ` + i), n;
  }
  return t;
}
class LS {
  constructor(t, e) {
    r(this, "writeCallbacks", []);
    r(this, "_applied", !1);
    r(this, "_object");
    r(this, "_prop");
    r(this, "_wrapperProp");
    this._object = t, this._prop = e, this._wrapperProp = Symbol("$" + e), this.apply();
  }
  subscribeWrite(t) {
    this.writeCallbacks.push(t);
  }
  unsubscribeWrite(t) {
    const e = this.writeCallbacks.indexOf(t);
    e !== -1 && this.writeCallbacks.splice(e, 1);
  }
  apply() {
    if (this._applied || !this._object)
      return;
    const t = this._object, e = this._prop;
    if (t[e] === void 0)
      return;
    this._applied = !0, t[this._wrapperProp] !== void 0 && console.warn("Watcher is being applied to an object that already has a wrapper property. This is not (yet) supported");
    const i = t[e];
    t[this._wrapperProp] = i, Object.defineProperty(t, e, {
      get: () => t[this._wrapperProp],
      set: (a) => {
        t[this._wrapperProp] = a;
        for (const l of this.writeCallbacks)
          l(a, this._prop);
      }
    });
  }
  revoke() {
    if (!this._applied || !this._object)
      return;
    this._applied = !1;
    const t = this._object, e = this._prop;
    Reflect.deleteProperty(t, e);
    const i = t[this._wrapperProp];
    t[e] = i, Reflect.deleteProperty(t, this._wrapperProp);
  }
  dispose() {
    this.revoke(), this.writeCallbacks.length = 0, this._object = null;
  }
}
class fo {
  constructor(t, e) {
    r(this, "_watches", []);
    if (Array.isArray(e))
      for (const i of e)
        this._watches.push(new fo(t, i));
    else
      this._watches.push(new LS(t, e));
  }
  subscribeWrite(t) {
    for (const e of this._watches)
      e.subscribeWrite(t);
  }
  unsubscribeWrite(t) {
    for (const e of this._watches)
      e.unsubscribeWrite(t);
  }
  apply() {
    for (const t of this._watches)
      t.apply();
  }
  revoke() {
    for (const t of this._watches)
      t.revoke();
  }
  dispose() {
    for (const t of this._watches)
      t.dispose();
    this._watches.length = 0;
  }
}
const na = Symbol("needle:watches");
function fg(s, t) {
  if (!s[na])
    if (s instanceof oe)
      s[na] = new fo(s, ["x", "y"]);
    else if (s instanceof v)
      s[na] = new fo(s, ["x", "y", "z"]);
    else if (s instanceof me || s instanceof W)
      s[na] = new fo(s, ["x", "y", "z", "w"]);
    else
      return !1;
  return s[na].subscribeWrite(t), !0;
}
function b0(s, t) {
  if (!s)
    return;
  const e = s[na];
  e && e.unsubscribeWrite(t);
}
var X;
((s) => {
  let t;
  function e() {
    if (t !== void 0)
      return t;
    const j = window.navigator.userAgent, H = /Windows|MacOS|Mac OS/.test(j), Y = /Windows NT/.test(j) && /Edg/.test(j) && !/Win64/.test(j);
    return t = H && !Y && !w();
  }
  s.isDesktop = e;
  let i;
  function n() {
    return i !== void 0 ? i : typeof window.orientation < "u" || navigator.userAgent.indexOf("IEMobile") !== -1 ? i = !0 : i = /iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent);
  }
  s.isMobileDevice = n;
  function o() {
    return l();
  }
  s.isIPad = o;
  let a;
  function l() {
    return a !== void 0 ? a : a = /iPad/.test(navigator.userAgent);
  }
  s.isiPad = l;
  let c;
  function h() {
    return c !== void 0 ? c : c = /Android/.test(navigator.userAgent);
  }
  s.isAndroidDevice = h;
  let d;
  function u() {
    return d !== void 0 ? d : d = /WebXRViewer\//i.test(navigator.userAgent);
  }
  s.isMozillaXR = u;
  let p;
  function m() {
    if (p !== void 0)
      return p;
    if (navigator.userAgentData)
      return p = navigator.userAgentData.platform === "macOS";
    {
      const j = navigator.userAgent.toLowerCase();
      return p = j.includes("mac os x") || j.includes("macintosh");
    }
  }
  s.isMacOS = m;
  let g;
  function _() {
    return g !== void 0 ? g : g = m() && "xr" in navigator;
  }
  s.isVisionOS = _;
  let y;
  const b = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"];
  function w() {
    return y !== void 0 ? y : y = b.includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  s.isiOS = w;
  let P;
  function k() {
    return P !== void 0 || (P = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), P;
  }
  s.isSafari = k;
  let O;
  function M() {
    return O !== void 0 ? O : O = navigator.userAgent.includes("OculusBrowser");
  }
  s.isQuest = M;
  let E;
  function B() {
    return E !== void 0 || (E = document.createElement("a").relList.supports("ar")), E;
  }
  s.supportsQuickLookAR = B;
  async function A() {
    try {
      return (await navigator.permissions.query({ name: "microphone" })).state !== "denied";
    } catch (j) {
      return console.error("Error querying `microphone` permissions.", j), !1;
    }
  }
  s.microphonePermissionsGranted = A;
  let F;
  function U() {
    if (F !== void 0)
      return F;
    const j = navigator.userAgent.match(/iPhone OS (\d+_\d+)/);
    if (j && (F = j[1].replace("_", ".")), !F) {
      const H = navigator.userAgent.match(/(?:\(Macintosh;|iPhone;|iPad;).*Version\/(\d+\.\d+)/);
      H && (F = H[1]);
    }
    return F || (F = null), F;
  }
  s.getiOSVersion = U;
  let Z;
  function T() {
    if (Z !== void 0)
      return Z;
    const j = navigator.userAgent.match(/(?:CriOS|Chrome)\/(\d+\.\d+\.\d+\.\d+)/);
    return j ? Z = j[1].replace("_", ".") : Z = null, Z;
  }
  s.getChromeVersion = T;
})(X || (X = {}));
function QI() {
  return X.isDesktop();
}
function YI() {
  return X.isMobileDevice();
}
function KI() {
  return X.isiPad();
}
function ZI() {
  return X.isiPad();
}
function JI() {
  return X.isAndroidDevice();
}
function eD() {
  return X.isMozillaXR();
}
function tD() {
  return X.isMacOS();
}
function iD() {
  return X.isiOS();
}
function nD() {
  return X.isSafari();
}
function sD() {
  return X.isQuest();
}
async function oD() {
  return X.microphonePermissionsGranted();
}
const jS = /ip=(?<ip>.+?)\n/s;
async function rD() {
  const t = await (await fetch("https://www.cloudflare.com/cdn-cgi/trace")).text(), e = jS.exec(t);
  return e ? e[1] : null;
}
async function aD() {
  const s = await fetch("https://api.db-ip.com/v2/free/self").catch(() => null);
  return s ? (await s.json()).ipAddress : void 0;
}
async function lD() {
  const s = await fetch("https://api.db-ip.com/v2/free/self").catch(() => null);
  return s ? await s.json() : void 0;
}
const oo = /* @__PURE__ */ new WeakMap();
function BS(s, t, e) {
  if (!oo.get(s)) {
    const n = new MutationObserver((o) => {
      zS(s, o);
    });
    oo.set(s, {
      observer: n,
      attributeChangedListeners: /* @__PURE__ */ new Map()
    }), n.observe(s, { attributes: !0 });
  }
  const i = oo.get(s).attributeChangedListeners;
  i.has(t) || i.set(t, []), i.get(t).push(e);
}
function FS(s, t, e) {
  if (!oo.get(s))
    return;
  const i = oo.get(s).attributeChangedListeners;
  if (!i.has(t))
    return;
  const n = i.get(t), o = n.indexOf(e);
  if (o !== -1 && (n.splice(o, 1), n.length <= 0)) {
    i.delete(t);
    const a = oo.get(s);
    a == null || a.observer.disconnect(), oo.delete(s);
  }
}
function zS(s, t) {
  const e = oo.get(s).attributeChangedListeners;
  for (const i of t)
    if (i.type === "attributes") {
      const n = i.attributeName, o = s.getAttribute(n);
      if (e.has(n))
        for (const a of e.get(n))
          a(o);
    }
}
class Q_ {
  constructor(t) {
    r(this, "reason");
    this.reason = t;
  }
}
async function v0(s) {
  const t = await Promise.allSettled(s).catch((n) => [
    new Q_(n.message)
  ]);
  let e = !1;
  const i = t.map((n) => "value" in n ? n.value : (e = !0, new Q_(n.reason)));
  return {
    anyFailed: e,
    results: i
  };
}
async function US(s) {
  if (!globalThis.QRCode) {
    const i = "https://cdn.rawgit.com/davidshimjs/qrcodejs/gh-pages/qrcode.min.js";
    let n = document.head.querySelector(`script[src="${i}"]`);
    n || (n = document.createElement("script"), n.src = i, document.head.appendChild(n)), await new Promise((o, a) => {
      n.addEventListener("load", () => {
        o(!0);
      });
    });
  }
  const t = globalThis.QRCode, e = s.domElement ?? document.createElement("div");
  return new t(e, {
    width: s.width ?? 256,
    height: s.height ?? 256,
    colorDark: "#000000",
    colorLight: "#ffffff",
    correctLevel: t.CorrectLevel.M,
    ...s
  }), e;
}
const w0 = x("debugdebug");
let Dc = !1;
(x("noerrors") || x("nooverlaymessages")) && (Dc = !0);
const Rf = "needle_engine_global_error_container";
var Zi = /* @__PURE__ */ ((s) => (s[s.Log = 0] = "Log", s[s.Warn = 1] = "Warn", s[s.Error = 2] = "Error", s))(Zi || {});
function pg() {
  return C0;
}
const im = new Array();
function NS(s) {
  im.push(s);
}
let kf = !1;
function $S(...s) {
  if (!kf) {
    kf = !0;
    try {
      for (let t = 0; t < im.length; t++)
        im[t](...s);
    } catch (t) {
      console.error(t);
    }
    kf = !1;
  }
}
const x0 = console.error, S0 = function(...s) {
  x0.apply(console, s), HS(s), Bn(2, s), nm(...s);
};
function WS(s) {
  Dc = !s, s ? console.error = S0 : console.error = x0;
}
function cD(s) {
  return WS(s);
}
function VS() {
  Dc || (w0 && console.warn("Patch console", window.location.hostname), console.error = S0, window.addEventListener("error", (s) => {
    if (!s)
      return;
    const t = s.error;
    if (t === void 0) {
      ui() && console.warn("Received unknown error", s, s.target);
      return;
    }
    Bn(2, t, s.filename, s.lineno), nm(s);
  }, !0), window.addEventListener("unhandledrejection", (s) => {
    Dc || s && (s.reason ? Bn(2, s.reason.message, s.reason.stack) : Bn(2, "unhandled rejection"), nm(s));
  }));
}
let C0 = 0;
function nm(...s) {
  C0 += 1, $S(...s);
}
function HS(s) {
  if (Array.isArray(s))
    for (let t = 0; t < s.length; t++) {
      const e = s[t];
      typeof e == "string" && e.startsWith("THREE.PropertyBinding: Trying to update node for track:") && (s[t] = "Some animated objects couldn't be found: see console for details");
    }
}
function Bn(s, t, e, i) {
  if (Dc)
    return;
  const n = fe.Current, o = (n == null ? void 0 : n.domElement) ?? document.querySelector("needle-engine");
  if (o) {
    if (Array.isArray(t)) {
      let a = "";
      for (let l = 0; l < t.length; l++) {
        let c = t[l];
        c instanceof Error && (c = c.message), typeof c != "object" && (l > 0 && (a += " "), a += c);
      }
      t = a;
    }
    !t || t.length <= 0 || GS(s, o, t);
  }
}
const rc = /* @__PURE__ */ new Map();
function GS(s, t, e) {
  if (e == null)
    return;
  const i = XS(t);
  if (i.childElementCount >= 20) {
    const l = i.lastElementChild;
    Y_(l);
  }
  e.length > 400 && (e = e.substring(0, 400) + "...");
  const n = e;
  if (rc.has(n))
    return;
  const o = QS(s, e);
  i.prepend(o);
  const a = () => {
    rc.delete(n), Y_(o);
  };
  rc.set(n, a), setTimeout(a, 1e4);
}
function hD() {
  w0 && console.log("Clearing messages");
  for (const s of rc.values())
    s == null || s.call(s);
  rc.clear();
}
const qS = `

@import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

div[data-needle_engine_debug_overlay] {
    font-family: 'Roboto Flex', sans-serif;
    font-weight: 400;
    font-size: 16px;
}

div[data-needle_engine_debug_overlay] strong {
    font-weight: 700;
}

div[data-needle_engine_debug_overlay] a {
    color: white;
    text-decoration: none;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

div[data-needle_engine_debug_overlay] a:hover {
    text-decoration: none;
    border: none;
}

div[data-needle_engine_debug_overlay] .log strong {
    color: rgba(200,200,200,.9);
}

div[data-needle_engine_debug_overlay] .warn strong {
    color: rgba(255,255,230, 1);
}

div[data-needle_engine_debug_overlay] .error strong {
    color: rgba(255,100,120, 1);
}
`;
function XS(s) {
  globalThis[Rf] || (globalThis[Rf] = /* @__PURE__ */ new Map());
  const t = globalThis[Rf];
  if (t.has(s))
    return t.get(s);
  {
    const e = document.createElement("div");
    t.set(s, e), e.setAttribute("data-needle_engine_debug_overlay", ""), e.classList.add("debug-container"), e.style.cssText = `
            position: absolute;
            top: 0;
            right: 5px;
            padding-top: 0px;
            max-width: 70%;
            max-height: calc(100% - 5px);
            z-index: 9999999999;
            pointer-events: scroll;
            display: flex;
            align-items: end;
            flex-direction: column;
            color: white;
            overflow: auto;
            word-break: break-word;
        `, s.shadowRoot ? s.shadowRoot.appendChild(e) : s.appendChild(e);
    const i = document.createElement("style");
    return i.innerHTML = qS, e.appendChild(i), e;
  }
}
const P0 = Symbol("logtype"), Bd = /* @__PURE__ */ new Map();
function Y_(s) {
  s.remove();
  const t = s[P0], e = Bd.get(t) ?? [];
  e.push(s), Bd.set(t, e);
}
function QS(s, t) {
  if (Bd.has(s)) {
    const i = Bd.get(s);
    if (i.length > 0) {
      const n = i.pop();
      return n.innerHTML = t, n;
    }
  }
  const e = document.createElement("div");
  switch (e.setAttribute("data-id", "__needle_engine_debug_overlay"), e.style.marginRight = "5px", e.style.padding = ".5em", e.style.backgroundColor = "rgba(0,0,0,.9)", e.style.marginTop = "5px", e.style.marginBottom = "3px", e.style.borderRadius = "8px", e.style.pointerEvents = "all", e.style.userSelect = "text", e.style.maxWidth = "250px", e.style.whiteSpace = "pre-wrap", e.style["backdrop-filter"] = "blur(10px)", e.style["-webkit-backdrop-filter"] = "blur(10px)", e.style.backgroundColor = "rgba(20,20,20,.8)", e.style.boxShadow = "inset 0 0 80px rgba(0,0,0,.2), 0 0 5px rgba(0,0,0,.2)", e.style.border = "1px solid rgba(160,160,160,.2)", e[P0] = s, s) {
    case 0:
      e.classList.add("log"), e.style.color = "rgba(200,200,200,.7)", e.style.backgroundColor = "rgba(40,40,40,.7)";
      break;
    case 1:
      e.classList.add("warn"), e.style.color = "rgb(255, 255, 150)", e.style.backgroundColor = "rgba(50,50,20,.8)";
      break;
    case 2:
      e.classList.add("error"), e.style.color = "rgb(255, 50, 50", e.style.backgroundColor = "rgba(50,20,20,.8)";
      break;
  }
  return e.title = "Open the browser console (F12) for more information", e.innerHTML = t, e;
}
class YS {
  constructor() {
    r(this, "Rad2Deg", 180 / Math.PI);
    r(this, "Deg2Rad", Math.PI / 180);
    r(this, "Epsilon", 1e-5);
  }
  random(t, e) {
    return Array.isArray(t) ? t.length <= 0 ? null : t[Math.floor(Math.random() * t.length)] : t !== void 0 && e !== void 0 ? Math.random() * (e - t) + t : Math.random();
  }
  randomVector3(t, e = 0, i = 1) {
    t.x = this.random(e, i), t.y = this.random(e, i), t.z = this.random(e, i);
  }
  clamp(t, e, i) {
    return t < e ? e : t > i ? i : t;
  }
  clamp01(t) {
    return this.clamp(t, 0, 1);
  }
  /**
   * Linear interpolate
   */
  lerp(t, e, i) {
    return i = i < 0 ? 0 : i, i = i > 1 ? 1 : i, t + (e - t) * i;
  }
  /**
   * 
   */
  inverseLerp(t, e, i) {
    return (i - t) / (e - t);
  }
  /**
   * Remaps a value from one range to another.
   * @param value The value to remap.
   * @param min1 The minimum value of the current range.
   * @param max1 The maximum value of the current range.
   * @param min2 The minimum value of the target range.
   * @param max2 The maximum value of the target range.
   */
  remap(t, e, i, n, o) {
    return n + (o - n) * (t - e) / (i - e);
  }
  moveTowards(t, e, i) {
    return t += i, (i < 0 && t < e || i > 0 && t > e) && (t = e), t;
  }
  /**
   * Converts radians to degrees
   */
  toDegrees(t) {
    return t * 180 / Math.PI;
  }
  /**
   * Converts degrees to radians
   */
  toRadians(t) {
    return t * Math.PI / 180;
  }
  tan(t) {
    return Math.tan(t);
  }
  gammaToLinear(t) {
    return Math.pow(t, 2.2);
  }
  linearToGamma(t) {
    return Math.pow(t, 1 / 2.2);
  }
  approximately(t, e, i = Number.EPSILON) {
    for (const n of KS) {
      const o = t[n], a = e[n];
      if (o === void 0 || a === void 0)
        break;
      if (Math.abs(o - a) > i)
        return !1;
    }
    return !0;
  }
  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }
}
const KS = ["x", "y", "z", "w"], $ = new YS();
class K_ {
  constructor(t) {
    r(this, "y");
    r(this, "s");
    r(this, "alpha", 0);
    this.setAlpha(t), this.y = null, this.s = null;
  }
  setAlpha(t) {
    if (t <= 0 || t > 1)
      throw new Error();
    this.alpha = t;
  }
  filter(t, e) {
    e && this.setAlpha(e);
    let i;
    return this.y ? i = this.alpha * t + (1 - this.alpha) * this.s : i = t, this.y = t, this.s = i, i;
  }
  lastValue() {
    return this.y;
  }
  reset(t) {
    this.y = t, this.s = t;
  }
}
class Tf {
  /** Create a new OneEuroFilter
   * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  constructor(t, e = 1, i = 0, n = 1) {
    /**
     * An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
     */
    r(this, "freq");
    /**
     * Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
     */
    r(this, "minCutOff");
    /**
     * Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
     */
    r(this, "beta");
    /**
     * Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
     */
    r(this, "dCutOff");
    /**
     * The low-pass filter for the signal.
     */
    r(this, "x");
    /**
     * The low-pass filter for the derivates.
     */
    r(this, "dx");
    /**
     * The last time the filter was called.
     */
    r(this, "lasttime");
    if (t <= 0 || e <= 0 || n <= 0)
      throw new Error();
    this.freq = t, this.minCutOff = e, this.beta = i, this.dCutOff = n, this.x = new K_(this.alpha(this.minCutOff)), this.dx = new K_(this.alpha(this.dCutOff)), this.lasttime = null;
  }
  alpha(t) {
    const e = 1 / this.freq;
    return 1 / (1 + 1 / (2 * Math.PI * t) / e);
  }
  /** Filter your value: call with your value and the current timestamp (e.g. from this.context.time.time) */
  filter(t, e = null) {
    this.lasttime && e && (this.freq = 1 / (e - this.lasttime)), this.lasttime = e;
    const i = this.x.lastValue(), n = i ? (t - i) * this.freq : 0, o = this.dx.filter(n, this.alpha(this.dCutOff)), a = this.minCutOff + this.beta * Math.abs(o);
    return this.x.filter(t, this.alpha(a));
  }
  reset(t) {
    t != null && this.x.reset(t), this.x.alpha = this.alpha(this.minCutOff), this.dx.alpha = this.alpha(this.dCutOff), this.lasttime = null;
  }
}
class O0 {
  /** Create a new OneEuroFilter
   * @param freq - An estimate of the frequency in Hz of the signal (> 0), if timestamps are not available.
   * @param minCutOff - Min cutoff frequency in Hz (> 0). Lower values allow to remove more jitter.
   * @param beta - Parameter to reduce latency (> 0). Higher values make the filter react faster to changes.
   * @param dCutOff - Used to filter the derivates. 1 Hz by default. Change this parameter if you know what you are doing.
   */
  constructor(t, e = 1, i = 0, n = 1) {
    r(this, "x");
    r(this, "y");
    r(this, "z");
    this.x = new Tf(t, e, i, n), this.y = new Tf(t, e, i, n), this.z = new Tf(t, e, i, n);
  }
  filter(t, e, i = null) {
    e.x = this.x.filter(t.x, i), e.y = this.y.filter(t.y, i), e.z = this.z.filter(t.z, i);
  }
  reset(t) {
    this.x.reset(t == null ? void 0 : t.x), this.y.reset(t == null ? void 0 : t.y), this.z.reset(t == null ? void 0 : t.z);
  }
}
const dd = "needle:cameraController";
function ZS(s) {
  return s[dd];
}
function Z_(s, t, e) {
  e ? s[dd] = t : s[dd] === t && (s[dd] = null);
}
const sm = "needle:autofit";
function JS(s) {
  return s[sm] === void 0 ? !0 : s[sm] !== !1;
}
function om(s, t) {
  s[sm] = t;
}
function dD(s, t, e) {
  const i = s.length(), n = t.length(), o = $.lerp(i, n, e);
  return s.lerp(t, e).normalize().multiplyScalar(o);
}
const Af = new W(), M0 = new W().setFromAxisAngle(new v(0, 1, 0), Math.PI);
function uD(s, t) {
  s.lookAt(t), s.quaternion.multiply(M0);
}
function Tu(s, t, e = !0, i = !1) {
  if (s === t)
    return;
  Af.copy(s.quaternion);
  const n = ie(t), o = ie(s);
  if (i) {
    if (wn(s, Ce(t)), e) {
      const a = o.y, l = o.sub(lC(s));
      l.y = a, s.lookAt(l), s.quaternion.multiply(M0);
    }
    Number.isNaN(s.quaternion.x) && s.quaternion.copy(Af);
    return;
  }
  e && (n.y = o.y), s.lookAt(n), Number.isNaN(s.quaternion.x) && s.quaternion.copy(Af);
}
function fD(s, t, e, i = 1) {
  if (e) {
    const n = G(0, 0, 0), o = t.x / window.innerWidth * 2 - 1, a = -(t.y / window.innerHeight) * 2 + 1;
    n.set(
      o,
      a,
      0
    ), n.unproject(e);
    const l = e.worldPosition, c = s.worldPosition.distanceTo(l), h = n.sub(l);
    h.multiplyScalar(i * 3.6 * c);
    const d = e.worldPosition.add(h);
    return s.lookAt(d), d;
  }
  return null;
}
const eC = new tn(() => new v(), 100);
function G(s, t, e) {
  const i = eC.get();
  return i.set(0, 0, 0), s instanceof v ? i.copy(s) : Array.isArray(s) ? i.set(s[0], s[1], s[2]) : s instanceof DOMPointReadOnly ? i.set(s.x, s.y, s.z) : typeof s == "number" ? (i.x = s, i.y = t !== void 0 ? t : i.x, i.z = e !== void 0 ? e : i.x) : typeof s == "object" && (i.x = s.x, i.y = s.y, i.z = s.z), i;
}
const tC = new tn(() => new ae(), 30);
function iC(s) {
  const t = tC.get();
  return s ? t.copy(s) : t.set(0, 0, 0), t;
}
const nC = new tn(() => new W(), 100);
function En(s) {
  const t = nC.get();
  return t.identity(), s instanceof W ? t.copy(s) : s instanceof DOMPointReadOnly && t.set(s.x, s.y, s.z, s.w), t;
}
const mg = new tn(() => new v(), 100), J_ = Symbol("lastMatrixWorldUpdateKey");
function ie(s, t = null, e = !0) {
  const i = t ?? mg.get();
  return s ? s.parent ? (e && s.updateWorldMatrix(!0, !1), s.matrixWorldNeedsUpdate && s[J_] !== Date.now() && (s[J_] = Date.now(), s.updateMatrixWorld()), i.setFromMatrixPosition(s.matrixWorld), i) : i.copy(s.position) : i.set(0, 0, 0);
}
function yt(s, t) {
  if (!s)
    return s;
  const e = mg.get();
  return t !== e && e.copy(t), ((s == null ? void 0 : s.parent) ?? s).worldToLocal(e), s.position.set(e.x, e.y, e.z), s;
}
function Fa(s, t, e, i) {
  const n = mg.get();
  return n.set(t, e, i), yt(s, n), s;
}
const Fd = new tn(() => new W(), 100), cr = new W(), Ef = new W();
function Ce(s, t = null) {
  if (!s)
    return Fd.get().identity();
  const e = t ?? Fd.get();
  return s.parent ? (s.getWorldQuaternion(e), e) : e.copy(s.quaternion);
}
function wn(s, t) {
  if (!s)
    return;
  t !== cr && cr.copy(t);
  const e = cr, i = s == null ? void 0 : s.parent;
  i == null || i.getWorldQuaternion(Ef), Ef.invert();
  const n = Ef.multiply(e);
  s.quaternion.set(n.x, n.y, n.z, n.w);
}
function R0(s, t, e, i, n) {
  cr.set(t, e, i, n), wn(s, cr);
}
const sC = new tn(() => new v(), 100), oC = new v();
function Ke(s, t = null) {
  return t || (t = sC.get()), s ? s.parent ? (s.getWorldScale(t), t) : t.copy(s.scale) : t.set(0, 0, 0);
}
function Lc(s, t) {
  if (!s)
    return;
  if (!s.parent) {
    s.scale.copy(t);
    return;
  }
  const e = oC;
  s.parent.getWorldScale(e), s.scale.copy(t), s.scale.divide(e);
}
const rC = new v(), ey = new W();
function pD(s) {
  return Ce(s, ey), rC.set(0, 0, 1).applyQuaternion(ey);
}
const aC = new tn(() => new v(), 100), ty = new W();
function lC(s, t) {
  return t || (t = aC.get().set(0, 0, 1)), Ce(s, ty), t.applyQuaternion(ty);
}
const iy = new jt(), ny = new jt(), cC = new v();
function k0(s) {
  const t = Fd.get();
  return s.getWorldQuaternion(t), ny.setFromQuaternion(t), ny;
}
function T0(s, t) {
  const e = Fd.get();
  wn(s, e.setFromEuler(t));
}
function Au(s) {
  const t = k0(s), e = cC;
  return e.set(t.x, t.y, t.z), e.x = $.toDegrees(e.x), e.y = $.toDegrees(e.y), e.z = $.toDegrees(e.z), e;
}
function A0(s, t) {
  Eu(s, t.x, t.y, t.z, !0);
}
function Eu(s, t, e, i, n = !0) {
  n && (t = $.toRadians(t), e = $.toRadians(e), i = $.toRadians(i)), iy.set(t, e, i), cr.setFromEuler(iy), wn(s, cr);
}
function rm(s, t = !0) {
  s && (t ? function e(i) {
    console.groupCollapsed((i.name ? i.name : "(no name : " + i.type + ")") + " %o", i), i.children.forEach(e), console.groupEnd();
  }(s) : s.traverse(function(e) {
    for (var i = "|___", n = e; n.parent !== null; )
      i = "	" + i, n = n.parent;
    console.log(i + e.name + " <" + e.type + ">");
  }));
}
function mD(s) {
  let t = (s == null ? void 0 : s.name) || "";
  if (!s)
    return t;
  let e = s.parent;
  for (; e; )
    t = e.name + "/" + t, e = e.parent;
  return t;
}
function hC(s) {
  if (s) {
    const t = s;
    return t.blendMode !== void 0 && t.clampWhenFinished !== void 0 && t.enabled !== void 0 && t.fadeIn !== void 0 && t.getClip !== void 0;
  }
  return !1;
}
class pn {
  /**
   * Create a blit material for copying textures
   */
  static createBlitMaterial(t) {
    return new bn({
      uniforms: { map: new co(null) },
      vertexShader: this.vertex,
      fragmentShader: t
    });
  }
  /** 
   * Copy a texture to a new texture
   * @param texture the texture to copy
   * @param blitMaterial the material to use for copying (optional)
   * @returns the newly created, copied texture
  */
  static copyTexture(t, e) {
    this.blitMaterial || (this.blitMaterial = new bn({
      uniforms: { map: new co(null) },
      vertexShader: this.vertex,
      fragmentShader: this.fragment
    }));
    const i = e || this.blitMaterial;
    i.uniforms.map.value = t, i.needsUpdate = !0, i.uniformsNeedUpdate = !0;
    const n = i.vertexShader;
    i.vertexShader = this.vertex, this.mesh || (this.mesh = new q(this.planeGeometry, this.blitMaterial));
    const o = this.mesh;
    o.material = i, o.frustumCulled = !1, this.scene.children.length = 0, this.scene.add(o), this.renderer || (this.renderer = new kr({ antialias: !1 })), this.renderer.setSize(t.image.width, t.image.height), this.renderer.clear(), this.renderer.render(this.scene, this.perspectiveCam);
    const a = new Fe(this.renderer.domElement);
    return a.name = "Copy", a.needsUpdate = !0, i.vertexShader = n, a;
  }
  // static blit(src: Texture, target: Texture, blitMaterial?: ShaderMaterial) {
  //     let material = blitMaterial ?? this.blipMaterial;
  //     material.uniforms.map.value = src;
  //     this.mesh.material = material;
  //     this.mesh.frustumCulled = false;
  //     this.mesh.matrix.identity();
  //     this.scene.children.length = 0;
  //     this.scene.add(this.mesh);
  //     this.renderer.setSize(src.image.width, src.image.height);
  //     this.renderer.clear();
  //     this.renderer.render(this.scene, this.perspectiveCam);
  //     return new Texture(this.renderer.domElement);
  // }
  /**
   * Copy a texture to a HTMLCanvasElement
   * @param texture the texture convert
   * @param force if true the texture will be copied to a new texture before converting
   * @returns the HTMLCanvasElement with the texture or null if the texture could not be copied
   */
  static textureToCanvas(t, e = !1) {
    if (!t)
      return null;
    (e === !0 || t.isCompressedTexture === !0) && (t = dC(t));
    const i = t.image;
    if (uC(i)) {
      const n = document.createElement("canvas");
      n.width = i.width, n.height = i.height;
      const o = n.getContext("2d");
      return o ? (o.drawImage(i, 0, 0, i.width, i.height, 0, 0, n.width, n.height), n) : (console.error("Failed getting canvas 2d context"), null);
    }
    return null;
  }
}
r(pn, "planeGeometry", new Xn(2, 2, 1, 1)), r(pn, "renderer"), r(pn, "perspectiveCam", new ye()), r(pn, "scene", new Mi()), r(pn, "vertex", `
    varying vec2 vUv;
    void main(){
        vUv = uv;
        gl_Position = vec4(position.xy * 1.0,0.,.999999);
    }`), r(pn, "fragment", `
    uniform sampler2D map; 
    varying vec2 vUv;
    void main(){ 
        vec2 uv = vUv;
        uv.y = 1.0 - uv.y;
        gl_FragColor = texture2D( map, uv);
        // gl_FragColor = vec4(uv.xy, 0, 1);
    }`), r(pn, "blitMaterial"), r(pn, "mesh");
function dC(s) {
  return pn.copyTexture(s);
}
function gD(s, t = !1) {
  return pn.textureToCanvas(s, t);
}
function uC(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas || typeof ImageBitmap < "u" && s instanceof ImageBitmap;
}
function fC(s) {
  const t = s.type;
  return t === "Mesh" || t === "SkinnedMesh";
}
function E0(s, t) {
  t ? s["needle:rendercustomshadow"] = !0 : s["needle:rendercustomshadow"] = !1;
}
function pC(s) {
  if (s) {
    if (s["needle:rendercustomshadow"] === !0)
      return !0;
    if (s["needle:rendercustomshadow"] == null)
      return !0;
  }
  return !1;
}
function ki(s, t = void 0, e = void 0, i = void 0) {
  const n = i || new Pi();
  n.makeEmpty();
  const o = [];
  function a(c) {
    let h = !0;
    if (c.visible && JS(c) !== !1 && !(c.type === "TransformControlsGizmo" || c.type === "TransformControlsPlane")) {
      if (c instanceof Kb && (h = !1), c instanceof ig && (h = !1), c instanceof Ba && (h = !1), c.isGizmo === !0 && (h = !1), c.material instanceof Yb && (h = !1), fC(c) || (h = !1), e && c.layers.test(e) === !1 && (h = !1), h) {
        if (t && Array.isArray(t) && (t != null && t.includes(c)))
          return;
        if (typeof t == "function" && t(c) === !0)
          return;
      }
      if (c.isUI !== !0) {
        if (h) {
          const d = c.children;
          c.children = o;
          const u = c.position, p = c.scale;
          if (Number.isNaN(u.x) || Number.isNaN(u.y) || Number.isNaN(u.z)) {
            console.warn(`Object "${c.name}" has NaN values in position or scale.... will ignore it`, u, p);
            return;
          }
          n.expandByObject(c, !0), c.children = d;
        }
        for (const d of c.children)
          a(d);
      }
    }
  }
  let l = !1;
  Array.isArray(s) || (s = [s]);
  for (const c of s)
    c && (l = !0, c.updateMatrixWorld(), a(c));
  return l || console.warn("No objects to fit camera to..."), n;
}
function mC(s, t, e) {
  const i = ki([s], e == null ? void 0 : e.ignore), n = new v();
  i.getSize(n);
  const o = new v();
  i.getCenter(o);
  const a = new v();
  t.getSize(a);
  const l = new v();
  t.getCenter(l);
  const c = new v();
  c.set(a.x / n.x, a.y / n.y, a.z / n.z);
  const h = Math.min(c.x, c.y, c.z), d = (e == null ? void 0 : e.scale) !== !1;
  if (d && Lc(s, Ke(s).multiplyScalar(h)), (e == null ? void 0 : e.position) !== !1) {
    const u = new v();
    i.getCenter(u), u.y = i.min.y;
    const p = new v();
    t.getCenter(p), p.y = t.min.y;
    const m = p.clone().sub(u);
    d && m.multiplyScalar(h), yt(s, ie(s).add(m));
  }
  return {
    boundsBefore: i,
    scale: c
  };
}
function gC(s, t) {
  const e = ki([s]), i = new v();
  e.getCenter(i), i.y = e.min.y;
  const n = t.clone().sub(i), o = ie(s);
  return yt(s, o.add(n)), {
    offset: n,
    bounds: e
  };
}
function I0(s, t, e, i) {
  if (Array.isArray(t)) {
    let a = !0;
    for (let l = 0; l < t.length; l++)
      I0(s, t[l], l, t) || (a = !1);
    return a;
  }
  if (t.type === "MeshStandardMaterial" || t.type === "MeshBasicMaterial")
    return !1;
  if (t["material:fbx"] != null)
    return !0;
  const n = new It();
  n["material:fbx"] = t;
  const o = t;
  return o && (o.map ? n.color.set(1, 1, 1) : n.color.copyLinearToSRGB(o.color), n.emissive.copyLinearToSRGB(o.emissive), n.emissiveIntensity = o.emissiveIntensity, n.opacity = o.opacity, n.displacementScale = o.displacementScale, n.transparent = o.transparent, n.bumpMap = o.bumpMap, n.aoMap = o.aoMap, n.map = o.map, n.displacementMap = o.displacementMap, n.emissiveMap = o.emissiveMap, n.normalMap = o.normalMap, n.envMap = o.envMap, n.alphaMap = o.alphaMap, n.metalness = o.reflectivity, n.vertexColors = o.vertexColors, o.shininess && (n.roughness = 1 - Math.sqrt(o.shininess) / 10), n.needsUpdate = !0), e === void 0 ? s.material = n : i[e] = n, !0;
}
let Rh = !1;
NS((...s) => {
  var t;
  z() && ((t = fe.Current) != null && t.isInXR) && (xa(!0), D0("error", ...s));
});
function xa(s) {
  if (s) {
    if (Rh)
      return;
    Rh = !0, yC();
  } else {
    if (!Rh)
      return;
    Rh = !1, bC();
  }
}
const ac = {
  log: void 0,
  warn: void 0,
  error: void 0
};
class _C {
  constructor() {
    r(this, "familyName", "needle-xr");
    r(this, "root", null);
    r(this, "context", null);
    r(this, "defaultFontSize", 0.06);
    r(this, "targetObject", new L());
    /** this is a point in forward view of the user */
    r(this, "userForwardViewPoint", new v());
    r(this, "oneEuroFilter", new O0(90, 0.8));
    r(this, "_lastElementRemoveTime", 0);
    r(this, "onBeforeRender", () => {
      var e, i;
      const t = (e = this.context) == null ? void 0 : e.mainCamera;
      if (this.context && t instanceof ye) {
        const n = this.getRoot();
        Number.isNaN(n.position.x) && n.position.set(0, 0, 0), Number.isNaN(n.quaternion.x) && n.quaternion.set(0, 0, 0, 1), this.context.scene.add(this.targetObject);
        const o = ((i = this.context.xr) == null ? void 0 : i.rigScale) ?? 1, a = 3.5 * o, l = t.worldForward;
        l.y = 0, l.normalize().multiplyScalar(a), this.userForwardViewPoint.copy(t.worldPosition).sub(l), this.targetObject.position.distanceTo(this.userForwardViewPoint) > 2 * o && (this.targetObject.position.copy(this.userForwardViewPoint), Tu(this.targetObject, t, !0, !0), this.targetObject.rotateY(Math.PI)), this.oneEuroFilter.filter(this.targetObject.position, n.position, this.context.time.time);
        const h = this.context.time.deltaTime;
        if (n.quaternion.slerp(this.targetObject.quaternion, h * 5), n.scale.setScalar(o), this.targetObject.removeFromParent(), this.context.scene.add(n), this.context.time.time - this._lastElementRemoveTime > 0.1) {
          this._lastElementRemoveTime = this.context.time.time;
          const d = Date.now();
          for (let u = 0; u < this._activeTexts.length; u++) {
            const p = this._activeTexts[u];
            if (p instanceof Te.Text && d - p._activatedTime > 2e4) {
              p.removeFromParent(), this._textBuffer.push(p), this._activeTexts.splice(u, 1);
              break;
            }
          }
        }
      }
    });
    r(this, "textOptions", {
      fontSize: this.defaultFontSize,
      fontFamily: this.familyName,
      padding: 0.03,
      margin: 5e-3,
      color: 0,
      backgroundColor: 16777215,
      backgroundOpacity: 0.4,
      borderRadius: 0.03,
      offset: 0.025
    });
    r(this, "_textBuffer", []);
    r(this, "_activeTexts", []);
    this.ensureFont();
  }
  onEnable() {
    this.context = fe.Current || fe.All[0], this.context.pre_render_callbacks.push(this.onBeforeRender);
  }
  onDisable() {
    var t, e, i;
    (e = this.context) == null || e.pre_render_callbacks.splice((t = this.context) == null ? void 0 : t.pre_render_callbacks.indexOf(this.onBeforeRender), 1), (i = this.root) == null || i.removeFromParent();
  }
  addLog(t, e) {
    const i = this.getRoot(), n = this.getText();
    let o = 16777215, a = 0;
    switch (t) {
      case "log":
        o = 16777215, a = 0;
        break;
      case "warn":
        o = 16772761, a = 4465152;
        break;
      case "error":
        o = 16755370, a = 7798784;
        break;
    }
    e.length > 1e3 && (e = e.substring(0, 1e3) + "...");
    const l = (/* @__PURE__ */ new Date()).toISOString().split("T")[1].split(".")[0];
    n.textContent = "[" + l + "] " + e, n.visible = !0, n._activatedTime = Date.now(), i.add(n), this._activeTexts.push(n), this.context && this.context.scene.add(i), n.set({
      backgroundColor: o,
      color: a
    }), Te.update();
  }
  ensureFont() {
    let t = Te.FontLibrary.getFontFamily(this.familyName);
    if (!t) {
      t = Te.FontLibrary.addFontFamily(this.familyName);
      const e = t.addVariant("normal", "normal", "./include/needle/arial-msdf.json", "./include/needle/arial.png");
      e == null || e.addEventListener("ready", () => {
        Te.update();
      });
    }
  }
  getText() {
    const t = this.getRoot();
    if (this._textBuffer.length > 0) {
      const i = this._textBuffer.pop();
      return i.visible = !0, setTimeout(() => this.disableDepthTestRecursive(i), 100), i;
    }
    if (t.children.length > 20 && this._activeTexts.length > 0)
      return this._activeTexts.shift();
    const e = new Te.Text(this.textOptions);
    return setTimeout(() => this.disableDepthTestRecursive(e), 500), setTimeout(() => this.disableDepthTestRecursive(e), 1500), e;
  }
  disableDepthTestRecursive(t, e = 0) {
    for (let n = 0; n < t.children.length; n++) {
      const o = t.children[n];
      o instanceof L && this.disableDepthTestRecursive(o, e + 1);
    }
    t.renderOrder = 10 * e, t.layers.set(2);
    const i = t.material;
    i && (i.depthWrite = !1, i.depthTest = !1, i.transparent = !0), e === 0 && Te.update();
  }
  getRoot() {
    if (this.root)
      return this.root;
    const t = this.defaultFontSize, e = {
      boxSizing: "border-box",
      fontFamily: this.familyName,
      width: "2.6",
      fontSize: t,
      color: 0,
      lineHeight: 1,
      backgroundColor: 16777215,
      backgroundOpacity: 0,
      // borderColor: 0xffffff,
      // borderOpacity: .5,
      // borderWidth: 0.01,
      // padding: 0.01,
      whiteSpace: "pre-wrap",
      flexDirection: "column-reverse"
    };
    return this.root = new Te.Block(e), this.root;
  }
}
let Kt = null;
function yC() {
  Kt || (Kt = new _C()), Kt.onEnable();
  for (const s in ac) {
    ac[s] = console[s];
    let t = !1;
    console[s] = function() {
      var e;
      if ((e = ac[s]) == null || e.apply(console, arguments), !t)
        try {
          t = !0, D0(s, ...arguments);
        } finally {
          t = !1;
        }
    };
  }
}
function bC() {
  Kt == null || Kt.onDisable();
  for (const s in ac)
    console[s] = ac[s];
}
const Ol = /* @__PURE__ */ new Map();
function D0(s, ...t) {
  try {
    switch (Ol.clear(), s) {
      case "log":
        Kt == null || Kt.addLog("log", e());
        break;
      case "warn":
        Kt == null || Kt.addLog("warn", e());
        break;
      case "error":
        Kt == null || Kt.addLog("error", e());
        break;
    }
  } catch (o) {
    console.error("Error in spatial console", o);
  } finally {
    Ol.clear();
  }
  function e() {
    let o = "";
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      o += i(l), a < t.length - 1 && (o += ", ");
    }
    return o;
  }
  function i(o, a = 0) {
    if (typeof o == "string")
      return '"' + o + '"';
    if (typeof o == "number") {
      if (o % 1 !== 0) {
        const c = o.toFixed(5), h = c.indexOf(".");
        let d = c.length - 1;
        for (; d > h && c[d] === "0"; )
          d--;
        return c.substring(0, d + 1);
      }
      return o.toString();
    } else if (Array.isArray(o)) {
      let l = "[";
      for (let c = 0; c < o.length; c++) {
        const h = o[c];
        l += i(h, a + 1), c < o.length - 1 && (l += ", ");
      }
      return l += "]", l;
    } else {
      if (o === null)
        return "null";
      if (o === void 0)
        return "undefined";
      if (typeof o == "function")
        return o.name + "()";
    }
    if (o instanceof oe)
      return `(${i(o.x)}, ${i(o.y)})`;
    if (o instanceof v)
      return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)})`;
    if (o instanceof me)
      return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)}, ${i(o.w)})`;
    if (o instanceof W)
      return `(${i(o.x)}, ${i(o.y)}, ${i(o.z)}, ${i(o.w)})`;
    if (o instanceof Se || o instanceof Fe)
      return o.name;
    if (o instanceof Zb)
      return `[${o.elements.join(", ")}]`;
    if (o instanceof se)
      return `[${o.elements.join(", ")}]`;
    if (o instanceof vo)
      return o.mask.toString();
    if (typeof o == "object") {
      if (Ol.has(o))
        return "*";
      let l = `{
`;
      l += n(a);
      const c = Object.keys(o);
      let h = "";
      for (let d = 0; d < c.length; d++) {
        const u = c[d], p = o[u];
        if (Ol.has(p)) {
          h += "";
          continue;
        }
        Ol.set(p, !0), h += u + ":" + i(p, a + 1), d < c.length - 1 && (h += ", "), h.length >= 60 && (h += `
`, h += n(a), l += h, h = "");
      }
      return l += h, l += `
}`, l;
    }
    return o;
  }
  function n(o) {
    let a = "";
    for (let l = 0; l < o; l++)
      a += " ";
    return a;
  }
}
const vC = x("nodevlogs");
function We(s, t = Zi.Log) {
  Bn(t, s);
}
function ve(s) {
  We(s, Zi.Warn);
}
function Iu(s) {
  We(s, Zi.Error);
}
let am, If;
function z() {
  if (vC)
    return !1;
  if (am !== void 0)
    return am;
  if (If !== void 0)
    return If;
  let s = ui();
  return s || (s = window.location.hostname.endsWith(".local-credentialless.webcontainer.io")), If = s, s;
}
function _D(s) {
  am = s;
}
let Zt, _i = null, Fn = null, Ml = !1, sy = null;
const L0 = "terminal", Hl = x("console"), wC = x("noerrors") || x("noconsole") || window.crossOriginIsolated;
Hl && j0();
if (!wC && (Hl || ui())) {
  if (ui() && !Hl) {
    const t = new URL(window.location.href);
    t.searchParams.set("console", "1"), console.log('🌵 Tip: You can add the "?console" query parameter to the url to show the debug console (on mobile it will automatically open in the bottom right corner when your get errors during development. In VR a spatial console will appear.)', `
Open this page to get the console: ` + t.toString());
  }
  const s = X.isMobileDevice() || X.isQuest() && z();
  if ((s || Hl) && (VS(), B0(), F0(!0), s)) {
    const t = document.querySelector("needle-engine");
    t == null || t.addEventListener("enter-ar", () => {
      (Hl || Zt || pg() > 0) && x("noerrors");
    }), t == null || t.addEventListener("exit-ar", () => {
      OC();
    });
  }
}
const lm = Symbol("consoleParent");
function j0() {
  if (Zt) {
    Zt.showSwitch();
    return;
  }
  F0();
}
function xC() {
  Zt && (Zt.hide(), Zt.hideSwitch());
}
function B0() {
  sy || (sy = setInterval(SC, 500));
}
let oy = 0;
function SC() {
  const s = pg(), t = s !== oy;
  oy = s, t && CC();
}
function CC() {
  j0(), Fn && (Fn.setAttribute("error", "true"), Fn.innerText = "🤬");
}
function PC() {
  Fn && (Fn.removeAttribute("error"), Fn.innerText = L0);
}
function OC() {
  _i && _i[lm] && _i[lm].appendChild(_i);
}
function F0(s = !1) {
  if (Zt !== void 0 || Ml)
    return;
  Ml = !0;
  const t = document.createElement("script");
  t.onload = () => {
    if (!globalThis.VConsole) {
      console.warn("🌵 Debug console failed to load."), Ml = !1, Zt = null;
      return;
    }
    Ml = !1, B0(), Zt = new VConsole({
      // defaultPlugins: ['system', 'network'],
      pluginOrder: ["default", "needle-console"]
    });
    const e = globalThis["needle:codegen_files"];
    if (e && e.length > 0 && Zt.addPlugin(MC()), _i = kC(), _i && (_i[lm] = _i.parentElement, _i.style.position = "absolute", _i.style.zIndex = Number.MAX_SAFE_INTEGER.toString()), Zt.setSwitchPosition(20, 30), Fn = RC(), Fn) {
      Fn.innerText = L0, Fn.addEventListener("click", PC);
      const i = document.createElement("style"), n = 40;
      i.innerHTML = `
                #__vconsole .vc-switch {
                    border: 1px solid rgba(255, 255, 255, .1);
                    border-radius: 50%;
                    width: ${n}px;
                    height: ${n}px;
                    padding: 0;
                    line-height: ${n}px;
                    font-size: ${n * 0.4}px;
                    text-align: center;
                    background: #ffffff5c;
                    backdrop-filter: blur(16px);
                    -webkit-backdrop-filter: blur(16px);
                    user-select: none;
                    pointer-events: auto;
                    transition: transform .2s ease-in-out;
                    box-shadow: 0px 7px 0.5rem 0px rgb(0 0 0 / 6%), inset 0px 0px 1.3rem rgba(0,0,0,.05);

                    font-family: 'Material Symbols Outlined';
                    color: black;
                    font-size: 2.3em;
                    font-weight: 100;
                }
                #__vconsole .vc-switch:hover {
                    cursor: pointer;
                    transform: scale(1.1);
                    transition: transform .1s ease-in-out, background .1s linear;
                    background: rgba(245, 245, 245, .8);
                    outline: rgba(0, 0, 0, .05) 1px solid;
                }
                #__vconsole .vc-switch[error] {
                    background: rgba(255,0,0,.2);
                    animation: vconsole-notify 1s ease-in-out;
                    line-height: 35px;
                }
                @keyframes vconsole-notify {
                    from {
                        transform: scale(1, 1);
                    }
                    10% {
                        transform: scale(1.3, 1.3);
                    }
                    70% {
                        transform: scale(1.4, 1.4);
                    }
                    to {
                        transform: scale(1, 1);
                    }
                }
                #__vconsole .vc-panel {
                    font-family: monospace;
                    font-size: 11px;
                }
                #__vconsole .vc-plugin-box.vc-actived {
                    height: 100%;
                }
                #__vconsole .vc-mask {
                    overflow: hidden;
                }
            `, _i == null || _i.prepend(i), s === !0 && pg() <= 0 && xC(), console.log("🌵 Debug console has loaded");
    }
  }, t.onerror = () => {
    console.warn("🌵 Debug console failed to load." + (window.crossOriginIsolated ? "This page is using cross-origin isolation, so external scripts can't be loaded." : "")), Ml = !1, Zt = null;
  }, t.src = "https://unpkg.com/vconsole@latest/dist/vconsole.min.js", document.body.appendChild(t);
}
function MC() {
  if (!globalThis.VConsole)
    return;
  const s = new VConsole.VConsolePlugin("needle-console", "🌵 Inspect glTF"), t = () => document.querySelector("#__vc_plug_" + s._id + " iframe");
  return s.on("renderTab", function(e) {
    const i = globalThis["needle:codegen_files"];
    if (!i || i.length === 0)
      return;
    let n = globalThis["needle:codegen_files"][0];
    const o = n.indexOf("?");
    o > -1 && (n = n.substring(0, o));
    const l = location.protocol + "//" + location.host + location.pathname + "/" + n, c = encodeURIComponent(l);
    s.fullUrl = "https://viewer.needle.tools?inspect&file=" + c;
    var h = '<iframe src="" style="width: 100%; height: 99%; border: none;"></iframe>';
    e(h);
  }), s.on("show", function() {
    const e = t();
    e && e.src !== s.fullUrl && (e.src = s.fullUrl);
  }), s.on("hide", function() {
    const e = t();
    e && (e.src = "");
  }), s.on("addTopBar", function(e) {
    var i = new Array();
    i.push({
      name: "Open in new window ↗",
      onClick: function(n) {
        window.open(s.fullUrl, "_blank"), Zt == null || Zt.hide();
      }
    }), i.push({
      name: "Reload",
      onClick: function(n) {
        const o = t();
        o && (o.src = s.fullUrl);
      }
    }), i.push({
      name: "Fullscreen",
      onClick: function(n) {
        const o = t();
        o.requestFullscreen ? o.requestFullscreen() : o.webkitRequestFullscreen instanceof Function && o.webkitRequestFullscreen();
      }
    }), e(i);
  }), s;
}
function RC() {
  const s = document.querySelector("#__vconsole .vc-switch");
  return s || null;
}
function kC() {
  const s = document.querySelector("#__vconsole");
  return s || null;
}
const z0 = x("debugdefines");
Co('if(!globalThis[""4.4.0-alpha.5""]) globalThis[""4.4.0-alpha.5""] = "0.0.0";');
Co('if(!globalThis[""undefined""]) globalThis[""undefined""] = "unknown";');
Co('if(!globalThis[""Thu Mar 27 2025 13:24:11 GMT+0100 (Central European Standard Time)""]) globalThis[""Thu Mar 27 2025 13:24:11 GMT+0100 (Central European Standard Time)""] = "unknown";');
Co('if(!globalThis[""npk_74222a9fbd1b42572cdd3bf7f639eeb17a07d07f40a6185fac5f722e8fd34df9""]) globalThis[""npk_74222a9fbd1b42572cdd3bf7f639eeb17a07d07f40a6185fac5f722e8fd34df9""] = "unknown";');
Co('globalThis["__NEEDLE_ENGINE_VERSION__"] = "4.4.0-alpha.5";');
Co('globalThis["__NEEDLE_ENGINE_GENERATOR__"] = "undefined";');
Co('globalThis["__NEEDLE_PROJECT_BUILD_TIME__"] = "Thu Mar 27 2025 13:24:11 GMT+0100 (Central European Standard Time)";');
Co('globalThis["__NEEDLE_PUBLIC_KEY__"] = "npk_74222a9fbd1b42572cdd3bf7f639eeb17a07d07f40a6185fac5f722e8fd34df9";');
const $n = "4.4.0-alpha.5", gg = "undefined", U0 = "Thu Mar 27 2025 13:24:11 GMT+0100 (Central European Standard Time)";
z0 && console.log(`Engine version: ${$n} (generator: ${gg})
Project built at ${U0}`);
const ud = "npk_74222a9fbd1b42572cdd3bf7f639eeb17a07d07f40a6185fac5f722e8fd34df9", po = "needle_isActiveInHierarchy", sa = "builtin_components", fd = "needle_editor_guid";
function Co(s) {
  try {
    (0, eval)(s);
  } catch (t) {
    z0 && console.error(t);
  }
}
const TC = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 160 187.74"><defs><linearGradient id="a" x1="89.64" y1="184.81" x2="90.48" y2="21.85" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#62d399"/><stop offset=".51" stop-color="#acd842"/><stop offset=".9" stop-color="#d7db0a"/></linearGradient><linearGradient id="b" x1="69.68" y1="178.9" x2="68.08" y2="16.77" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#0ba398"/><stop offset=".5" stop-color="#4ca352"/><stop offset="1" stop-color="#76a30a"/></linearGradient><linearGradient id="c" x1="36.6" y1="152.17" x2="34.7" y2="84.19" gradientUnits="userSpaceOnUse"><stop offset=".19" stop-color="#36a382"/><stop offset=".54" stop-color="#49a459"/><stop offset="1" stop-color="#76a30b"/></linearGradient><linearGradient id="d" x1="15.82" y1="153.24" x2="18" y2="90.86" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#267880"/><stop offset=".51" stop-color="#457a5c"/><stop offset="1" stop-color="#717516"/></linearGradient><linearGradient id="e" x1="135.08" y1="135.43" x2="148.93" y2="63.47" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#b0d939"/><stop offset="1" stop-color="#eadb04"/></linearGradient><linearGradient id="f" x1="-4163.25" y1="2285.12" x2="-4160.81" y2="2215.34" gradientTransform="rotate(20 4088.49 13316.712)" gradientUnits="userSpaceOnUse"><stop offset=".17" stop-color="#74af52"/><stop offset=".48" stop-color="#99be32"/><stop offset="1" stop-color="#c0c40a"/></linearGradient><symbol id="g" viewBox="0 0 160 187.74"><path style="fill:url(#a)" d="M79.32 36.98v150.76L95 174.54l6.59-156.31-22.27 18.75z"/><path style="fill:url(#b)" d="M79.32 36.98 57.05 18.23l6.59 156.31 15.68 13.2V36.98z"/><path style="fill:url(#c)" d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33z"/><path style="fill:url(#d)" d="M25.19 104.83 0 90.24l16.97 53.86 16.85 9.77-8.63-49.04z"/><path style="fill:#9c3" d="M43.86 82.5 18.69 67.98 0 90.24l25.18 14.59L43.86 82.5z"/><path style="fill:url(#e)" d="m134.82 78.69-9.97 56.5 15.58-9.04L160 64.1l-25.18 14.59z"/><path style="fill:url(#f)" d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5z"/><path style="fill:#ffe113" d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33L160 64.1z"/><path style="fill:#f3e600" d="M101.59 18.23 79.32 0 57.05 18.23l22.27 18.75 22.27-18.75z"/></symbol></defs><use width="160" height="187.74" xlink:href="#g"/></svg>', AC = btoa(TC), EC = "data:image/svg+xml;base64," + AC, IC = EC, DC = `<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'> <svg clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" version="1.1" viewBox="0 0 1014 282" xml:space="preserve" xmlns="http://www.w3.org/2000/svg"> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m665.95 132.73v44.88l-10.56-8.4c-0.8-0.64-1.2-1.44-1.2-2.4v-32.4c0-6.48-4.12-9.72-12.36-9.72-2.16 0-4.18 0.4-6.06 1.2s-3.54 1.8-4.98 3-2.56 2.5-3.36 3.9-1.2 2.7-1.2 3.9v40.92l-10.68-8.4c-0.72-0.64-1.08-1.44-1.08-2.4v-53.76l10.92 8.52c0.32 0.24 0.56 0.44 0.72 0.6s0.36 0.32 0.6 0.48c0.96-1.2 2.14-2.28 3.54-3.24s2.92-1.76 4.56-2.4 3.34-1.14 5.1-1.5 3.44-0.54 5.04-0.54c1.44 0 2.92 0.04 4.44 0.12s2.84 0.28 3.96 0.6c4.56 1.12 7.8 3.12 9.72 6s2.88 6.56 2.88 11.04z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m732.38 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m795.93 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m858.57 97.21c0.64 0.48 0.96 1.16 0.96 2.04v74.88c-0.08 1.04-0.12 2.12-0.12 3.24-1.84-1.52-3.56-2.92-5.16-4.2-1.36-1.12-2.66-2.18-3.9-3.18s-2.06-1.66-2.46-1.98c-1.76 2.48-4.26 4.44-7.5 5.88s-7.02 2.16-11.34 2.16c-3.84 0-7.4-0.7-10.68-2.1s-6.14-3.44-8.58-6.12-4.34-5.94-5.7-9.78-2.04-8.16-2.04-12.96c0-4.32 0.78-8.34 2.34-12.06s3.6-6.92 6.12-9.6 5.38-4.78 8.58-6.3 6.48-2.28 9.84-2.28c2.56 0 4.82 0.22 6.78 0.66s3.68 1.06 5.16 1.86 2.78 1.74 3.9 2.82 2.16 2.22 3.12 3.42v-35.04l10.68 8.64zm-27.96 67.92c3.6 0 6.52-0.68 8.76-2.04s3.98-3.06 5.22-5.1 2.1-4.22 2.58-6.54 0.72-4.44 0.72-6.36v-1.2c0-1.12-0.22-2.7-0.66-4.74s-1.28-4.06-2.52-6.06-3-3.7-5.28-5.1-5.22-2.02-8.82-1.86c-3.44 0-6.26 0.74-8.46 2.22s-3.96 3.26-5.28 5.34-2.24 4.2-2.76 6.36-0.78 3.92-0.78 5.28c0 1.84 0.24 3.92 0.72 6.24s1.36 4.48 2.64 6.48 3.04 3.68 5.28 5.04 5.12 2.04 8.64 2.04z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m882.81 97.09c0.64 0.48 0.96 1.12 0.96 1.92l-0.12 41.04v37.08l-10.56-8.4c-0.72-0.64-1.08-1.44-1.08-2.4v-77.88l10.8 8.64z" fill-rule="nonzero"/> </g> <g transform="matrix(1.008 0 0 1.008 -2.239 .61874)"> <path d="m950.36 146.05c0 0.88 0.02 1.5 0.06 1.86s-0.02 0.98-0.18 1.86h-7.08c-2.08 0-4.44-0.02-7.08-0.06s-5.36-0.06-8.16-0.06h-22.08c0 2.88 0.56 5.36 1.68 7.44s2.6 3.8 4.44 5.16 3.94 2.36 6.3 3 4.74 0.96 7.14 0.96c3.04 0 5.9-0.76 8.58-2.28s4.94-3.52 6.78-6c0.64 0.56 1.54 1.48 2.7 2.76s2.94 3.2 5.34 5.76c-2.8 3.36-6.22 6.02-10.26 7.98s-8.42 2.94-13.14 2.94-8.92-0.64-12.84-1.92-7.32-3.24-10.2-5.88-5.12-5.98-6.72-10.02-2.4-8.82-2.4-14.34c0-4.96 0.66-9.42 1.98-13.38s3.22-7.32 5.7-10.08 5.44-4.9 8.88-6.42 7.32-2.28 11.64-2.28c5.76 0 10.52 0.88 14.28 2.64s6.72 4.16 8.88 7.2 3.66 6.54 4.5 10.5 1.26 8.18 1.26 12.66zm-29.4-22.8c-2.16 0.16-4.16 0.72-6 1.68s-3.42 2.2-4.74 3.72-2.36 3.28-3.12 5.28-1.14 4.12-1.14 6.36h33.12c0-2-0.22-4.06-0.66-6.18s-1.3-4.02-2.58-5.7-3.1-3.02-5.46-4.02-5.5-1.38-9.42-1.14z" fill-rule="nonzero"/> </g> <g transform="matrix(1.8559 0 0 .7642 45.348 36.475)"> <g transform="translate(2.7114)"> <path d="m3.935 173.02c-0.331 0-0.497-0.402-0.497-1.207v-51.002c0-0.738 0.138-1.107 0.414-1.107h1.781c0.277 0 0.415 0.335 0.415 1.006v5.935c0 0.336 0.027 0.553 0.083 0.654 0.055 0.101 0.151-0.017 0.289-0.352 0.912-1.744 1.754-3.236 2.527-4.477 0.773-1.24 1.554-2.179 2.341-2.816s1.65-0.956 2.588-0.956c1.685 0 3.011 0.922 3.977 2.766 0.967 1.845 1.602 3.84 1.905 5.986 0.056 0.268 0.139 0.369 0.249 0.302s0.221-0.235 0.331-0.503c0.939-1.811 1.802-3.353 2.589-4.628 0.787-1.274 1.581-2.246 2.382-2.917s1.671-1.006 2.61-1.006c2.016 0 3.569 1.392 4.66 4.175 1.09 2.783 1.636 6.421 1.636 10.915v37.925c0 0.871-0.18 1.307-0.539 1.307h-1.739c-0.138 0-0.249-0.1-0.332-0.301-0.083-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.338-6.321-1.015-8.3-0.676-1.978-1.76-2.967-3.251-2.967-0.884 0-1.726 0.386-2.527 1.157s-1.519 1.727-2.154 2.867-1.201 2.213-1.699 3.219c-0.248 0.469-0.421 0.905-0.517 1.308-0.097 0.402-0.145 0.972-0.145 1.71v37.221c0 0.871-0.166 1.307-0.497 1.307h-1.74c-0.166 0-0.29-0.1-0.373-0.301-0.083-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.332-6.321-0.994-8.3-0.663-1.978-1.754-2.967-3.273-2.967-1.242 0-2.375 0.704-3.396 2.112-1.022 1.409-2.223 3.555-3.604 6.439v39.031c0 0.805-0.18 1.207-0.539 1.207h-1.698z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m53.642 166.28c-1.077 2.549-2.237 4.477-3.479 5.785-1.243 1.307-2.61 1.961-4.101 1.961-2.154 0-3.853-1.324-5.095-3.973-1.243-2.649-1.864-6.187-1.864-10.613 0-3.488 0.4-6.489 1.201-9.004s1.988-4.51 3.562-5.985c1.574-1.476 3.521-2.414 5.841-2.817l3.686-0.704c0.221-0.067 0.394-0.218 0.518-0.453 0.124-0.234 0.187-0.587 0.187-1.056v-2.917c0-3.89-0.504-6.975-1.512-9.255s-2.354-3.42-4.039-3.42c-1.298 0-2.472 0.72-3.521 2.162s-2.002 3.572-2.858 6.388c-0.083 0.268-0.159 0.453-0.228 0.554-0.069 0.1-0.172 0.083-0.311-0.051l-1.698-1.71c-0.083-0.134-0.138-0.285-0.166-0.453-0.027-0.167 0.014-0.452 0.125-0.855 0.856-3.353 2.009-6.052 3.459-8.098 1.449-2.045 3.224-3.068 5.322-3.068 1.74 0 3.211 0.687 4.412 2.062s2.112 3.37 2.734 5.986c0.621 2.615 0.932 5.7 0.932 9.255v35.712c0 0.536-0.035 0.888-0.104 1.056s-0.2 0.251-0.393 0.251h-1.533c-0.166 0-0.29-0.117-0.373-0.352-0.083-0.234-0.124-0.553-0.124-0.955l-0.083-5.231c-0.055-0.939-0.221-1.006-0.497-0.202zm0.456-19.314c0-1.14-0.194-1.643-0.58-1.509l-3.107 0.603c-1.436 0.202-2.686 0.638-3.749 1.308-1.063 0.671-1.953 1.543-2.671 2.616s-1.257 2.33-1.616 3.772-0.538 3.102-0.538 4.98c0 3.152 0.455 5.616 1.367 7.393 0.911 1.778 2.14 2.666 3.686 2.666 0.939 0 1.85-0.419 2.734-1.257s1.671-1.895 2.361-3.169c0.663-1.408 1.181-2.85 1.553-4.326 0.373-1.475 0.56-2.883 0.56-4.225v-8.852z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m79.034 173.02c-0.166 0-0.297-0.117-0.394-0.352-0.096-0.234-0.145-0.553-0.145-0.955v-4.628c0-0.536-0.041-0.838-0.124-0.905s-0.207 0.1-0.373 0.503c-0.276 0.67-0.69 1.593-1.242 2.766-0.553 1.174-1.271 2.23-2.154 3.169-0.884 0.939-1.961 1.408-3.231 1.408-1.74 0-3.314-0.989-4.722-2.967-1.409-1.979-2.534-4.963-3.376-8.953-0.843-3.991-1.264-8.937-1.264-14.838 0-5.701 0.415-10.68 1.243-14.939s1.988-7.595 3.479-10.009c1.492-2.415 3.204-3.622 5.137-3.622 1.436 0 2.616 0.57 3.541 1.71 0.926 1.14 1.719 2.381 2.382 3.722 0.249 0.47 0.414 0.637 0.497 0.503s0.125-0.536 0.125-1.207v-23.841c0-0.805 0.151-1.208 0.455-1.208h1.864c0.276 0 0.414 0.369 0.414 1.107v72.128c0 0.537-0.041 0.905-0.124 1.107-0.083 0.201-0.235 0.301-0.455 0.301h-1.533zm-0.621-42.049c-0.939-2.213-1.885-3.94-2.838-5.181s-2.009-1.861-3.169-1.861c-1.463 0-2.768 0.889-3.914 2.666s-2.044 4.376-2.693 7.796-0.973 7.578-0.973 12.474c0 5.097 0.338 9.272 1.015 12.524 0.676 3.253 1.567 5.651 2.672 7.193 1.104 1.543 2.305 2.314 3.603 2.314 1.188 0 2.258-0.704 3.211-2.113 0.952-1.408 1.705-3.118 2.257-5.13s0.829-3.957 0.829-5.835v-24.847z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m89.514 149.38c0 3.42 0.345 6.606 1.035 9.557 0.691 2.951 1.609 5.315 2.755 7.092s2.437 2.666 3.873 2.666c1.519 0 2.837-0.738 3.956-2.213 1.118-1.476 2.064-3.655 2.837-6.539 0.083-0.336 0.166-0.52 0.249-0.554 0.083-0.033 0.179 0.017 0.29 0.151l1.408 1.912c0.221 0.268 0.235 0.67 0.041 1.207-0.69 2.548-1.47 4.661-2.34 6.337-0.87 1.677-1.857 2.935-2.962 3.773-1.104 0.838-2.319 1.257-3.645 1.257-2.043 0-3.838-1.14-5.385-3.42-1.546-2.28-2.761-5.482-3.645-9.607-0.884-4.124-1.325-8.836-1.325-14.134 0-5.901 0.455-10.931 1.367-15.089 0.911-4.158 2.14-7.377 3.686-9.658 1.547-2.28 3.3-3.42 5.261-3.42 1.988 0 3.714 1.073 5.178 3.219 1.463 2.146 2.595 5.231 3.396 9.255s1.201 8.886 1.201 14.587c0 0.469-0.02 0.939-0.062 1.408-0.041 0.469-0.214 0.704-0.517 0.704h-16.362c-0.083 0-0.152 0.151-0.207 0.453-0.056 0.302-0.083 0.654-0.083 1.056zm13.752-6.237c0.304 0 0.497-0.1 0.58-0.302 0.083-0.201 0.124-0.57 0.124-1.106 0-3.219-0.283-6.187-0.849-8.903s-1.367-4.896-2.402-6.539c-1.036-1.643-2.272-2.464-3.708-2.464-1.629 0-2.996 0.955-4.101 2.867-1.104 1.911-1.94 4.342-2.506 7.293s-0.849 6.002-0.849 9.154h13.711z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m148.54 119.7c0.165 0 0.283 0.117 0.352 0.352s0.076 0.52 0.02 0.855l-6.254 50.902c-0.028 0.47-0.104 0.788-0.228 0.956s-0.297 0.251-0.518 0.251h-1.615c-0.442 0-0.718-0.402-0.829-1.207l-5.26-40.138c-0.111-0.604-0.201-0.905-0.27-0.905s-0.131 0.301-0.186 0.905l-5.012 40.138c-0.028 0.47-0.097 0.788-0.207 0.956-0.111 0.168-0.277 0.251-0.497 0.251h-1.74c-0.442 0-0.718-0.402-0.829-1.207l-6.503-50.801c-0.055-0.403-0.048-0.721 0.021-0.956s0.2-0.352 0.393-0.352h1.823c0.166 0 0.297 0.067 0.393 0.201 0.097 0.134 0.159 0.403 0.187 0.805l5.302 41.848c0.083 0.671 0.179 0.989 0.29 0.956 0.11-0.034 0.207-0.386 0.29-1.056l5.219-41.949c0.055-0.268 0.124-0.47 0.207-0.604s0.193-0.201 0.331-0.201h1.533c0.138 0 0.262 0.067 0.373 0.201 0.11 0.134 0.179 0.403 0.207 0.805l5.468 41.848c0.083 0.671 0.179 0.989 0.29 0.956 0.11-0.034 0.207-0.386 0.29-1.056l5.053-41.849c0.055-0.335 0.138-0.57 0.249-0.704 0.11-0.134 0.234-0.201 0.373-0.201h1.284z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m156.49 171.51c0 0.604-0.042 1.006-0.125 1.208-0.082 0.201-0.262 0.301-0.538 0.301h-1.533c-0.221 0-0.366-0.083-0.435-0.251s-0.103-0.486-0.103-0.956v-50.902c0-0.805 0.152-1.207 0.456-1.207h1.822c0.304 0 0.456 0.402 0.456 1.207v50.6zm0.165-63.979c0 1.207-0.207 1.811-0.621 1.811h-1.905c-0.221 0-0.366-0.135-0.435-0.403s-0.104-0.67-0.104-1.207v-7.847c0-1.006 0.18-1.509 0.539-1.509h1.988c0.359 0 0.538 0.47 0.538 1.409v7.746z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m168.3 124.83c-0.221 0-0.331 0.269-0.331 0.805v33.801c0 3.42 0.221 5.667 0.663 6.74 0.441 1.073 1.09 1.609 1.946 1.609h3.024c0.138 0 0.242 0.084 0.311 0.252 0.069 0.167 0.103 0.419 0.103 0.754v2.716c0 0.537-0.138 0.906-0.414 1.107-0.248 0.067-0.614 0.134-1.098 0.201-0.483 0.067-0.959 0.118-1.429 0.151-0.469 0.034-0.828 0.05-1.077 0.05-1.712 0-2.934-0.955-3.665-2.867-0.732-1.911-1.098-5.013-1.098-9.305v-35.108c0-0.604-0.124-0.906-0.373-0.906h-3.521c-0.248 0-0.373-0.268-0.373-0.804v-3.521c0-0.537 0.111-0.805 0.332-0.805h3.686c0.166 0 0.263-0.268 0.29-0.805l0.415-16.095c0-0.805 0.124-1.207 0.372-1.207h1.492c0.303 0 0.455 0.436 0.455 1.307v15.995c0 0.537 0.097 0.805 0.29 0.805h5.468c0.221 0 0.331 0.268 0.331 0.805v3.521c0 0.536-0.124 0.804-0.373 0.804h-5.426z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> <g transform="translate(2.7114)"> <path d="m179.4 173.02c-0.331 0-0.497-0.402-0.497-1.207v-72.329c0-0.738 0.138-1.107 0.414-1.107h1.782c0.276 0 0.414 0.336 0.414 1.006v27.162c0 0.335 0.034 0.536 0.103 0.603s0.159-0.033 0.27-0.302c0.994-1.81 1.898-3.319 2.713-4.526 0.814-1.208 1.629-2.113 2.444-2.717 0.814-0.603 1.691-0.905 2.63-0.905 2.182 0 3.839 1.375 4.971 4.125 1.132 2.749 1.698 6.404 1.698 10.965v37.925c0 0.871-0.166 1.307-0.497 1.307h-1.74c-0.165 0-0.29-0.1-0.373-0.301-0.082-0.202-0.124-0.503-0.124-0.906v-36.315c0-3.555-0.366-6.321-1.097-8.3-0.732-1.978-1.899-2.967-3.501-2.967-0.883 0-1.705 0.318-2.464 0.956-0.76 0.637-1.526 1.576-2.299 2.816-0.773 1.241-1.643 2.834-2.61 4.779v39.031c0 0.805-0.179 1.207-0.538 1.207h-1.699z" fill-rule="nonzero" stroke="#000" stroke-width=".7px"/> </g> </g> <g transform="matrix(.80638 0 0 .80638 452.53 65.421)" fill-rule="nonzero"> <path d="m79.32 36.98v150.76l15.68-13.2 6.59-156.31-22.27 18.75z" fill="url(#f)"/> <path d="m79.32 36.98-22.27-18.75 6.59 156.31 15.68 13.2v-150.76z" fill="url(#e)"/> <path d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33z" fill="url(#d)"/> <path d="m25.19 104.83-25.19-14.59 16.97 53.86 16.85 9.77-8.63-49.04z" fill="url(#c)"/> <path d="M43.86,82.5L18.69,67.98L0,90.24L25.18,104.83L43.86,82.5Z" fill="#9c3"/> <path d="m134.82 78.69-9.97 56.5 15.58-9.04 19.57-62.05-25.18 14.59z" fill="url(#b)"/> <path d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5z" fill="url(#a)"/> <path d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33 25.19-14.59z" fill="#ffe113"/> <path d="M101.59,18.23L79.32,0L57.05,18.23L79.32,36.98L101.59,18.23Z" fill="#f3e600"/> </g> <defs> <linearGradient id="f" x2="1" gradientTransform="matrix(.84 -162.96 162.96 .84 89.64 184.81)" gradientUnits="userSpaceOnUse"><stop stop-color="#62d399" offset="0"/><stop stop-color="#acd842" offset=".51"/><stop stop-color="#d7db0a" offset=".9"/><stop stop-color="#d7db0a" offset="1"/></linearGradient> <linearGradient id="e" x2="1" gradientTransform="matrix(-1.6,-162.13,162.13,-1.6,69.68,178.9)" gradientUnits="userSpaceOnUse"><stop stop-color="#0ba398" offset="0"/><stop stop-color="#4ca352" offset=".5"/><stop stop-color="#76a30a" offset="1"/></linearGradient> <linearGradient id="d" x2="1" gradientTransform="matrix(-1.9,-67.98,67.98,-1.9,36.6,152.17)" gradientUnits="userSpaceOnUse"><stop stop-color="#36a382" offset="0"/><stop stop-color="#36a382" offset=".19"/><stop stop-color="#49a459" offset=".54"/><stop stop-color="#76a30b" offset="1"/></linearGradient> <linearGradient id="c" x2="1" gradientTransform="matrix(2.18,-62.38,62.38,2.18,15.82,153.24)" gradientUnits="userSpaceOnUse"><stop stop-color="#267880" offset="0"/><stop stop-color="#457a5c" offset=".51"/><stop stop-color="#717516" offset="1"/></linearGradient> <linearGradient id="b" x2="1" gradientTransform="matrix(13.85,-71.96,71.96,13.85,135.08,135.43)" gradientUnits="userSpaceOnUse"><stop stop-color="#b0d939" offset="0"/><stop stop-color="#eadb04" offset="1"/></linearGradient> <linearGradient id="a" x2="1" gradientTransform="matrix(26.159 -64.737 64.737 26.159 107.42 128.14)" gradientUnits="userSpaceOnUse"><stop stop-color="#74af52" offset="0"/><stop stop-color="#74af52" offset=".17"/><stop stop-color="#99be32" offset=".48"/><stop stop-color="#c0c40a" offset="1"/></linearGradient> </defs> </svg>`;
btoa(DC);
const LC = '<svg viewBox="0 0 509 154" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M665.95 132.73v44.88l-10.56-8.4c-.8-.64-1.2-1.44-1.2-2.4v-32.4c0-6.48-4.12-9.72-12.36-9.72-2.16 0-4.18.4-6.06 1.2-1.88.8-3.54 1.8-4.98 3-1.44 1.2-2.56 2.5-3.36 3.9-.8 1.4-1.2 2.7-1.2 3.9v40.92l-10.68-8.4c-.72-.64-1.08-1.44-1.08-2.4v-53.76l10.92 8.52c.32.24.56.44.72.6.16.16.36.32.6.48.96-1.2 2.14-2.28 3.54-3.24 1.4-.96 2.92-1.76 4.56-2.4 1.64-.64 3.34-1.14 5.1-1.5 1.76-.36 3.44-.54 5.04-.54 1.44 0 2.92.04 4.44.12 1.52.08 2.84.28 3.96.6 4.56 1.12 7.8 3.12 9.72 6 1.92 2.88 2.88 6.56 2.88 11.04ZM732.38 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14ZM795.93 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14ZM858.57 97.21c.64.48.96 1.16.96 2.04v74.88c-.08 1.04-.12 2.12-.12 3.24-1.84-1.52-3.56-2.92-5.16-4.2-1.36-1.12-2.66-2.18-3.9-3.18-1.24-1-2.06-1.66-2.46-1.98-1.76 2.48-4.26 4.44-7.5 5.88-3.24 1.44-7.02 2.16-11.34 2.16-3.84 0-7.4-.7-10.68-2.1-3.28-1.4-6.14-3.44-8.58-6.12-2.44-2.68-4.34-5.94-5.7-9.78-1.36-3.84-2.04-8.16-2.04-12.96 0-4.32.78-8.34 2.34-12.06 1.56-3.72 3.6-6.92 6.12-9.6 2.52-2.68 5.38-4.78 8.58-6.3 3.2-1.52 6.48-2.28 9.84-2.28 2.56 0 4.82.22 6.78.66 1.96.44 3.68 1.06 5.16 1.86s2.78 1.74 3.9 2.82a35.92 35.92 0 0 1 3.12 3.42V88.57l10.68 8.64Zm-27.96 67.92c3.6 0 6.52-.68 8.76-2.04 2.24-1.36 3.98-3.06 5.22-5.1a20.5 20.5 0 0 0 2.58-6.54c.48-2.32.72-4.44.72-6.36v-1.2c0-1.12-.22-2.7-.66-4.74-.44-2.04-1.28-4.06-2.52-6.06s-3-3.7-5.28-5.1c-2.28-1.4-5.22-2.02-8.82-1.86-3.44 0-6.26.74-8.46 2.22-2.2 1.48-3.96 3.26-5.28 5.34-1.32 2.08-2.24 4.2-2.76 6.36-.52 2.16-.78 3.92-.78 5.28 0 1.84.24 3.92.72 6.24.48 2.32 1.36 4.48 2.64 6.48s3.04 3.68 5.28 5.04c2.24 1.36 5.12 2.04 8.64 2.04ZM882.81 97.09c.64.48.96 1.12.96 1.92l-.12 41.04v37.08l-10.56-8.4c-.72-.64-1.08-1.44-1.08-2.4V88.45l10.8 8.64ZM950.36 146.05c0 .88.02 1.5.06 1.86.04.36-.02.98-.18 1.86h-7.08c-2.08 0-4.44-.02-7.08-.06-2.64-.04-5.36-.06-8.16-.06h-22.08c0 2.88.56 5.36 1.68 7.44 1.12 2.08 2.6 3.8 4.44 5.16 1.84 1.36 3.94 2.36 6.3 3 2.36.64 4.74.96 7.14.96 3.04 0 5.9-.76 8.58-2.28 2.68-1.52 4.94-3.52 6.78-6 .64.56 1.54 1.48 2.7 2.76 1.16 1.28 2.94 3.2 5.34 5.76-2.8 3.36-6.22 6.02-10.26 7.98-4.04 1.96-8.42 2.94-13.14 2.94-4.72 0-8.92-.64-12.84-1.92-3.92-1.28-7.32-3.24-10.2-5.88-2.88-2.64-5.12-5.98-6.72-10.02-1.6-4.04-2.4-8.82-2.4-14.34 0-4.96.66-9.42 1.98-13.38 1.32-3.96 3.22-7.32 5.7-10.08s5.44-4.9 8.88-6.42c3.44-1.52 7.32-2.28 11.64-2.28 5.76 0 10.52.88 14.28 2.64 3.76 1.76 6.72 4.16 8.88 7.2 2.16 3.04 3.66 6.54 4.5 10.5.84 3.96 1.26 8.18 1.26 12.66Zm-29.4-22.8c-2.16.16-4.16.72-6 1.68-1.84.96-3.42 2.2-4.74 3.72-1.32 1.52-2.36 3.28-3.12 5.28-.76 2-1.14 4.12-1.14 6.36h33.12c0-2-.22-4.06-.66-6.18-.44-2.12-1.3-4.02-2.58-5.7-1.28-1.68-3.1-3.02-5.46-4.02-2.36-1-5.5-1.38-9.42-1.14Z" style="fill-rule:nonzero" transform="translate(-452.406 -63.709) scale(1.00797)"/><path d="M79.32 36.98v150.76L95 174.54l6.59-156.31-22.27 18.75Z" style="fill:url(#a);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M79.32 36.98 57.05 18.23l6.59 156.31 15.68 13.2V36.98Z" style="fill:url(#b);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m25.19 104.83 8.63 49.04 12.5-14.95-2.46-56.42-18.67 22.33Z" style="fill:url(#c);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M25.19 104.83 0 90.24l16.97 53.86 16.85 9.77-8.63-49.04Z" style="fill:url(#d);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M43.86 82.5 18.69 67.98 0 90.24l25.18 14.59L43.86 82.5Z" style="fill:#9c3;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m134.82 78.69-9.97 56.5 15.58-9.04L160 64.1l-25.18 14.59Z" style="fill:url(#e);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m134.82 78.69-18.68-22.33-2.86 65 11.57 13.83 9.97-56.5Z" style="fill:url(#f);fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="m160 64.1-18.69-22.26-25.17 14.52 18.67 22.33L160 64.1Z" style="fill:#ffe113;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><path d="M101.59 18.23 79.32 0 57.05 18.23l22.27 18.75 22.27-18.75Z" style="fill:#f3e600;fill-rule:nonzero" transform="matrix(.80638 0 0 .80638 2.361 1.094)"/><defs><linearGradient id="a" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="matrix(.84 -162.96 162.96 .84 89.64 184.81)"><stop offset="0" style="stop-color:#62d399;stop-opacity:1"/><stop offset=".51" style="stop-color:#acd842;stop-opacity:1"/><stop offset=".9" style="stop-color:#d7db0a;stop-opacity:1"/><stop offset="1" style="stop-color:#d7db0a;stop-opacity:1"/></linearGradient><linearGradient id="b" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-90.565 123.412 54.953) scale(162.14)"><stop offset="0" style="stop-color:#0ba398;stop-opacity:1"/><stop offset=".5" style="stop-color:#4ca352;stop-opacity:1"/><stop offset="1" style="stop-color:#76a30a;stop-opacity:1"/></linearGradient><linearGradient id="c" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="scale(-68) rotate(88.4 .881 -1.396)"><stop offset="0" style="stop-color:#36a382;stop-opacity:1"/><stop offset=".19" style="stop-color:#36a382;stop-opacity:1"/><stop offset=".54" style="stop-color:#49a459;stop-opacity:1"/><stop offset="1" style="stop-color:#76a30b;stop-opacity:1"/></linearGradient><linearGradient id="d" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-88 87.255 68.431) scale(62.42)"><stop offset="0" style="stop-color:#267880;stop-opacity:1"/><stop offset=".51" style="stop-color:#457a5c;stop-opacity:1"/><stop offset="1" style="stop-color:#717516;stop-opacity:1"/></linearGradient><linearGradient id="e" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-79.1 149.53 -14.065) scale(73.28)"><stop offset="0" style="stop-color:#b0d939;stop-opacity:1"/><stop offset="1" style="stop-color:#eadb04;stop-opacity:1"/></linearGradient><linearGradient id="f" x1="0" y1="0" x2="1" y2="0" gradientUnits="userSpaceOnUse" gradientTransform="rotate(-67.997 148.705 -15.558) scale(69.8226)"><stop offset="0" style="stop-color:#74af52;stop-opacity:1"/><stop offset=".17" style="stop-color:#74af52;stop-opacity:1"/><stop offset=".48" style="stop-color:#99be32;stop-opacity:1"/><stop offset="1" style="stop-color:#c0c40a;stop-opacity:1"/></linearGradient></defs></svg>', jC = btoa(LC), BC = "data:image/svg+xml;charset=utf-8;base64," + jC, FC = BC, zC = x("debugpatch");
function _g(s, t, e, i) {
  const n = zC === t;
  if (!e && !i)
    return;
  const o = t + "___needle";
  UC(s, t, e, i);
  const a = Object.getOwnPropertyDescriptor(s, t), l = s[t];
  n && console.log("Patch", s.constructor.name, t, a, l), a ? (n && console.log("Apply patch with existing descriptor", s.constructor.name, t, a), typeof a.value == "function" && (s[t] = ay(a.value, s, t))) : (n && console.log("Create patch with new property", s.constructor.name, t, a), Object.defineProperty(s, t, {
    set: function(c) {
      if (typeof c == "function")
        this[o] = ay(c, s, t);
      else {
        const h = this[o];
        N0(s, t, this, h, c), this[o] = c, $0(s, t, this, h, c);
      }
    },
    get: function() {
      const c = this[o];
      return typeof c == "function" && c[o] ? c[o] : c;
    }
  }));
}
function yD(s, t, e) {
  const i = yg(s, t);
  if (i)
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      o.prefix === e && (o.prefix = null), o.postfix === e && (o.postfix = null), !o.prefix && !o.postfix && i.splice(n, 1);
    }
}
const ry = Symbol("Needle:Patches:WrappedFunction");
function ay(s, t, e) {
  if (s[ry])
    return s;
  const i = function(...n) {
    N0(t, e, this, ...n);
    const o = s.apply(this, n);
    return $0(t, e, this, o, ...n), o;
  };
  return i[ry] = !0, i;
}
const Df = "Needle:Patches";
function cm() {
  return globalThis[Df] || (globalThis[Df] = /* @__PURE__ */ new WeakMap()), globalThis[Df];
}
function yg(s, t) {
  const e = cm().get(s);
  return e ? e.get(t) : null;
}
function UC(s, t, e, i) {
  let n = cm().get(s);
  n || (n = /* @__PURE__ */ new Map(), cm().set(s, n));
  let o = n.get(t);
  o || (o = [], n.set(t, o)), o.push({
    prefix: e,
    postfix: i
  });
}
function N0(s, t, e, ...i) {
  var o;
  if (!e)
    return;
  const n = yg(s, t);
  if (n)
    for (const a of n)
      (o = a.prefix) == null || o.call(e, ...i);
}
function $0(s, t, e, i, ...n) {
  var a;
  if (!e)
    return;
  const o = yg(s, t);
  if (o)
    for (const l of o)
      (a = l.postfix) == null || a.call(e, i, ...n);
}
const za = [];
function bg(s) {
  za.indexOf(s) === -1 && za.push(s);
}
function bD(s) {
  const t = za.indexOf(s);
  t !== -1 && za.splice(t, 1);
}
const Ua = [];
function W0(s) {
  Ua.indexOf(s) === -1 && Ua.push(s);
}
function vD(s) {
  const t = Ua.indexOf(s);
  t !== -1 && Ua.splice(t, 1);
}
function NC(s) {
  globalThis.dispatchEvent(new CustomEvent("needle-xrsession-start", { detail: s }));
  for (let t = 0; t < za.length; t++)
    za[t](s);
}
function $C(s) {
  globalThis.dispatchEvent(new CustomEvent("needle-xrsession-end", { detail: s }));
  for (let t = 0; t < Ua.length; t++)
    Ua[t](s);
}
const lt = x("debuginput");
var vg = /* @__PURE__ */ ((s) => (s.Mouse = "mouse", s.Touch = "touch", s.Controller = "controller", s.Hand = "hand", s))(vg || {}), Ne = /* @__PURE__ */ ((s) => (s.PointerDown = "pointerdown", s.PointerUp = "pointerup", s.PointerMove = "pointermove", s.KeyDown = "keydown", s.KeyUp = "keyup", s.KeyPressed = "keypress", s))(Ne || {});
class Ys extends PointerEvent {
  constructor(e, i, n) {
    super(e, n);
    /**
     * Spatial input data
     */
    r(this, "clientZ");
    /** the device index: mouse and touch are always 0, otherwise e.g. index of the connected Gamepad or XRController */
    r(this, "deviceIndex");
    /** The origin of the event contains a reference to the creator of this event.   
     * This can be the Needle Engine input system or e.g. a XR controller.  
     * Implement `onPointerHits` to receive the intersections of this event.
     */
    r(this, "origin");
    /** the browser event that triggered this event (if any) */
    r(this, "source");
    /** Is the pointer event created via a touch on screen or a spatial device like a XR controller or hand tracking? */
    r(this, "mode");
    r(this, "_ray");
    /** The device space (this object is not necessarily rendered in the scene but you can access or copy the matrix)   
     * E.g. you can access the input world space source position with `space.worldPosition` or world direction with `space.worldForward`
    */
    r(this, "space");
    /** true if this event is a click */
    r(this, "isClick", !1);
    /** true if this event is a double click */
    r(this, "isDoubleClick", !1);
    r(this, "_used", !1);
    r(this, "_pointerid");
    r(this, "_pointerType");
    r(this, "_type");
    /** metadata can be used to associate additional information with the event */
    r(this, "metadata", {});
    /** intersections that were generated from this event (or are associated with this event in any way) */
    r(this, "intersections", new Array());
    r(this, "_immediatePropagationStopped", !1);
    r(this, "_propagationStopped", !1);
    this.clientZ = n.clientZ, this._pointerid = n.pointerId, this._pointerType = n.pointerType, this._type = e, this.deviceIndex = n.deviceIndex, this.origin = n.origin, this.source = i, this.mode = n.mode, this._ray = n.ray, this.space = n.device;
  }
  /** Returns true if the input was emitted in 3D space (and not by e.g. clicking on a 2D screen). You can use {@link mode} if you need more information about the input source */
  get isSpatial() {
    return this.mode != "screen";
  }
  /** A ray in worldspace for the event.    
   * If the ray is undefined you can also use `space.worldForward` and `space.worldPosition` */
  get ray() {
    return this._ray || (this._ray = new wo(this.space.worldPosition.clone(), this.space.worldForward.clone())), this._ray;
  }
  set ray(e) {
    this._ray = e;
  }
  /**@returns true if this event has a ray. If you access the ray property a ray will automatically created */
  get hasRay() {
    return this._ray !== void 0;
  }
  /** @returns `true` if the event is marked to be used (when `use()` has been called). Default: `false` */
  get used() {
    return this._used;
  }
  /** Call to mark an event to be used */
  use() {
    this._used = !0;
  }
  /** Unique identifier for this input: a combination of the deviceIndex + button to uniquely identify the exact input (e.g. LeftController:Button0 = 0, RightController:Button1 = 11) */
  get pointerId() {
    return this._pointerid;
  }
  // this is set via the init arguments (we override it here for intellisense to show the string options)
  /** What type of input created this event: touch, mouse, xr controller, xr hand tracking... */
  get pointerType() {
    return this._pointerType;
  }
  // this is set via the init arguments (we override it here for intellisense to show the string options)
  /** The input that raised this event like `pointerdown` */
  get type() {
    return this._type;
  }
  get immediatePropagationStopped() {
    return this._immediatePropagationStopped;
  }
  get propagationStopped() {
    return this._immediatePropagationStopped || this._propagationStopped;
  }
  stopImmediatePropagation() {
    var e;
    this._immediatePropagationStopped = !0, super.stopImmediatePropagation(), (e = this.source) == null || e.stopImmediatePropagation();
  }
  stopPropagation() {
    var e;
    this._propagationStopped = !0, super.stopPropagation(), (e = this.source) == null || e.stopPropagation(), lt && console.warn("Stop propagation...", this.pointerId, this.pointerType);
  }
}
class kh extends KeyboardEvent {
  constructor(e, i, n) {
    super(e, n);
    r(this, "source");
    this.source = i;
  }
  stopImmediatePropagation() {
    var e;
    super.stopImmediatePropagation(), (e = this.source) == null || e.stopImmediatePropagation();
  }
}
class wD {
  constructor(t) {
    r(this, "key");
    r(this, "keyType");
    r(this, "source");
    this.key = t.key, this.keyType = t.type, this.source = t;
  }
}
var vi = /* @__PURE__ */ ((s) => (s[s.Early = -100] = "Early", s[s.Default = 0] = "Default", s[s.Late = 100] = "Late", s))(vi || {});
class WC {
  /** @internal */
  constructor(t) {
    /** This is a list of event listeners per event type (e.g. pointerdown, pointerup, keydown...). Each entry contains a priority and list of listeners.  
     * That way users can control if they want to receive events before or after other listeners (e.g subscribe to pointer events before the EventSystem receives them) - this allows certain listeners to be always invoked first (or last) and stop propagation  
     * Listeners per event are sorted
     */
    r(this, "_eventListeners", {});
    r(this, "_doubleClickTimeThreshold", 0.2);
    r(this, "_longPressTimeThreshold", 1);
    r(this, "_setCursorTypes", []);
    r(this, "context");
    r(this, "_pointerDown", [!1]);
    r(this, "_pointerUp", [!1]);
    r(this, "_pointerClick", [!1]);
    r(this, "_pointerDoubleClick", [!1]);
    r(this, "_pointerPressed", [!1]);
    r(this, "_pointerPositions", [new oe()]);
    r(this, "_pointerPositionsLastFrame", [new oe()]);
    r(this, "_pointerPositionsDelta", [new oe()]);
    r(this, "_pointerPositionsRC", [new oe()]);
    r(this, "_pointerPositionDown", [new v()]);
    r(this, "_pointerDownTime", []);
    r(this, "_pointerUpTime", []);
    r(this, "_pointerUpTimestamp", []);
    r(this, "_pointerIds", []);
    r(this, "_pointerTypes", [""]);
    r(this, "_mouseWheelChanged", [!1]);
    r(this, "_mouseWheelDeltaY", [0]);
    r(this, "_pointerEvent", []);
    /** current pressed pointer events. Used to check if any of those events was used  */
    r(this, "_pointerEventsPressed", []);
    /** This is added/updated for pointers. screenspace pointers set this to the camera near plane  */
    r(this, "_pointerSpace", []);
    r(this, "_pressedStack", /* @__PURE__ */ new Map());
    /** this is the html element we subscribed to for events */
    r(this, "_htmlEventSource");
    r(this, "onLostFocus", () => {
      for (const t in this.keysPressed)
        this.keysPressed[t].pressed = !1;
    });
    r(this, "_receivedPointerMoveEventsThisFrame", new Array());
    r(this, "onEndOfFrame", () => {
      this._receivedPointerMoveEventsThisFrame.length = 0;
      for (let t = 0; t < this._pointerUp.length; t++)
        this._pointerUp[t] = !1;
      for (let t = 0; t < this._pointerDown.length; t++)
        this._pointerDown[t] = !1;
      for (let t = 0; t < this._pointerClick.length; t++)
        this._pointerClick[t] = !1;
      for (let t = 0; t < this._pointerDoubleClick.length; t++)
        this._pointerDoubleClick[t] = !1;
      for (const t of this._pointerPositionsDelta)
        t.set(0, 0);
      for (let t = 0; t < this._mouseWheelChanged.length; t++)
        this._mouseWheelChanged[t] = !1;
      for (let t = 0; t < this._mouseWheelDeltaY.length; t++)
        this._mouseWheelDeltaY[t] = 0;
    });
    r(this, "onContextMenu", (t) => {
      this.canReceiveInput(t) !== !1 && t instanceof PointerEvent && t.pointerType;
    });
    r(this, "keysPressed", {});
    r(this, "onKeyDown", (t) => {
      if (lt && console.log(`key down ${t.code}, ${this.context.application.hasFocus}`, t), !this.context.application.hasFocus)
        return;
      const e = this.keysPressed[t.code];
      if (e && e.pressed)
        return;
      this.keysPressed[t.code] = { pressed: !0, frame: this.context.time.frameCount + 1, startFrame: this.context.time.frameCount + 1, key: t.key, code: t.code };
      const i = new kh("keydown", t, t);
      this.onDispatchEvent(i);
    });
    r(this, "onKeyPressed", (t) => {
      if (!this.context.application.hasFocus)
        return;
      const e = this.keysPressed[t.code];
      if (!e)
        return;
      e.pressed = !0, e.frame = this.context.time.frameCount + 1;
      const i = new kh("keypress", t, t);
      this.onDispatchEvent(i);
    });
    r(this, "onKeyUp", (t) => {
      if (!this.context.application.hasFocus)
        return;
      const e = this.keysPressed[t.code];
      if (!e)
        return;
      e.pressed = !1, e.frame = this.context.time.frameCount + 1;
      const i = new kh("keyup", t, t);
      this.onDispatchEvent(i);
    });
    r(this, "onWheelWindow", (t) => {
      document.pointerLockElement && this.onMouseWheel(t);
    });
    r(this, "onMouseWheel", (t) => {
      if (this.canReceiveInput(t) === !1)
        return;
      this._mouseWheelDeltaY.length <= 0 && this._mouseWheelDeltaY.push(0), this._mouseWheelChanged.length <= 0 && this._mouseWheelChanged.push(!1), this._mouseWheelChanged[0] = !0;
      const e = this._mouseWheelDeltaY[0];
      this._mouseWheelDeltaY[0] = e + t.deltaY;
    });
    r(this, "onPointerDown", (t) => {
      if (this.context.isInAR || this.canReceiveInput(t) === !1)
        return;
      t.target instanceof HTMLElement && t.target.setPointerCapture(t.pointerId);
      const e = this.getPointerId(t);
      lt && We(`pointer down #${e}, identifier:${t.pointerId}`);
      const i = this.getAndUpdateSpatialObjectForScreenPosition(e, t.clientX, t.clientY), n = new Ys("pointerdown", t, { origin: this, mode: "screen", deviceIndex: 0, pointerId: e, button: t.button, clientX: t.clientX, clientY: t.clientY, pointerType: t.pointerType, buttonName: this.getButtonName(t), device: i, pressure: t.pressure });
      this.onDown(n);
    });
    r(this, "onPointerMove", (t) => {
      if (this.context.isInAR || this._receivedPointerMoveEventsThisFrame.includes(t.pointerId))
        return;
      this._receivedPointerMoveEventsThisFrame.push(t.pointerId);
      let e = t.button;
      t.pointerType === "mouse" && (e = this.getFirstPressedButtonForPointer(0) ?? 0);
      const i = this.getPointerId(t, e);
      e === -1 && (e = i);
      const n = this.getAndUpdateSpatialObjectForScreenPosition(i, t.clientX, t.clientY), o = new Ys("pointermove", t, { origin: this, mode: "screen", deviceIndex: 0, pointerId: i, button: e, clientX: t.clientX, clientY: t.clientY, pointerType: t.pointerType, buttonName: this.getButtonName(t), device: n, pressure: t.pressure });
      this.onMove(o);
    });
    r(this, "onPointerCancel", (t) => {
      this.context.isInAR || (lt && console.log("Pointer cancel", t), this.onPointerUp(t));
    });
    r(this, "onPointerUp", (t) => {
      if (this.context.isInAR)
        return;
      t.target instanceof HTMLElement && t.target.releasePointerCapture(t.pointerId);
      const e = this.getPointerId(t), i = new Ys("pointerup", t, { origin: this, mode: "screen", deviceIndex: 0, pointerId: e, button: t.button, clientX: t.clientX, clientY: t.clientY, pointerType: t.pointerType, buttonName: this.getButtonName(t), device: this.getAndUpdateSpatialObjectForScreenPosition(e, t.clientX, t.clientY), pressure: t.pressure });
      this.onUp(i), this._pointerIds[e] = -1, lt && console.log("ID=" + e, "PointerId=" + t.pointerId, "ALL:", [...this._pointerIds]);
    });
    // the touch events are currently only used for AR support on android
    r(this, "onTouchStart", (t) => {
      if (this.context.isInAR)
        for (let e = 0; e < t.changedTouches.length; e++) {
          const i = t.changedTouches[e], n = this.getPointerIndex(i.identifier), o = this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), a = new Ys("pointerdown", t, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: o, pressure: i.force });
          this.onDown(a);
        }
    });
    r(this, "onTouchMove", (t) => {
      if (this.context.isInAR)
        for (let e = 0; e < t.changedTouches.length; e++) {
          const i = t.changedTouches[e], n = this.getPointerIndex(i.identifier), o = this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), a = new Ys("pointermove", t, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: o, pressure: i.force });
          this.onMove(a);
        }
    });
    r(this, "onTouchEnd", (t) => {
      if (this.context.isInAR)
        for (let e = 0; e < t.changedTouches.length; e++) {
          const i = t.changedTouches[e], n = this.getPointerIndex(i.identifier), o = new Ys("pointerup", t, { origin: this, mode: "screen", deviceIndex: 0, pointerId: n, button: 0, clientX: i.clientX, clientY: i.clientY, pointerType: "touch", buttonName: "unknown", device: this.getAndUpdateSpatialObjectForScreenPosition(n, i.clientX, i.clientY), pressure: i.force });
          this.onUp(o), this._pointerIds[n] = -1;
        }
    });
    r(this, "tempNearPlaneVector", new v());
    r(this, "tempFarPlaneVector", new v());
    r(this, "tempLookMatrix", new se());
    this.context = t, this.context.post_render_callbacks.push(this.onEndOfFrame);
  }
  addEventListener(t, e, i) {
    if (this._eventListeners[t] || (this._eventListeners[t] = []), !e || typeof e != "function") {
      console.error("Invalid call to addEventListener: callback is required and must be a function!");
      return;
    }
    i ? i = { ...i } : i = {};
    let n = 0;
    (i == null ? void 0 : i.queue) != null && (n = i.queue);
    const o = this._eventListeners[t], a = o.find((l) => l.priority === n);
    a ? a.listeners.push({ callback: e, options: i }) : (o.push({ priority: n, listeners: [{ callback: e, options: i }] }), o.sort((l, c) => l.priority - c.priority));
  }
  removeEventListener(t, e, i) {
    if (!this._eventListeners[t] || !e)
      return;
    const n = this._eventListeners[t];
    if ((i == null ? void 0 : i.queue) != null) {
      const o = n.find((l) => l.priority === i.queue);
      if (!o)
        return;
      const a = o.listeners.findIndex((l) => l.callback === e);
      a >= 0 && o.listeners.splice(a, 1);
    } else
      for (const o of n) {
        const a = o.listeners.findIndex((l) => l.callback === e);
        a >= 0 && o.listeners.splice(a, 1);
      }
  }
  dispatchEvent(t) {
    var i, n, o, a;
    let e = !1;
    if (t instanceof kh) {
      const l = this._eventListeners[t.type];
      if (l)
        for (const c of l)
          for (let h = 0; h < c.listeners.length; h++) {
            const d = c.listeners[h];
            if ((n = (i = d.options) == null ? void 0 : i.signal) != null && n.aborted) {
              c.listeners.splice(h, 1), h--;
              continue;
            }
            d.options.once && (c.listeners.splice(h, 1), h--), d.callback(t);
          }
    }
    if (t instanceof Ys) {
      const l = this._eventListeners[t.type];
      if (l)
        for (const c of l) {
          if (e)
            break;
          for (let h = 0; h < c.listeners.length; h++) {
            const d = c.listeners[h];
            if ((a = (o = d.options) == null ? void 0 : o.signal) != null && a.aborted) {
              c.listeners.splice(h, 1), h--;
              continue;
            }
            if (t.immediatePropagationStopped) {
              e = !0, lt && console.log("immediatePropagationStopped", t.type);
              break;
            } else
              t.propagationStopped && (e = !0, lt && console.log("propagationStopped", t.type));
            d.options.once && (c.listeners.splice(h, 1), h--), d.callback(t);
          }
        }
    }
  }
  get mousePosition() {
    return this._pointerPositions[0];
  }
  get mousePositionRC() {
    return this._pointerPositionsRC[0];
  }
  get mouseDown() {
    return this._pointerDown[0];
  }
  get mouseUp() {
    return this._pointerUp[0];
  }
  /** Is the primary pointer clicked (usually the left button). This is equivalent to `input.click` */
  get mouseClick() {
    return this._pointerClick[0];
  }
  /** Was a double click detected for the primary pointer? This is equivalent to `input.doubleClick` */
  get mouseDoubleClick() {
    return this._pointerDoubleClick[0];
  }
  get mousePressed() {
    return this._pointerPressed[0];
  }
  get mouseWheelChanged() {
    return this.getMouseWheelChanged(0);
  }
  /** Is the primary pointer double clicked (usually the left button). This is equivalent to `input.mouseDoubleClick` */
  get click() {
    return this._pointerClick[0];
  }
  /** Was a double click detected for the primary pointer? */
  get doubleClick() {
    return this._pointerDoubleClick[0];
  }
  /**
   * Get a connected Gamepad    
   * Note: For a gamepad to be available to the browser it must have received input before while the page was focused.  
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API
   * @returns The gamepad or null if no gamepad is connected
   */
  getGamepad(t = 0) {
    return typeof navigator < "u" && "getGamepads" in navigator && navigator.getGamepads()[t] || null;
  }
  /** @deprecated use setCursor("pointer") */
  setCursorPointer() {
    this.setCursor("pointer");
  }
  /** @deprecated use unsetCursor() */
  setCursorNormal() {
    this.unsetCursor("pointer");
  }
  /**
   * Set a custom cursor. This will set the cursor type until unsetCursor is called
   */
  setCursor(t) {
    this._setCursorTypes.push(t), this._setCursorTypes.length > 10 && this._setCursorTypes.shift(), this.updateCursor();
  }
  /**
   * Unset a custom cursor. This will set the cursor type to the previous type or default
   */
  unsetCursor(t) {
    for (let e = this._setCursorTypes.length - 1; e >= 0; e--)
      if (this._setCursorTypes[e] === t) {
        this._setCursorTypes.splice(e, 1), this.updateCursor();
        break;
      }
  }
  updateCursor() {
    var t;
    ((t = this._setCursorTypes) == null ? void 0 : t.length) == 0 ? this.context.domElement.style.cursor = "default" : this.context.domElement.style.cursor = this._setCursorTypes[this._setCursorTypes.length - 1];
  }
  /**
   * Check if a pointer id is currently used.
   */
  getIsPointerIdInUse(t) {
    for (const e of this._pointerEventsPressed)
      if (e.pointerId === t && e.used)
        return !0;
    return !1;
  }
  /** how many pointers are currently pressed */
  getPointerPressedCount() {
    let t = 0;
    for (let e = 0; e < this._pointerPressed.length; e++)
      this._pointerPressed[e] && t++;
    return t;
  }
  /**
   * Gets the position of the given pointer index in pixel
   * @param i The pointer index
   * @returns The position of the pointer in pixel
   */
  getPointerPosition(t) {
    return t >= this._pointerPositions.length ? null : this._pointerPositions[t];
  }
  getPointerPositionLastFrame(t) {
    return t >= this._pointerPositionsLastFrame.length ? null : this._pointerPositionsLastFrame[t];
  }
  getPointerPositionDelta(t) {
    return t >= this._pointerPositionsDelta.length ? null : this._pointerPositionsDelta[t];
  }
  /**
   * The pointer position in screenspace coordinates (-1 to 1) where 0 is the center of the screen.  
   * This can be useful for e.g. raycasting (see https://threejs.org/docs/#api/en/core/Raycaster.setFromCamera)
   */
  getPointerPositionRC(t) {
    return t >= this._pointerPositionsRC.length ? null : this._pointerPositionsRC[t];
  }
  getPointerDown(t) {
    return t >= this._pointerDown.length ? !1 : this._pointerDown[t];
  }
  getPointerUp(t) {
    return t >= this._pointerUp.length ? !1 : this._pointerUp[t];
  }
  getPointerPressed(t) {
    return t >= this._pointerPressed.length ? !1 : this._pointerPressed[t];
  }
  getPointerClicked(t) {
    return t >= this._pointerClick.length ? !1 : this._pointerClick[t];
  }
  getPointerDoubleClicked(t) {
    return t >= this._pointerDoubleClick.length ? !1 : this._pointerDoubleClick[t];
  }
  getPointerDownTime(t) {
    return t >= this._pointerDownTime.length ? -1 : this._pointerDownTime[t];
  }
  getPointerUpTime(t) {
    return t >= this._pointerUpTime.length ? -1 : this._pointerUpTime[t];
  }
  getPointerLongPress(t) {
    return t >= this._pointerDownTime.length ? !1 : this.getPointerPressed(t) && this.context.time.time - this._pointerDownTime[t] > this._longPressTimeThreshold;
  }
  getIsMouse(t) {
    return t < 0 || t >= this._pointerTypes.length ? !1 : this._pointerTypes[t] === "mouse";
  }
  getIsTouch(t) {
    return t < 0 || t >= this._pointerTypes.length ? !1 : this._pointerTypes[t] === "touch";
  }
  getTouchesPressedCount() {
    let t = 0;
    for (let e = 0; e < this._pointerPressed.length; e++)
      this._pointerPressed[e] && this.getIsTouch(e) && t++;
    return t;
  }
  getMouseWheelChanged(t = 0) {
    return t >= this._mouseWheelChanged.length ? !1 : this._mouseWheelChanged[t];
  }
  getMouseWheelDeltaY(t = 0) {
    return t >= this._mouseWheelDeltaY.length ? 0 : this._mouseWheelDeltaY[t];
  }
  getPointerEvent(t) {
    if (!(t >= this._pointerEvent.length))
      return this._pointerEvent[t] ?? void 0;
  }
  *foreachPointerId(t) {
    for (let e = 0; e < this._pointerTypes.length; e++)
      if (this._pointerIsActive(e)) {
        if (t !== void 0) {
          const i = this._pointerTypes[e];
          if (Array.isArray(t)) {
            let n = !1;
            for (const o of t)
              if (i === o) {
                n = !0;
                break;
              }
            if (!n)
              continue;
          } else if (t !== i)
            continue;
        }
        yield e;
      }
  }
  *foreachTouchId() {
    for (let t = 0; t < this._pointerTypes.length; t++)
      this._pointerTypes[t] === "touch" && this._pointerIsActive[t] && (yield t);
  }
  _pointerIsActive(t) {
    return t < 0 ? !1 : this._pointerPressed[t] || this._pointerDown[t] || this._pointerUp[t];
  }
  onDownButton(t, e) {
    let i = this._pressedStack.get(t);
    i || (i = [], this._pressedStack.set(t, i)), i.push(e);
  }
  onReleaseButton(t, e) {
    const i = this._pressedStack.get(t);
    if (!i)
      return;
    const n = i.indexOf(e);
    n >= 0 && i.splice(n, 1);
  }
  /** the first button that was down and is currently pressed */
  getFirstPressedButtonForPointer(t) {
    const e = this._pressedStack.get(t);
    if (e)
      return e[0];
  }
  /** the last (most recent) button that was down and is currently pressed */
  getLatestPressedButtonForPointer(t) {
    const e = this._pressedStack.get(t);
    if (e)
      return e[e.length - 1];
  }
  getKeyDown() {
    for (const t in this.keysPressed) {
      const e = this.keysPressed[t];
      if (e.startFrame === this.context.time.frameCount)
        return e.key;
    }
    return null;
  }
  getKeyPressed() {
    for (const t in this.keysPressed) {
      const e = this.keysPressed[t];
      if (e.pressed)
        return e.key;
    }
    return null;
  }
  isKeyDown(t) {
    var i;
    if (!this.context.application.isVisible || !this.context.application.hasFocus)
      return !1;
    const e = this.getCodeForCommonKeyName(t);
    if (e !== null) {
      for (const n of e)
        if (this.isKeyDown(n))
          return !0;
      return !1;
    }
    return ((i = this.keysPressed[t]) == null ? void 0 : i.startFrame) === this.context.time.frameCount && this.keysPressed[t].pressed;
  }
  isKeyUp(t) {
    var i;
    if (!this.context.application.isVisible || !this.context.application.hasFocus)
      return !1;
    const e = this.getCodeForCommonKeyName(t);
    if (e !== null) {
      for (const n of e)
        if (this.isKeyUp(n))
          return !0;
      return !1;
    }
    return ((i = this.keysPressed[t]) == null ? void 0 : i.frame) === this.context.time.frameCount && !this.keysPressed[t].pressed;
  }
  isKeyPressed(t) {
    var i;
    if (!this.context.application.isVisible || !this.context.application.hasFocus)
      return !1;
    const e = this.getCodeForCommonKeyName(t);
    if (e !== null) {
      for (const n of e)
        if (this.isKeyPressed(n))
          return !0;
      return !1;
    }
    return (i = this.keysPressed[t]) == null ? void 0 : i.pressed;
  }
  // utility helper for mapping common names to actual codes; e.g. "Shift" -> "ShiftLeft" and "ShiftRight" or "a" -> "KeyA"
  getCodeForCommonKeyName(t) {
    if (t.length === 1) {
      if (t >= "0" && t <= "9")
        return ["Digit" + t];
      if (t >= "a" && t <= "z")
        return ["Key" + t.toUpperCase()];
      if (t == " ")
        return ["Space"];
    }
    switch (t) {
      case "shift":
      case "Shift":
        return ["ShiftLeft", "ShiftRight"];
      case "control":
      case "Control":
        return ["ControlLeft", "ControlRight"];
      case "alt":
      case "Alt":
        return ["AltLeft", "AltRight"];
    }
    return null;
  }
  createInputEvent(t) {
    switch (t.type) {
      case "pointerdown":
        lt && We("Create Pointer down"), this.onDownButton(t.deviceIndex, t.button), this.onDown(t);
        break;
      case "pointermove":
        lt && We("Create Pointer move"), this.onMove(t);
        break;
      case "pointerup":
        lt && We("Create Pointer up"), this.onUp(t), this.onReleaseButton(t.deviceIndex, t.button);
        break;
    }
  }
  convertScreenspaceToRaycastSpace(t) {
    return t.x = (t.x - this.context.domX) / this.context.domWidth * 2 - 1, t.y = -((t.y - this.context.domY) / this.context.domHeight) * 2 + 1, t;
  }
  bindEvents() {
    this.unbindEvents(), this._htmlEventSource = this.context.renderer.domElement, window.addEventListener("contextmenu", this.onContextMenu), this._htmlEventSource.addEventListener("pointerdown", this.onPointerDown, { passive: !0 }), window.addEventListener("pointermove", this.onPointerMove, { passive: !0, capture: !0 }), window.addEventListener("pointerup", this.onPointerUp, { passive: !0 }), window.addEventListener("pointercancel", this.onPointerCancel, { passive: !0 }), window.addEventListener("touchstart", this.onTouchStart, { passive: !0 }), window.addEventListener("touchmove", this.onTouchMove, { passive: !0 }), window.addEventListener("touchend", this.onTouchEnd, { passive: !0 }), this._htmlEventSource.addEventListener("wheel", this.onMouseWheel, { passive: !0 }), window.addEventListener("wheel", this.onWheelWindow, { passive: !0 }), window.addEventListener("keydown", this.onKeyDown, !1), window.addEventListener("keypress", this.onKeyPressed, !1), window.addEventListener("keyup", this.onKeyUp, !1), window.addEventListener("blur", this.onLostFocus);
  }
  unbindEvents() {
    var t, e;
    window.removeEventListener("contextmenu", this.onContextMenu), (t = this._htmlEventSource) == null || t.removeEventListener("pointerdown", this.onPointerDown), window.removeEventListener("pointermove", this.onPointerMove), window.removeEventListener("pointerup", this.onPointerUp), window.removeEventListener("pointercancel", this.onPointerCancel), window.removeEventListener("touchstart", this.onTouchStart), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd), (e = this._htmlEventSource) == null || e.removeEventListener("wheel", this.onMouseWheel, !1), window.removeEventListener("wheel", this.onWheelWindow, !1), window.removeEventListener("keydown", this.onKeyDown, !1), window.removeEventListener("keypress", this.onKeyPressed, !1), window.removeEventListener("keyup", this.onKeyUp, !1), window.removeEventListener("blur", this.onLostFocus);
  }
  dispose() {
    const t = this.context.post_render_callbacks.indexOf(this.onEndOfFrame);
    t >= 0 && this.context.post_render_callbacks.splice(t, 1), this.unbindEvents();
  }
  canReceiveInput(t) {
    var e;
    return t.target === ((e = this.context.renderer) == null ? void 0 : e.domElement) || t.target === this.context.domElement || this.context.isInAR || this.context.isInAR && t.target === document.body && X.isMozillaXR() ? !0 : (lt && console.warn("CanReceiveInput:False for", t.target), !1);
  }
  getPointerId(t, e) {
    return t.pointerType === "mouse" ? 0 + (e ?? t.button) : this.getPointerIndex(t.pointerId);
  }
  getButtonName(t) {
    const e = t.button;
    if (t.pointerType === "mouse")
      switch (e) {
        case 0:
          return "left";
        case 1:
          return "middle";
        case 2:
          return "right";
      }
    return "unknown";
  }
  getAndUpdateSpatialObjectForScreenPosition(t, e, i) {
    let n = this._pointerSpace[t];
    n || (n = new L(), this._pointerSpace[t] = n), this._pointerSpace[t] = n;
    const o = this.context.mainCamera;
    if (o) {
      const a = this.tempNearPlaneVector.set(e, i, -1);
      this.convertScreenspaceToRaycastSpace(a);
      const l = this.tempFarPlaneVector.set(a.x, a.y, 1);
      a.unproject(o), l.unproject(o);
      const c = o.worldUp || G(0, 1, 0).applyQuaternion(Ce(o));
      this.tempLookMatrix.lookAt(l, a, c), n.position.set(a.x, a.y, a.z), n.quaternion.setFromRotationMatrix(this.tempLookMatrix);
    }
    return n;
  }
  // Prevent the same event being handled twice (e.g. on touch we get a mouseUp and touchUp evt with the same timestamp)
  // private isNewEvent(timestamp: number, index: number, arr: number[]): boolean {
  //     while (arr.length <= index) arr.push(-1);
  //     if (timestamp === arr[index]) return false;
  //     arr[index] = timestamp;
  //     return true;
  // }
  isInRect(t) {
    if (this.context.isInXR)
      return !0;
    const e = this.context.domElement.getBoundingClientRect(), i = t.clientX, n = t.clientY, o = i >= e.x && i <= e.right && n >= e.y && n <= e.bottom;
    return lt && !o && console.log("Not in rect", e, i, n), o;
  }
  onDown(t) {
    const e = t.pointerId;
    if (this.getPointerPressed(e) && console.warn(`Received pointerDown for pointerId that is already pressed: ${e}`, lt ? t : ""), lt && console.log(t.pointerType, "DOWN", e), !!this.isInRect(t)) {
      for (this.setPointerState(e, this._pointerPressed, !0), this.setPointerState(e, this._pointerDown, !0), this.setPointerStateT(e, this._pointerEvent, t.source); e >= this._pointerTypes.length; )
        this._pointerTypes.push(t.pointerType);
      for (this._pointerTypes[e] = t.pointerType; e >= this._pointerPositionDown.length; )
        this._pointerPositionDown.push(new v());
      for (this._pointerPositionDown[e].set(t.clientX, t.clientY, t.clientZ ?? 0); e >= this._pointerPositions.length; )
        this._pointerPositions.push(new oe());
      this._pointerPositions[e].set(t.clientX, t.clientY), e >= this._pointerDownTime.length && this._pointerDownTime.push(0), this._pointerDownTime[e] = this.context.time.realtimeSinceStartup, this.updatePointerPosition(t), this._pointerEventsPressed.push(t), this.onDispatchEvent(t);
    }
  }
  // moveEvent?: Event;
  onMove(t) {
    const e = t.pointerId, i = this.getPointerPressed(e);
    i === !1 && !this.isInRect(t) || t.pointerType === "touch" && !i || (this.updatePointerPosition(t), this.setPointerStateT(e, this._pointerEvent, t.source), this.onDispatchEvent(t));
  }
  onUp(t) {
    const e = t.pointerId;
    if (!this.getPointerPressed(e)) {
      lt && console.log(t.pointerType, "UP", e, "was not down");
      return;
    }
    lt && console.log(t.pointerType, "UP", e), this.setPointerState(e, this._pointerPressed, !1), this.setPointerStateT(e, this._pointerEvent, t.source), this.setPointerState(e, this._pointerUp, !0), this.updatePointerPosition(t);
    for (let c = this._pointerEventsPressed.length - 1; c >= 0; c--)
      if (this._pointerEventsPressed[c].pointerId === e) {
        this._pointerEventsPressed.splice(c, 1);
        break;
      }
    if (!this._pointerPositionDown[e]) {
      lt && ve("Received pointer up event without matching down event for button: " + e), console.warn("Received pointer up event without matching down event for button: " + e);
      return;
    }
    const n = this._pointerUpTime[e], o = this._pointerDownTime[e], a = this.context.time.realtimeSinceStartup, l = a - o;
    if (e >= this._pointerUpTime.length && this._pointerUpTime.push(-99), this._pointerUpTime[e] = a, l < 1) {
      let c = t.clientX - this._pointerPositionDown[e].x, h = t.clientY - this._pointerPositionDown[e].y, d = 0;
      if (t.isSpatial && t.clientZ != null && (d = t.clientZ - this._pointerPositionDown[e].z, c *= 200, h *= 200, d *= 200), Math.abs(c) < 5 && Math.abs(h) < 5 && Math.abs(d) < 5) {
        this.setPointerState(e, this._pointerClick, !0), t.isClick = !0;
        const u = a - n;
        lt && console.log("CLICK", e, c, h, d, u), u < this._doubleClickTimeThreshold && u > 0 && (this.setPointerState(e, this._pointerDoubleClick, !0), t.isDoubleClick = !0);
      }
    }
    this.onDispatchEvent(t);
  }
  updatePointerPosition(t) {
    const e = t.pointerId;
    for (; e >= this._pointerPositions.length; )
      this._pointerPositions.push(new oe());
    for (; e >= this._pointerPositionsLastFrame.length; )
      this._pointerPositionsLastFrame.push(new oe());
    for (; e >= this._pointerPositionsDelta.length; )
      this._pointerPositionsDelta.push(new oe());
    const i = this._pointerPositionsLastFrame[e];
    i.copy(this._pointerPositions[e]);
    const n = this._pointerPositionsDelta[e];
    let o = t.clientX - i.x, a = t.clientY - i.y;
    if (t.source instanceof MouseEvent || t.source instanceof TouchEvent) {
      const d = t.source;
      o === 0 && d.movementX !== 0 && (o = d.movementX || 0), a === 0 && d.movementY !== 0 && (a = d.movementY || 0);
    }
    n.x += o, n.y += a, this._pointerPositions[e].x = t.clientX, this._pointerPositions[e].y = t.clientY;
    const l = t.clientX, c = t.clientY;
    for (; e >= this._pointerPositionsRC.length; )
      this._pointerPositionsRC.push(new oe());
    const h = this._pointerPositionsRC[e];
    h.set(l, c), this.convertScreenspaceToRaycastSpace(h);
  }
  /** get the next free id */
  getPointerIndex(t) {
    let e = -1;
    for (let i = 0; i < this._pointerIds.length; i++) {
      if (this._pointerIds[i] === t)
        return i;
      e === -1 && this._pointerIds[i] === -1 && (e = i);
    }
    return e !== -1 ? (this._pointerIds[e] = t, e) : (lt && console.log("PUSH pointerId:", t), this._pointerIds.push(t), this._pointerIds.length - 1);
  }
  setPointerState(t, e, i) {
    e[t] = i;
  }
  setPointerStateT(t, e, i) {
    return e[t] = i, i;
  }
  onDispatchEvent(t) {
    const e = ee.Current;
    try {
      ee.Current = this.context, this.dispatchEvent(t);
    } finally {
      ee.Current = e;
    }
  }
}
const Sa = new se().makeRotationY(Math.PI), Gi = new W().setFromAxisAngle(new v(0, 1, 0), Math.PI), VC = x("debugwebxr");
class HC {
  constructor() {
    r(this, "priority", -1e5);
    r(this, "gameObject");
    if (this.gameObject = new L(), this.gameObject.name = "Implicit XR Rig", VC) {
      const t = Sg(16733661);
      t.position.y += 0.5, this.gameObject.add(t);
    }
  }
  isXRRig() {
    return !0;
  }
  get isActive() {
    return this.gameObject.visible;
  }
}
const ns = x("debugwebxr"), Th = x("debugcustomgesture"), GC = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", qC = "generic-trigger", XC = new W().setFromEuler(new jt(Cs.degToRad(0), Cs.degToRad(-90), Cs.degToRad(-90))), QC = new v(0.04, -0.04, 0);
class V0 {
  constructor(t, e, i) {
    /** the Needle XR Session */
    r(this, "xr");
    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource
     */
    r(this, "inputSource");
    /** the input source index */
    r(this, "index", 0);
    /** When enabled the controller will create input events in the Needle Engine input system (e.g. when a button is pressed or the controller is moved)   
     * You can disable this if you don't want inputs to go through the input system but be aware that this will result in `onPointerDown` component callbacks to not be invoked anymore for this XRController
    */
    r(this, "emitEvents", !0);
    r(this, "_connected", !0);
    r(this, "_isTracking", !1);
    r(this, "__gamepad");
    r(this, "__hand");
    r(this, "__side");
    r(this, "_hitTestSource");
    r(this, "_hasSelectEvent", !1);
    r(this, "_isMxInk", !1);
    r(this, "_isMetaQuestTouchController", !1);
    /** This is cleared at the beginning of each frame */
    r(this, "_handJointPoses", /* @__PURE__ */ new Map());
    /** Grip matrix in grip space */
    r(this, "_gripMatrix", new se());
    /** Grip position in grip space */
    r(this, "_gripPosition", new v());
    /** Grip rotation in grip space */
    r(this, "_gripQuaternion", new W());
    r(this, "_linearVelocity", new v());
    r(this, "_rayPositionRaw", new v());
    r(this, "_rayRotationRaw", new W());
    /** ray matrix in grip space */
    r(this, "_rayMatrix", new se());
    /** Ray position in rig space */
    r(this, "_rayPosition", new v());
    /** Ray rotation in rig space */
    r(this, "_rayQuaternion", new W());
    r(this, "_gripWorldPosition", new v());
    r(this, "_gripWorldQuaternion", new W());
    r(this, "_rayWorldPosition", new v());
    r(this, "_rayWorldQuaternion", new W());
    r(this, "_pinchPosition", new v());
    r(this, "_ray");
    /** Recalculated once per update */
    r(this, "_hand_wristDotUp");
    r(this, "_object");
    r(this, "_gripSpaceObject");
    r(this, "_raySpaceObject");
    /** Assigned the model that you use for rendering. This can be used as a hint for other components */
    r(this, "model", null);
    r(this, "_debugAxesHelper", new Oi(0.15));
    r(this, "_debugGripAxesHelper", new Oi(0.07));
    r(this, "_debugRayAxesHelper", new Oi(0.07));
    r(this, "_hitTestSourcePromise", null);
    r(this, "onPointerHits", (t) => {
    });
    r(this, "_needleGamepadButtons", {});
    r(this, "_buttonMap", /* @__PURE__ */ new Map());
    // the motion controller contains the controller scheme, we use this to simplify button access
    r(this, "_motioncontroller");
    r(this, "_layout");
    r(this, "getMotionController");
    /**
     * When enabled the controller will automatically emit pointer down events to the Needle Engine Input System.   
     * @default true
     */
    r(this, "emitPointerDownEvent", !0);
    /**
     * When enabled the controller will automatically emit pointer up events to the Needle Engine Input System.   
     * @default true
     */
    r(this, "emitPointerUpEvent", !0);
    /**
     * When enabled the controller will automatically emit pointer move events to the Needle Engine Input System.   
     * @default true
     */
    r(this, "emitPointerMoveEvent", !0);
    /**
     * The distance threshold for pointer move events. This value is in units in rig space
     * @default 0.03
     */
    r(this, "pointerMoveDistanceThreshold", 0.03);
    /**
     * The angle threshold for pointer move events. This value is in radians.
     * @default 0.05
     */
    r(this, "pointerMoveAngleThreshold", 0.05);
    r(this, "_selectButtonIndex");
    r(this, "_squeezeButtonIndex");
    r(this, "onSelectStart", (t) => {
      var n, o, a, l;
      if (!this.emitPointerDownEvent || this.inputSource !== t.inputSource)
        return;
      this.onUpdateFrame(t.frame), this._hasSelectEvent = !0;
      const e = (n = this._layout) == null ? void 0 : n.selectComponentId, i = (l = (a = (o = this._layout) == null ? void 0 : o.components[e]) == null ? void 0 : a.gamepadIndices) == null ? void 0 : l.button;
      i !== void 0 && (this._selectButtonIndex = i), !Th && (ns && V.DrawDirection(this.rayWorldPosition, G(0, 0.01, 1).applyQuaternion(this.rayWorldQuaternion), 16711680, 10), this.emitPointerEvent(Ne.PointerDown, this._selectButtonIndex || 0, "xr-standard-trigger", !0, t));
    });
    r(this, "onSelectEnd", (t) => {
      this.emitPointerUpEvent && (Th || this.inputSource === t.inputSource && this.emitPointerEvent(Ne.PointerUp, this._selectButtonIndex || 0, "xr-standard-trigger", !0, t));
    });
    r(this, "onSequeezeStart", (t) => {
      var e, i, n;
      this.emitPointerDownEvent && this.inputSource === t.inputSource && (this._squeezeButtonIndex = (n = (i = (e = this._layout) == null ? void 0 : e.components["xr-standard-squeeze"]) == null ? void 0 : i.gamepadIndices) == null ? void 0 : n.button, this._squeezeButtonIndex !== void 0 && (ns && V.DrawDirection(this.rayWorldPosition, G(0, 0.01, 1).applyQuaternion(this.rayWorldQuaternion), 255, 10), this.emitPointerEvent(Ne.PointerDown, this._squeezeButtonIndex || 0, "xr-standard-squeeze", !0, t)));
    });
    r(this, "onSequeezeEnd", (t) => {
      this.emitPointerUpEvent && this.inputSource === t.inputSource && this._squeezeButtonIndex !== void 0 && this.emitPointerEvent(Ne.PointerUp, this._squeezeButtonIndex || 0, "xr-standard-squeeze", !0, t);
    });
    /** Index = button index */
    r(this, "states", {});
    r(this, "_didMoveLastFrame", !1);
    r(this, "_lastPointerMovePosition", new v());
    r(this, "_lastPointerMoveQuaternion", new W());
    /** cached spatial pointer init object. We re-use it to not have */
    r(this, "pointerInit");
    this.xr = t, this.inputSource = e, this.index = i, this._object = new L(), this._object.name = `NeedleXRController_${i}`, ns && (this._object.add(this._debugAxesHelper), this._gripSpaceObject = new L(), this._raySpaceObject = new L(), this._gripSpaceObject.name = `NeedleXRController_${i}_gripSpace`, this._raySpaceObject.name = `NeedleXRController_${i}_raySpace`, this._gripSpaceObject.add(this._debugGripAxesHelper), this._raySpaceObject.add(this._debugRayAxesHelper), this.xr.context.scene.add(this._gripSpaceObject), this.xr.context.scene.add(this._raySpaceObject)), this.xr.context.scene.add(this._object), this._ray = new wo(), this.pointerInit = {
      origin: this,
      pointerType: this.hand ? "hand" : "controller",
      deviceIndex: this.index,
      pointerId: -1,
      // < this will be updated in the emitPointerEvent method
      mode: this.inputSource.targetRayMode,
      ray: this._ray,
      device: this._object,
      buttonName: "none"
    }, this.initialize(), this.subscribeEvents();
  }
  get context() {
    return this.xr.context;
  }
  /** Is the controller still connected?  */
  get connected() {
    return this._connected;
  }
  get isTracking() {
    return this._isTracking;
  }
  /** the input source gamepad giving raw access to the gamepad values  
   * You should usually use the `getButton` and `getStick` methods instead to get access to named buttons and sticks   
   */
  get gamepad() {
    return this.__gamepad ?? (this.__gamepad = this.inputSource.gamepad);
  }
  /** @returns true if this is a hand (otherwise this is a controller) */
  get isHand() {
    return this.hand != null;
  }
  /** 
   * If this is a hand then this is the hand info (XRHand)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRHand
   */
  get hand() {
    return this.__hand ?? (this.__hand = this.inputSource.hand);
  }
  /** threejs XRHandSpace, shorthand for `context.renderer.xr.getHand(controllerIndex)` 
   * @link https://threejs.org/docs/#api/en/renderers/webxr/WebXRManager.getHand
  */
  get handObject() {
    return this.context.renderer.xr.getHand(this.index);
  }
  /** The input source profiles */
  get profiles() {
    return this.inputSource.profiles;
  }
  /** The device input layout */
  get layout() {
    return this._layout;
  }
  /** shorthand for `inputSource.targetRayMode` */
  get targetRayMode() {
    return this.inputSource.targetRayMode;
  }
  /** shorthand for `inputSource.targetRaySpace` */
  get targetRaySpace() {
    return this.inputSource.targetRaySpace;
  }
  /** shorthand for `inputSource.gripSpace` */
  get gripSpace() {
    return this.inputSource.gripSpace;
  }
  /** 
   * If the controller if held in the left or right hand (or if it's a left or right hand) 
   **/
  get side() {
    return this.__side ?? (this.__side = this.inputSource.handedness);
  }
  /** is right side. shorthand for `side === 'right'` */
  get isRight() {
    return this.side === "right";
  }
  /** is left side. shorthand for `side === 'left'` */
  get isLeft() {
    return this.side === "left";
  }
  /** is XR stylus, e.g. Logitech MX Ink */
  get isStylus() {
    return this._isMxInk;
  }
  /** The XRTransientInputHitTestSource can be used to perform hit tests with the controller ray against the real world.   
   * see https://developer.mozilla.org/en-US/docs/Web/API/XRSession/requestHitTestSourceForTransientInput for more information
   * Requires the hit-test feature to be enabled in the XRSession   
   * 
   * NOTE: The hit test source should be cancelled once it's not needed anymore. Call `cancelHitTestSource` to do this
   */
  getHitTestSource() {
    return this._hitTestSource || this._requestHitTestSource(), this._hitTestSource;
  }
  get hasHitTestSource() {
    return this._hitTestSource;
  }
  /** Make sure to cancel the hittest source once it's not needed anymore */
  cancelHitTestSource() {
    this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0);
  }
  get hasSelectEvent() {
    return this._hasSelectEvent;
  }
  /** Perform a hit test against the XR planes or meshes. shorthand for `xr.getHitTest(controller)`
   * @returns the hit test result (with position and rotation in worldspace) or null if no hit was found
   */
  getHitTest() {
    return this.xr.getHitTest(this);
  }
  /** Get the hand joint pose from the current XRFrame. Results are cached for a frame to avoid calling getJointPose multiple times */
  getHandJointPose(t, e) {
    var n;
    if (e = e || this.xr.frame, !this.hand || !(e != null && e.getJointPose) || !this.xr.referenceSpace)
      return null;
    let i = (n = this._handJointPoses) == null ? void 0 : n.get(t);
    return i || (i = e.getJointPose(t, this.xr.referenceSpace), i && this._handJointPoses.set(t, i), i);
  }
  /** Grip position in rig space */
  get gripPosition() {
    return G(this._gripPosition);
  }
  /** Grip rotation in rig space */
  get gripQuaternion() {
    return En(this._gripQuaternion);
  }
  get gripMatrix() {
    return this._gripMatrix;
  }
  /** Grip linear velocity in rig space
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRPose/linearVelocity
   */
  get gripLinearVelocity() {
    return G(this._linearVelocity).applyQuaternion(Gi);
  }
  /** Ray position in rig space */
  get rayPosition() {
    return G(this._rayPosition);
  }
  /** Ray rotation in rig space */
  get rayQuaternion() {
    return En(this._rayQuaternion);
  }
  /** Controller grip position in worldspace */
  get gripWorldPosition() {
    return G(this._gripWorldPosition);
  }
  /** Controller grip rotation in wordspace */
  get gripWorldQuaternion() {
    return En(this._gripWorldQuaternion);
  }
  /** Controller ray position in worldspace (this value is calculated once per frame by default - call `updateRayWorldPosition` to force an update) */
  get rayWorldPosition() {
    return G(this._rayWorldPosition);
  }
  /** Recalculates the ray world position */
  updateRayWorldPosition() {
    var e;
    const t = (e = this.xr.context.mainCamera) == null ? void 0 : e.parent;
    this._rayWorldPosition.copy(this._rayPositionRaw), t && this._rayWorldPosition.applyMatrix4(t.matrixWorld);
  }
  /** Controller ray rotation in wordspace (this value is calculated once per frame by default - call `updateRayWorldQuaternion` to force an update) */
  get rayWorldQuaternion() {
    return En(this._rayWorldQuaternion);
  }
  get pinchPosition() {
    return G(this._pinchPosition);
  }
  /** Recalculates the ray world quaternion */
  updateRayWorldQuaternion() {
    var i;
    const t = (i = this.xr.context.mainCamera) == null ? void 0 : i.parent, e = t ? Ce(t) : void 0;
    this._rayWorldQuaternion.copy(this._rayRotationRaw).multiply(Gi), e && this._rayWorldQuaternion.premultiply(e);
  }
  /** The controller ray in worldspace */
  get ray() {
    return this._ray.origin.copy(this.rayWorldPosition), this._ray.direction.copy(G(0, 0, 1).applyQuaternion(this.rayWorldQuaternion)), this._ray;
  }
  /**
   * The dot product of the hand palm with the up vector. 
   * This is a number between -1 and 1, where 1 means the palm is directly up and -1 means the palm is directly down (upside down).
   * This value is undefined if there's no hand
   */
  get handWristDotUp() {
    var e;
    if (this._hand_wristDotUp !== void 0)
      return this._hand_wristDotUp;
    const t = (e = this.handObject) == null ? void 0 : e.joints.wrist;
    if (t) {
      const i = G(0, 1, 0).applyQuaternion(t.quaternion), n = G(0, 1, 0).dot(i);
      return this._hand_wristDotUp = n;
    }
  }
  /**
   * @returns true if the hand is upside down
   */
  get isHandUpsideDown() {
    return this.handWristDotUp !== void 0 ? this.handWristDotUp < -0.7 : !1;
  }
  /**
   * @returns true if the hand is upside down and we got a pinch down event this frame.
   */
  get isTeleportGesture() {
    var t;
    return this.isHandUpsideDown && ((t = this.getGesture("pinch")) == null ? void 0 : t.isDown);
  }
  /** The controller object space.  
   * You can use it to attach objects to the controller.   
   * Children will be automatically detached and put into the scene when the controller disconnects
   */
  get object() {
    return this._object;
  }
  /** returns the URL of the default controller model */
  async getModelUrl() {
    var t;
    return (t = this.getMotionController) == null ? void 0 : t.then((e) => (e == null ? void 0 : e.assetUrl) || null);
  }
  _requestHitTestSource() {
    var t;
    return this._hitTestSourcePromise ? this._hitTestSourcePromise : this.xr.mode === "immersive-ar" && this.inputSource.targetRayMode === "tracked-pointer" && this.xr.session.requestHitTestSourceForTransientInput ? this._hitTestSourcePromise = ((t = this.xr.session.requestHitTestSourceForTransientInput({
      profile: this.inputSource.profiles[0],
      offsetRay: new XRRay()
    })) == null ? void 0 : t.then((e) => (this._hitTestSourcePromise = null, this.connected ? this._hitTestSource = e : (e.cancel(), null)))) ?? null : null;
  }
  onUpdate(t) {
    performance.mark("NeedleXRController onUpdate start"), this.onUpdateFrame(t), this.updateInputEvents(), this.onUpdateMove(), performance.mark("NeedleXRController onUpdate end"), performance.measure("NeedleXRController onUpdate", "NeedleXRController onUpdate start", "NeedleXRController onUpdate end");
  }
  onRenderDebug() {
    var o;
    V.DrawSphere(this.rayWorldPosition, 3e-3), V.DrawDirection(this.rayWorldPosition, G(0, 0, 10).applyQuaternion(this.rayWorldQuaternion));
    const e = (this.inputSource.gripSpace ? this.gripWorldPosition : this.object.worldPosition).sub(this.object.worldForward.multiplyScalar(0.1)), i = this.inputSource.profiles.join(`
`);
    let n = `Controller[${this.index}] (${this.inputSource.targetRayMode}, ${this.side})
C:${this.connected ? "x" : "-"} T:${this.isTracking ? "x" : "-"} Hand:${this.inputSource.hand ? "x" : "-"} Pen: ${this._isMxInk ? "x" : "-"}`;
    if (this.inputSource.hand && (n += `
Pinch: ${(o = this.getGesture("pinch")) == null ? void 0 : o.value.toFixed(3)}`), n += `
` + i, n += `
` + (this.inputSource.targetRaySpace ? "Ray: x" : "Ray: -") + (this.inputSource.gripSpace ? " Grip: x" : " Grip: -") + (this.inputSource.gamepad ? ` Gamepad: ${this.inputSource.gamepad.mapping}` : " Gamepad: -"), this.inputSource.gamepad) {
      const a = this.inputSource.gamepad;
      let l = "[btns " + a.buttons.length + "]: " + a.buttons.map((c) => c.value.toPrecision(1)).join(",");
      l += `
[axes ` + a.axes.length + "]: " + a.axes.map((c) => c.toPrecision(1)).join(","), n += `
` + l;
    }
    V.DrawLabel(e, n, 6e-3);
  }
  onUpdateFrame(t) {
    var d, u, p, m, g, _, y, b, w, P, k;
    if (this._handJointPoses.clear(), this._hand_wristDotUp = void 0, !this.xr.referenceSpace) {
      this._isTracking = !1;
      return;
    }
    const e = t.getPose(this.inputSource.targetRaySpace, this.xr.referenceSpace);
    this._isTracking = e != null;
    let i = null, n = null, o = null, a = null;
    if (e) {
      const O = e.transform;
      this._rayMatrix.fromArray(O.matrix).premultiply(Sa), this._rayMatrix.decompose(this._rayPosition, this._rayQuaternion, G(1, 1, 1)), o = G(O.position), a = En(O.orientation), this._rayPositionRaw.copy(o), this._rayRotationRaw.copy(a);
    }
    if (this.inputSource.gripSpace) {
      const O = t.getPose(this.inputSource.gripSpace, this.xr.referenceSpace);
      if (O) {
        const M = O.transform;
        if (i = G(M.position), n = En(M.orientation), this._gripMatrix.fromArray(M.matrix).premultiply(Sa), this._gripMatrix.decompose(this._gripPosition, this._gripQuaternion, G(1, 1, 1)), "linearVelocity" in O && O.linearVelocity) {
          const E = O.linearVelocity;
          this._linearVelocity.set(E.x, E.y, E.z);
        }
      }
    }
    (d = this.xr.context.mainCamera) != null && d.parent && (this._object.parent !== ((u = this.xr.context.mainCamera) == null ? void 0 : u.parent) && this.xr.context.mainCamera.parent.add(this._object), this._gripSpaceObject !== void 0 && ((p = this._gripSpaceObject) == null ? void 0 : p.parent) !== ((m = this.xr.context.mainCamera) == null ? void 0 : m.parent) && this.xr.context.mainCamera.parent.add(this._gripSpaceObject), this._raySpaceObject !== void 0 && ((g = this._raySpaceObject) == null ? void 0 : g.parent) !== ((_ = this.xr.context.mainCamera) == null ? void 0 : _.parent) && this.xr.context.mainCamera.parent.add(this._raySpaceObject));
    const l = this.hand;
    if (l) {
      let O = !1;
      const M = l.get("wrist"), E = M && this.getHandJointPose(M, t);
      if (E) {
        O = !0;
        const F = E.transform.position, U = E.transform.orientation;
        this._object.position.set(F.x, F.y, F.z), this._object.quaternion.set(U.x, U.y, U.z, U.w).multiply(Gi);
      }
      O || (this._object.position.copy(this._rayPosition), this._object.quaternion.copy(this._rayQuaternion).multiply(Gi));
      const B = l.get("middle-finger-metacarpal"), A = B && this.getHandJointPose(B, t);
      A && (this._gripMatrix.fromArray(A.transform.matrix).premultiply(Sa), this._gripMatrix.decompose(this._gripPosition, this._gripQuaternion, G(1, 1, 1)), i = G().copy(A.transform.position), n = En().copy(A.transform.orientation), n.multiply(XC), i.add(G(QC).applyQuaternion(n)));
    } else
      this.inputSource.gripSpace && this.targetRayMode === "transient-pointer" && i && n ? (this._object.position.copy(i), this._object.quaternion.copy(n).multiply(Gi)) : o && a && (this._object.position.copy(o), this._object.quaternion.copy(a).multiply(Gi));
    ns && (o && a && ((y = this._raySpaceObject) == null || y.position.copy(o), (b = this._raySpaceObject) == null || b.quaternion.copy(a).multiply(Gi)), i && n && ((w = this._gripSpaceObject) == null || w.position.copy(i), (P = this._gripSpaceObject) == null || P.quaternion.copy(n).multiply(Gi)));
    const c = (k = this.xr.context.mainCamera) == null ? void 0 : k.parent, h = c ? Ce(c) : void 0;
    i && n && (this._gripWorldPosition.copy(i), c && this._gripWorldPosition.applyMatrix4(c.matrixWorld), this._gripWorldQuaternion.copy(n), this._gripWorldQuaternion.multiply(Gi), h && this._gripWorldQuaternion.premultiply(h)), this.updateRayWorldPosition(), this.updateRayWorldQuaternion();
  }
  /** Called when the input source disconnects */
  onDisconnected() {
    var t, e, i, n, o, a;
    this._connected = !1, ns && console.warn("Controller disconnected", this.index);
    for (const l of this._object.children)
      this.xr.context.scene.attach(l);
    (t = this._object) == null || t.removeFromParent(), (e = this._debugAxesHelper) == null || e.removeFromParent(), (i = this._debugGripAxesHelper) == null || i.removeFromParent(), (n = this._debugRayAxesHelper) == null || n.removeFromParent(), (o = this._gripSpaceObject) == null || o.removeFromParent(), (a = this._raySpaceObject) == null || a.removeFromParent(), this.unsubscribeEvents(), this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0);
  }
  /**
   * Get a gamepad button
   * @link https://github.com/immersive-web/webxr-gamepads-module/blob/main/gamepads-module-explainer.md
   * @param key the controller button name e.g. x-button
   * @returns the gamepad button if it exists on the controller - otherwise undefined
   */
  getButton(t) {
    var i;
    if (!this._layout)
      return;
    switch (t) {
      case "primary-button":
        if (this.isLeft)
          t = "x-button";
        else if (this.isRight)
          t = "a-button";
        else
          return;
        break;
      case "primary":
        return this.hand ? this.getGesture("pinch") : this.toNeedleGamepadButton(0, t);
    }
    if (this._buttonMap.has(t))
      return this.toNeedleGamepadButton(this._buttonMap.get(t), t);
    const e = (i = this._layout) == null ? void 0 : i.components[t];
    if (e != null && e.gamepadIndices)
      switch (e.type) {
        case "button":
        case "squeeze":
          if (this.inputSource.gamepad) {
            const n = e.gamepadIndices.button;
            return this._buttonMap.set(t, n), this.toNeedleGamepadButton(n, t);
          }
          break;
        default:
          console.warn("Unsupported component type", e.type);
          break;
      }
    this._buttonMap.set(t, void 0);
  }
  /** Get a gesture state */
  getGesture(t) {
    const e = this.states[t];
    if (!e)
      return null;
    this.states[t] = e;
    const i = this._needleGamepadButtons[t] || new cy(void 0, t);
    return i.pressed = e.pressed, i.value = e.value, i.isDown = e.isDown, i.isUp = e.isUp, this._needleGamepadButtons[t] = i, i;
  }
  getPointerId(t) {
    if ((t === "primary" || t === "pinch") && (t = 0), typeof t != "number") {
      const e = this._buttonMap.get(t);
      if (e === void 0)
        return;
      t = e;
    }
    return this.index * 10 + t;
  }
  /** combine the InputState information + the GamepadButton information (since GamepadButtons can not be extended) */
  toNeedleGamepadButton(t, e) {
    var a, l;
    if (!((a = this.inputSource.gamepad) != null && a.buttons))
      return;
    const i = (l = this.inputSource.gamepad) == null ? void 0 : l.buttons[t], n = this.states[t], o = this._needleGamepadButtons[t] || new cy(t, e);
    return i && (o.pressed = i.pressed, o.value = i.value, o.touched = i.touched), n && (o.isDown = n.isDown, o.isUp = n.isUp), this._needleGamepadButtons[t] = o, o;
  }
  /**
   * Get the values of a controller joystick
   * @link https://github.com/immersive-web/webxr-gamepads-module/blob/main/gamepads-module-explainer.md
   * @returns the stick values where x is left/right, y is up/down and z is the button value
   */
  getStick(t) {
    var i, n, o, a, l, c, h, d, u;
    if (!this._layout)
      return { x: 0, y: 0, z: 0 };
    if (t === "primary") {
      const p = ((i = this.inputSource.gamepad) == null ? void 0 : i.axes[0]) || 0, m = ((n = this.inputSource.gamepad) == null ? void 0 : n.axes[1]) || 0, g = ((a = (o = this.inputSource.gamepad) == null ? void 0 : o.buttons[3]) == null ? void 0 : a.value) || 0;
      return { x: p, y: m, z: g };
    }
    const e = (l = this._layout) == null ? void 0 : l.components[t];
    if (e != null && e.gamepadIndices)
      switch (e.type) {
        case "thumbstick":
          if (this.inputSource.gamepad) {
            const p = e.gamepadIndices.xAxis, m = e.gamepadIndices.yAxis;
            let g = (c = this.inputSource.gamepad) == null ? void 0 : c.axes[p], _ = (h = this.inputSource.gamepad) == null ? void 0 : h.axes[m];
            g *= -1, _ *= -1;
            const y = e.gamepadIndices.button, b = (u = (d = this.inputSource.gamepad) == null ? void 0 : d.buttons[y]) == null ? void 0 : u.value;
            return { x: g, y: _, z: b };
          }
      }
    return { x: 0, y: 0, z: 0 };
  }
  initialize() {
    if (this._hasSelectEvent = this.profiles.includes("generic-hand-select") || this.profiles.some((t) => t.startsWith("generic-trigger")), this._isMetaQuestTouchController = this.profiles.includes("meta-quest-touch-plus") || this.profiles.includes("oculus-touch-v3"), this._isMxInk = this.profiles.includes("logitech-mx-ink"), !this._layout) {
      if (this.inputSource.targetRayMode === "transient-pointer")
        return;
      const t = mS(this.inputSource, GC, qC);
      this.getMotionController = t.then((e) => {
        var o;
        if (!this.connected)
          return null;
        this._motioncontroller = new gS(
          this.inputSource,
          e.profile,
          e.assetPath || ""
        );
        const n = e.profile.layouts[this.inputSource.handedness];
        if (this._layout = n, this._layout && !((o = this._layout.gamepad) != null && o.length)) {
          this._layout.gamepad = [];
          for (const a in this._layout.components) {
            const l = this._layout.components[a];
            this._layout.gamepad[l.gamepadIndices.button] = a;
          }
        }
        return this._motioncontroller;
      }).catch((e) => (this.inputSource && console.warn("Couldn't initialize motion controller profile for ", this.inputSource, e), null));
    }
  }
  subscribeEvents() {
    this.xr.session.addEventListener("selectstart", this.onSelectStart), this.xr.session.addEventListener("selectend", this.onSelectEnd), this.xr.session.addEventListener("squeezestart", this.onSequeezeStart), this.xr.session.addEventListener("squeezeend", this.onSequeezeEnd);
  }
  unsubscribeEvents() {
    this.xr.session.removeEventListener("selectstart", this.onSelectStart), this.xr.session.removeEventListener("selectend", this.onSelectEnd), this.xr.session.removeEventListener("squeezestart", this.onSequeezeStart), this.xr.session.removeEventListener("squeezeend", this.onSequeezeEnd);
  }
  // If we want to invoke button events for ALL buttons we need to keep track of the previous state
  // instead of using XR input select start events which is only raised for the primary button
  // we should probably do both but then we need to ignore the primary index in the following function (to not raise an event for the same button twice)
  // and start with index = 1
  updateInputEvents() {
    var t, e, i;
    if ((t = this.gamepad) != null && t.buttons) {
      for (let n = 0; n < this.gamepad.buttons.length; n++) {
        const o = this.gamepad.buttons[n], a = this.states[n] || new ly();
        let l = null;
        this._isMxInk && (n === 4 || n === 5) ? (o.value > 0 && !a.pressed ? (l = "pointerdown", a.isDown = !0, a.isUp = !1) : o.value === 0 && a.pressed ? (l = "pointerup", a.isDown = !1, a.isUp = !0) : a.pressed && (l = "pointermove", a.isDown = !1, a.isUp = !1), a.pressed = o.value > 0, a.value = o.value) : (o.pressed && !a.pressed ? (l = "pointerdown", a.isDown = !0, a.isUp = !1) : !o.pressed && a.pressed ? (l = "pointerup", a.isDown = !1, a.isUp = !0) : (a.isDown = !1, a.isUp = !1), a.pressed = o.pressed, a.value = o.value), this.states[n] = a;
        const c = n !== this._selectButtonIndex && n !== this._squeezeButtonIndex;
        if (l != null && c) {
          let h = (e = this._layout) == null ? void 0 : e.gamepad[n];
          this._isMxInk && n === 4 && (h = "stylus-touch"), this._isMxInk && n === 5 && (h = "stylus-tip"), (ns || Th) && console.log("Emitting pointer event", l, n, h, o.value, this.gamepad, this._layout), this.emitPointerEvent(l, n, h ?? "none", !1, null, o.value);
        }
      }
      if (this._isMetaQuestTouchController) {
        const n = this.gamepad.buttons.length - 1, o = this.states[n];
        if (o && o.isDown) {
          const a = this.context.menu;
          a.spatialMenuIsVisible ? a.setSpatialMenuVisible(!1) : this.context.menu.setSpatialMenuVisible(!0);
        }
      }
    }
    if (this.hand) {
      const n = this.handObject;
      if (n) {
        const o = n.joints["index-finger-tip"], a = n.joints["thumb-tip"];
        if (o && a) {
          const l = o.position.distanceTo(a.position);
          this._pinchPosition.lerpVectors(o.position, a.position, 0.5);
          const c = (i = this.xr.context.mainCamera) == null ? void 0 : i.parent;
          if (c && this._pinchPosition.applyMatrix4(c.matrixWorld), l !== 0) {
            const u = this.states.pinch || new ly(), p = (0.02 + 0.01) * 1.5;
            u.value = 1 - (l - 0.02) / p;
            const m = l < 0.02 - 0.01, g = l > 0.02 + 0.01;
            m && !u.pressed ? (Th && console.log("pinch start", l), u.isDown = !0, u.isUp = !1, u.pressed = !0) : g && u.pressed ? (u.isDown = !1, u.isUp = !0, u.pressed = !1) : (u.isDown = !1, u.isUp = !1), this.states.pinch = u;
          }
        }
      }
    }
  }
  onUpdateMove() {
    var i, n;
    if (!this.emitPointerMoveEvent)
      return;
    let t = !1;
    if (this._lastPointerMovePosition.distanceTo(this.gripWorldPosition) > this.pointerMoveDistanceThreshold * this.xr.rigScale && (t = !0), t || this._lastPointerMoveQuaternion.angleTo(this.gripWorldQuaternion) > this.pointerMoveAngleThreshold && (t = !0), t) {
      this._didMoveLastFrame = !0, this._lastPointerMovePosition.copy(this.gripWorldPosition), this._lastPointerMoveQuaternion.copy(this.gripWorldQuaternion), ns && V.DrawLabel(this.rayWorldPosition.add(this.object.worldForward.multiplyScalar(0.1)), "move", 0.01);
      let o = this.xr.context.input.getFirstPressedButtonForPointer(this.index);
      o === void 0 && (o = 0);
      const a = (n = (i = this.gamepad) == null ? void 0 : i.buttons[o]) == null ? void 0 : n.value;
      this.emitPointerEvent("pointermove", o, "none", !1, null, a);
    } else
      this._didMoveLastFrame = !1;
  }
  emitPointerEvent(t, e, i, n, o = null, a) {
    if (!this.emitEvents) {
      ns && t !== Ne.PointerMove && console.warn("Pointer events are disabled for this controller", this.index, t, e);
      return;
    }
    if (this.xr.mode === "immersive-vr" || this.xr.isPassThrough) {
      this.pointerInit.origin = this, this.pointerInit.pointerId = this.getPointerId(e), this.pointerInit.pointerType = this.hand ? "hand" : "controller", this.pointerInit.button = e, this.pointerInit.buttonName = i, this.pointerInit.isPrimary = n, this.pointerInit.mode = this.inputSource.targetRayMode, this.pointerInit.ray = this.ray, this.pointerInit.device = this.object, this.pointerInit.pressure = a, this.pointerInit.clientX = this._rayPosition.x / this.xr.rigScale, this.pointerInit.clientY = this._rayPosition.y / this.xr.rigScale, this.pointerInit.clientZ = this._rayPosition.z / this.xr.rigScale;
      const l = ee.Current;
      ee.Current = this.xr.context, ns && t !== "pointermove" && console.warn("Pointer event", t, e, i, { ...this.pointerInit }), this.xr.context.input.createInputEvent(new Ys(t, o, this.pointerInit)), ee.Current = l;
    }
  }
}
class ly {
  constructor() {
    /** if the button was pressed the last update */
    r(this, "isDown", !1);
    /** if the button was released the last update */
    r(this, "isUp", !1);
    r(this, "pressed", !1);
    r(this, "value", 0);
  }
}
class cy {
  constructor(t, e) {
    /** The index of the button in the input gamepad */
    r(this, "index");
    r(this, "name");
    r(this, "touched", !1);
    r(this, "pressed", !1);
    r(this, "value", 0);
    /** was the button just pressed down the last update */
    r(this, "isDown", !1);
    /** was the button just released the last update */
    r(this, "isUp", !1);
    this.index = t, this.name = e;
  }
}
const Ca = /* @__PURE__ */ new Map(), ua = /* @__PURE__ */ new Map();
let hy = 0;
function Ds(s, t, e) {
  if (Ca.has(t) || Ca.set(t, new Array()), Ca.get(t).push({
    method: s,
    options: { once: !1, ...e }
  }), hy < 30) {
    const i = ua.get(t);
    i && (i == null ? void 0 : i.length) > 100 && (hy += 1, console.warn(`You have ${i.length} methods registered for Event ${t}.

This might be a performance issue!
Consider unregistering the methods when they are not needed anymore!

To unregister you can call the function returned by your event hook (e.g.const unregister = onStart(...)) 

or by using the once option like onStart(()=>{}, { once:true }).

See https://engine.needle.tools/docs/scripting.html#special-lifecycle-hooks for more information.`));
  }
}
function Po(s, t) {
  const e = ua.get(t);
  if (e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].method === s) {
        e.splice(n, 1);
        return;
      }
  }
  const i = Ca.get(t);
  if (i) {
    for (let n = 0; n < i.length; n++)
      if (i[n].method === s) {
        i.splice(n, 1);
        return;
      }
  }
}
function Mn(s, t) {
  t === pe.ContextCreated && hm.delete(s), H0(s, t);
}
function H0(s, t) {
  t === Re.Start && Ca.get(pe.ContextCreated) && H0(s, pe.ContextCreated);
  const e = t === Re.Start || t === pe.ContextCreated, i = ua.get(t);
  i && i.length > 0 && uy(s, i, e);
  const n = Ca.get(t);
  if (n && n.length > 0) {
    const o = [...n];
    n.length = 0, uy(s, o, e), o.length > 0 && (ua.has(t) || ua.set(t, new Array()), ua.get(t).push(...o));
  }
}
const Ah = new Array(), dy = {
  context: null
};
function uy(s, t, e) {
  var n, o;
  Ah.length = 0;
  for (let a = 0; a < t.length; a++)
    Ah.push(t[a]);
  let i = hm.get(s);
  for (let a = 0; a < Ah.length; a++) {
    const l = Ah[a];
    let c = !0;
    if (i && i.has(l) && (c = !1), c)
      try {
        dy.context = s, (n = l.method) == null || n.call(dy, s);
      } catch (h) {
        console.error("Error in lifecycle method", h);
      }
    if ((o = l.options) != null && o.once) {
      for (let h = 0; h < t.length; h++)
        if (t[h] === l) {
          t.splice(h, 1);
          break;
        }
    } else
      e && (i || (i = /* @__PURE__ */ new Set(), hm.set(s, i)), i.add(l));
  }
}
const hm = /* @__PURE__ */ new WeakMap(), G0 = {};
function q0(s, t) {
  G0[s] = t;
}
function YC(s) {
  const t = s.getBufferIdentifier(), e = G0[t];
  return e(s);
}
function KC(s) {
  return typeof s.guid == "function" ? s.guid() : null;
}
let wg;
function xD() {
  return wg;
}
function SD(s) {
  wg = s;
}
function ZC(s, t) {
  return t || (t = {}), t = {
    ...wg,
    ...t
  }, s ? new F_(s, t) : new F_(t);
}
async function fy() {
  const s = await import("./vendor.js").then((t) => t.bundler);
  return console.log(s), s.default === void 0 ? s : s.default;
}
class JC {
  constructor() {
    r(this, "_host");
    r(this, "_client");
    r(this, "_clientData");
    this.onEnable();
  }
  get isHost() {
    return this._host !== void 0;
  }
  onEnable() {
    const t = "HOST-5980e65c-8438-453e-8b35-f13c736dcd81";
    this.trySetupHost(t);
  }
  async trySetupHost(t) {
    const e = await fy(), i = new e(t);
    i.on("error", (n) => {
      console.error(n), this._host = void 0, this.trySetupClient(t);
    }), i.on("open", (n) => {
      this._host = new tP(i);
    });
  }
  async trySetupClient(t) {
    const e = await fy();
    this._client = new e(), this._client.on("error", (i) => {
      console.error("Client error", i);
    }), this._client.on("open", (i) => {
      console.log("client connected", i), this._clientData = this._client.connect(t, { metadata: { id: i } }), this._clientData.on("open", () => {
        console.log("Connected to host");
      }), this._clientData.on("data", (n) => {
        console.log("<<", n);
      });
    });
  }
}
class eP {
  constructor(t) {
    r(this, "_peer");
    this._peer = t;
  }
}
class tP extends eP {
  constructor(e) {
    var i;
    super(e);
    r(this, "_connections", []);
    console.log("I AM THE HOST"), (i = this._peer) == null || i.on("connection", this.onConnection.bind(this)), this._peer.on("close", () => {
      this.broadcast("BYE");
    }), setInterval(() => {
      this.broadcast("HELLO");
    }, 2e3);
  }
  get isHost() {
    return !0;
  }
  onConnection(e) {
    console.log("host connection", e), e.on("open", () => {
      this._connections.push(e), this.broadcastConnection(e);
    });
  }
  broadcastConnection(e) {
    const i = this._connections.map((n) => {
      var o;
      return (o = n.metadata) == null ? void 0 : o.id;
    }).filter((n) => n !== void 0);
    this.broadcast({ type: "connection-list", connections: i });
  }
  broadcast(e) {
    if (e != null) {
      console.log(">>", e);
      for (const i in this._peer.connections) {
        const n = this._peer.connections[i];
        if (n)
          if (Array.isArray(n))
            for (const o of n)
              o && o.send(e);
          else
            console.warn(n);
      }
    }
  }
}
var In = /* @__PURE__ */ ((s) => (s[s.OnConnection = 0] = "OnConnection", s[s.OnRoomJoin = 1] = "OnRoomJoin", s[s.Queued = 2] = "Queued", s[s.Immediate = 3] = "Immediate", s))(In || {});
const py = "https://urls.needle.tools/default-networking-backend/index";
let li = "wss://networking.needle.tools/socket";
const gi = !!x("debugnet"), Eh = !!(gi || x("debugowner")), Lf = x("debugnetbin");
var iP = /* @__PURE__ */ ((s) => (s.ConnectionInfo = "connection-start-info", s))(iP || {}), ne = /* @__PURE__ */ ((s) => (s.Join = "join-room", s.Leave = "leave-room", s.JoinedRoom = "joined-room", s.LeftRoom = "left-room", s.UserJoinedRoom = "user-joined-room", s.UserLeftRoom = "user-left-room", s.RoomStateSent = "room-state-sent", s))(ne || {});
class CD {
  constructor() {
    r(this, "room");
    // room name
    r(this, "viewId");
    r(this, "allowEditing");
    r(this, "inRoom");
  }
  // connection ids
}
class PD {
  constructor() {
    r(this, "room");
  }
  // room name
}
class OD {
  constructor() {
    r(this, "userId");
  }
}
var nP = /* @__PURE__ */ ((s) => (s.RequestHasOwner = "request-has-owner", s.ResponseHasOwner = "response-has-owner", s.RequestIsOwner = "request-is-owner", s.ResponseIsOwner = "response-is-owner", s.RequestOwnership = "request-ownership", s.GainedOwnership = "gained-ownership", s.RemoveOwnership = "remove-ownership", s.LostOwnership = "lost-ownership", s.GainedOwnershipBroadcast = "gained-ownership-broadcast", s.LostOwnershipBroadcast = "lost-ownership-broadcast", s))(nP || {});
class X0 {
  constructor(t, e) {
    r(this, "guid");
    r(this, "connection");
    r(this, "_hasOwnership", !1);
    r(this, "_isOwned");
    r(this, "_gainSubscription");
    r(this, "_lostSubscription");
    r(this, "_hasOwnerResponse");
    r(this, "_isWaitingForOwnershipResponseCallback", null);
    this.connection = t, this.guid = e, this._gainSubscription = this.onGainedOwnership.bind(this), this._lostSubscription = this.onLostOwnership.bind(this), t.beginListen("lost-ownership", this._lostSubscription), t.beginListen("gained-ownership-broadcast", this._gainSubscription), this._hasOwnerResponse = this.onHasOwnerResponse.bind(this), t.beginListen("response-has-owner", this._hasOwnerResponse);
  }
  get hasOwnership() {
    return this._hasOwnership;
  }
  // TODO: server should just send id to everyone
  // if anyone has ownership
  get isOwned() {
    return this._isOwned;
  }
  get isConnected() {
    return this.connection.isConnected;
  }
  updateIsOwned() {
    this.connection.send("request-has-owner", { guid: this.guid });
  }
  onHasOwnerResponse(t) {
    t.guid === this.guid && (this._isOwned = t.value);
  }
  requestOwnershipIfNotOwned() {
    return this._isWaitingForOwnershipResponseCallback !== null ? this : (this._isWaitingForOwnershipResponseCallback = this.waitForHasOwnershipRequestResponse.bind(this), this.connection.beginListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this.connection.send("request-has-owner", { guid: this.guid }), this);
  }
  waitForHasOwnershipRequestResponse(t) {
    t.guid === this.guid && (this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null), this._isOwned = t.value, t.value || (Eh && console.log("request ownership", this.guid), this.requestOwnership()));
  }
  requestOwnershipAsync() {
    return new Promise((t, e) => {
      this.requestOwnership();
      let i = 0;
      const n = () => {
        if (i++ > 10)
          return e("Timeout");
        setTimeout(() => {
          this.hasOwnership ? t(this) : n();
        }, 100);
      };
      n();
    });
  }
  requestOwnership() {
    return Eh && console.log("Request ownership", this.guid), this.connection.send("request-ownership", { guid: this.guid }), this;
  }
  freeOwnership() {
    return this.connection.send("remove-ownership", { guid: this.guid }), this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null), this;
  }
  destroy() {
    this.connection.stopListen("gained-ownership", this._gainSubscription), this.connection.stopListen("lost-ownership", this._lostSubscription), this.connection.stopListen("response-has-owner", this._hasOwnerResponse), this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null);
  }
  onGainedOwnership(t) {
    t.guid === this.guid && (this._isOwned = !0, this.connection.connectionId === t.owner ? (Eh && console.log("GAINED OWNERSHIP", this.guid), this._hasOwnership = !0) : this._hasOwnership = !1);
  }
  onLostOwnership(t) {
    t === this.guid && (Eh && console.log("LOST OWNERSHIP", this.guid), this._hasOwnership = !1, this._isOwned = !1);
  }
}
class sP {
  constructor(t) {
    r(this, "context");
    r(this, "_peer", null);
    r(this, "_usersInRoomCopy", []);
    r(this, "_defaultMessagesBuffer", []);
    r(this, "_defaultMessagesBufferArray", []);
    r(this, "netWebSocketUrlProvider");
    r(this, "_listeners", {});
    r(this, "_listenersBinary", {});
    r(this, "connected", !1);
    r(this, "channelId");
    r(this, "_connectionId", null);
    // Websocket ------------------------------------------------------------
    r(this, "_ws");
    r(this, "_waitingForSocket", {});
    r(this, "_isInRoom", !1);
    r(this, "_currentRoomName", null);
    r(this, "_currentRoomViewId", null);
    r(this, "_currentRoomAllowEditing", !0);
    r(this, "_currentInRoom", []);
    r(this, "_state", {});
    r(this, "_currentDelay", -1);
    r(this, "_connectingToWebsocketPromise", null);
    this.context = t;
  }
  /** Experimental: networking via peerjs */
  get peer() {
    return this._peer || (this._peer = new JC()), this._peer;
  }
  /**
   * Returns the state of a given guid.
   */
  tryGetState(t) {
    return t === "invalid" ? null : this._state[t];
  }
  /** The connection id of the local user - it is given by the networking backend and can not be changed */
  get connectionId() {
    return this._connectionId;
  }
  /** Returns true if the networking backend is in debug mode.  
   * To see all networking messages in the console use `?debugnet` in the url
   */
  get isDebugEnabled() {
    return gi;
  }
  /** True when connected to the networking backend */
  get isConnected() {
    return this.connected;
  }
  /** The name of the room the user is currently connected to */
  get currentRoomName() {
    return this._currentRoomName;
  }
  /** True when connected to a room via a regular url, otherwise (when using a view only url) false indicating that the user should not be able to modify the scene */
  get allowEditing() {
    return this._currentRoomAllowEditing;
  }
  /**
   * The view id of the room the user is currently connected to.
   */
  get currentRoomViewId() {
    return this._currentRoomViewId;
  }
  /**
   * Returns a url that can be shared with others to view the current room in view only mode.  
   * This is useful for sharing a room with others without allowing them to modify the scene.  
   * Use `connection.allowEditing` to check if the current room is in view only mode.  
   */
  getViewOnlyUrl() {
    if (this.currentRoomViewId === null)
      return null;
    const t = new URL(window.location.href);
    return t.searchParams.set("view", this.currentRoomViewId), t.href;
  }
  /** True if connected to a networked room. Use the joinRoom function or a `SyncedRoom` component */
  get isInRoom() {
    return this._isInRoom;
  }
  /** Latency to currently connected backend server */
  get currentLatency() {
    return this._currentDelay;
  }
  /**
   * The current server url that the networking backend is connected to (e.g. the url of the websocket server)
   */
  get currentServerUrl() {
    var t;
    return ((t = this._ws) == null ? void 0 : t.url) ?? null;
  }
  /** A ping is sent to the server at a regular interval while the browser tab is active. This method can be used to send additional ping messages when needed so that the user doesn't get disconnected from the networking backend */
  sendPing() {
    this.send("ping", { time: this.context.time.time });
  }
  /** Returns true if a user with the given connectionId is in the room */
  userIsInRoom(t) {
    return this._currentInRoom.indexOf(t) !== -1;
  }
  /** Returns a list of all user ids in the current room */
  usersInRoom(t = null) {
    t || (t = this._usersInRoomCopy), t.length = 0;
    for (const e of this._currentInRoom)
      t.push(e);
    return t;
  }
  /** Joins a networked room. If you don't want to manage a connection yourself you can use a `SyncedRoom` component as well */
  joinRoom(t, e = !1) {
    return t ? t.length > 1024 ? (console.error('Room name too long, can not join: "' + t + '". Max length is 1024 characters.'), !1) : (this.connect(), gi && console.log("join: " + t), this.send("join-room", { room: t, viewOnly: e }, In.OnConnection), !0) : (console.error('Missing room name, can not join: "' + t + '"'), !1);
  }
  /** Use to leave a room that you are currently connected to (use `leaveRoom()` to disconnect from the currently active room but you can also specify a room name) */
  leaveRoom(t = null) {
    return t || (t = this.currentRoomName), t ? (this.send("leave-room", { room: t }), !0) : (console.error('Missing room name, can not join: "' + t + '"'), !1);
  }
  /** Send a message to the networking backend - it will broadcasted to all connected users in the same room by default */
  send(t, e = null, i = In.Queued) {
    if (e === null && (e = {}), i === In.Queued) {
      this._defaultMessagesBuffer.push({ key: t, value: e });
      return;
    }
    return this.sendWithWebsocket(t, e, i);
  }
  /** Use to delete state for a given guid on the server */
  sendDeleteRemoteState(t) {
    this.send("delete-state", { guid: t, dontSave: !0 }), delete this._state[t];
  }
  /** Use to delete all state in the currently connected room on the server */
  sendDeleteRemoteStateAll() {
    this.send("delete-all-state"), this._state = {};
  }
  /** Send a binary message to the server (broadcasted to all connected users) */
  sendBinary(t) {
    var e;
    Lf && console.log("<< send binary", this.context.time.frame, t.length / 1024 + " KB"), (e = this._ws) == null || e.send(t);
  }
  sendBufferedMessagesNow() {
    var i;
    if (!this._ws)
      return;
    this._defaultMessagesBufferArray.length = 0;
    const t = Object.keys(this._defaultMessagesBuffer).length;
    for (const n in this._defaultMessagesBuffer) {
      const o = this._defaultMessagesBuffer[n];
      if (t <= 1) {
        this.sendWithWebsocket(o.key, o.value, In.Immediate);
        break;
      }
      const a = this.toMessage(o.key, o.value);
      this._defaultMessagesBufferArray.push(a);
    }
    if (this._defaultMessagesBuffer.length = 0, this._defaultMessagesBufferArray.length > 0 && gi && console.log("SEND BUFFERED", this._defaultMessagesBufferArray.length), this._defaultMessagesBufferArray.length <= 0)
      return;
    const e = JSON.stringify(this._defaultMessagesBufferArray);
    (i = this._ws) == null || i.send(e);
  }
  /** Use to start listening to networking events.   
   * To unsubscribe from events use the `stopListen` method.   
   * See the example below for typical usage:
   * 
   * ### Component Example
   * ```ts
   * // Make sure to unsubscribe from events when the component is disabled
   * export class MyComponent extends Behaviour {
   *   onEnable() {
   *     this.connection.beginListen("joined-room", this.onJoinedRoom)
   *   }
   *   onDisable() {
   *     this.connection.stopListen("joined-room", this.onJoinedRoom)
   *   }
   *   onJoinedRoom = () => {
   *      console.log("I joined a networked room")
   *   }
   * }
   * ```
   * @link https://engine.needle.tools/docs/networking.html
   * 
  */
  beginListen(t, e) {
    return this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e), e;
  }
  /**@deprecated please use stopListen instead (2.65.2-pre) */
  stopListening(t, e) {
    return this.stopListen(t, e);
  }
  /** Use to stop listening to networking events  
   * To subscribe to events use the `beginListen` method.   
   * See the example below for typical usage:
   * 
   * ### Component Example
   * ```ts
   * // Make sure to unsubscribe from events when the component is disabled
   * export class MyComponent extends Behaviour {
   *   onEnable() {
   *     this.connection.beginListen("joined-room", this.onJoinedRoom)
   *   }
   *   onDisable() {
   *     this.connection.stopListen("joined-room", this.onJoinedRoom)
   *   }
   *   onJoinedRoom = () => {
   *      console.log("I joined a networked room")
   *   }
   * }
   * ```
   */
  stopListen(t, e) {
    if (!e || !this._listeners[t])
      return;
    const i = this._listeners[t].indexOf(e);
    i >= 0 && this._listeners[t].splice(i, 1);
  }
  /** Use to start listening to networking binary events */
  beginListenBinary(t, e) {
    return this._listenersBinary[t] || (this._listenersBinary[t] = []), this._listenersBinary[t].push(e), e;
  }
  /** Use to stop listening to networking binary events */
  stopListenBinary(t, e) {
    if (!this._listenersBinary[t])
      return;
    const i = this._listenersBinary[t].indexOf(e);
    i >= 0 && this._listenersBinary[t].splice(i, 1);
  }
  /** Use to override the networking server backend url. This is what the `Networking` component uses to modify the backend url */
  registerProvider(t) {
    this.netWebSocketUrlProvider = t;
  }
  /** Used to connect to the networking server */
  async connect(t) {
    var i;
    if (this.connected && t && t !== li)
      return Promise.reject("Can not connect to different server url. Please disconnect first.");
    if (this.connected)
      return Promise.resolve(!0);
    t && console.debug("Connecting to user provided url " + t);
    const e = t || ((i = this.netWebSocketUrlProvider) == null ? void 0 : i.getWebsocketUrl());
    return e ? li = e : kS() && (li = "wss://" + window.location.host + "/socket"), this.connectWebsocket();
  }
  /** Used to disconnect from the networking server */
  disconnect() {
    var t;
    (t = this._ws) == null || t.close(), this._ws = void 0, li = void 0;
  }
  connectWebsocket() {
    return this._connectingToWebsocketPromise ? this._connectingToWebsocketPromise : this._connectingToWebsocketPromise = new Promise(async (t, e) => {
      var h, d;
      let i = !1;
      const n = (u) => {
        i || (i = !0, t(u));
      };
      if (li === void 0 && (console.log("Fetch default backend url: " + py), li = await (await fetch(py)).text()), li === void 0) {
        n(!1);
        return;
      }
      console.debug(`⊡ Connecting to networking backend on
` + li);
      const o = await import("./vendor.js").then((u) => u.index), a = ((h = o.default) == null ? void 0 : h.WebsocketBuilder) ?? o.WebsocketBuilder, l = ((d = o.default) == null ? void 0 : d.ExponentialBackoff) ?? o.ExponentialBackoff, c = new a(li).withMaxRetries(10).withBackoff(new l(2e3, 4)).onOpen(() => {
        this._connectingToWebsocketPromise = null, this._ws = c, this.connected = !0, z() || gi ? console.log(`⊞ Connected to networking backend
` + li) : console.debug("⊞ Connected to networking backend", li), n(!0), this.onSendQueued(In.OnConnection);
      }).onClose((u) => {
        this._connectingToWebsocketPromise = null, this.connected = !1, this._isInRoom = !1, n(!1);
        let p = "Websocket connection closed...";
        li != null && li.includes("/socket") || (p += ' Do you perhaps mean to connect to "/socket"?'), console.error(p);
      }).onError((u) => {
        console.error("⊠ Websocket connection failed..."), n(!1);
      }).onRetry(() => {
        console.log("→ Retry connecting to networking websocket");
      }).build();
      c.addEventListener(o.WebsocketEvent.message, (u, p) => {
        this.onMessage(u, p);
      });
    });
  }
  onMessage(t, e) {
    const i = e.data;
    try {
      if (typeof i != "string") {
        i.size && this.handleIncomingBinaryMessage(i);
        return;
      }
      const n = JSON.parse(i);
      if (Array.isArray(n))
        for (const o of n)
          this.handleIncomingStringMessage(o);
      else
        this.handleIncomingStringMessage(n);
      return;
    } catch (n) {
      gi && i === "pong" ? console.log("<<", i) : z() && console.error("Failed to parse message", n);
    }
  }
  async handleIncomingBinaryMessage(t) {
    Lf && console.log("<< bin", this.context.time.frame);
    const e = await t.arrayBuffer();
    var i = new Uint8Array(e);
    const n = new _S(i), o = n.getBufferIdentifier(), a = this._listenersBinary[o], l = YC(n), c = KC(l);
    if (c && typeof c == "string" && (this._state[c] = l), !a)
      return;
    const h = l ?? n;
    for (const d of a)
      d(h);
  }
  handleIncomingStringMessage(t) {
    var n, o;
    if (gi && console.log("<<", t.key ?? t), t.key)
      switch (t.key) {
        case "connection-start-info":
          if (t.data) {
            const c = t.data;
            c && (console.assert(
              c.id !== void 0 && c.id !== null && c.id.length > 0,
              "server did not send connection id",
              c.id
            ), console.debug("Your id is: " + c.id, this.context.alias ?? ""), this._connectionId = c.id);
          } else
            console.warn("Expected connection id in " + t.key);
          break;
        case "joined-room":
          if (gi && console.log(t), t) {
            this._isInRoom = !0;
            const c = t;
            this._currentRoomName = c.room, this._currentRoomViewId = c.viewId, this._currentRoomAllowEditing = c.allowEditing ?? !0, this._currentInRoom.length = 0, this._currentInRoom.push(...c.inRoom), (Lf || z()) && console.debug("Joined Needle Engine Room: " + c.room);
            const h = new URL(window.location.href);
            h.searchParams.has("room") && h.searchParams.delete("room"), h.searchParams.set("view", this._currentRoomViewId), console.debug(`Room view id: ${this._currentRoomViewId}
${h.href}`);
          }
          this.onSendQueued(In.OnRoomJoin);
          break;
        case "left-room":
          t.room === this.currentRoomName && (this._isInRoom = !1, this._currentRoomName = null, this._currentInRoom.length = 0);
          break;
        case "user-joined-room":
          if (t.data) {
            const c = t.data;
            this._currentInRoom.push(c.userId), gi && console.log(c.userId + " joined", "now in room:", this._currentInRoom);
          }
          break;
        case "user-left-room":
          if (t.data) {
            const c = t.data, h = this._currentInRoom.indexOf(c.userId);
            h >= 0 && (gi && console.log(c.userId + " left", "now in room:", this._currentInRoom), this._currentInRoom.splice(h, 1)), c.userId === this.connectionId && console.log("you left the room");
          }
          break;
        case "all-room-state-deleted":
          gi && console.log("RECEIVED all-room-state-deleted"), this._state = {};
          break;
        case "ping":
        case "pong":
          const l = (n = t.data) == null ? void 0 : n.time;
          l && (this._currentDelay = this.context.time.time - l), gi && console.log("Current latency: " + this._currentDelay.toFixed(4) + " sec", "Clients in room: " + ((o = this._currentInRoom) == null ? void 0 : o.length));
          break;
      }
    const e = t.data;
    e && (this._state[e.guid] = e);
    let i = this._listeners[t.key];
    if (i) {
      i = [...i];
      for (const a of i)
        try {
          a(t.data);
        } catch (l) {
          console.error('Error invoking callback for "' + t.key + '"', l);
        }
    }
  }
  toMessage(t, e) {
    return {
      key: t,
      data: e
    };
  }
  sendWithWebsocket(t, e, i = In.OnRoomJoin) {
    if (!this._ws) {
      const o = this._waitingForSocket[i] || [];
      o.push(() => this.sendWithWebsocket(t, e, i)), this._waitingForSocket[i] = o;
      return;
    }
    const n = JSON.stringify(this.toMessage(t, e));
    gi && console.log(">>", t), this._ws.send(n);
  }
  onSendQueued(t) {
    const e = this._waitingForSocket[t];
    if (e) {
      for (const i of e)
        i();
      e.length = 0;
    }
  }
}
const lc = x("debugwebxr");
class jf {
  constructor(t, e) {
    r(this, "controllerStates", []);
    r(this, "userId");
    r(this, "context");
    r(this, "userStateEvtName");
    r(this, "onReceivedControllerState", (t) => {
      lc && console.log(`XRSync: Received change for ${this.userId}: ${t.type} ${t.handedness}; tracked=${t.isTracking}`);
      let e = !1;
      for (let i = 0; i < this.controllerStates.length; i++)
        if (this.controllerStates[i].index === t.index) {
          this.controllerStates[i] = t, e = !0;
          break;
        }
      e || this.controllerStates.push(t);
    });
    this.userId = t, this.context = e, this.userStateEvtName = "xr-sync-user-state-" + t, this.context.connection.beginListen(this.userStateEvtName, this.onReceivedControllerState);
  }
  dispose() {
    this.context.connection.stopListen(this.userStateEvtName, this.onReceivedControllerState);
  }
  update(t) {
    if (this.context.connection.isConnected != !1) {
      for (let e = this.controllerStates.length - 1; e >= 0; e--) {
        const i = this.controllerStates[e];
        let n = !1;
        for (let o = 0; o < t.controllers.length; o++)
          t.controllers[o].index === i.index && (n = !0);
        n || (lc && console.log(`XRSync: ${i.type} ${i.handedness} removed`, i.index), this.controllerStates.splice(e, 1), this.sendControllerRemoved(i));
      }
      for (const e of t.controllers)
        this.updateControllerStates(e);
    }
  }
  onExitXR(t) {
    for (const e of this.controllerStates)
      this.sendControllerRemoved(e);
    this.controllerStates.length = 0;
  }
  sendControllerRemoved(t) {
    t.isTracking = !1, t.guid = "", this.context.connection.send(this.userStateEvtName, t), this.context.connection.sendDeleteRemoteState(t.guid);
  }
  updateControllerStates(t) {
    const e = this.controllerStates.find((i) => i.index === t.index);
    if (e) {
      let i = !1;
      i || (i = e.isTracking != t.isTracking), i && (e.isTracking = t.isTracking, this.context.connection.send(this.userStateEvtName, e));
    } else {
      const i = {
        guid: this.userId + "-" + t.index,
        isTracking: t.isTracking,
        handedness: t.side,
        index: t.index,
        type: t.hand ? "hand" : "controller"
      };
      this.controllerStates.push(i), this.context.connection.send(this.userStateEvtName, i), lc && console.log(`XRSync: ${i.type} ${i.handedness} added`, i.index);
    }
  }
}
class oP {
  constructor(t) {
    r(this, "context");
    r(this, "onJoinedRoom", () => {
      if (this.context.connection.connectionId) {
        this._states.has(this.context.connection.connectionId) || (lc && console.log("XRSync: Local user joined room", this.context.connection.connectionId), this._states.set(this.context.connection.connectionId, new jf(this.context.connection.connectionId, this.context)));
        for (const t of this.context.connection.usersInRoom())
          this._states.has(t) || this._states.set(t, new jf(t, this.context));
      }
    });
    r(this, "onLeftRoom", () => {
      if (this.context.connection.connectionId && !this._states.has(this.context.connection.connectionId)) {
        const t = this._states.get(this.context.connection.connectionId);
        t == null || t.dispose(), this._states.delete(this.context.connection.connectionId);
      }
    });
    r(this, "onOtherUserJoinedRoom", (t) => {
      const e = t.userId;
      this._states.has(e) || (lc && console.log("XRSync: Remote user joined room", e), this._states.set(e, new jf(e, this.context)));
    });
    r(this, "onOtherUserLeftRoom", (t) => {
      const e = t.userId;
      if (!this._states.has(e)) {
        const i = this._states.get(e);
        i == null || i.dispose(), this._states.delete(e);
      }
    });
    r(this, "_states", /* @__PURE__ */ new Map());
    this.context = t, this.context.connection.beginListen(ne.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ne.LeftRoom, this.onLeftRoom), this.context.connection.beginListen(ne.UserJoinedRoom, this.onOtherUserJoinedRoom), this.context.connection.beginListen(ne.UserLeftRoom, this.onOtherUserLeftRoom);
  }
  hasState(t) {
    return t ? this._states.has(t) : !1;
  }
  /** Is the left controller or hand tracked */
  isTracking(t, e) {
    if (!t)
      return;
    const i = this._states.get(t);
    if (!i)
      return;
    const n = i.controllerStates.find((o) => o.handedness === e);
    return (n == null ? void 0 : n.isTracking) || !1;
  }
  /** Is it hand tracking or a controller */
  getDeviceType(t, e) {
    if (!t)
      return;
    const i = this._states.get(t);
    if (!i)
      return;
    const n = i.controllerStates.find((o) => o.handedness === e);
    return (n == null ? void 0 : n.type) || "unknown";
  }
  destroy() {
    this.context.connection.stopListen(ne.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ne.LeftRoom, this.onLeftRoom), this.context.connection.stopListen(ne.UserJoinedRoom, this.onOtherUserJoinedRoom), this.context.connection.stopListen(ne.UserLeftRoom, this.onOtherUserLeftRoom);
  }
  onUpdate(t) {
    if (this.context.connection.isConnected && this.context.connection.connectionId) {
      const e = this._states.get(this.context.connection.connectionId);
      e == null || e.update(t);
    }
  }
  onExitXR(t) {
    if (this.context.connection.isConnected && this.context.connection.connectionId) {
      const e = this._states.get(this.context.connection.connectionId);
      e == null || e.onExitXR(t);
    }
  }
}
class my {
  constructor() {
    r(this, "_fadeToColorQuad");
    r(this, "_fadeToColorMaterial");
    r(this, "_requestedFadeValue", 0);
    r(this, "_transitionPromise", null);
    r(this, "_transitionResolve", null);
    this._fadeToColorMaterial = new Me({
      color: 0,
      transparent: !0,
      depthTest: !1,
      fog: !1,
      side: Ri
    }), this._fadeToColorQuad = new q(new Xn(10, 10), this._fadeToColorMaterial);
  }
  dispose() {
    this._fadeToColorQuad.geometry.dispose(), this._fadeToColorMaterial.dispose();
  }
  update(t, e) {
    const i = this._fadeToColorQuad, n = this._fadeToColorMaterial;
    i.parent !== t && n.opacity > 0 ? t.add(i) : n.opacity === 0 && i.removeFromParent(), i.layers.set(2), i.material = this._fadeToColorMaterial, i.position.z = -1, i.renderOrder = 1 / 0;
    const o = this._requestedFadeValue;
    n.opacity = $.lerp(n.opacity, o, e / 0.03), Math.abs(n.opacity - o) <= 0.01 && this._transitionResolve && (this._transitionResolve(), this._transitionResolve = null, this._transitionPromise = null, this._requestedFadeValue = 0);
  }
  remove() {
    this._fadeToColorQuad.removeFromParent();
  }
  /** Call to fade rendering to black for a short moment (the returned promise will be resolved when fully black)   
   * This can be used to mask scene transitions or teleportation
   * @returns a promise that is resolved when the screen is fully black
   * @example `fadeTransition().then(() => { <fully_black> })`
  */
  fadeTransition() {
    if (this._transitionPromise)
      return this._transitionPromise;
    this._requestedFadeValue = 1;
    const t = new Promise((e) => {
      this._transitionResolve = e;
    });
    return this._transitionPromise = t, t;
  }
}
var Na = /* @__PURE__ */ ((s) => (s[s.Quad = 0] = "Quad", s[s.Cube = 1] = "Cube", s[s.Sphere = 2] = "Sphere", s[s.RoundedCube = 10] = "RoundedCube", s))(Na || {}), Hc, dm;
class Ar {
  /**
   * Creates a 3D text object
   * @param text The text to display
   * @param opts Options to create the object
   */
  static createText(t, e) {
    let i = null;
    const n = (e == null ? void 0 : e.font) || aP((e == null ? void 0 : e.familyFamily) || null);
    n instanceof Q1 ? i = Pl(this, Hc, dm).call(this, t, n, e) : i == null && (i = new Ps());
    const o = (e == null ? void 0 : e.color) || 16777215, a = new q(i, (e == null ? void 0 : e.material) ?? new It({ color: o }));
    return this.applyDefaultObjectOptions(a, e), n instanceof Promise ? n.then((l) => {
      a.geometry = Pl(this, Hc, dm).call(this, t, l, e), e != null && e.onGeometry && e.onGeometry(a);
    }) : e != null && e.onGeometry && e.onGeometry(a), a;
  }
  /**
   * Creates an occluder object that only render depth but not color
   * @param type The type of primitive to create
   * @returns The created object
   */
  static createOccluder(t) {
    const e = new Me({ colorWrite: !1, depthWrite: !0, side: Ri });
    return this.createPrimitive(t, { material: e });
  }
  static createPrimitive(t, e) {
    let i;
    const n = (e == null ? void 0 : e.color) || 16777215;
    switch (t) {
      case "Quad":
      case 0:
        {
          const o = new Xn(1, 1, 1, 1), a = (e == null ? void 0 : e.material) ?? new It({ color: n });
          e != null && e.texture && "map" in a && (a.map = e.texture), i = new q(o, a), i.name = "Quad";
        }
        break;
      case "Cube":
      case 1:
        {
          const o = new Da(1, 1, 1), a = (e == null ? void 0 : e.material) ?? new It({ color: n });
          e != null && e.texture && "map" in a && (a.map = e.texture), i = new q(o, a), i.name = "Cube";
        }
        break;
      case 10:
      case "RoundedCube":
        {
          const o = rP(1, 1, 1, 0.1, 2), a = (e == null ? void 0 : e.material) ?? new It({ color: n });
          e != null && e.texture && "map" in a && (a.map = e.texture), i = new q(o, a), i.name = "RoundedCube";
        }
        break;
      case "Sphere":
      case 2:
        {
          const o = new vu(0.5, 16, 16), a = (e == null ? void 0 : e.material) ?? new It({ color: n });
          e != null && e.texture && "map" in a && (a.map = e.texture), i = new q(o, a), i.name = "Sphere";
        }
        break;
      case "ShaderBall":
        i = new ho(), i.name = "ShaderBall", lP(i, e);
        break;
    }
    return this.applyDefaultObjectOptions(i, e), i;
  }
  /**
   * Creates a Sprite object  
   * @param opts Options to create the object
   * @returns The created object
   */
  static createSprite(t) {
    const i = new kx({ color: 16777215 });
    t != null && t.texture && "map" in i && (i.map = t.texture);
    const n = new Tx(i);
    return this.applyDefaultObjectOptions(n, t), n;
  }
  static applyDefaultObjectOptions(t, e) {
    t.receiveShadow = !0, t.castShadow = !0, e != null && e.name && (t.name = e.name), e != null && e.position && (Array.isArray(e.position) ? t.position.set(e.position[0], e.position[1], e.position[2]) : t.position.set(e.position.x, e.position.y, e.position.z)), e != null && e.rotation && (Array.isArray(e.rotation) ? t.rotation.set(e.rotation[0], e.rotation[1], e.rotation[2]) : t.rotation.set(e.rotation.x, e.rotation.y, e.rotation.z)), e != null && e.scale && (typeof e.scale == "number" ? t.scale.set(e.scale, e.scale, e.scale) : Array.isArray(e.scale) ? t.scale.set(e.scale[0], e.scale[1], e.scale[2]) : t.scale.set(e.scale.x, e.scale.y, e.scale.z)), (e == null ? void 0 : e.receiveShadow) != null && (t.receiveShadow = e.receiveShadow), (e == null ? void 0 : e.castShadow) != null && (t.castShadow = e.castShadow), e != null && e.parent && e.parent.add(t);
  }
}
Hc = new WeakSet(), dm = function(t, e, i) {
  const n = (i == null ? void 0 : i.depth) || 0.1;
  return new Y1(t, {
    font: e,
    size: 1,
    depth: n,
    height: n,
    bevelEnabled: (i == null ? void 0 : i.bevel) || !1,
    bevelThickness: 0.01,
    bevelOffset: 0.01,
    bevelSize: 0.01
  });
}, zi(Ar, Hc);
function rP(s, t, e, i, n) {
  const o = new Ax(), a = 1e-5, l = i - a;
  o.absarc(a, a, a, -Math.PI / 2, -Math.PI, !0), o.absarc(a, t - l * 2, a, Math.PI, Math.PI / 2, !0), o.absarc(s - l * 2, t - l * 2, a, Math.PI / 2, 0, !0), o.absarc(s - l * 2, a, a, 0, -Math.PI / 2, !0);
  const c = new Ex(o, {
    bevelEnabled: !0,
    bevelSegments: n * 2,
    steps: 1,
    bevelSize: l,
    bevelThickness: i,
    curveSegments: n
  });
  return c.scale(1, 1, 1 - i), c.center(), c.computeVertexNormals(), c;
}
const Ih = /* @__PURE__ */ new Map();
function aP(s) {
  let t = "";
  switch (s) {
    default:
    case "OpenSans":
      t = "https://cdn.needle.tools/static/fonts/facetype/Open Sans_Regular_ascii.json";
      break;
    case "Helvetiker":
      t = "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json";
      break;
  }
  if (Ih.has(t)) {
    const n = Ih.get(t);
    if (n)
      return n;
  }
  const e = new K1(), i = new Promise((n, o) => {
    e.load(t, (a) => {
      Ih.set(t, a), n(a);
    }, void 0, o);
  });
  return Ih.set(t, i), i;
}
let Bf = !1, Ff = null;
function lP(s, t) {
  if (Ff === null) {
    const e = "https://cdn.needle.tools/static/models/shaderball.glb", i = new xr(), n = hg(null);
    i.setDRACOLoader(n.dracoLoader), i.setKTX2Loader(n.ktx2Loader), Bf = !0, Ff = i.loadAsync(e).then((o) => {
      const a = o.scene;
      return a.position.y -= 0.5, a;
    }).catch((o) => (console.warn("Failed to load shaderball mesh: " + o.message), _y())).finally(() => {
      Bf = !1;
    });
  }
  if (Bf) {
    const e = _y();
    e.name = "ShaderBall-Placeholder";
    const i = e.children[0];
    (i == null ? void 0 : i.type) === "Mesh" && gy(i, t), s.add(e);
  }
  Ff.then((e) => {
    s.children.forEach((o) => {
      o.name === "ShaderBall-Placeholder" && s.remove(o);
    });
    const i = e.clone(), n = i.children[0];
    (n == null ? void 0 : n.type) === "Mesh" && gy(n, t), s.add(i);
  });
}
function gy(s, t) {
  var i;
  if ((t == null ? void 0 : t.color) || (t == null ? void 0 : t.material) || (t == null ? void 0 : t.texture)) {
    const n = (t == null ? void 0 : t.material) ?? ((i = s.material) == null ? void 0 : i.clone()) ?? new It();
    t.color && "color" in n && n.color instanceof ae && n.color.set(t.color), t != null && t.texture && "map" in n && (n.map = t.texture), s.material = n;
  }
}
function _y() {
  return new ho().add(Ar.createPrimitive("Sphere", { material: new Me({ transparent: !0, opacity: 0.1 }) }));
}
const S_ = class {
  constructor(t, e, i) {
    r(this, "_session");
    r(this, "_mode");
    r(this, "_init");
    r(this, "_renderer");
    r(this, "_camera");
    r(this, "_scene");
    r(this, "onEnd", () => {
      var t;
      (t = this._session) == null || t.removeEventListener("end", this.onEnd), this._renderer.setAnimationLoop(null), this._renderer.dispose(), this._scene.clear();
    });
    r(this, "_lastTime", 0);
    r(this, "onFrame", (t, e) => {
      const i = t - this._lastTime;
      this.update(t, i), this._camera.parent !== this._scene && this._scene.add(this._camera), this._renderer.render(this._scene, this._camera);
    });
    r(this, "_objects", []);
    this._mode = t, this._init = e, this._session = i, this._session.addEventListener("end", this.onEnd), this._renderer = new kr({ alpha: !0 }), this._renderer.setAnimationLoop(this.onFrame), this._renderer.xr.setSession(i), this._renderer.xr.enabled = !0, this._camera = new ye(), this._scene = new Mi(), this._scene.fog = new Jb(4473924, 10, 250), this._scene.add(this._camera), this.setupScene();
  }
  static get active() {
    return this._active;
  }
  static async start(t, e) {
    if (this._active)
      return console.error("Cannot start a new XR session while one is already active"), null;
    if (this._requestInFlight)
      return console.error("Cannot start a new XR session while a request is already in flight"), null;
    if ("xr" in navigator && navigator.xr) {
      if (!e)
        return console.error("XRSessionInit must be provided"), null;
      this._requestInFlight = !0;
      const i = await navigator.xr.requestSession(t, e);
      return i.addEventListener("end", () => {
        this._active = null;
      }), this._requestInFlight ? (this._requestInFlight = !1, this._active = new S_(t, e, i), this._active) : (i.end(), null);
    }
    return null;
  }
  static async handoff() {
    return this._active ? this._active.handoff() : null;
  }
  static async stop() {
    this._requestInFlight = !1, this._active && (await this._active.end(), await Gn(100)), this._active = null;
  }
  get isAR() {
    return this._mode === "immersive-ar";
  }
  end() {
    return this._session ? this._session.end() : Promise.resolve();
  }
  /** returns the session and session info and stops the temporary rendering */
  async handoff() {
    if (!this._session)
      throw new Error("Cannot handoff a session that has already ended");
    const t = {
      session: this._session,
      mode: this._mode,
      init: this._init
    };
    return await this.onBeforeHandoff(), this.onEnd(), this._session = null, t;
  }
  /** can be used to prepare the user or fade to black */
  async onBeforeHandoff() {
    await Gn(1e3), this._scene.clear();
  }
  setupScene() {
    this._scene.background = new ae(0), this._scene.add(new ig(5, 10, 1118481, 1118481));
    const t = new Yp(16777215, 1);
    t.position.set(0, 20, 0), t.castShadow = !1, this._scene.add(t);
    const e = new Yp(16777215, 1);
    e.position.set(0, -1, 0), e.castShadow = !1, this._scene.add(e);
    const i = new ng(16777215, 1, 100, 1);
    i.position.set(0, 2, 0), i.castShadow = !1, i.distance = 200, this._scene.add(i);
    const n = 50;
    for (let o = 0; o < 100; o++) {
      const a = new It({
        color: 2236962,
        metalness: 1,
        roughness: 0.8
      });
      this.isAR && (a.emissive = new ae(Math.random(), Math.random(), Math.random()), a.emissiveIntensity = Math.random());
      const l = $.random(0, 1) > 0.5 ? Na.Sphere : Na.Cube, c = Ar.createPrimitive(l, {
        material: a
      });
      c.position.x = $.random(-n, n), c.position.y = $.random(-2, n), c.position.z = $.random(-n, n), c.rotation.x = $.random(0, Math.PI * 2), c.rotation.y = $.random(0, Math.PI * 2), c.rotation.z = $.random(0, Math.PI * 2), c.scale.multiplyScalar(0.5 + Math.random() * 10);
      const h = c.position.distanceTo(this._camera.position) - c.scale.x;
      h < 1 && c.position.multiplyScalar(1 + 1 / h), this._objects.push(c), this._scene.add(c);
    }
  }
  update(t, e) {
    const i = t * 4e-4;
    for (let n = 0; n < this._objects.length; n++) {
      const o = this._objects[n];
      o.position.y += Math.sin(i + n * 0.5) * 5e-3, o.rotateY(2e-3);
    }
  }
};
let ro = S_;
r(ro, "_active", null), r(ro, "_requestInFlight", !1);
var jc;
((s) => {
  const t = [];
  function e() {
    if (!(t != null && t.length))
      return !1;
    for (const o of t)
      o.exportAndOpen();
    return !0;
  }
  s.exportAndOpen = e;
  function i(o) {
    t.push(o);
  }
  s.registerExporter = i;
  function n(o) {
    if (!t)
      return;
    const a = t.indexOf(o);
    a >= 0 && t.splice(a, 1);
  }
  s.unregisterExporter = n;
})(jc || (jc = {}));
const yy = "NeedleXRSession onStart", by = "NeedleXRSession onEnd", ft = x("debugwebxr"), vy = x("stats");
let zf = 0;
function cP(s) {
  let t = null;
  const e = s;
  return e.getAROverlayContainer ? t = e.getAROverlayContainer() : t = s, t;
}
hP();
async function hP() {
  var s;
  if (x("debugasap")) {
    let t = globalThis["needle:XRSession"];
    if (t instanceof Promise) {
      delete globalThis["needle:XRSession"], fe.addContextCreatedCallback(async (e) => {
        if (!t)
          return;
        xa(!0);
        const i = await t;
        if (i) {
          const n = J.getDefaultSessionInit("immersive-vr");
          J.setSession("immersive-vr", i, n, e.context);
        } else
          console.error("NeedleXRSession: ASAP session was rejected");
        t = void 0;
      });
      return;
    }
  }
  if ("xr" in navigator) {
    if (/WebXRViewer\//i.test(navigator.userAgent)) {
      console.warn("WebXRViewer does not support addEventListener");
      return;
    }
    (s = navigator.xr) == null || s.addEventListener("sessiongranted", async () => {
      xa(!0), console.log("Received Session Granted..."), await Gn(100);
      const t = sessionStorage.getItem("needle_xr_session_mode"), e = sessionStorage.getItem("needle_xr_session_init") ?? null, i = e ? JSON.parse(e) : null;
      let n = null;
      if (Q0() && (await ro.start(t || "immersive-vr", i || J.getDefaultSessionInit("immersive-vr")), await fP(), n = await ro.handoff()), n)
        J.setSession(n.mode, n.session, n.init, ee.Current);
      else if (t && e) {
        console.log("Session Granted: Restore last session");
        const o = JSON.parse(e);
        J.start(t, o).catch((a) => console.warn(a));
      } else
        J.start("immersive-vr").catch((o) => console.warn("Session Granted failed:", o));
    }, { once: !0 });
  }
}
function dP(s, t) {
  sessionStorage.setItem("needle_xr_session_mode", s), sessionStorage.setItem("needle_xr_session_init", JSON.stringify(t));
}
function uP() {
  sessionStorage.removeItem("needle_xr_session_mode"), sessionStorage.removeItem("needle_xr_session_init");
}
const xg = /* @__PURE__ */ new Set();
fe.registerCallback(pe.ContextCreationStart, async (s) => {
  xg.add(s.context);
});
fe.registerCallback(pe.ContextCreated, async (s) => {
  xg.delete(s.context);
});
function Q0() {
  return xg.size > 0;
}
function fP() {
  return new Promise((s) => {
    const t = Date.now(), e = setInterval(() => {
      (!Q0() || Date.now() - t > 6e4) && (clearInterval(e), s());
    }, 100);
  });
}
X.isDesktop() && z() && window.addEventListener("keydown", (s) => {
  (s.key === "x" || s.key === "Escape") && J.active && J.stop();
});
const ps = class {
  constructor(t, e, i, n) {
    /** The needle engine context this session was started from */
    r(this, "context");
    /**
     * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession
     */
    r(this, "session");
    /** XR Session Mode: AR or VR */
    r(this, "mode");
    /** The currently active/connected controllers */
    r(this, "controllers", []);
    r(this, "_rigScale", 1);
    r(this, "_lastRigScaleUpdate", -1);
    r(this, "_rigs", []);
    r(this, "_viewerHitTestSource", null);
    /** this is the implictly created XR rig */
    r(this, "_defaultRig");
    /** all scripts that receive some sort of XR update event */
    r(this, "_xr_scripts");
    /** scripts that have onUpdateXR event methods */
    r(this, "_xr_update_scripts", []);
    /** scripts that are in the scene but inactive (e.g. disabled parent gameObject) */
    r(this, "_inactive_scripts", []);
    r(this, "_controllerAdded");
    r(this, "_controllerRemoved");
    r(this, "_originalCameraWorldPosition");
    r(this, "_originalCameraWorldRotation");
    r(this, "_originalCameraWorldScale");
    r(this, "_originalCameraParent");
    /** we store the main camera reference here each frame to make sure we have a rendering camera
     * this e.g. the case when the XR rig with the camera gets disabled (and thus this.context.mainCamera is unassigned)
     */
    r(this, "_mainCamera", null);
    /** called when renderer.setSession is fulfilled */
    r(this, "onRendererSessionSet", () => {
      var t;
      this.running && (this.context.renderer.xr.enabled = !0, this.context.renderer.xr.updateCamera(this.context.mainCamera), (t = this.context.mainCameraComponent) == null || t.applyClearFlags());
    });
    r(this, "onInputSourceAdded", (t) => {
      if (t.targetRayMode === "screen")
        return;
      let e = 0;
      for (let n = 0; n < this.session.inputSources.length; n++)
        if (this.session.inputSources[n] === t) {
          e = n;
          break;
        }
      if (this.controllers.find((n) => n.inputSource === t)) {
        console.debug("Controller already exists for input source", e);
        return;
      } else if (this._newControllers.find((n) => n.inputSource === t)) {
        console.debug("Controller already registered for input source", e);
        return;
      }
      const i = new V0(this, t, e);
      this._newControllers.push(i);
    });
    r(this, "_ended", !1);
    r(this, "_newControllers", []);
    r(this, "onEnd", (t) => {
      var o, a, l;
      if (this._ended)
        return;
      this._ended = !0, console.debug("XR Session ended"), uP(), this.onAfterRender(), this.revertCustomForward(), this._didStart = !1, this._previousCameraParent = null, Po(this.onBefore, Re.LateUpdate);
      const e = this.context.pre_render_callbacks.indexOf(this.onBeforeRender);
      e >= 0 && this.context.pre_render_callbacks.splice(e, 1);
      const i = this.context.post_render_callbacks.indexOf(this.onAfterRender);
      i >= 0 && this.context.post_render_callbacks.splice(i, 1), this.context.xr = null, this.context.renderer.xr.enabled = !1, this.context.pre_update_oneshot_callbacks.push(() => {
        var c, h;
        (c = this.context.mainCameraComponent) == null || c.applyClearFlags(), (h = this.context.mainCameraComponent) == null || h.applyClippingPlane();
      }), $C({ session: this });
      for (const c of ps._xrEndListeners)
        c({ xr: this });
      const n = [...this.controllers];
      for (let c = 0; c < n.length; c++)
        this.disconnectInputSource(n[c].inputSource);
      this._newControllers.length = 0, this.controllers.length = 0;
      for (const c of this._xr_scripts)
        (o = c == null ? void 0 : c.onLeaveXR) == null || o.call(c, { xr: this });
      (a = this.sync) == null || a.onExitXR(this), this.context.mainCamera && ((l = this._originalCameraParent) == null || l.add(this.context.mainCamera), this._originalCameraWorldPosition && yt(this.context.mainCamera, this._originalCameraWorldPosition), this._originalCameraWorldRotation && wn(this.context.mainCamera, this._originalCameraWorldRotation), this._originalCameraWorldScale && Lc(this.context.mainCamera, this._originalCameraWorldScale)), this.context.requestSizeUpdate(), this._defaultRig.gameObject.removeFromParent(), xa(!1), performance.mark(by), performance.measure("NeedleXRSession", yy, by);
    });
    r(this, "_didStart", !1);
    /** Called every frame by the engine */
    r(this, "onBefore", (t) => {
      var n, o, a, l, c, h, d, u;
      const e = t.xrFrame;
      if (!e)
        return;
      performance.mark("NeedleXRSession onBefore start"), this.context.xr = this, this.context.mainCameraComponent && this.context.mainCameraComponent !== this._mainCamera && (this._mainCamera = this.context.mainCameraComponent), ((n = this.rig) == null ? void 0 : n.isActive) == !1 && (ft && console.warn("Latest rig is not active - trying to activate a different rig", this.rig), this.updateActiveXRRig()), this.rig && ((o = this._mainCamera) != null && o.gameObject) && ((l = (a = this._mainCamera) == null ? void 0 : a.gameObject) == null ? void 0 : l.parent) !== this.rig.gameObject && this.rig.gameObject.add((c = this._mainCamera) == null ? void 0 : c.gameObject), this.internalUpdateState(), this.applyCustomForward();
      const i = { xr: this };
      if (this._didStart) {
        if (this.context.new_scripts_xr.length > 0) {
          const p = [...this.context.new_scripts_xr];
          for (let m = 0; m < p.length; m++) {
            const g = this.context.new_scripts_xr[m];
            if (!g || g.destroyed || ((h = g.supportsXR) == null ? void 0 : h.call(g, this.mode)) == !1) {
              this.context.new_scripts_xr.splice(m, 1);
              continue;
            }
            if (!g.activeAndEnabled) {
              this.context.new_scripts_xr.splice(m, 1), this.markInactive(g);
              continue;
            }
            if (this.addScript(g)) {
              this.invokeCallback_EnterXR(g);
              for (const _ of this.controllers)
                this.invokeCallback_ControllerAdded(g, _);
            }
          }
        }
      } else {
        if (this._didStart = !0, this.mode === "immersive-vr") {
          const m = ki(this.context.scene.children);
          if (m) {
            const g = m.getSize(G());
            if (g.length() > 0) {
              const _ = this._defaultRig.gameObject;
              _.position.set(m.min.x + g.x * 0.5, m.min.y, m.max.z + g.z * 0.5 + 1.5);
              const y = m.getCenter(G());
              y.y = _.position.y, _.lookAt(y);
            }
          }
        }
        NC({ session: this });
        for (const m of ps._xrStartListeners)
          m(i);
        const p = [...this._xr_scripts];
        ft && console.log("NeedleXRSession start, handle scripts:", p);
        for (const m of p) {
          if (m.destroyed) {
            this._script_to_remove.push(m);
            continue;
          }
          if (!m.activeAndEnabled) {
            this.markInactive(m);
            continue;
          }
          this.invokeCallback_EnterXR(m);
          for (const g of this.controllers)
            this.invokeCallback_ControllerAdded(m, g);
        }
      }
      this.syncCameraCullingMask();
      for (const p of this.controllers)
        p.onUpdate(e);
      if (this._newControllers.length > 0) {
        const p = [...this._newControllers];
        this._newControllers.length = 0;
        for (const m of p) {
          if (!m.connected) {
            console.warn("New controller is not connected", m);
            continue;
          }
          this.controllers.push(m);
          for (const g of this._xr_scripts) {
            if (g.destroyed) {
              this._script_to_remove.push(g);
              continue;
            }
            g.activeAndEnabled !== !1 && this.invokeCallback_ControllerAdded(g, m);
          }
        }
        this.controllers.sort((m, g) => m.index - g.index);
      }
      ft && this.context.time.frame % 30 === 0 && this.controllers.length <= 0 && this.session.inputSources.length > 0 && (xa(!0), console.error("XRControllers are not added but inputSources are present")), performance.mark("NeedleXRSession update scripts start");
      for (const p of this._xr_update_scripts) {
        if (p.destroyed === !0) {
          this._script_to_remove.push(p);
          continue;
        }
        if (p.activeAndEnabled === !1) {
          this.markInactive(p);
          continue;
        }
        p.onUpdateXR && p.onUpdateXR(i);
      }
      if (performance.mark("NeedleXRSession update scripts end"), performance.measure("NeedleXRSession update scripts", "NeedleXRSession update scripts start", "NeedleXRSession update scripts end"), this.handleInactiveScripts(), this._script_to_remove.length > 0) {
        const p = [...new Set(this._script_to_remove)];
        this._script_to_remove.length = 0;
        for (const m of p)
          !m.destroyed && this.running && ((d = m.onLeaveXR) == null || d.call(m, i)), this.removeScript(m);
      }
      (u = this.sync) == null || u.onUpdate(this), this.onRenderDebug(), performance.mark("NeedleXRSession onBefore end"), performance.measure("NE XR frame", "NeedleXRSession onBefore start", "NeedleXRSession onBefore end");
    });
    r(this, "onBeforeRender", () => {
      this.context.mainCamera && this.updateFade(this.context.mainCamera);
    });
    r(this, "onAfterRender", () => {
      if (this.onUpdateFade_PostRender(), X.isDesktop() || !this._renderOnceOnDevice) {
        const t = this.context.renderer;
        if (t.xr.isPresenting && this.context.mainCamera) {
          this._renderOnceOnDevice = !0;
          const e = t.xr.enabled, i = t.getRenderTarget(), n = this.context.scene.background;
          t.xr.enabled = !1, t.setRenderTarget(null), this.isPassThrough && (this.context.scene.background = null), this.context.composer ? this.context.composer.render(this.context.time.deltaTime) : t.render(this.context.scene, this.context.mainCamera), t.xr.enabled = e, t.setRenderTarget(i), this.context.scene.background = n;
        }
      }
    });
    r(this, "_script_to_remove", []);
    r(this, "_camera");
    r(this, "_cameraRenderParent", new L().rotateY(Math.PI));
    r(this, "_previousCameraParent");
    r(this, "_customforward", !0);
    r(this, "originalCameraNearPlane");
    r(this, "_viewerPose");
    r(this, "_transformOrientation", new W());
    r(this, "_transformPosition", new v());
    // TODO: for scene transitions (e.g. SceneSwitcher) where creating the scene might take a few moments we might want more control over when/how this fading occurs and how long the scene stays black
    r(this, "_transition");
    var o, a;
    performance.mark(yy), dP(t, n.init), this.session = e, this.mode = t, this.context = i, (ft || x("console")) && xa(!0), this._xr_scripts = [...n.scripts], this._xr_update_scripts = this._xr_scripts.filter((l) => typeof l.onUpdateXR == "function"), this._controllerAdded = n.controller_added, this._controllerRemoved = n.controller_removed, Ds(this.onBefore, Re.LateUpdate), this.context.pre_render_callbacks.push(this.onBeforeRender), this.context.post_render_callbacks.push(this.onAfterRender), ((o = n.init.optionalFeatures) != null && o.includes("hit-test") || (a = n.init.requiredFeatures) != null && a.includes("hit-test")) && e.requestReferenceSpace("viewer").then((l) => {
      var c, h;
      return (h = (c = e.requestHitTestSource) == null ? void 0 : c.call(e, { space: l })) == null ? void 0 : h.then((d) => this._viewerHitTestSource = d).catch((d) => console.error(d));
    }).catch((l) => console.error(l)), this.context.mainCamera && (this._originalCameraWorldPosition = ie(this.context.mainCamera, new v()), this._originalCameraWorldRotation = Ce(this.context.mainCamera, new W()), this._originalCameraWorldScale = Ke(this.context.mainCamera, new v()), this._originalCameraParent = this.context.mainCamera.parent), this._defaultRig = new HC(), this.context.scene.add(this._defaultRig.gameObject), this.addRig(this._defaultRig);
    for (let l = 0; l < e.inputSources.length; l++) {
      const c = e.inputSources[l];
      if (!c.handedness) {
        console.warn("Input source in xr session has no handedness - ignoring", l);
        continue;
      }
      this.onInputSourceAdded(c);
    }
    this.session.addEventListener("end", this.onEnd), this.session.addEventListener(
      "inputsourceschange",
      /* @ts-ignore (ignore CI XRInputSourceChangeEvent mismatch) */
      (l) => {
        for (const c of l.removed)
          this.disconnectInputSource(c);
        for (const c of l.added)
          this.onInputSourceAdded(c);
      }
    ), this.context.xr = this, this.context.renderer.xr.setSession(this.session).then(this.onRendererSessionSet), "controllerAutoUpdate" in this.context.renderer.xr ? (console.debug("Disabling three.js controllerAutoUpdate"), this.context.renderer.xr.controllerAutoUpdate = !1) : ft && console.warn("controllerAutoUpdate is not available in three.js - cannot disable it");
  }
  static getXRSync(t) {
    return this._sync || (this._sync = new oP(t)), this._sync;
  }
  static get currentSessionRequest() {
    return this._currentSessionRequestMode;
  }
  /**
   * @returns the active @type {NeedleXRSession} (if any active) or null
   */
  static get active() {
    return this._activeSession;
  }
  /** The active xr session mode (if any xr session is active) 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSessionMode
  */
  static get activeMode() {
    var t;
    return ((t = this._activeSession) == null ? void 0 : t.mode) ?? null;
  }
  /** XRSystem via navigator.xr access
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem
   */
  static get xrSystem() {
    return "xr" in navigator ? navigator.xr : void 0;
  }
  /**
   * @returns true if the browser supports WebXR (`immersive-vr` or `immersive-ar`)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
   */
  static isXRSupported() {
    return Promise.all([this.isVRSupported(), this.isARSupported()]).then((t) => t.some((e) => e)).catch(() => !1);
  }
  /** 
   * @returns true if the browser supports immersive-vr (WebXR)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
   */
  static isVRSupported() {
    return this.isSessionSupported("immersive-vr");
  }
  /** 
   * @returns true if the browser supports immersive-ar (WebXR) 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported
  */
  static isARSupported() {
    return this.isSessionSupported("immersive-ar");
  }
  /**
   * @param mode The XRSessionMode to check if it is supported
   * @returns true if the browser supports the given XRSessionMode
   */
  static isSessionSupported(t) {
    var e;
    return ((e = this.xrSystem) == null ? void 0 : e.isSessionSupported(t).catch((i) => (ft && console.error(i), !1))) ?? Promise.resolve(!1);
  }
  /** Register to listen to XRSession start events. Unsubscribe with `offXRSessionStart` */
  static onSessionRequestStart(t) {
    this._sessionRequestStartListeners.push(t);
  }
  /** Unsubscribe from request start evt. Register with `onSessionRequestStart` */
  static offSessionRequestStart(t) {
    const e = this._sessionRequestStartListeners.indexOf(t);
    e >= 0 && this._sessionRequestStartListeners.splice(e, 1);
  }
  /** Called after the session request has finished */
  static onSessionRequestEnd(t) {
    this._sessionRequestEndListeners.push(t);
  }
  /** Unsubscribe from request end evt */
  static offSessionRequestEnd(t) {
    const e = this._sessionRequestEndListeners.indexOf(t);
    e >= 0 && this._sessionRequestEndListeners.splice(e, 1);
  }
  /** Listen to XR session started. Unsubscribe with `offXRSessionStart` */
  static onXRSessionStart(t) {
    this._xrStartListeners.push(t);
  }
  /** Unsubscribe from XRSession started events */
  static offXRSessionStart(t) {
    const e = this._xrStartListeners.indexOf(t);
    e >= 0 && this._xrStartListeners.splice(e, 1);
  }
  /** Listen to XR session ended. Unsubscribe with `offXRSessionEnd` */
  static onXRSessionEnd(t) {
    this._xrEndListeners.push(t);
  }
  /** Unsubscribe from XRSession started events */
  static offXRSessionEnd(t) {
    const e = this._xrEndListeners.indexOf(t);
    e >= 0 && this._xrEndListeners.splice(e, 1);
  }
  /** Listen to controller added events. 
   * Events are cleared when starting a new session 
   **/
  static onControllerAdded(t) {
    this._controllerAddedListeners.push(t);
  }
  /** Unsubscribe from controller added evts */
  static offControllerAdded(t) {
    const e = this._controllerAddedListeners.indexOf(t);
    e >= 0 && this._controllerAddedListeners.splice(e, 1);
  }
  /** Listen to controller removed events 
   * Events are cleared when starting a new session 
   **/
  static onControllerRemoved(t) {
    this._controllerRemovedListeners.push(t);
  }
  /** Unsubscribe from controller removed events */
  static offControllerRemoved(t) {
    const e = this._controllerRemovedListeners.indexOf(t);
    e >= 0 && this._controllerRemovedListeners.splice(e, 1);
  }
  /** If the browser supports offerSession - creating a VR or AR button in the browser navigation bar */
  static offerSession(t, e, i) {
    return "xr" in navigator && navigator.xr && "offerSession" in navigator.xr ? (typeof navigator.xr.offerSession == "function" && (console.log("WebXR offerSession is available - requesting mode: " + t), e == "default" && (e = this.getDefaultSessionInit(t)), navigator.xr.offerSession(t, {
      ...e
    }).then((n) => ps.setSession(t, n, e, i)).catch((n) => {
      console.log("XRSession offer rejected (perhaps because another call to offerSession was made or a call to requestSession was made)");
    })), !0) : !1;
  }
  /** @returns a new XRSession init object with defaults */
  static getDefaultSessionInit(t) {
    switch (t) {
      case "immersive-ar":
        const e = ["anchors", "local-floor", "layers", "dom-overlay", "hit-test", "unbounded"];
        return X.isVisionOS() || e.push("hand-tracking"), {
          optionalFeatures: e
        };
      case "immersive-vr":
        const i = ["local-floor", "bounded-floor", "high-fixed-foveation-level", "layers"];
        return X.isVisionOS() || i.push("hand-tracking"), {
          optionalFeatures: i
        };
      default:
        return console.warn("No default session init for mode", t), {};
    }
  }
  /** start a new webXR session (make sure to stop already running sessions before calling this method)
   * @param mode The XRSessionMode to start (e.g. `immersive-vr` or `immersive-ar`) or `ar` to start `immersive-ar` on supported devices OR on iOS devices it will export an interactive USDZ and open in Quicklook.  
   * Get more information about WebXR modes: https://developer.mozilla.org/en-US/docs/Web/API/XRSessionMode
   * @param init The XRSessionInit to use (optional), docs: https://developer.mozilla.org/en-US/docs/Web/API/XRSessionInit
   * @param context The Needle Engine context to use
   */
  static async start(t, e, i) {
    var l, c, h, d;
    if (X.isiOS()) {
      if (t === "ar")
        if (await this.isARSupported())
          t = "immersive-ar";
        else
          return jc.exportAndOpen(), null;
    } else
      t == "ar" && (t = "immersive-ar");
    if (z() && x("debugxrpreroom"))
      return console.warn("Debug: Starting temporary XR session"), await ro.start(t, e || ps.getDefaultSessionInit(t)), null;
    if (this._currentSessionRequest)
      return console.warn("A XRSession is already being requested"), (ft || z()) && ve("A XRSession is already being requested"), this._currentSessionRequest.then(() => this._activeSession);
    if (this._activeSession)
      return console.error("A XRSession is already running"), this._activeSession;
    if (i || (i = ee.Current), i || (i = fe.All[0]), !i)
      throw new Error("No Needle Engine Context found");
    switch (performance.mark("NeedleXRSession start"), e || (e = {}), t) {
      case "immersive-ar":
        {
          if (await ((l = this.xrSystem) == null ? void 0 : l.isSessionSupported("immersive-ar")) !== !0)
            return console.error(t + " is not supported by this browser."), null;
          const p = this.getDefaultSessionInit(t), m = cP(i.domElement);
          m && !X.isQuest() && (p.domOverlay = { root: m }, p.optionalFeatures.push("dom-overlay")), e = {
            ...p,
            ...e
          };
        }
        break;
      case "immersive-vr":
        {
          if (await ((c = this.xrSystem) == null ? void 0 : c.isSessionSupported("immersive-vr")) !== !0)
            return console.error(t + " is not supported by this browser."), null;
          e = {
            ...this.getDefaultSessionInit(t),
            ...e
          };
        }
        break;
      default:
        console.warn("No default session init for mode", t);
        break;
    }
    e.optionalFeatures ?? (e.optionalFeatures = []), e.requiredFeatures ?? (e.requiredFeatures = []), await ro.stop();
    const n = t == "immersive-ar" ? i.scripts_immersive_ar : i.scripts_immersive_vr;
    ft ? console.log(`%cRequesting ${t} session`, "font-weight:bold;", e, n) : console.log(`%cRequesting ${t} session`, "font-weight:bold;");
    for (const u of n)
      u.onBeforeXR && u.onBeforeXR(t, e);
    for (const u of this._sessionRequestStartListeners)
      u({ mode: t, init: e });
    ft && We("Requesting " + t + " session (" + Date.now() + ")"), this._currentSessionRequest = (h = navigator.xr) == null ? void 0 : h.requestSession(t, e), this._currentSessionRequestMode = t;
    const o = await ((d = this._currentSessionRequest) == null ? void 0 : d.catch((u) => {
      console.error(u, "Code: " + u.code), u.code === 9 && ve("Make sure your device has the required permissions (e.g. camera access)"), console.log("If the specified XR configuration is not supported (e.g. entering AR doesnt work) - make sure you access the website on a secure connection (HTTPS) and your device has the required permissions (e.g. camera access)"), location.protocol === "http:" && ve("XR requires a secure connection (HTTPS)");
    }));
    this._currentSessionRequest = void 0, this._currentSessionRequestMode = null;
    for (const u of this._sessionRequestEndListeners)
      u({ mode: t, init: e, newSession: o || null });
    if (!o)
      return console.warn("XR Session request was rejected"), null;
    const a = this.setSession(t, o, e, i);
    return performance.mark("NeedleXRSession end"), performance.measure("NeedleXRSession Startup", "NeedleXRSession start", "NeedleXRSession end"), a;
  }
  static setSession(t, e, i, n) {
    if (this._activeSession)
      return console.error("A XRSession is already running"), this._activeSession;
    const o = t == "immersive-ar" ? n.scripts_immersive_ar : n.scripts_immersive_vr;
    return this._activeSession = new ps(t, e, n, {
      scripts: o,
      controller_added: this._controllerAddedListeners,
      controller_removed: this._controllerRemovedListeners,
      init: i
    }), e.addEventListener("end", this.onEnd), ft ? console.log(`%cStarted ${t} session`, "font-weight:bold;", o) : console.log(`%cStarted ${t} session`, "font-weight:bold;"), this._activeSession;
  }
  /** stops the active XR session */
  static stop() {
    var t;
    (t = this._activeSession) == null || t.end();
  }
  get sync() {
    return ps._sync;
  }
  /** Returns true if the xr session is still active */
  get running() {
    return !this._ended && this.session != null;
  }
  /** 
   * The XRSession interface's read-only interactionMode property describes the best space (according to the user agent) for the application to draw an interactive UI for the current session.
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/interactionMode 
   */
  get interactionMode() {
    return this.session.interactionMode;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/visibilityState
   * @returns {XRVisibilityState} The visibility state of the XRSession
   */
  get visibilityState() {
    return this.session.visibilityState;
  }
  /**
   * Check if the session is `visible-blurred` - this means e.g. the keyboard is shown
   */
  get isVisibleBlurred() {
    return this.session.visibilityState === "visible-blurred";
  }
  /**
   * Check if the session has system keyboard support
   */
  get isSystemKeyboardSupported() {
    return this.session.isSystemKeyboardSupported;
  }
  /**
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRSession/environmentBlendMode
   */
  get environmentBlendMode() {
    return this.session.environmentBlendMode;
  }
  /** 
   * The current XR frame 
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRFrame
   */
  get frame() {
    return this.context.xrFrame;
  }
  /** shorthand to query the left controller. Use `controllers` to get access to all connected controllers */
  get leftController() {
    return this.controllers.find((t) => t.side === "left");
  }
  /** shorthand to query the right controller. Use `controllers` to get access to all connected controllers */
  get rightController() {
    return this.controllers.find((t) => t.side === "right");
  }
  /** @returns the given controller if it is connected */
  getController(t) {
    return typeof t == "number" ? this.controllers[t] || null : this.controllers.find((e) => e.side === t) || null;
  }
  /** Returns true if running in pass through mode in immersive AR (e.g. user is wearing a headset while in AR) */
  get isPassThrough() {
    return !!(this.environmentBlendMode !== "opaque" && this.interactionMode === "world-space" || this.mode === "immersive-ar" && this.environmentBlendMode !== "opaque" && this.controllers.some((t) => t.inputSource.targetRayMode === "tracked-pointer") || z() && X.isDesktop() && this.mode === "immersive-ar");
  }
  get isAR() {
    return this.mode === "immersive-ar";
  }
  get isVR() {
    return this.mode === "immersive-vr";
  }
  /** If the AR mode is not immersive (meaning the user is e.g. holding a phone instead of wearing a AR passthrough headset) */
  get isScreenBasedAR() {
    return this.isAR && !this.isPassThrough;
  }
  get posePosition() {
    return this._transformPosition;
  }
  get poseOrientation() {
    return this._transformOrientation;
  }
  /** @returns the context.renderer.xr.getReferenceSpace() result */
  get referenceSpace() {
    return this.context.renderer.xr.getReferenceSpace();
  }
  /** @returns the XRFrame `viewerpose` using the xr `referenceSpace` */
  get viewerPose() {
    return this._viewerPose;
  }
  /** @returns `true` if any image is currently being tracked */
  /** returns true if images are currently being tracked */
  get isTrackingImages() {
    if (this.frame && "getImageTrackingResults" in this.frame && typeof this.frame.getImageTrackingResults == "function")
      try {
        const t = this.frame.getImageTrackingResults();
        for (const e of t)
          if (e.trackingState === "tracked")
            return !0;
      } catch {
        return !1;
      }
    return !1;
  }
  /** The currently active XR rig */
  get rig() {
    const t = this._rigs[0] ?? null;
    return t != null && t.gameObject && Wa(t.gameObject) || (t == null ? void 0 : t.isActive) === !1 ? (this.updateActiveXRRig(), this._rigs[0] ?? null) : t;
  }
  /** Get the XR Rig worldscale.   
   * 
   * **For AR**   
   * If you want to modify the scale in AR at runtime get the WebARSessionRoot component via `findObjectOfType(WebARSessionRoot)` and then set the `arScale` value. 
   * 
  */
  get rigScale() {
    return this._rigs[0] ? (this._lastRigScaleUpdate !== this.context.time.frame && (this._lastRigScaleUpdate = this.context.time.frame, this._rigScale = this._rigs[0].gameObject.worldScale.x), this._rigScale) : 1;
  }
  /** add a rig to the available XR rigs - if it's priority is higher than the currently active rig it will be enabled */
  addRig(t) {
    this._rigs.indexOf(t) >= 0 || (t.priority === void 0 && (t.priority = 0), this._rigs.push(t), this.updateActiveXRRig());
  }
  /** Remove a rig from the available XR Rigs */
  removeRig(t) {
    const e = this._rigs.indexOf(t);
    e !== -1 && (this._rigs.splice(e, 1), this.updateActiveXRRig());
  }
  /** Sets a XRRig to be active which will parent the camera to this rig */
  setRigActive(t) {
    const e = this._rigs.indexOf(t), i = this._rigs[0];
    this._rigs.splice(e, 1), this._rigs.unshift(t), t.priority = (i == null ? void 0 : i.priority) ?? 0, this.updateActiveXRRig();
  }
  /**
   * @returns the user position in the rig space
   */
  getUserOffsetInRig() {
    var i;
    const t = (i = this.context.mainCamera) == null ? void 0 : i.position;
    if (!t || !this.rig)
      return G(0, 0, 0);
    const e = G(t);
    return e.x *= -1, e.z *= -1, e.applyQuaternion(En(this.rig.gameObject.quaternion)), e;
  }
  updateActiveXRRig() {
    const t = this._rigs[0] ?? null;
    this._defaultRig.gameObject.parent !== this.context.scene && this.context.scene.add(this._defaultRig.gameObject), this._defaultRig.gameObject.visible = !0, this._rigs.includes(this._defaultRig) || this._rigs.push(this._defaultRig);
    let e = this._rigs[0];
    e && e.priority === void 0 && (e.priority = 0);
    for (let i = 1; i < this._rigs.length; i++) {
      const n = this._rigs[i];
      if (n.isActive) {
        if (Wa(n.gameObject)) {
          this._rigs.splice(i, 1), i--;
          continue;
        }
        (!e || e.isActive === !1 || n.priority !== void 0 && n.priority > e.priority) && (e = n);
      }
    }
    if (t !== e) {
      const i = this._rigs.indexOf(e);
      i >= 0 && this._rigs.splice(i, 1), this._rigs.unshift(e);
    }
    ft && (t === e ? console.log("Updated Active XR Rig:", e, "prev:", t) : console.log("Updated Active XRRig:", e, " (the same as before)"));
  }
  /** Returns a XR hit test result (if hit-testing is available) in rig space   
   * @param source If provided, the hit test will be performed for the given controller
  */
  getHitTest(t) {
    if (t)
      return this.getControllerHitTest(t);
    if (!this._viewerHitTestSource)
      return null;
    const e = this._viewerHitTestSource, i = this.frame.getHitTestResults(e);
    if (i.length > 0) {
      const n = i[0];
      return this.convertHitTestResult(n);
    }
    return null;
  }
  getControllerHitTest(t) {
    const e = t.getHitTestSource();
    if (!e)
      return null;
    const i = this.frame.getHitTestResultsForTransientInput(e);
    for (const n of i)
      if (n.inputSource === t.inputSource)
        for (const o of n.results)
          return this.convertHitTestResult(o);
    return null;
  }
  convertHitTestResult(t) {
    const e = this.context.renderer.xr.getReferenceSpace(), i = e && t.getPose(e);
    if (i) {
      const n = G(i.transform.position), o = En(i.transform.orientation), a = this.context.mainCamera;
      if ((a == null ? void 0 : a.parent) !== this._cameraRenderParent && n.applyMatrix4(Sa), a != null && a.parent) {
        n.applyMatrix4(a.parent.matrixWorld), o.multiply(Gi);
        const l = Ce(a.parent);
        l.premultiply(Gi), o.premultiply(l);
      }
      return { hit: t, position: n, quaternion: o };
    }
    return null;
  }
  /** convert a XRRigidTransform from XR session space to threejs / Needle Engine XR space */
  convertSpace(t) {
    const e = G(t.position);
    e.applyMatrix4(Sa);
    const i = En(t.orientation);
    return i.premultiply(Gi), { position: e, quaternion: i };
  }
  /** Disconnects the controller, invokes events and notifies previou controller (if any) */
  disconnectInputSource(t) {
    const e = (i, n, o) => {
      if (i.inputSource === t) {
        ft && console.log("Disconnecting controller", i.index), this.controllers.splice(o, 1), this.invokeControllerEvent(i, this._controllerRemoved, "removed");
        const a = {
          xr: this,
          controller: i,
          change: "removed"
        };
        for (const l of this._xr_scripts)
          l.onXRControllerRemoved && l.onXRControllerRemoved(a);
        i.onDisconnected();
      }
    };
    for (let i = this.controllers.length - 1; i >= 0; i--) {
      const n = this.controllers[i];
      e(n, this.controllers, i);
    }
    for (let i = this._newControllers.length - 1; i >= 0; i--) {
      const n = this._newControllers[i];
      e(n, this._newControllers, i);
    }
  }
  /** End the XR Session */
  end() {
    this._ended || this.session.end().catch((t) => console.warn(t));
  }
  onRenderDebug() {
    if (ft)
      for (const t of this.controllers)
        t.onRenderDebug();
    if ((ft || vy) && this.rig && (zf++, zf >= 20)) {
      const t = this.rig.gameObject.worldPosition, e = this.rig.gameObject.worldForward;
      t.add(e.multiplyScalar(1.5));
      const i = this.rig.gameObject.worldUp;
      t.add(i.multiplyScalar(2.5));
      let n = "";
      if (n += `${this.context.time.smoothedFps.toFixed(0)} FPS`, n += `, calls: ${this.context.renderer.info.render.calls}, tris: ${this.context.renderer.info.render.triangles.toLocaleString()}`, ft || vy)
        for (const o of this.controllers)
          n += `
${o.hand ? "hand" : "ctrl"} ${o.inputSource.handedness}[${o.index}] con:${o.connected} tr:${o.isTracking} hts:${o.hasHitTestSource ? "yes" : "no"}`;
      zf = 0, V.DrawLabel(t, n, void 0, 1 / 60 * 20);
    }
  }
  /** register a new XR script if it hasnt added yet */
  addScript(t) {
    return this._xr_scripts.includes(t) ? !1 : (ft && console.log("Register new XRScript", t), this._xr_scripts.push(t), typeof t.onUpdateXR == "function" && this._xr_update_scripts.push(t), !0);
  }
  /** mark a script as inactive and invokes callbacks */
  markInactive(t) {
    if (!(this._inactive_scripts.indexOf(t) >= 0)) {
      this.removeScript(t, !1), this._inactive_scripts.push(t);
      for (const e of this.controllers)
        this.invokeCallback_ControllerRemoved(t, e);
      this.invokeCallback_LeaveXR(t);
    }
  }
  handleInactiveScripts() {
    if (this._inactive_scripts.length > 0)
      for (let t = this._inactive_scripts.length - 1; t >= 0; t--) {
        const e = this._inactive_scripts[t];
        if (e.activeAndEnabled) {
          this._inactive_scripts.splice(t, 1), this.addScript(e), this.invokeCallback_EnterXR(e);
          for (const i of this.controllers)
            this.invokeCallback_ControllerAdded(e, i);
        }
      }
  }
  removeScript(t, e = !0) {
    ft && console.log("Remove XRScript", t);
    const i = this._xr_scripts.indexOf(t);
    i >= 0 && this._xr_scripts.splice(i, 1);
    const n = this._xr_update_scripts.indexOf(t);
    if (n >= 0 && this._xr_update_scripts.splice(n, 1), e) {
      const o = this._inactive_scripts.indexOf(t);
      o >= 0 && this._inactive_scripts.splice(o, 1);
    }
  }
  invokeCallback_EnterXR(t) {
    t.onEnterXR && t.onEnterXR({ xr: this });
  }
  invokeCallback_ControllerAdded(t, e) {
    t.onXRControllerAdded && t.onXRControllerAdded({ xr: this, controller: e, change: "added" });
  }
  invokeCallback_ControllerRemoved(t, e) {
    t.onXRControllerRemoved && t.onXRControllerRemoved({ xr: this, controller: e, change: "removed" });
  }
  invokeCallback_LeaveXR(t) {
    t.onLeaveXR && !t.destroyed && t.onLeaveXR({ xr: this });
  }
  syncCameraCullingMask() {
    var i;
    const t = this.context.xrCamera, e = (i = this.context.mainCameraComponent) == null ? void 0 : i.cullingMask;
    if (t && e !== void 0) {
      for (const n of t.cameras)
        n.layers.mask = e;
      t.layers.mask = e;
    } else if (t) {
      for (const n of t.cameras)
        n.layers.enableAll();
      t.layers.enableAll();
    }
  }
  invokeControllerEvent(t, e, i) {
    for (let n = e.length - 1; n >= 0; n--) {
      const o = e[n];
      if (o)
        try {
          o({
            xr: this,
            controller: t,
            change: i
          });
        } catch (a) {
          console.error(a);
        }
    }
  }
  /** This is used to have the XR system camera look into threejs Z forward direction (instead of -z) */
  applyCustomForward() {
    var t;
    if (this.context.mainCamera && this._customforward) {
      this._camera = this.context.mainCamera, this._camera.parent !== this._cameraRenderParent && (this._previousCameraParent = this._camera.parent, (t = this._previousCameraParent) == null || t.add(this._cameraRenderParent)), this._cameraRenderParent.name = "XR Camera Render Parent", this._cameraRenderParent.add(this._camera);
      let e = 0.02;
      if (this.rig) {
        const i = Ke(this.rig.gameObject);
        e *= i.x;
      }
      this._camera instanceof ye && this._camera.near > e && (this.originalCameraNearPlane = this._camera.near, this._camera.near = e);
    }
  }
  revertCustomForward() {
    this._camera && this._previousCameraParent && this._previousCameraParent.add(this._camera), this._previousCameraParent = null, this._camera instanceof ye && this.originalCameraNearPlane != null && (this._camera.near = this.originalCameraNearPlane);
  }
  internalUpdateState() {
    const t = this.context.renderer.xr.getReferenceSpace();
    if (!t) {
      this._viewerPose = void 0;
      return;
    }
    if (this._viewerPose = this.frame.getViewerPose(t), this._viewerPose) {
      const e = this._viewerPose.transform;
      this._transformPosition.set(e.position.x, e.position.y, e.position.z), this._transformOrientation.set(e.orientation.x, e.orientation.y, e.orientation.z, e.orientation.w);
    }
  }
  get transition() {
    return this._transition || (this._transition = new my()), this._transition;
  }
  /** Call to fade rendering to black for a short moment (the returned promise will be resolved when fully black)   
   * This can be used to mask scene transitions or teleportation
   * @returns a promise that is resolved when the screen is fully black
   * @example `fadeTransition().then(() => { <fully_black> })`
  */
  fadeTransition() {
    return this._transition || (this._transition = new my()), this._transition.fadeTransition();
  }
  /** e.g. FadeToBlack */
  updateFade(t) {
    this._transition && t instanceof ye && this._transition.update(t, this.context.time.deltaTime);
  }
  onUpdateFade_PostRender() {
    var t;
    (t = this._transition) == null || t.remove();
  }
};
let J = ps;
r(J, "_sync", null), r(J, "_currentSessionRequestMode", null), r(J, "_currentSessionRequest"), r(J, "_activeSession"), r(J, "_sessionRequestStartListeners", []), r(J, "_sessionRequestEndListeners", []), r(J, "_xrStartListeners", []), r(J, "_xrEndListeners", []), r(J, "_controllerAddedListeners", []), r(J, "_controllerRemovedListeners", []), r(J, "onEnd", () => {
  ft && console.log("XR Session ended"), ps._activeSession = null;
});
const Uf = x("debugwebxr");
class pP {
  /** Searches the hierarchy for objects following a specific naming scheme */
  static tryFindAvatarObjects(t, e, i) {
    if (i.head && i.leftHand && i.rightHand)
      return;
    const n = t.name.toLocaleLowerCase();
    !i.head && n.includes("head") && (Uf && console.log("FOUND AVATAR HEAD", t.name), i.head = new re("", e, t)), n.includes("hand") && (!i.leftHand && n.includes("left") && (Uf && console.log("FOUND AVATAR LEFT HAND", t.name), i.leftHand = new re("", e, t)), !i.rightHand && n.includes("right") && (Uf && console.log("FOUND AVATAR RIGHT HAND", t.name), i.rightHand = new re("", e, t)));
    for (let o = 0; o < t.children.length; o++) {
      if (i.head && i.leftHand && i.rightHand)
        return;
      const a = t.children[o];
      this.tryFindAvatarObjects(a, e, i);
    }
  }
}
const At = new v(), wy = new v(), xy = new W(), mP = x("debuggizmos"), cn = 8947848, Nf = 32, Hi = class {
  constructor() {
  }
  /** 
   * Returns true if a given object is a gizmo
   */
  static isGizmo(t) {
    return t[um] !== void 0;
  }
  /** Set visibility of all currently rendered gizmos */
  static setVisible(t) {
    for (const e of Ee.timedObjectsBuffer)
      e.visible = t;
  }
  /**
   * Draw a label in the scene or attached to an object (if a parent is provided)
   * @param position the position of the label in world space
   * @param text the text of the label
   * @param size the size of the label in world space
   * @param duration the duration in seconds the label will be rendered. If 0 it will be rendered for one frame
   * @param color the color of the label
   * @param backgroundColor the background color of the label
   * @param parent the parent object to attach the label to. If no parent is provided the label will be attached to the scene
   * @returns a handle to the label that can be used to update the text
   */
  static DrawLabel(t, e, i = 0.05, n = 0, o, a, l) {
    var d;
    if (!Hi.enabled)
      return null;
    o || (o = cn);
    const c = ((d = J.active) == null ? void 0 : d.rigScale) ?? 1, h = Ee.getTextLabel(n, e, i * c, o, a);
    return l instanceof L && l.add(h), h.position.x = t.x, h.position.y = t.y, h.position.z = t.z, h;
  }
  /**
   * Draw a ray gizmo in the scene
   * @param origin the origin of the ray in world space
   * @param dir the direction of the ray in world space
   * @param color the color of the ray
   * @param duration the duration in seconds the ray will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the ray will be rendered with depth test
   */
  static DrawRay(t, e, i = cn, n = 0, o = !0) {
    if (!Hi.enabled)
      return;
    const a = Ee.getLine(n), l = a.geometry.getAttribute("position");
    l.setXYZ(0, t.x, t.y, t.z), At.set(e.x, e.y, e.z).multiplyScalar(999999999), l.setXYZ(1, t.x + At.x, t.y + At.y, t.z + At.z), l.needsUpdate = !0, a.material.color.set(i), a.material.depthTest = o, a.material.depthWrite = !1;
  }
  /**
   * Draw a line gizmo in the scene
   * @param pt0 the start point of the line in world space
   * @param pt1 the end point of the line in world space
   * @param color the color of the line
   * @param duration the duration in seconds the line will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the line will be rendered with depth test
   * @param lengthFactor the length of the line. Default is 1
   */
  static DrawDirection(t, e, i = cn, n = 0, o = !0, a = 1) {
    if (!Hi.enabled)
      return;
    const l = Ee.getLine(n), c = l.geometry.getAttribute("position");
    c.setXYZ(0, t.x, t.y, t.z), e.w !== void 0 ? (At.set(0, 0, -a), xy.set(e.x, e.y, e.z, e.w), At.applyQuaternion(xy)) : (At.set(e.x, e.y, e.z), At.multiplyScalar(a)), c.setXYZ(1, t.x + At.x, t.y + At.y, t.z + At.z), c.needsUpdate = !0, l.material.color.set(i), l.material.depthTest = o, l.material.depthWrite = !1;
  }
  /**
   * Draw a line gizmo in the scene
   * @param pt0 the start point of the line in world space
   * @param pt1 the end point of the line in world space
   * @param color the color of the line
   * @param duration the duration in seconds the line will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the line will be rendered with depth test
   */
  static DrawLine(t, e, i = cn, n = 0, o = !0) {
    if (!Hi.enabled)
      return;
    const a = Ee.getLine(n), l = a.geometry.getAttribute("position");
    l.setXYZ(0, t.x, t.y, t.z), l.setXYZ(1, e.x, e.y, e.z), l.needsUpdate = !0, a.material.color.set(i), a.material.depthTest = o, a.material.depthWrite = !1, a.material.fog = !1;
  }
  /**
   * Draw a 2D circle gizmo in the scene
   * @param pt0 the center of the circle in world space
   * @param normal the normal of the circle in world space
   * @param radius the radius of the circle in world space
   * @param color the color of the circle
   * @param duration the duration in seconds the circle will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the circle will be rendered with depth test
   */
  static DrawCircle(t, e, i, n = cn, o = 0, a = !0) {
    if (!Hi.enabled)
      return;
    const l = Ee.getCircle(o);
    l.position.set(t.x, t.y, t.z), l.scale.set(i, i, i), l.quaternion.setFromUnitVectors(this._up, At.set(e.x, e.y, e.z).normalize()), l.material.color.set(n), l.material.depthTest = a, l.material.depthWrite = !1, l.material.fog = !1;
  }
  /**
   * Draw a 3D wiremesh sphere gizmo in the scene
   * @param center the center of the sphere in world space
   * @param radius the radius of the sphere in world space
   * @param color the color of the sphere
   * @param duration the duration in seconds the sphere will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the sphere will be rendered with depth test
   */
  static DrawWireSphere(t, e, i = cn, n = 0, o = !0) {
    if (!Hi.enabled)
      return;
    const a = Ee.getSphere(e, n, !0);
    Fa(a, t.x, t.y, t.z), a.material.color.set(i), a.material.depthTest = o, a.material.depthWrite = !1, a.material.fog = !1;
  }
  /**
   * Draw a 3D sphere gizmo in the scene
   * @param center the center of the sphere in world space
   * @param radius the radius of the sphere in world space
   * @param color the color of the sphere
   * @param duration the duration in seconds the sphere will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the sphere will be rendered with depth test
   */
  static DrawSphere(t, e, i = cn, n = 0, o = !0) {
    if (!Hi.enabled)
      return;
    const a = Ee.getSphere(e, n, !1);
    Fa(a, t.x, t.y, t.z), a.material.color.set(i), a.material.depthTest = o, a.material.depthWrite = !1;
  }
  /**
   * Draw a 3D wiremesh box gizmo in the scene
   * @param center the center of the box in world space
   * @param size the size of the box in world space
   * @param color the color of the box
   * @param duration the duration in seconds the box will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the box will be rendered with depth test
   */
  static DrawWireBox(t, e, i = cn, n = 0, o = !0) {
    if (!Hi.enabled)
      return;
    const a = Ee.getBox(n);
    a.position.set(t.x, t.y, t.z), a.scale.set(e.x, e.y, e.z), a.material.color.set(i), a.material.depthTest = o, a.material.wireframe = !0, a.material.depthWrite = !1, a.material.fog = !1;
  }
  /**
   * Draw a 3D wiremesh box gizmo in the scene
   * @param box the box in world space
   * @param color the color of the box
   * @param duration the duration in seconds the box will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the box will be rendered with depth test
   */
  static DrawWireBox3(t, e = cn, i = 0, n = !0) {
    if (!Hi.enabled)
      return;
    const o = Ee.getBox(i);
    o.position.copy(t.getCenter(At)), o.scale.copy(t.getSize(At)), o.material.color.set(e), o.material.depthTest = n, o.material.wireframe = !0, o.material.depthWrite = !1, o.material.fog = !1;
  }
  /**
   * Draw an arrow gizmo in the scene
   * @param pt0 the start point of the arrow in world space
   * @param pt1 the end point of the arrow in world space
   * @param color the color of the arrow
   * @param duration the duration in seconds the arrow will be rendered. If 0 it will be rendered for one frame
   * @param depthTest if true the arrow will be rendered with depth test
   * @param wireframe if true the arrow will be rendered as wireframe
   */
  static DrawArrow(t, e, i = cn, n = 0, o = !0, a = !1) {
    if (!Hi.enabled)
      return;
    const l = Ee.getArrowHead(n);
    l.position.set(e.x, e.y, e.z), l.quaternion.setFromUnitVectors(this._up.set(0, 1, 0), At.set(e.x, e.y, e.z).sub(wy.set(t.x, t.y, t.z)).normalize());
    const h = At.set(e.x, e.y, e.z).sub(wy.set(t.x, t.y, t.z)).length() * 0.1;
    l.scale.set(h, h, h), l.material.color.set(i), l.material.depthTest = o, l.material.wireframe = a, this.DrawLine(t, e, i, n, o);
  }
  /**
   * Render a wireframe mesh in the scene. The mesh will be removed after the given duration (if duration is 0 it will be rendered for one frame).   
   * If a mesh object is provided then the mesh's matrixWorld and geometry will be used. Otherwise, the provided matrix and geometry will be used.
   * @param options the options for the wire mesh
   * @param options.duration the duration in seconds the mesh will be rendered. If 0 it will be rendered for one frame
   * @param options.color the color of the wire mesh
   * @param options.depthTest if true the wire mesh will be rendered with depth test
   * @param options.mesh the mesh object to render (if it is provided the matrix and geometry will be used)
   * @param options.matrix the matrix of the mesh to render
   * @param options.geometry the geometry of the mesh to render
   * @example
   * ```typescript
   * Gizmos.DrawWireMesh({ duration: 1, color: 0xff0000, mesh: myMesh });
   * ```
   */
  static DrawWireMesh(t) {
    const e = Ee.getMesh(t.duration ?? 0);
    "mesh" in t ? (e.geometry = t.mesh.geometry, e.matrix.copy(t.mesh.matrixWorld)) : (e.geometry = t.geometry, e.matrix.copy(t.matrix)), e.matrixAutoUpdate = !1, e.matrixWorldAutoUpdate = !1, e.material.color.set(t.color ?? cn), e.material.depthTest = t.depthTest ?? !0, e.material.wireframe = !0;
  }
};
let V = Hi;
/**
 * Allow creating gizmos   
 * If disabled then no gizmos will be added to the scene anymore
 */
r(V, "enabled", !0), r(V, "_up", new v(0, 1, 0));
const gP = new Da(1, 1, 1);
function Sg(s = null) {
  const t = new ae(s ?? 14540253), e = new Dx(gP);
  return new e0(e, new t0({ color: t }));
}
const um = Symbol("GizmoCache");
class Ee {
  static ensureFont() {
    let t = Te.FontLibrary.getFontFamily(this.familyName);
    if (!t) {
      t = Te.FontLibrary.addFontFamily(this.familyName);
      const e = t.addVariant("normal", "normal", "https://uploads.needle.tools/include/font-msdf.json", "https://uploads.needle.tools/include/font.png");
      e == null || e.addEventListener("ready", () => {
        Te.update();
      });
    }
  }
  static getTextLabel(t, e, i, n, o) {
    this.ensureFont();
    let a = this.textLabelCache.pop(), l = 1;
    o && typeof o == "string" && (o == null ? void 0 : o.length) >= 8 && o.startsWith("#") ? (l = parseInt(o.substring(7), 16) / 255, o = o.substring(0, 7), mP && console.log(o, l)) : typeof o == "object" && o.a !== void 0 && (l = o.a);
    const c = {
      boxSizing: "border-box",
      fontFamily: this.familyName,
      width: "auto",
      fontSize: i,
      color: n,
      lineHeight: 1,
      backgroundColor: o ?? void 0,
      backgroundOpacity: l,
      textContent: e,
      borderRadius: 0.5 * i,
      padding: 0.8 * i,
      whiteSpace: "pre",
      offset: 0.05 * i
    };
    if (a)
      a.set(c);
    else {
      a = new p0(c);
      const h = this, d = a;
      d.setText = function(u) {
        this.set({ textContent: u }), h.tmuiNeedsUpdate = !0;
      };
    }
    return this.tmuiNeedsUpdate = !0, this.registerTimedObject(ee.Current, a, t, this.textLabelCache), a;
  }
  static getBox(t) {
    let e = this.boxesCache.pop();
    if (!e) {
      const i = new Da(1, 1, 1);
      e = new q(i);
    }
    return this.registerTimedObject(ee.Current, e, t, this.boxesCache), e;
  }
  static getLine(t) {
    let e = this.linesCache.pop();
    if (!e) {
      e = new Ac();
      let i = e.geometry.getAttribute("position");
      i || (i = new mt(new Float32Array(2 * 3), 3), e.geometry.setAttribute("position", i));
    }
    return e.frustumCulled = !1, this.registerTimedObject(ee.Current, e, t, this.linesCache), e;
  }
  static getCircle(t) {
    let e = this.circlesCache.pop();
    if (!e) {
      e = new Ac();
      let i = e.geometry.getAttribute("position");
      if (!i) {
        i = new mt(new Float32Array(Nf * 3), 3), e.geometry.setAttribute("position", i);
        const n = G(0, 1, 0), o = G(0, 0, 1), a = G(o);
        a.cross(n).normalize();
        const l = G(a), c = Math.PI * 2 / (Nf - 1);
        for (let h = 0; h < Nf + 1; h++) {
          const d = c * h;
          n.copy(l).multiplyScalar(Math.cos(d) * 1), a.copy(o).multiplyScalar(Math.sin(d) * 1);
          const u = n.add(a);
          i.setXYZ(h, u.x, u.y, u.z);
        }
      }
    }
    return e.frustumCulled = !1, this.registerTimedObject(ee.Current, e, t, this.circlesCache), e;
  }
  static getSphere(t, e, i) {
    let n = this.spheresCache.pop();
    return n || (n = new q(new vu(1, 8, 8))), n.scale.set(t, t, t), n.material.wireframe = i, this.registerTimedObject(ee.Current, n, e, this.spheresCache), n;
  }
  static getArrowHead(t) {
    let e = this.arrowHeadsCache.pop();
    return e || (e = new q(new Ix(0, 0.5, 1, 8))), this.registerTimedObject(ee.Current, e, t, this.arrowHeadsCache), e;
  }
  static getMesh(t) {
    let e = this.mesh.pop();
    return e || (e = new q(), e.material = new Me()), this.registerTimedObject(ee.Current, e, t, this.mesh), e;
  }
  static registerTimedObject(t, e, i, n) {
    if (!t) {
      console.error("No Needle Engine context available. Did you call a Gizmos function in global scope?");
      return;
    }
    const o = this.contextBeforeRenderCallbacks.get(t), a = this.contextPostRenderCallbacks.get(t);
    if (o) {
      if (t.pre_render_callbacks[t.pre_render_callbacks.length - 1] !== o) {
        const l = t.pre_render_callbacks.indexOf(o);
        l >= 0 && t.pre_render_callbacks.splice(l, 1), t.pre_render_callbacks.push(o);
      }
    } else {
      const l = () => {
        this.onBeforeRender(t, this.timedObjectsBuffer);
      };
      this.contextBeforeRenderCallbacks.set(t, l), t.pre_render_callbacks.push(l);
    }
    if (a) {
      if (t.post_render_callbacks[t.post_render_callbacks.length - 1] !== a) {
        const l = t.post_render_callbacks.indexOf(a);
        l >= 0 && t.post_render_callbacks.splice(l, 1), t.post_render_callbacks.push(a);
      }
    } else {
      const l = () => {
        this.onPostRender(t, this.timedObjectsBuffer, this.timesBuffer);
      };
      this.contextPostRenderCallbacks.set(t, l), t.post_render_callbacks.push(l);
    }
    e.traverse((l) => {
      l.layers.disableAll(), l.layers.enable(2);
    }), e.renderOrder = 999999, e[um] = n, e.castShadow = !1, e.receiveShadow = !1, e.isGizmo = !0, this.timedObjectsBuffer.push(e), this.timesBuffer.push(ee.Current.time.realtimeSinceStartup + i), t.scene.add(e);
  }
  static onBeforeRender(t, e) {
    this.tmuiNeedsUpdate && (this.tmuiNeedsUpdate = !1, Te.update());
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      if (t.mainCamera && n instanceof Te.MeshUIBaseElement) {
        if (Wa(n))
          continue;
        const o = t.isInVR, a = !1, l = !o;
        Tu(n, t.mainCamera, a, l);
      }
    }
  }
  static onPostRender(t, e, i) {
    const n = t.time.realtimeSinceStartup;
    for (let o = e.length - 1; o >= 0; o--) {
      const a = e[o];
      n >= i[o] - 1e-6 && (e.splice(o, 1), i.splice(o, 1), a.removeFromParent(), Wa(a) != !0 && a[um].push(a));
    }
  }
}
// private static createdLines: number = 0;
r(Ee, "familyName", "needle-gizmos"), r(Ee, "linesCache", []), r(Ee, "circlesCache", []), r(Ee, "spheresCache", []), r(Ee, "boxesCache", []), r(Ee, "arrowHeadsCache", []), r(Ee, "mesh", []), r(Ee, "textLabelCache", []), r(Ee, "timedObjectsBuffer", new Array()), r(Ee, "timesBuffer", new Array()), r(Ee, "contextPostRenderCallbacks", /* @__PURE__ */ new Map()), r(Ee, "contextBeforeRenderCallbacks", /* @__PURE__ */ new Map()), r(Ee, "tmuiNeedsUpdate", !1);
const yi = x("debugphysics"), Sy = new vo();
class Ts {
  constructor() {
    r(this, "ray");
    r(this, "cam");
    r(this, "screenPoint");
    r(this, "raycaster");
    r(this, "results");
    r(this, "targets");
    r(this, "recursive", !0);
    r(this, "minDistance");
    r(this, "maxDistance");
    r(this, "lineThreshold");
    r(this, "layerMask");
    r(this, "ignore");
    r(this, "testObject");
    r(this, "useAcceleratedRaycast");
  }
  screenPointFromOffset(t, e) {
    this.screenPoint === void 0 && (this.screenPoint = new oe()), this.screenPoint.x = t / window.innerWidth * 2 - 1, this.screenPoint.y = -(e / window.innerHeight) * 2 + 1;
  }
  /** sets one layer for raycasting (e.g. layer 4, only objects on layer 4 will then be hit) */
  setLayer(t) {
    Sy.set(t), this.layerMask = Sy;
  }
  /** sets the layer.mask value directly, use setLayer if you want to set e.g. an individual layer only active. See https://threejs.org/docs/#api/en/core/Layers for more information about layers */
  setMask(t) {
    this.layerMask || (this.layerMask = new vo());
    const e = this.layerMask;
    e ? e.mask = t : this.layerMask = t;
  }
}
r(Ts, "AllLayers", 4294967295);
class Y0 {
  constructor(t, e, i) {
    r(this, "distance");
    r(this, "point");
    r(this, "object");
    this.object = t, this.distance = e, this.point = i;
  }
}
const hu = class {
  constructor(t) {
    r(this, "context");
    r(this, "engine");
    // raycasting
    r(this, "raycaster", new xu());
    r(this, "defaultRaycastOptions", new Ts());
    r(this, "targetBuffer", new Array(1));
    r(this, "defaultThresholds", {
      Mesh: {},
      Line: { threshold: -1 },
      LOD: {},
      Points: { threshold: 0 },
      Sprite: {}
    });
    r(this, "sphereResults", new Array());
    r(this, "sphereMask", new vo());
    r(this, "sphere", new wu());
    r(this, "tempBoundingBox", new Pi());
    this.context = t;
  }
  /**
   * Returns true if raycasting is currently happening
   */
  static get raycasting() {
    return this._raycasting > 0;
  }
  /**@deprecated use `this.context.physics.engine.raycast` {@link IPhysicsEngine.raycast} */
  raycastPhysicsFast(t, e = void 0, i = 1 / 0, n = !0) {
    var o;
    return ((o = this.context.physics.engine) == null ? void 0 : o.raycast(t, e, { maxDistance: i, solid: n })) ?? null;
  }
  /**@deprecated use `this.context.physics.engine.raycastAndGetNormal` {@link IPhysicsEngine.raycastAndGetNormal} */
  raycastPhysicsFastAndGetNormal(t, e = void 0, i = 1 / 0, n = !0) {
    var o;
    return ((o = this.context.physics.engine) == null ? void 0 : o.raycastAndGetNormal(t, e, { maxDistance: i, solid: n })) ?? null;
  }
  /**@deprecated use this.context.physics.engine.sphereOverlap */
  sphereOverlapPhysics(t, e) {
    var i;
    return ((i = this.context.physics.engine) == null ? void 0 : i.sphereOverlap(t, e)) ?? null;
  }
  /** Test overlapping of a sphere with the threejs geometry. This does not use colliders. This does not return an exact intersection point (intersections returned contain the object and the world position of the object that is being hit)
   * For a more accurate test use the physics engine's collider overlap test (see sphereOverlapPhysics)
   * @param spherePos the center of the sphere in world space
   * @param radius the radius of the sphere
   * @param traverseChildsAfterHit if false it will stop after the first hit. If true it will continue to traverse and add all hits to the result array
   * @param bvh use MeshBVH for raycasting. This is faster than the default threejs raycaster but uses more memory.
   * @param shouldRaycast optional callback to filter objects. Return `false` to ignore the object completely or `"continue in children"` to skip the object but continue to traverse its children (if you do raycast with `recursive` enabled)
   */
  sphereOverlap(t, e, i = !0, n = !1, o = null) {
    if (this.sphereResults.length = 0, !this.context.scene)
      return this.sphereResults;
    const a = this.sphereMask;
    a.enableAll(), a.disable(2);
    for (const l of this.context.scene.children)
      this.intersectSphere(l, t, e, a, this.sphereResults, i, n, o);
    return this.sphereResults.sort((l, c) => l.distance - c.distance);
  }
  raycastFromRay(t, e = null) {
    const i = e ?? this.defaultRaycastOptions;
    i.ray = t;
    const n = this.raycast(i);
    return i === this.defaultRaycastOptions && (i.ray = void 0), n;
  }
  /** raycast against rendered three objects. This might be very slow depending on your scene complexity.
   * We recommend setting objects to IgnoreRaycast layer (2) when you don't need them to be raycasted.
   * Raycasting SkinnedMeshes is specially expensive.
   * Use raycastPhysics for raycasting against physic colliders only. Depending on your scenario this might be faster.
   * @param options raycast options. If null, default options will be used.
   */
  raycast(t = null) {
    yi && performance.mark("raycast.start"), t || (t = this.defaultRaycastOptions);
    const e = t.screenPoint ?? this.context.input.mousePositionRC, i = t.raycaster ?? this.raycaster;
    if (i.near = t.minDistance ?? 0, i.far = t.maxDistance ?? 1 / 0, i.params = this.defaultThresholds, t.lineThreshold === void 0 && (t.lineThreshold = -1), i.params.Line = { threshold: t.lineThreshold }, t.ray)
      i.ray.copy(t.ray);
    else {
      const l = t.cam ?? this.context.mainCamera;
      if (!l)
        return yi && console.error("Can not perform raycast - no main camera found"), this.defaultRaycastOptions.results && (this.defaultRaycastOptions.results.length = 0), this.defaultRaycastOptions.results ?? [];
      const c = this.context.xrCamera;
      this.context.isInXR && c instanceof Lx && c.cameras.length > 0 ? i.setFromCamera(e, c.cameras[0]) : i.setFromCamera(e, l);
    }
    let n = t.targets;
    n || (n = this.targetBuffer, n.length = 1, n[0] = this.context.scene);
    let o = t.results;
    this.defaultRaycastOptions.results && (this.defaultRaycastOptions.results.length = 0), o || (this.defaultRaycastOptions.results || (this.defaultRaycastOptions.results = new Array()), o = this.defaultRaycastOptions.results), t.layerMask !== void 0 ? t.layerMask instanceof vo ? i.layers.mask = t.layerMask.mask : i.layers.mask = t.layerMask : (i.layers.enableAll(), i.layers.disable(2)), yi && console.time("raycast"), o.length = 0, hu._raycasting++, this.intersect(this.raycaster, n, o, t), o.sort((l, c) => l.distance - c.distance);
    const a = t.ignore;
    return a !== void 0 && a.length > 0 && (o = o.filter((l) => !a.includes(l.object))), hu._raycasting--, yi && (console.timeEnd("raycast"), console.warn("#" + this.context.time.frame + ", hits:", o != null && o.length ? [...o] : "nothing"), performance.mark("raycast.end"), performance.measure("raycast", "raycast.start", "raycast.end")), o;
  }
  intersect(t, e, i, n) {
    var o, a, l;
    for (const c of e) {
      if (!c || c.visible === !1 || V.isGizmo(c) || n.lineThreshold !== void 0 && n.lineThreshold < 0 && c instanceof Ac)
        continue;
      let h = !0;
      const d = c, u = d.geometry;
      if (n.testObject) {
        const p = (o = n.testObject) == null ? void 0 : o.call(n, c);
        if (p === !1)
          continue;
        p === "continue in children" && (h = !1);
      }
      if (h && (u && Cy(u) || (h = !1)), h) {
        const p = a0(c);
        p && (d.geometry = p);
        const m = i.length;
        let g = !0;
        if (n.precise === !1 && (g = !1), g || (g = ((l = (a = u.getAttribute("position")) == null ? void 0 : a.array) == null ? void 0 : l.length) < 64), d instanceof Ba && (g = !1), !g && yP(d, t, i) || (n.useAcceleratedRaycast !== !1 ? zd.runMeshBVHRaycast(t, d, i, this.context) : t.intersectObject(d, !1, i)), yi && i.length != m) {
          const _ = i[i.length - 1], y = p ? 8969557 : 7798784;
          V.DrawWireSphere(_.point, 0.1, y, 1, !1), V.DrawWireMesh({ mesh: c, depthTest: !1, duration: 0.2, color: y });
        }
        d.geometry = u;
      }
      n.recursive !== !1 && this.intersect(t, c.children, i, n);
    }
    return i;
  }
  intersectSphere(t, e, i, n, o, a, l, c) {
    let h = t && t.isMesh && t.layers.test(n) && !V.isGizmo(t);
    h && (h = t.visible), h && (h = !(t instanceof Ac)), h && (h = !(t instanceof Ba));
    const d = t, u = d.geometry;
    if (h && c) {
      const p = c(t);
      if (p === !1)
        return;
      p === "continue in children" && (h = !1);
    }
    if (u && Cy(u) || (h = !1), h) {
      if (l) {
        const p = this.sphere;
        p.center.copy(e), p.radius = i;
        const m = o.length;
        if (zd.runMeshBVHRaycast(this.sphere, d, o, this.context), m != o.length && !a)
          return;
      } else if (u.boundingBox || u.computeBoundingBox(), u.boundingBox) {
        d.matrixWorldNeedsUpdate && d.updateWorldMatrix(!1, !1);
        const p = this.tempBoundingBox.copy(u.boundingBox).applyMatrix4(d.matrixWorld), m = this.sphere;
        if (m.center.copy(e), m.radius = i, m.intersectsBox(p)) {
          const g = ie(t), _ = g.distanceTo(m.center), y = new Y0(t, _, g);
          if (o.push(y), !a)
            return;
        }
      }
    }
    if (t.children)
      for (const p of t.children) {
        const m = o.length;
        if (this.intersectSphere(p, e, i, n, o, a, l, c), m != o.length && !a)
          return;
      }
  }
};
let cc = hu;
r(cc, "_raycasting", 0);
function Cy(s) {
  return !(s.index && s.index.array.length < 3);
}
const No = new wu(), Dh = new vr(), _P = new Zb();
function yP(s, t, e) {
  const i = s._computeIntersections;
  if (!i)
    return !1;
  let n = s["_computeIntersections:Needle"];
  return n || (n = s["_computeIntersections:Needle"] = function(o, a, l) {
    const c = this, h = c.geometry.boundingSphere;
    if (h) {
      if (c instanceof Ba) {
        Dh.setFromNormalAndCoplanarPoint(G(0, 1, 0), G(0, -c.position.y, 0)), Dh.applyMatrix4(c.matrixWorld, _P);
        const u = o.ray.intersectPlane(Dh, G());
        if (u) {
          No.copy(h), No.applyMatrix4(c.matrixWorld);
          const m = G(u).sub(o.ray.origin).length(), g = No.radius * 0.5;
          m < g && a.push({ distance: m, point: u, object: c, normal: Dh.normal.clone() });
        }
        return;
      }
      No.copy(h), No.applyMatrix4(c.matrixWorld);
      const d = o.ray.intersectSphere(No, G());
      if (d) {
        const u = G(d).sub(o.ray.origin), p = u.length();
        if (p > No.radius) {
          const m = u.clone().normalize();
          a.push({ distance: p, point: d, object: c, normal: m });
        }
      }
    }
  }), s._computeIntersections = n, t.intersectObject(s, !1, e), s._computeIntersections = i, !0;
}
var zd;
((s) => {
  function t(b, w, P, k) {
    var M, E, B;
    if (!w.geometry || !w.geometry.hasAttribute("position"))
      return !1;
    const O = w.geometry;
    if (w != null && w.isSkinnedMesh) {
      const A = w, F = A.bvhNeedsUpdate;
      if (!A.staticGenerator)
        l(), o && (A.staticGenerator = new o(w), A.staticGenerator.applyWorldTransforms = !1, A.staticGeometry = A.staticGenerator.generate(), O.boundsTree = a == null ? void 0 : a.call(A.staticGeometry), A.staticGeometryLastUpdate = performance.now() + Math.random() * 200, A.autoUpdateMeshBVH === void 0 && (A.autoUpdateMeshBVH = !1));
      else if (O.boundsTree && (A.autoUpdateMeshBVH === !0 || F === !0)) {
        const U = performance.now(), Z = U - A.staticGeometryLastUpdate;
        (F || Z > 100) && (A.bvhNeedsUpdate = !1, A.staticGeometryLastUpdate = U, (M = A.staticGenerator) == null || M.generate(A.staticGeometry), O.boundsTree.refit());
      }
    } else if (!O.boundsTree) {
      h || y();
      let A = !0;
      if ((k.xr || O[m] === !1 || (E = O.getAttribute("position")) != null && E.isInterleavedBufferAttribute || O.index && ((B = O.index) != null && B.isInterleavedBufferAttribute)) && (A = !1), A && u) {
        if (O[p] === void 0) {
          let F = null;
          if (_.length > 0) {
            const U = _.shift();
            U && !U.running && (F = U);
          }
          if (!F && g.length < 3 && (F = new u(), g.push(F)), F != null && !F.running) {
            const U = w.name;
            yi && console.log("<<<< worker start", U, F), O[p] = "queued", performance.mark("bvh.create.start");
            const Z = O.clone();
            try {
              F.generate(Z).then((T) => {
                O[p] = "done", O.boundsTree = T;
              }).catch((T) => {
                O[p] = "failed - " + (T == null ? void 0 : T.message), O[m] = !1, yi && console.error("Failed to generate mesh bvh on worker", T);
              }).finally(() => {
                yi && console.log(">>>>> worker done", U, { hasBoundsTre: O.boundsTree != null }), _.push(F), Z.dispose(), performance.mark("bvh.create.end"), performance.measure("bvh.create (worker)", "bvh.create.start", "bvh.create.end");
              });
            } catch (T) {
              console.error("Failed to generate mesh bvh on worker", T);
            }
          } else
            yi && console.warn("No worker available");
        }
      } else
        (!d || !A) && (l(), n && (performance.mark("bvh.create.start"), O.boundsTree = new n(O), performance.mark("bvh.create.end"), performance.measure("bvh.create", "bvh.create.start", "bvh.create.end")));
    }
    if (b instanceof xu) {
      const A = b, F = w.raycast;
      O.boundsTree ? (l(), i && (w.acceleratedRaycast || (w.acceleratedRaycast = i.bind(w), yi && console.debug(`Physics: bind acceleratedRaycast fn to "${w.name}"`)), w.raycast = w.acceleratedRaycast)) : yi && console.warn("No bounds tree found for mesh", w.name, { workerTask: O[p], hasAcceleratedRaycast: i != null });
      const U = A.firstHitOnly;
      return A.firstHitOnly = !1, A.intersectObject(w, !1, P), A.firstHitOnly = U, w.raycast = F, !0;
    } else if (b instanceof wu) {
      const A = O.boundsTree;
      if (A) {
        const F = b;
        if (c.copy(w.matrixWorld).invert(), F.applyMatrix4(c), A.intersectsSphere(F)) {
          const Z = ie(w), T = Z.distanceTo(F.center), j = new Y0(w, T, Z);
          P.push(j);
        }
      }
      return !0;
    }
    return !1;
  }
  s.runMeshBVHRaycast = t;
  let e = !1, i = null, n = null, o = null, a = null;
  function l() {
    e || (e = !0, import("./vendor.js").then((b) => b.index$1).then((b) => {
      i = b.acceleratedRaycast, n = b.MeshBVH, o = b.StaticGeometryGenerator, a = b.computeBoundsTree;
    }).catch((b) => {
      (yi || z()) && console.error("Failed to load BVH library...", b.message);
    }));
  }
  const c = new se();
  let h = !1, d = !1, u = null;
  const p = Symbol("Needle:MeshBVH-Worker"), m = Symbol("Needle:MeshBVH-CanUseWorker"), g = [], _ = [];
  function y() {
    h = !0, d = !0, Promise.resolve().then(() => LI).then((b) => {
      u = b.GenerateMeshBVHWorker;
    }).catch((b) => {
      (yi || z()) && console.warn("Failed to setup mesh bvh worker");
    }).finally(() => {
      d = !1;
    });
  }
})(zd || (zd = {}));
const Py = Symbol("gltf-loader-internal-usage-tracker"), bP = x("debugusers"), Sc = class {
  constructor(t) {
    r(this, "parser");
    r(this, "_getDependency");
    r(this, "_loadingId");
    r(this, "_loadedObjects", /* @__PURE__ */ new Set());
    this.parser = t, this._getDependency = this.parser.getDependency, this._loadingId = Date.now().toString();
  }
  get name() {
    return "NEEDLE_internal_usage_tracker";
  }
  static isLoading(t) {
    return Sc._loadingProcesses > 0;
  }
  beforeRoot() {
    Sc._loadingProcesses++;
    const t = this, e = this._getDependency;
    return this.parser.getDependency = function(i, n) {
      const o = e.call(this, i, n);
      return o.then((a) => (a && (t._loadedObjects.add(a), a[Py] = t._loadingId), a)), o;
    }, null;
  }
  afterRoot(t) {
    Sc._loadingProcesses--, this.parser.getDependency = this._getDependency;
    for (const e of this._loadedObjects)
      delete e[Py], e instanceof L && (e.parent || e instanceof q && setTimeout(() => {
        bP && console.warn("> GLTF LOADER: Mesh not used in scene!", e), e.material = null, e.geometry = null;
      }, 1e3));
    return null;
  }
  // private readonly _creatingNodeMesh: Map<number, CreateNodeMesh> = new Map();
  // createNodeMesh(_nodeIndex: number): CreateNodeMesh | null {
  //     // if (!this.parser) return null;
  //     // let process = this._creatingNodeMesh.get(nodeIndex);
  //     // if (process) return process;
  //     // process = this.parser.createNodeMesh(nodeIndex)?.then((mesh) => {
  //     //     console.log("createNodeMesh", nodeIndex, mesh);
  //     //     return mesh;
  //     // }) as CreateNodeMesh;
  //     // this._creatingNodeMesh.set(nodeIndex, process);
  //     // return process;
  // }
};
let hc = Sc;
r(hc, "_loadingProcesses", 0);
class vP {
  constructor() {
    window.addEventListener("unhandledrejection", (t) => {
      var i;
      if (t.defaultPrevented)
        return;
      const e = (i = t == null ? void 0 : t.reason) == null ? void 0 : i.path;
      if (e) {
        const n = e[0];
        n && n.tagName === "IMG" && (console.warn(`Could not load image:
` + n.src), t.preventDefault());
      }
    });
  }
}
const Du = x("trackresources");
function K0() {
  return Du === "dispose";
}
let Er = !0;
Du === 0 && (Er = !1);
function MD(s) {
  Er = s;
}
function wP() {
  return Er;
}
const Z0 = Symbol("disposable");
function J0(s, t) {
  s && (s[Z0] = t, hr && console.warn("Set disposable", t, s));
}
const ev = Symbol("disposed");
function RD(s) {
  return s[ev] === !0;
}
function Ae(s) {
  var t;
  if (s) {
    if (s[Z0] === !1) {
      hr && console.warn("Object is marked as not disposable", s);
      return;
    }
    if (s[ev] = !0, s instanceof Mi)
      Ae(s.environment), Ae(s.background), Ae(s.customDepthMaterial), Ae(s.customDistanceMaterial);
    else if (s instanceof Os)
      Ae(s.geometry), Ae(s.material), Ae(s.skeleton), Ae(s.bindMatrix), Ae(s.bindMatrixInverse), Ae(s.customDepthMaterial), Ae(s.customDistanceMaterial), s.geometry = null, s.material = null, s.visible = !1;
    else if (s instanceof q)
      Ae(s.geometry), Ae(s.material), Ae(s.customDepthMaterial), Ae(s.customDistanceMaterial), s.geometry = null, s.material = null, s.visible = !1;
    else if (s instanceof Ps) {
      Gr(s);
      for (const e of Object.keys(s.attributes)) {
        const i = s.attributes[e];
        Ae(i);
      }
    } else if (s instanceof mt || s instanceof i0)
      hr && console.warn("BufferAttribute dispose not supported", s.count);
    else if (s instanceof Array)
      for (const e of s)
        e instanceof Se && Ae(e);
    else if (s instanceof Se) {
      Gr(s);
      for (const i of Object.keys(s)) {
        const n = s[i];
        n instanceof Fe && (Ae(n), s[i] = null);
      }
      const e = s.uniforms;
      if (e)
        for (const i of Object.keys(e)) {
          const n = e[i];
          n instanceof Fe ? (Ae(n), e[i] = null) : n instanceof co && (Ae(n.value), n.value = null);
        }
    } else
      s instanceof Fe ? (Gr(s), Gr(s.source), ((t = s.source) == null ? void 0 : t.data) instanceof ImageBitmap && Gr(s.source.data)) : s instanceof jx ? (Gr(s.boneTexture), s.boneTexture = null) : s instanceof Bx || !(s instanceof L) && hr && console.warn("Unknown object type", s);
  }
}
function Gr(s) {
  s && ((hr || K0() || Du) && console.warn("🧨 FREE", s), s instanceof ImageBitmap ? s.close() : s instanceof Fx ? s.data = null : s.dispose());
}
function xP(s) {
  (s instanceof q || s instanceof Os) && (s.material = null, s.geometry = null);
}
const SP = /* @__PURE__ */ new Set();
function tv(s, t, e = null, i) {
  if (i || (i = SP, i.clear()), !s)
    return i;
  const n = s[Bc];
  if (n)
    for (const o of n)
      i.has(o) || (e == null ? void 0 : e.call(null, o)) !== !1 && (i.add(o), t && tv(o, !0, e, i));
  return i;
}
function kD(s) {
  return s[Gl];
}
const hr = x("debugresourceusers") || x("debugmemory"), Bc = Symbol("needle-resource-users"), Gl = Symbol("needle-resource-users-count");
function Wt(s, t) {
  _g(s, t, function(e, i) {
    Er && !cc.raycasting && (Ud(Bc, this, e, !1), Ud(Bc, this, i, !0));
  });
}
Er && (Wt(q.prototype, "material"), Wt(q.prototype, "geometry"), Wt(Se.prototype, "map"), Wt(Se.prototype, "bumpMap"), Wt(Se.prototype, "alphaMap"), Wt(Se.prototype, "normalMap"), Wt(Se.prototype, "displacementMap"), Wt(Se.prototype, "roughnessMap"), Wt(Se.prototype, "metalnessMap"), Wt(Se.prototype, "emissiveMap"), Wt(Se.prototype, "specularMap"), Wt(Se.prototype, "envMap"), Wt(Se.prototype, "lightMap"), Wt(Se.prototype, "aoMap"), Wt(Se.prototype, "gradientMap"));
function CP(s) {
  if (Er === !1)
    return;
  const t = s[Bc];
  if (t)
    for (const e of t)
      Ud(Bc, e, s, !1);
}
Er && _g(Se.prototype, "dispose", function() {
  CP(this);
});
let fm = 0;
function Ud(s, t, e, i) {
  if (fm > 0)
    return;
  if (Array.isArray(e)) {
    for (const o of e)
      Ud(s, t, o, i);
    return;
  }
  if (!e)
    return;
  let n = e[s];
  if (n || (n = /* @__PURE__ */ new Set()), i) {
    if (t && !n.has(t)) {
      n.add(t);
      let o = e[Gl] || 0;
      o += 1, e[Gl] = o, hr && console.warn(`🟢 Added user of "${e.type}"`, t, e, o, "users:", n);
    }
  } else if (t && n.has(t)) {
    n.delete(t);
    let o = e[Gl] || 0;
    o > 0 && (o -= 1, e[Gl] = o), hr && console.warn(`🔴 Removed user of "${e.type}"`, t, e, o, "users:", n), o <= 0 && (hc.isLoading(e) || (Du && console.warn(`🔴 Removed all user of "${e.type}"`, e), K0() && Ae(e)));
  }
  e[s] = n;
}
try {
  _g(
    kr.prototype,
    "render",
    function() {
      fm++;
    },
    function() {
      fm--;
    }
  );
} catch (s) {
  console.warn("Could not wrap WebGLRenderer.render", s);
}
const Oy = x("debugcomponentevents");
class Lu {
  static addComponentLifecylceEventListener(t, e) {
    this.eventListeners.has(t) && this.eventListeners.set(t, []);
    let i = this.eventListeners.get(t);
    i || (i = []), i.push(e), this.eventListeners.set(t, i), Oy && console.log("Added event listener for " + t, this.eventListeners);
  }
  static removeComponentLifecylceEventListener(t, e) {
    const i = this.eventListeners.get(t);
    if (!i)
      return;
    const n = i.indexOf(e);
    n < 0 || i.splice(n, 1);
  }
  static dispatchComponentLifecycleEvent(t, e) {
    const i = this.eventListeners.get(t);
    if (Oy && console.log("Dispatching event " + t, i), !!i)
      for (const n of i)
        n(e);
  }
}
r(Lu, "eventListeners", /* @__PURE__ */ new Map());
const Fc = Symbol("NEEDLE_NEED_UPDATE_INSTANCE"), iv = Symbol("isUsingInstancing"), nv = Symbol("instancingRenderer"), ql = Symbol("instancingAutoUpdateBounds");
class _n {
  /** Is this object rendered using a InstancedMesh */
  static isUsingInstancing(t) {
    return t[iv] === !0;
  }
  /** Returns the instanced mesh IF the object is rendered by an instanced mesh
   * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
   */
  static getRenderer(t) {
    return t[nv] || null;
  }
  setAutoUpdateBounds(t, e) {
    const i = _n.getRenderer(t);
    i && (i[ql] = e);
  }
  // TODO: change this so it does not set matrix world directly but some flag that is only used by instancing
  /** Mark an instanced object dirty so the instance matrix will be updated */
  static markDirty(t, e = !0) {
    if (t && (this.isUsingInstancing(t) && (t[Fc] = !0, t.matrixWorldNeedsUpdate = !0), e))
      for (const i of t.children)
        _n.markDirty(i, !0);
  }
}
function Pa(s, t) {
  try {
    t ? s(t) : s();
  } catch (e) {
    return console.error(e), !1;
  }
  return !0;
}
const pm = x("debugnewscripts"), PP = x("debughierarchy"), je = [];
function OP() {
  return je.length > 0;
}
function Nd(s) {
  if (pm && console.log("Register new components", s.new_scripts.length, [...s.new_scripts], s.alias ? "element: " + s.alias : s.hash, s), s.new_scripts_pre_setup_callbacks.length > 0) {
    for (const t of s.new_scripts_pre_setup_callbacks)
      t && t();
    s.new_scripts_pre_setup_callbacks.length = 0;
  }
  if (!(s.new_scripts.length <= 0)) {
    je.length = 0, s.new_scripts.length > 0 && je.push(...s.new_scripts), s.new_scripts.length = 0;
    for (let t = 0; t < je.length; t++)
      try {
        const e = je[t];
        if (e.isComponent !== !0) {
          (z() || pm) && console.error(`Registered script is not a Needle Engine component. 
The script will be ignored. Please make sure your component extends "Behaviour" imported from "@needle-tools/engine"
`, e), je.splice(t, 1), t--;
          continue;
        }
        if (e.destroyed)
          continue;
        if (!e.gameObject) {
          console.warn(`Component can not be initialized: no GameObject assigned.
Did you add and remove a component in the same frame?`), je.splice(t, 1), t--;
          continue;
        }
        e.context = s, dc(e.gameObject), Cg(e, s);
      } catch (e) {
        console.error(e), ys(je[t], s), je.splice(t, 1), t--;
      }
    for (let t = 0; t < je.length; t++)
      try {
        const e = je[t];
        if (e.destroyed) {
          ys(je[t], s), je.splice(t, 1), t--;
          continue;
        }
        if (e.registering)
          try {
            e.registering();
          } catch (i) {
            console.error(i);
          }
        e.__internalAwake !== void 0 && (e.gameObject || console.error("Calling awake for a component without a GameObject", e, e.gameObject), dc(e.gameObject), e.activeAndEnabled && Pa(e.__internalAwake.bind(e)));
      } catch (e) {
        console.error(e), ys(je[t], s), je.splice(t, 1), t--;
      }
    for (let t = 0; t < je.length; t++)
      try {
        const e = je[t];
        if (e.destroyed || e.enabled === !1 || (dc(e.gameObject), e.activeAndEnabled === !1))
          continue;
        e.__internalEnable !== void 0 && (e.enabled = !0, Pa(e.__internalEnable.bind(e)));
      } catch (e) {
        console.error(e), ys(je[t], s), je.splice(t, 1), t--;
      }
    for (let t = 0; t < je.length; t++)
      try {
        const e = je[t];
        if (e.destroyed || !e.gameObject)
          continue;
        s.new_script_start.push(e);
      } catch (e) {
        console.error(e), ys(je[t], s), je.splice(t, 1), t--;
      }
    je.length = 0;
    for (const t of s.new_scripts_post_setup_callbacks)
      t && t();
    s.new_scripts_post_setup_callbacks.length = 0;
  }
}
function MP(s) {
  s && (s.__internalDisable(!0), ys(s, s.context));
}
function sv(s, t) {
  for (let e = 0; e < s.new_script_start.length; e++)
    try {
      const i = s.new_script_start[e];
      if (t !== void 0 && i.gameObject !== t || i.destroyed || i.activeAndEnabled === !1)
        continue;
      Pa(i.__internalAwake.bind(i)), i.enabled && (Pa(i.__internalEnable.bind(i)), Pa(i.__internalStart.bind(i)), s.new_script_start.splice(e, 1), e--);
    } catch (i) {
      console.error(i), ys(s.new_script_start[e], s), s.new_script_start.splice(e, 1), e--;
    }
}
function Cg(s, t) {
  t.scripts.indexOf(s) === -1 && (t.scripts.push(s), s.earlyUpdate && t.scripts_earlyUpdate.push(s), s.update && t.scripts_update.push(s), s.lateUpdate && t.scripts_lateUpdate.push(s), s.onBeforeRender && t.scripts_onBeforeRender.push(s), s.onAfterRender && t.scripts_onAfterRender.push(s), s.onPausedChanged && t.scripts_pausedChanged.push(s), $f(s, null) && t.new_scripts_xr.push(s), $f(s, "immersive-vr") && t.scripts_immersive_vr.push(s), $f(s, "immersive-ar") && t.scripts_immersive_ar.push(s));
}
function ys(s, t) {
  Ui(s, t.new_scripts), Ui(s, t.new_script_start), Ui(s, t.scripts), Ui(s, t.scripts_earlyUpdate), Ui(s, t.scripts_update), Ui(s, t.scripts_lateUpdate), Ui(s, t.scripts_onBeforeRender), Ui(s, t.scripts_onAfterRender), Ui(s, t.scripts_pausedChanged), Ui(s, t.new_scripts_xr), Ui(s, t.scripts_immersive_vr), Ui(s, t.scripts_immersive_ar), t.stopAllCoroutinesFrom(s);
}
function Ui(s, t) {
  const e = t.indexOf(s);
  e >= 0 && t.splice(e, 1);
}
function $f(s, t) {
  var e;
  if (s) {
    const i = s;
    if (i.onBeforeXR || i.onEnterXR || i.onUpdateXR || i.onLeaveXR || i.onXRControllerAdded || i.onXRControllerRemoved)
      return !(t != null && ((e = i.supportsXR) == null ? void 0 : e.call(i, t)) === !1);
  }
  return !1;
}
function pd(s) {
  if (s || (s = fe.Current.scene), !s) {
    console.trace("Invalid call - no current context.");
    return;
  }
  const t = Yc(s);
  ov(s, t, !0) || (pm || z() ? console.error(`Error updating hierarchy
Do you have circular references in your project? <a target="_blank" href="https://docs.needle.tools/circular-reference"> Click here for more information.`, s) : console.error('Failed to update active state in hierarchy of "' + s.name + '"', s), console.warn(" ↑ this error might be caused by circular references. Please make sure you don't have files with circular references (e.g. one GLB 1 is loading GLB 2 which is then loading GLB 1 again)."));
}
function ov(s, t, e, i = 0) {
  if (i > 1e3)
    return console.warn("Hierarchy is too deep (> 1000 level) - will abort updating active state"), !1;
  const n = Yc(s);
  if (t && (t = n, t && s.parent)) {
    const c = s.parent;
    t = c[po], t === void 0 && (c instanceof Mi || (t = !0));
  }
  const a = s[po] !== t;
  s[po] = t, a && (PP && console.warn("ACTIVE CHANGE", s.name, n, s.visible, t, "changed?" + a, s), e && RP(s, (c) => {
    t ? c.enabled && (Pa(c.__internalAwake.bind(c)), c.enabled && c.__internalEnable()) : c.__didAwake && c.enabled && (c.__didEnable = !1, c.onDisable());
  }));
  let l = !0;
  if (s.children)
    for (const c of s.children)
      ov(c, t, e, i + 1) === !1 && (l = !1);
  return l;
}
function dc(s) {
  let t = !0, e = s, i = !1;
  for (; e && e; ) {
    if (e.type === "Scene" && (i = !0), !Yc(e)) {
      t = !1;
      break;
    }
    e = e.parent;
  }
  if (!s) {
    console.error("GO is null");
    return;
  }
  s[po] = t && i;
}
function RP(s, t) {
  var e;
  if ((e = s.userData) != null && e.components)
    for (const i of s.userData.components)
      t(i);
}
const md = /* @__PURE__ */ new Map(), rv = Symbol("prewarmFlag"), mm = Symbol("waitingForPrewarm"), gm = x("debugprewarm");
function kP(s, t) {
  if (!s || s[rv] === !0 || s[mm] === !0)
    return;
  md.has(t) || md.set(t, []), s[mm] = !0, md.get(t).push(s), gm && console.debug("register prewarm", s.name);
}
let My = null, Ry = null;
function TP(s) {
  if (!s)
    return;
  const t = md.get(s);
  if (!(t != null && t.length))
    return;
  const e = s.mainCamera;
  if (e) {
    gm && console.log("prewarm", t.length, "objects", [...t]);
    const i = s.renderer;
    if (i.compile) {
      const n = s.scene;
      i.compile(n, e), My ?? (My = new zx(64)), Ry ?? (Ry = new Ux(1e-3, 9999999, My)), Ry.update(i, n);
      for (const o of t)
        o[rv] = !0, o[mm] = !1;
      t.length = 0, gm && console.log("prewarm done");
    }
  }
}
fe.registerCallback(pe.ContextCreated, (s) => {
  const t = s.context;
  jP(t), IP(t);
});
const $d = x("debugcomponents"), ky = "eff8ba80-635d-11ec-90d6-0242ac120003";
class Bt {
  constructor(t) {
    r(this, "_originalSeed");
    r(this, "_seed");
    typeof t == "string" && (t = Bt.hash(t)), this._originalSeed = t, this._seed = t;
  }
  get seed() {
    return this._seed;
  }
  set seed(t) {
    this._seed = t;
  }
  reset() {
    this._seed = this._originalSeed;
  }
  generateUUID(t) {
    if (typeof t == "string")
      return z_(t, ky);
    const e = this._seed;
    return this._seed -= 1, z_(e.toString(), ky);
  }
  initialize(t) {
    typeof t == "string" ? this._seed = Bt.hash(t) : this._seed = t;
  }
  static createFromString(t) {
    return new Bt(this.hash(t));
  }
  static hash(t) {
    let e = 0;
    for (let i = 0; i < t.length; i++)
      e = t.charCodeAt(i) + ((e << 5) - e);
    return e;
  }
}
var AP = /* @__PURE__ */ ((s) => (s.NewInstanceCreated = "new-instance-created", s.InstanceDestroyed = "instance-destroyed", s))(AP || {});
class EP {
  constructor(t) {
    r(this, "guid");
    r(this, "dontSave");
    this.guid = t;
  }
}
function ju(s, t, e = !0, i) {
  if (!s)
    return;
  const n = s;
  if (nn(s, e), !t) {
    console.warn("Can not send destroy: No networking connection provided", s.guid);
    return;
  }
  if (!t.isConnected) {
    z() && console.debug("Can not send destroy: not connected", s.guid);
    return;
  }
  let o = s.guid;
  if (!o && n.uuid && (o = n.uuid), !o) {
    console.warn("Can not send destroy: failed to find guid", s);
    return;
  }
  av(o, t, i);
}
function av(s, t, e) {
  const i = new EP(s);
  (e == null ? void 0 : e.saveInRoom) === !1 && (i.dontSave = !0), t.send("instance-destroyed", i, In.Queued);
}
function IP(s) {
  s.connection.beginListen("instance-destroyed", (t) => {
    $d && console.log("[Remote] Destroyed", s.scene, t);
    const e = bv(t.guid, s.scene);
    e && nn(e);
  });
}
class TD {
  constructor(t, e, i) {
    /** File to download */
    r(this, "filename");
    /** Checksum to verify its the correct file */
    r(this, "hash");
    /** Expected size of the referenced file and its dependencies */
    r(this, "size");
    this.filename = t, this.hash = e, this.size = i;
  }
}
class DP {
  constructor(t, e) {
    r(this, "guid");
    r(this, "originalGuid");
    r(this, "seed");
    r(this, "visible");
    r(this, "hostData");
    r(this, "dontSave");
    r(this, "parent");
    r(this, "position");
    r(this, "rotation");
    r(this, "scale");
    /** Set to true to prevent this model from being instantiated */
    r(this, "preventCreation");
    /**
     * When set this will delete the server state when the user disconnects
     */
    r(this, "deleteStateOnDisconnect");
    this.originalGuid = t, this.guid = e;
  }
}
function lv(s, t, e, i) {
  var c, h;
  const n = s;
  if (!n.guid)
    return console.warn("Can not instantiate: No guid", n), null;
  if (t.context || (t.context = ee.Current), !t.context)
    return console.error("Missing network instantiate options / reference to network connection in sync instantiate"), null;
  const o = t ? { ...t } : null, { instance: a, seed: l } = BP(n, t);
  if (a) {
    const d = a;
    if (d.guid) {
      $d && console.log("[Local] new instance", "gameobject:", a == null ? void 0 : a.guid);
      const u = new DP(n.guid, d.guid);
      u.seed = l, t.deleteOnDisconnect === !0 && (u.deleteStateOnDisconnect = !0), o && (o.position && (u.position = { x: o.position.x, y: o.position.y, z: o.position.z }), o.rotation && (u.rotation = { x: o.rotation.x, y: o.rotation.y, z: o.rotation.z, w: o.rotation.w }), o.scale && (u.scale = { x: o.scale.x, y: o.scale.y, z: o.scale.z })), u.position || (u.position = { x: d.position.x, y: d.position.y, z: d.position.z }), u.rotation || (u.rotation = { x: d.quaternion.x, y: d.quaternion.y, z: d.quaternion.z, w: d.quaternion.w }), u.scale || (u.scale = { x: d.scale.x, y: d.scale.y, z: d.scale.z }), u.visible = n.visible, o != null && o.parent && (typeof o.parent == "string" ? u.parent = o.parent : u.parent = o.parent.guid), u.hostData = e, i === !1 && (u.dontSave = !0), !((c = t == null ? void 0 : t.context) == null ? void 0 : c.connection) && z() && console.debug("Object will be instantiated but it will not be synced: not connected", n.guid), t.context.connection.isInRoom && oa.push(new WeakRef(d)), (h = t == null ? void 0 : t.context) == null || h.connection.send("new-instance-created", u);
    } else
      console.warn("Missing guid, can not send new instance event", d);
  }
  return a;
}
function LP() {
  return Math.random() * 9999999;
}
const oa = new Array();
function jP(s) {
  s.connection.beginListen("new-instance-created", async (t) => {
    const e = await zP(t.originalGuid, s.scene);
    if (t.preventCreation === !0)
      return;
    if (!e) {
      console.warn("could not find object that was instantiated: " + t.guid);
      return;
    }
    const i = new Qn();
    t.position && (i.position = new v(t.position.x, t.position.y, t.position.z)), t.rotation && (i.rotation = new W(t.rotation.x, t.rotation.y, t.rotation.z, t.rotation.w)), t.scale && (i.scale = new v(t.scale.x, t.scale.y, t.scale.z)), i.parent = t.parent, t.seed && (i.idProvider = new Bt(t.seed)), i.visible = t.visible, i.context = s, $d && s.alias && console.log("[Remote] instantiate in: " + s.alias);
    const n = Ha(e, i);
    oa.push(new WeakRef(n)), n && (t.parent === "scene" && s.scene.add(n), $d && console.log("[Remote] new instance", "gameobject:", n == null ? void 0 : n.guid, e));
  }), s.connection.beginListen("left-room", () => {
    oa.length > 0 && console.debug(`Left networking room, cleaning up ${oa.length} instantiated objects`);
    for (const t of oa) {
      const e = t.deref();
      e && e.destroy();
    }
    oa.length = 0;
  });
}
function BP(s, t) {
  const e = LP(), i = t ?? new Qn();
  i.idProvider = new Bt(e);
  const n = Ha(s, i);
  return { seed: e, instance: n };
}
const cv = {};
function FP(s, t) {
  cv[s] = t;
}
async function zP(s, t) {
  const e = cv[s];
  if (e != null) {
    const i = await e(s);
    if (i)
      return i;
  }
  return hv(s, t);
}
function hv(s, t) {
  if (t === null || !s)
    return null;
  if (t.guid === s)
    return t;
  if (t.children)
    for (const e of t.children) {
      const i = hv(s, e);
      if (i)
        return i;
    }
  return null;
}
const Xc = x("gizmos"), gt = x("debugextension"), Wf = x("debugtypes");
class UP {
  constructor() {
    r(this, "_types", /* @__PURE__ */ new Map());
    Wf && console.warn("TypeStore: Created", this);
  }
  /**
   * add a type to the store
   */
  add(t, e) {
    Wf && console.warn("ADD TYPE", t);
    const i = this._types.get(t);
    i ? Wf && i !== e && console.warn("Type name exists multiple times in your project and may lead to runtime errors:", t) : this._types.set(t, e);
  }
  /**
   * @returns the type for the given key if registered
   */
  get(t) {
    return this._types.get(t) || null;
  }
  /**
   * @returns the key/name for the given type if registered
   */
  getKey(t) {
    for (const [e, i] of this._types)
      if (i === t)
        return e;
    return null;
  }
}
const NP = Symbol("BuiltInType"), R = new UP(), AD = function(s) {
  R.get(s.name) || R.add(s.name, s);
}, Pg = x("debugresolvedependencies"), $P = ["/extensions/", "extensions/"], WP = [
  { prefix: "/nodes/", dependencyName: "node" },
  { prefix: "/meshes/", dependencyName: "mesh" },
  { prefix: "/materials/", dependencyName: "material" },
  { prefix: "/textures/", dependencyName: "texture" },
  { prefix: "/animations/", dependencyName: "animation" },
  // legacy support
  { prefix: "nodes/", dependencyName: "node" },
  { prefix: "meshes/", dependencyName: "mesh" },
  { prefix: "materials/", dependencyName: "material" },
  { prefix: "textures/", dependencyName: "texture" },
  { prefix: "animations/", dependencyName: "animation" }
];
async function Og(s, t) {
  Pg && console.log(s, t);
  const e = [];
  _m(WP, s, t, e);
  const i = await Promise.all(e);
  return typeof t == "string" && i.length === 1 ? i[0] : i;
}
function VP(s, t) {
  return !s || !t ? !1 : s["needle:identifier"] != null && t["needle:identifier"] != null ? s["needle:identifier"] === t["needle:identifier"] : !1;
}
function HP(s, t) {
  s["needle:identifier"] = t;
}
function _m(s, t, e, i) {
  if (typeof e == "object" && e !== void 0 && e !== null)
    for (const n of Object.keys(e)) {
      const o = e[n];
      if (typeof o == "string") {
        const a = Ty(t, o);
        if (a != null)
          typeof a.then == "function" ? i.push(a.then((l) => e[n] = l)) : e[n] = a;
        else {
          const l = Ay(s, t, o);
          if (l) {
            i.push(l.then((c) => (e[n] = c, c)));
            continue;
          }
        }
      } else if (Array.isArray(o))
        for (let a = 0; a < o.length; a++) {
          const l = o[a], c = Ty(t, l);
          if (c !== null) {
            typeof c.then == "function" ? i.push(c.then((h) => o[a] = h)) : o[a] = c;
            continue;
          }
          for (const h of s) {
            const d = dv(h.prefix, l);
            if (d >= 0) {
              Pg && console.log(h, d, h.dependencyName), i.push(t.getDependency(h.dependencyName, d).then((u) => o[a] = u));
              break;
            }
          }
          typeof l == "object" && _m(s, t, l, i);
        }
      else
        typeof o == "object" && _m(s, t, o, i);
    }
  else if (typeof e == "string") {
    const n = Ay(s, t, e);
    n && i.push(n);
  }
}
function Ty(s, t) {
  if (s && s.plugins && typeof t == "string") {
    for (const e of $P)
      if (t.startsWith(e)) {
        let i = t.substring(e.length);
        const n = i.indexOf("/");
        n >= 0 && (i = i.substring(0, n));
        const o = s.plugins[i];
        if (gt && console.log(i, o), typeof (o == null ? void 0 : o.resolve) == "function") {
          const a = t.substring(e.length + i.length + 1);
          return o.resolve(s, a);
        }
        break;
      }
  }
  return null;
}
function Ay(s, t, e) {
  for (const i of s) {
    const n = dv(i.prefix, e);
    if (n >= 0)
      return Pg && console.warn("GET DEPENDENCY", i, n, i.dependencyName), t.getDependency(i.dependencyName, n);
  }
  return null;
}
function dv(s, t) {
  if (typeof t == "string" && t.startsWith(s)) {
    const e = t.substring(s.length), i = Number.parseInt(e);
    if (i >= 0)
      return i;
  }
  return -1;
}
const Vf = "NEEDLE_persistent_assets";
function GP(s) {
  return (s == null ? void 0 : s.___persistentAsset) === !0;
}
class qP {
  constructor(t) {
    r(this, "parser");
    this.parser = t;
  }
  get name() {
    return Vf;
  }
  async afterRoot(t) {
    var n, o;
    if (!((o = (n = this.parser) == null ? void 0 : n.json) != null && o.extensions))
      return;
    const e = this.parser.json.extensions[Vf];
    if (!e)
      return;
    gt && console.log(e);
    const i = new Array();
    for (const a of e == null ? void 0 : e.assets) {
      const l = Og(this.parser, a);
      l && i.push(l);
    }
    await Promise.all(i);
  }
  resolve(t, e) {
    const i = Number.parseInt(e);
    if (i >= 0) {
      gt && console.log(e);
      const n = t.json.extensions[Vf];
      if (n) {
        const o = n == null ? void 0 : n.assets[i];
        if (o && typeof o == "object") {
          o.___persistentAsset = !0;
          const a = o.__type;
          a && R.get(a);
        }
        return o;
      }
    }
    return null;
  }
}
const Dn = x("debugserializer");
class XP {
  constructor() {
    /** type > serializer map */
    r(this, "typeMap", /* @__PURE__ */ new Map());
  }
  register(t, e) {
    if (this.typeMap.has(t)) {
      const i = this.typeMap.get(t);
      if (i === e)
        return;
      Dn && console.warn("Type: " + t + " is already registered", e, i);
    }
    Dn && console.log("Register type serializer", e.name, e, t), this.typeMap.set(t, e);
  }
  getSerializer(t) {
    if (t)
      return this.typeMap.get(t);
  }
  getSerializerForConstructor(t, e = 0) {
    if (e > 20)
      return;
    if (!t || !t.constructor) {
      Dn && console.log("invalid type");
      return;
    }
    const i = t.name, n = this.getSerializer(t);
    if (n !== void 0)
      return Dn && console.log("FOUND SERIALIZER", n == null ? void 0 : n.name, t.name, t.constructor.name, "for type: " + i, n, t, this.typeMap), n;
    const o = Object.getPrototypeOf(t);
    if (o && o !== t) {
      const a = this.getSerializerForConstructor(o, ++e);
      if (a) {
        const l = o.constructor || o.prototype;
        Dn && console.log("FOUND SERIALIZER(in constructor) " + l.constructor.name, l.name, l, a), this.register(l, a);
      }
      return a;
    }
    Dn && console.warn("No serializer found for " + i, t, t.name, t.constructor.name);
  }
}
const Wd = new XP();
class rn {
  // register<T>(c: Constructor<T> | Constructor<T>[])
  // {
  //     if (Array.isArray(c)) {
  //         for (const t of c) {
  //             helper.register(t.name, this);
  //         }
  //     }
  //     else {
  //         helper.register(c.name, this);
  //     }
  // }
  constructor(t, e) {
    r(this, "name");
    if (this.name = e, Array.isArray(t))
      for (const i of t)
        Wd.register(i, this);
    else
      Wd.register(t, this);
  }
}
class QP {
  constructor() {
    r(this, "isDevMode", ui());
    r(this, "cache", {});
  }
  /** only call when assigning values for the very first time */
  registerDefinedKeys(t, e) {
    if (this.isDevMode && this.cache[t] === void 0) {
      this.cache[t] = Object.keys(e);
      const i = e;
      i.$serializedTypes && Object.keys(i.$serializedTypes) && this.cache[t].push(...Object.keys(i.$serializedTypes)), Dn && console.log("registerDefinedKeys for " + t, this.cache[t], e);
    }
  }
  getDefinedKey(t, e) {
    return this.cache[t] === void 0 ? !1 : this.cache[t].includes(e);
  }
}
class uv {
  constructor(t) {
    r(this, "root");
    r(this, "gltf");
    /** the url of the glb that is currently being loaded */
    r(this, "gltfId");
    r(this, "object");
    r(this, "target");
    r(this, "nodeId");
    r(this, "nodeToObject");
    r(this, "objectToNode");
    r(this, "context");
    r(this, "path");
    r(this, "type");
    /** the serializable attribute for this field (target.path) */
    r(this, "serializable");
    /** holds information if a field was undefined before serialization. This gives us info if we might want to warn the user about missing attributes */
    r(this, "implementationInformation");
    this.root = t;
  }
}
function YP(s, t) {
  const e = s.$serializedTypes;
  if (e === void 0)
    return null;
  const i = {};
  for (const o in e) {
    const a = s[o];
    if (a != null && typeof a == "object") {
      const l = Wd.getSerializerForConstructor(a);
      if (l) {
        i[o] = l.onSerialize(a, t);
        continue;
      }
    }
    i[o] = a;
  }
  function n(o) {
    const a = R._types;
    for (const [l, c] of a)
      if (c === s.constructor)
        return l;
    return o.__name || o.constructor.name;
  }
  return i.name = n(s), typeof s.guid == "string" && (i.guid = s.guid), i;
}
const gd = [];
function fv(s, t) {
  if (!s)
    return t;
  typeof s.$serializedTypes == "object" && (t || (t = {}), Object.assign(t, s.$serializedTypes));
  const e = Object.getPrototypeOf(s);
  return fv(e, t);
}
function ym(s, t, e) {
  if (!s)
    return !1;
  if (e.target = s, s.onBeforeDeserialize !== void 0) {
    const n = s.onBeforeDeserialize(t, e);
    if (typeof n == "boolean")
      return n;
  }
  const i = fv(s);
  if (t) {
    if (typeof t.guid == "string" && (s.guid = t.guid), i)
      for (const n in i) {
        let o = function(c) {
          const d = c.type;
          return d ? bm(l, d, e, void 0, s[n]) : bm(l, c, e, void 0, s[n]);
        };
        const a = i[n], l = t[n];
        if (Dn && console.log(n, l, s, a), !(s[n] !== void 0 && l === void 0) && (e.type = void 0, e.path = n, e.serializable = a, !(s.onBeforeDeserializeMember !== void 0 && s.onBeforeDeserializeMember(n, l, e) === !0))) {
          if (a === null)
            s[n] = l;
          else {
            if (Array.isArray(a))
              for (let c = 0; c < a.length; c++) {
                const h = a[c], d = o(h);
                if (d !== void 0 || c === a.length - 1) {
                  s[n] = d;
                  break;
                }
              }
            else
              s[n] = o(a);
            gd.length = 0;
          }
          s.onAfterDeserializeMember !== void 0 && s.onAfterDeserializeMember(n, l, e);
        }
      }
    JP(s, t);
  }
  return ZP(s, t, e.implementationInformation), s.onAfterDeserialize !== void 0 && s.onAfterDeserialize(t, e), !0;
}
const KP = x("noerrors");
function ZP(s, t, e) {
  var o, a;
  if (KP || !t || !ui() || !s || s.constructor && s.constructor[NP] === !0)
    return;
  const i = (o = s.constructor) == null ? void 0 : o.name, n = Object.getOwnPropertyNames(t);
  for (const l of n) {
    if (l === "sourceId")
      continue;
    const c = s[l];
    if (c == null)
      continue;
    const h = t[l];
    if ((e == null ? void 0 : e.getDefinedKey(i, l)) === !1) {
      const d = l.charAt(0).toUpperCase() + l.slice(1);
      e.getDefinedKey(i, d) && (Bn(Zi.Warn, '<strong>Please rename</strong> "' + d + '" to "' + l + '" in ' + i), console.warn('Please use lowercase for field: "' + d + '" in ' + i, h, s));
      continue;
    }
    if (h != null) {
      if (typeof h == "object" && (c === void 0 || !c.isObject3D)) {
        if (typeof h.node == "number" || typeof h.guid == "string") {
          if (h.could_not_resolve)
            continue;
          if (!(c !== void 0 && Object.keys(c).length > 1)) {
            Bn(Zi.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(Object3D)
${l}? : Object3D;

in ${i}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">See documentation</a>`), console.warn(i, l, s[l], s);
            continue;
          }
        } else if (!Array.isArray(c)) {
          const d = (a = c.constructor) == null ? void 0 : a.name;
          if (d === "Object" && !c.constructor["did_warn:missing_serializable"]) {
            c.constructor["did_warn:missing_serializable"] = !0;
            const u = 'You might be missing a @serializable(Type) decorator for field "' + l + '" in ' + i + ".ts";
            console.warn(u + `
${l}:`, h, d), Bn(Zi.Warn, "Dev Warning: Are you missing a type in @serializable? Please check the browser console for details");
          }
        }
      }
      if (typeof c == "string" && typeof h == "string" && (h.endsWith(".gltf") || h.endsWith(".glb"))) {
        Bn(Zi.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(AssetReference)
${l}? : AssetReference;

in script ${i}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">documentation</a>`), console.warn(i, l, s[l], s);
        continue;
      }
    }
  }
}
function JP(s, t) {
  for (const e of Object.keys(t)) {
    const i = t[e];
    if (typeof i == "object" && i !== null && i !== void 0) {
      const n = s[e];
      if (!n) {
        Dn && console.log(e, "is undefined on", s);
        continue;
      }
      for (const o of Object.keys(i))
        if (n[o] === void 0 && Ey(i[o]) && !Ey(n)) {
          const l = eO(n, o);
          if (l && ((l == null ? void 0 : l.writable) === void 0 || (l == null ? void 0 : l.writable) === !1) && l.set === void 0) {
            Dn && console.warn('Property is not writable "' + o + '"', n, l, i[o], n[o]);
            continue;
          }
          n[o] = i[o];
        }
    }
  }
}
function eO(s, t) {
  for (; s; ) {
    const e = Object.getOwnPropertyDescriptor(s, t);
    if (e)
      return e;
    s = Object.getPrototypeOf(s);
  }
}
function Ey(s) {
  switch (typeof s) {
    case "number":
    case "string":
    case "boolean":
      return !0;
  }
  return !1;
}
function bm(s, t, e, i, n) {
  let o = typeof t == "function" && t.prototype === void 0, a = t;
  if (o)
    try {
      if (a = t == null ? void 0 : t.call(t, n), o = !1, a == null)
        return;
    } catch (d) {
      console.error("Error in callback", d, s);
    }
  if (e.type = a, !o && n && (n instanceof Se || n instanceof Fe || n instanceof q || n instanceof Ps || n instanceof uo))
    return n;
  if (i || (i = {
    serializer: Wd.getSerializerForConstructor(a)
  }), n && typeof n == "object" && GP(n)) {
    if (n.__concreteInstance)
      return n.__concreteInstance;
    const d = n;
    if (!d.$serializedTypes && a.prototype.$serializedTypes && (d.$serializedTypes = a.prototype.$serializedTypes), d.$serializedTypes && ym(d, s, e), n && a !== void 0)
      try {
        let u = null;
        i.serializer && (u = i.serializer.onDeserialize(s, e)), u || (u = new a(), gt && console.log("Create concrete instance for persistent asset", n, "instance:", u), $a(u, n)), n.__concreteInstance = u, n = u;
      } catch (u) {
        console.error("Error creating instance or creating values on instance", u, n, a);
      }
    return n;
  }
  if (Array.isArray(s)) {
    const d = [];
    for (let u = 0; u < s.length; u++) {
      const p = s[u], m = bm(p, t, e, i, p);
      d.push(m);
    }
    return d;
  }
  const l = i == null ? void 0 : i.serializer;
  if (l)
    return l.onDeserialize(s, e);
  let c;
  if (s && (s.isMaterial || s.isTexture || s.isObject3D || s instanceof uo))
    c = s;
  else {
    if (s === void 0)
      return;
    if (s === null && (a === Se || a === Fe || a === q || a === uo))
      return null;
    try {
      c = new a(...tO(s));
    } catch (d) {
      console.error("Error creating " + e.path, e.target, d);
      return;
    }
  }
  const h = c;
  return h.$serializedTypes && ym(h, s, e), c;
}
function tO(s) {
  if (gd.length = 0, typeof s == "object" && s !== null && s !== void 0)
    for (const t of Object.keys(s))
      gd.push(s[t]);
  return gd;
}
const vm = Symbol("assigned component properties");
function $a(s, t, e) {
  var n;
  if (t == null || s == null)
    return;
  s[vm] = !0;
  const i = ((n = s.constructor) == null ? void 0 : n.name) ?? "unknown";
  e == null || e.registerDefinedKeys(i, s);
  for (const o of Object.keys(t)) {
    const a = iO(s, o);
    typeof (a == null ? void 0 : a.value) != "function" && (!a || a.writable === !0 || (a == null ? void 0 : a.set) !== void 0) && (s[o] = t[o]);
  }
  delete s[vm];
}
function iO(s, t) {
  let e;
  do
    e = Object.getOwnPropertyDescriptor(s, t);
  while (!e && (s = Object.getPrototypeOf(s)));
  return e;
}
const pv = Symbol("customVisibilityFlag");
function bs(s, t) {
  s.layers[pv] = t;
}
const Iy = Symbol("DidPatchLayers");
function nO() {
  const s = vo.prototype;
  if (s[Iy])
    return;
  s[Iy] = !0;
  const t = s.test;
  s.test = function(e) {
    return this[pv] === !1 ? !1 : t.call(this, e);
  };
}
nO();
Object.defineProperty(ye.prototype, "fov", {
  get: function() {
    return this._fov;
  },
  set: function(s) {
    const t = s !== this._fov;
    this._fov = s, t && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
Object.defineProperty(ye.prototype, "near", {
  get: function() {
    return this._near;
  },
  set: function(s) {
    const t = s !== this._near;
    this._near = s, t && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
Object.defineProperty(ye.prototype, "far", {
  get: function() {
    return this._far;
  },
  set: function(s) {
    const t = s !== this._far;
    this._far = s, t && this.view !== void 0 && this.updateProjectionMatrix();
  },
  configurable: !0
});
const mv = /* @__PURE__ */ new Map();
function sO(s, t) {
  if (!s)
    return;
  if (!t) {
    console.warn("No prototype found", s, s.prototype, s.constructor);
    return;
  }
  const e = mv.get(t);
  e && e.apply(s);
}
function oO(s) {
  const t = rO(s.prototype);
  mv.set(s, t);
}
function rO(s) {
  return new aO(s);
}
class aO {
  constructor(t) {
    r(this, "$symbol");
    r(this, "extensions");
    r(this, "descriptors");
    this.$symbol = Symbol("prototype-extension"), this.extensions = Object.keys(t), this.descriptors = new Array();
    for (let e = 0; e < this.extensions.length; e++) {
      const i = this.extensions[e], n = Object.getOwnPropertyDescriptor(t, i);
      n && this.descriptors.push(n);
    }
  }
  apply(t) {
    if (!t[this.$symbol]) {
      t[this.$symbol] = !0;
      for (let e = 0; e < this.extensions.length; e++) {
        const i = this.extensions[e], n = this.descriptors[e];
        n && Object.defineProperty(t, i, n);
      }
    }
  }
}
const lO = x("debuggetcomponent"), Dy = () => lO || globalThis.NEEDLE_DEBUG_GETCOMPONENT === !0;
function cO(s) {
  return s == null || s.isObject3D ? s : s.object && s.object.isObject3D ? s.object : s;
}
function gv(s, t) {
  if (!s || !s.userData.components)
    return t;
  const e = s.userData.components.indexOf(t);
  return e < 0 || (Lu.dispatchComponentLifecycleEvent("removing-component", t), t.gameObject = null, s.userData.components.splice(e, 1)), t;
}
function Bu(s, t, e) {
  const i = Ya(s, t);
  return i || en(s, t, e);
}
const _v = new Bt("addComponentIdProvider");
function Oa(s, t, e = !0) {
  s.userData || (s.userData = {}), s.userData.components || (s.userData.components = []), s.userData.components.push(t), t.gameObject = s, (t.guid === void 0 || t.guid === "invalid") && (t.guid = _v.generateUUID()), Rg(s), Eg(t, t.context);
  try {
    e && t.__internalAwake && (dc(s), t.activeAndEnabled && t.__internalAwake()), Lu.dispatchComponentLifecycleEvent("component-added", t);
  } catch (i) {
    console.error(i);
  }
  return t;
}
function en(s, t, e, i) {
  if (typeof t == "function") {
    const n = new t();
    e && n.__internalNewInstanceCreated(e);
    let o = !0;
    return (i == null ? void 0 : i.callAwake) != null && (o = i.callAwake), Oa(s, n, o);
  }
  if (t.destroyed)
    return console.warn("Can not move/add a destroyed component", t), t;
  if (t.gameObject === s)
    return t;
  if (t.gameObject && t.gameObject.userData.components) {
    const n = t.gameObject.userData.components.indexOf(t);
    t.gameObject.userData.components.splice(n, 1);
  }
  if (!s.userData.components)
    s.userData.components = [];
  else if (s.userData.components.includes(t))
    return t;
  return s.userData.components.push(t), t.gameObject = s, (t.guid === void 0 || t.guid === "invalid") && (t.guid = _v.generateUUID()), e && t._internalInit(e), Eg(t, t.context), t;
}
function hO(s) {
  if (s.gameObject && s.gameObject.userData.components) {
    const t = s.gameObject.userData.components.indexOf(s);
    s.gameObject.userData.components.splice(t, 1);
  }
  s.__internalDisable && s.__internalDisable(), ys(s, s.context ?? ee.Current), s.destroy(), s.gameObject = null;
}
let Ly = !1;
function yv(s, t, e) {
  var i;
  if (s == null)
    return null;
  if (!s.isObject3D)
    return console.error("Object is not object3D"), null;
  if (!((i = s == null ? void 0 : s.userData) != null && i.components) || (typeof t == "string" && (Ly || (Ly = !0, console.warn(`Accessing components by name is not supported.
Please use the component type instead. This may keep working in local development but it will fail when bundling your application.

You can import other modules your main module to get access to types
or if you use npmdefs you can make types available globally using globalThis:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis`, t))), Dy() && console.log("[onGetComponent] FIND", t), t == null))
    return null;
  for (let n = 0; n < s.userData.components.length; n++) {
    const o = s.userData.components[n];
    let a = Object.getPrototypeOf(o);
    for (; a; ) {
      if (a === t.prototype)
        if (Dy() && console.log("[onGetComponent] MATCH BY PROTOYPE", a), e)
          e.push(o);
        else
          return o;
      a = Object.getPrototypeOf(a);
    }
  }
  return e || null;
}
function Ya(s, t) {
  const e = yv(s, t);
  return e ? Array.isArray(e) ? e[0] : e : null;
}
function Fu(s, t, e, i = !0) {
  return e || (e = []), i && (e.length = 0), yv(s, t, e), e;
}
function zu(s, t, e) {
  var n;
  const i = Ya(s, t);
  if (e === !1 && (i == null ? void 0 : i.enabled) === !1)
    return null;
  if (i)
    return i;
  for (let o = 0; o < ((n = s == null ? void 0 : s.children) == null ? void 0 : n.length); o++) {
    const a = zu(s.children[o], t);
    if (a)
      return a;
  }
  return null;
}
function Qc(s, t, e, i = !0) {
  var n;
  e || (e = []), i && (e.length = 0), Fu(s, t, e, !1);
  for (let o = 0; o < ((n = s == null ? void 0 : s.children) == null ? void 0 : n.length); o++)
    Qc(s.children[o], t, e, !1);
  return e;
}
function Vd(s, t) {
  if (!s)
    return null;
  if (Array.isArray(s)) {
    for (let i = 0; i < s.length; i++) {
      const n = cO(s[i]), o = Vd(n, t);
      if (o)
        return o;
    }
    return null;
  }
  const e = Ya(s, t);
  return e || (s.parent ? Vd(s.parent, t) : null);
}
function Mg(s, t, e, i = !0) {
  return e || (e = []), i && (e.length = 0), s ? (Fu(s, t, e, !1), s.parent ? Mg(s.parent, t, e, !1) : e) : e;
}
function Uu(s, t = void 0, e = !0) {
  if (!s)
    return null;
  if (!t && (t = ee.Current, !t))
    return console.error("Can not search object without any needle context or scene!!!"), null;
  let i = t;
  if (i.isScene || (i = t == null ? void 0 : t.scene), !i)
    return null;
  for (const n in i.children) {
    const o = i.children[n];
    if (e === !1 && o[po] === !1)
      continue;
    const a = zu(o, s);
    if (a)
      return a;
  }
  return null;
}
function dO(s, t, e = void 0) {
  if (!s)
    return t ?? [];
  if (t || (t = []), t.length = 0, !e && (e = ee.Current, !e))
    return console.error("Can not search object without any needle context or scene!!!"), t;
  "scene" in e && (e = e.scene);
  const i = e;
  if (!i)
    return t;
  for (const n in i.children) {
    const o = i.children[n];
    Qc(o, s, t, !1);
  }
  return t;
}
function Rg(s) {
  s && s.isObject3D === !0 && sO(s, L);
}
L.prototype.SetActive = function(s) {
  this.visible = s;
};
L.prototype.setActive = function(s) {
  this.visible = s;
};
L.prototype.destroy = function() {
  nn(this);
};
L.prototype.addComponent = function(s, t) {
  return en(this, s, t);
};
L.prototype.addNewComponent = function(s, t) {
  return en(this, s, t);
};
L.prototype.removeComponent = function(s) {
  return gv(this, s);
};
L.prototype.getOrAddComponent = function(s, t) {
  return Bu(this, s, t);
};
L.prototype.getComponent = function(s) {
  return Ya(this, s);
};
L.prototype.getComponents = function(s, t) {
  return Fu(this, s, t);
};
L.prototype.getComponentInChildren = function(s) {
  return zu(this, s);
};
L.prototype.getComponentsInChildren = function(s, t) {
  return Qc(this, s, t);
};
L.prototype.getComponentInParent = function(s) {
  return Vd(this, s);
};
L.prototype.getComponentsInParent = function(s, t) {
  return Mg(this, s, t);
};
Object.getOwnPropertyDescriptor(L.prototype, "activeSelf") || Object.defineProperty(L.prototype, "activeSelf", {
  get: function() {
    return Yc(this);
  },
  set: function(s) {
    bd(this, s);
  }
});
Object.getOwnPropertyDescriptor(L.prototype, "worldPosition") || Object.defineProperty(L.prototype, "worldPosition", {
  get: function() {
    return this instanceof l0 ? ie(this.object) : ie(this);
  },
  set: function(s) {
    yt(this, s);
  }
});
Object.getOwnPropertyDescriptor(L.prototype, "worldQuaternion") || Object.defineProperty(L.prototype, "worldQuaternion", {
  get: function() {
    return this instanceof l0 ? Ce(this.object) : Ce(this);
  },
  set: function(s) {
    wn(this, s);
  }
});
Object.getOwnPropertyDescriptor(L.prototype, "worldRotation") || Object.defineProperty(L.prototype, "worldRotation", {
  get: function() {
    return Au(this);
  },
  set: function(s) {
    A0(this, s);
  }
});
Object.getOwnPropertyDescriptor(L.prototype, "worldScale") || Object.defineProperty(L.prototype, "worldScale", {
  get: function() {
    return Ke(this);
  },
  set: function(s) {
    Lc(this, s);
  }
});
Object.getOwnPropertyDescriptor(L.prototype, "worldForward") || Object.defineProperty(L.prototype, "worldForward", {
  get: function() {
    return G().set(0, 0, 1).applyQuaternion(Ce(this));
  }
});
Object.getOwnPropertyDescriptor(L.prototype, "worldRight") || Object.defineProperty(L.prototype, "worldRight", {
  get: function() {
    return G().set(1, 0, 0).applyQuaternion(Ce(this));
  }
});
Object.getOwnPropertyDescriptor(L.prototype, "worldUp") || Object.defineProperty(L.prototype, "worldUp", {
  get: function() {
    return G().set(0, 1, 0).applyQuaternion(Ce(this));
  }
});
oO(L);
class we extends ae {
  constructor(e, i, n, o) {
    var t = (...args) => {
      super(...args);
      r(this, "alpha", 1);
    };
    i != null && n != null ? (t(e, i, n), this.alpha = o) : (t(e), this.alpha = 1);
  }
  get isRGBAColor() {
    return !0;
  }
  set a(e) {
    this.alpha = e;
  }
  get a() {
    return this.alpha;
  }
  clone() {
    const e = super.clone();
    return e.alpha = this.alpha, e;
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, "alpha" in e && typeof e.alpha == "number" ? this.alpha = e.alpha : typeof e.a == "number" && (this.alpha = e.a), this;
  }
  lerp(e, i) {
    const n = e;
    return n.alpha != null && (this.alpha = $.lerp(this.alpha, n.alpha, i)), super.lerp(e, i);
  }
  lerpColors(e, i, n) {
    const o = e, a = i;
    return o.alpha != null && a.alpha != null && (this.alpha = $.lerp(o.alpha, a.alpha, n)), super.lerpColors(e, i, n);
  }
  multiply(e) {
    const i = e;
    return i.alpha != null && (this.alpha = this.alpha * i.alpha), super.multiply(e);
  }
  fromArray(e, i = 0) {
    return this.alpha = e[i + 3], super.fromArray(e, i);
  }
}
const _d = x("debuggetcomponent"), yd = x("debuginstantiate");
class Qn {
  constructor() {
    r(this, "idProvider");
    r(this, "parent");
    r(this, "keepWorldPosition");
    r(this, "position");
    r(this, "rotation");
    r(this, "scale");
    r(this, "visible");
    r(this, "context");
    r(this, "components");
  }
  clone() {
    var e, i, n;
    const t = new Qn();
    return t.idProvider = this.idProvider, t.parent = this.parent, t.keepWorldPosition = this.keepWorldPosition, t.position = (e = this.position) == null ? void 0 : e.clone(), t.rotation = (i = this.rotation) == null ? void 0 : i.clone(), t.scale = (n = this.scale) == null ? void 0 : n.clone(), t.visible = this.visible, t.context = this.context, t.components = this.components, t;
  }
  /** Copy fields from another object, clone field references */
  cloneAssign(t) {
    var e, i, n;
    this.idProvider = t.idProvider, this.parent = t.parent, this.keepWorldPosition = t.keepWorldPosition, this.position = (e = t.position) == null ? void 0 : e.clone(), this.rotation = (i = t.rotation) == null ? void 0 : i.clone(), this.scale = (n = t.scale) == null ? void 0 : n.clone(), this.visible = t.visible, this.context = t.context, this.components = t.components;
  }
}
function Yc(s) {
  return s.visible;
}
function bd(s, t) {
  return typeof t == "number" && (t = t > 0.5), s.visible = t, s.visible;
}
function uO(s) {
  return s[po] || kg(s);
}
function fO(s, t) {
  s[iv] = t;
}
function kg(s) {
  return _n.isUsingInstancing(s);
}
function bv(s, t) {
  return Ic(s, t, !0, !0);
}
const vv = Symbol("isDestroyed");
function Wa(s) {
  return s[vv];
}
function pO(s, t) {
  s[vv] = t;
}
const wm = Symbol("isDontDestroy");
function Rl(s, t = !0) {
  s[wm] = t;
}
const vd = [], wd = [];
function nn(s, t = !0, e = !1) {
  vd.length = 0, wd.length = 0, xm(s, t, !0);
  for (const i of vd)
    i.gameObject = null, i.context = null;
  for (const i of wd)
    pO(i, !0), e && Ae(i), xP(i);
  wd.length = 0, vd.length = 0;
}
function xm(s, t = !0, e = !0) {
  var a;
  if (s == null)
    return;
  const i = s;
  if (i.isComponent) {
    if (i[wm])
      return;
    vd.push(i);
    const l = i.gameObject;
    i.__internalDisable(), i.__internalDestroy(), i.gameObject = l;
    return;
  }
  if (s[wm])
    return;
  const n = s;
  _d && console.log(n), wd.push(n);
  const o = (a = n.userData) == null ? void 0 : a.components;
  if (o != null && Array.isArray(o)) {
    let l = o.length;
    for (let c = 0; c < o.length; c++) {
      const h = o[c];
      xm(h, t, !1), o.length < l && (l = o.length, c--);
    }
  }
  if (t && n.children)
    for (const l of n.children)
      xm(l, t, !1);
  e && n.removeFromParent();
}
function Va(s, t, e = !0) {
  return wv(s, t, e);
}
function* Tg(s, t, e = !1, i = 999, n = 0) {
  if (s != null && s.userData.components && !(n > i)) {
    for (const o of s.userData.components)
      t && (o == null ? void 0 : o.isComponent) === !0 && o instanceof t ? yield o : yield o;
    if (e === !0)
      for (const o of s.children)
        yield* Tg(o, t, !0, i, n + 1);
  }
}
function wv(s, t, e, i = 0) {
  var n;
  if (s) {
    if (s.isObject3D, i > 1e3) {
      console.warn("Failed to iterate components: too many levels");
      return;
    }
    if ((n = s.userData) != null && n.components)
      for (let o = 0; o < s.userData.components.length; o++) {
        const a = s.userData.components[o];
        if ((a == null ? void 0 : a.isComponent) === !0) {
          const l = t(a);
          if (l !== void 0)
            return l;
        }
      }
    if (e && s.children) {
      const o = i + 1;
      for (let a = 0; a < s.children.length; a++) {
        const l = s.children[a];
        if (!l)
          continue;
        const c = wv(l, t, e, o);
        if (c !== void 0)
          return c;
      }
    }
  }
}
function Ha(s, t) {
  if ("isAssetReference" in s)
    return s.instantiate(t ?? void 0);
  let e = null;
  t != null && (t.x !== void 0 ? (e = new Qn(), e.position = t) : e = t);
  let i = ee.Current;
  e != null && e.context && (i = e.context), _d && i.alias && console.log("context", i.alias), e && !e.idProvider && (e.idProvider = new Bt(Date.now()));
  const n = [], o = {}, a = {}, l = xv(i, s, e, n, o, a);
  l && (gO(o), mO(a, o)), _d && (rm(s, !0), rm(l, !0));
  const c = {};
  if ((e == null ? void 0 : e.components) !== !1) {
    for (const h in n) {
      const d = n[h], u = d.guid;
      e && e.idProvider && (d.guid = e.idProvider.generateUUID(), c[u] = d.guid, _d && console.log(d.name, d.guid)), Eg(d, i), d.__internalNewInstanceCreated && d.__internalNewInstanceCreated();
    }
    for (const h in n) {
      const d = n[h];
      d.resolveGuids && d.resolveGuids(c), d.enabled !== !1 && (d.enabled = !0);
    }
    Nd(i);
  }
  return l;
}
function xv(s, t, e, i, n, o) {
  var d;
  if (!t)
    return null;
  const a = t.userData;
  t.userData = {};
  const l = t.children;
  t.children = [];
  const c = t.clone(!1);
  if (Rg(c), t.userData = a, t.children = l, n[t.uuid] = { original: t, clone: c }, yd && console.log("ADD", t, c), t.type === "SkinnedMesh" && (o[t.uuid] = { original: t, clone: c }), (e == null ? void 0 : e.visible) !== void 0 && (c.visible = e.visible), e != null && e.idProvider) {
    c.uuid = e.idProvider.generateUUID();
    const u = c;
    u && (u.guid = c.uuid);
  }
  t.animations && t.animations.length > 0 && (c.animations = [...t.animations]);
  const h = t.parent;
  if (h && h.add(c), e != null && e.position ? yt(c, e.position) : c.position.copy(t.position), e != null && e.rotation ? wn(c, e.rotation) : c.quaternion.copy(t.quaternion), e != null && e.scale ? c.scale.copy(e.scale) : c.scale.copy(t.scale), e != null && e.parent && e.parent !== "scene") {
    let u = null;
    if (typeof e.parent == "string" ? u = Ic(e.parent, s.scene, !0) : u = e.parent, u) {
      const p = e.keepWorldPosition === !0 ? u.attach : u.add;
      p ? p.call(u, c) : console.error("Invalid parent object", u, "received when instantiating:", t);
    } else
      console.warn("could not find parent:", e.parent);
  }
  for (const [u, p] of Object.entries(t.userData))
    u !== "components" && (c.userData[u] = p);
  if ((d = t.userData) != null && d.components) {
    const u = t.userData.components, p = [];
    c.userData.components = p;
    for (let m = 0; m < u.length; m++) {
      const g = u[m], _ = new g.constructor();
      $a(_, g), g[fd] !== void 0 && (_[fd] = g[fd]), p.push(_), _.gameObject = c, i.push(_), n[g.guid] = { original: g, clone: _ }, Lu.dispatchComponentLifecycleEvent("component-added", _);
    }
  }
  e && (e.position = void 0, e.rotation = void 0, e.scale = void 0, e.parent = void 0);
  for (const u in t.children) {
    const p = t.children[u], m = xv(s, p, e, i, n, o);
    m && c.add(m);
  }
  return c;
}
function mO(s, t) {
  for (const e in s) {
    const i = s[e], n = i.original, o = n.skeleton, a = i.clone;
    if (!o) {
      console.warn("Skinned mesh has no skeleton?", i);
      continue;
    }
    const l = o.bones, c = a.skeleton.clone();
    a.skeleton = c, a.bindMatrix.clone().copy(n.bindMatrix), a.bindMatrixInverse.copy(n.bindMatrixInverse);
    const h = [];
    c.bones = h;
    for (let d = 0; d < l.length; d++) {
      const u = l[d], m = t[u.uuid].clone;
      h.push(m);
    }
  }
  for (const e in s) {
    const i = s[e].clone;
    i.skeleton.update(), i.bind(i.skeleton, i.bindMatrix), i.updateMatrixWorld(!0);
  }
}
function gO(s) {
  var t;
  for (const e in s) {
    const n = s[e].clone;
    if (n != null && n.isObject3D && ((t = n == null ? void 0 : n.userData) != null && t.components))
      for (let o = 0; o < n.userData.components.length; o++) {
        const a = n.userData.components[o], l = Object.entries(a);
        for (const [c, h] of l)
          if (Array.isArray(h)) {
            const d = [];
            a[c] = d;
            for (let u = 0; u < h.length; u++) {
              const p = h[u];
              if (typeof p != "object") {
                d.push(p);
                continue;
              }
              const m = jy(a, c, p, s);
              m !== void 0 ? d.push(m) : d.push(p);
            }
          } else if (typeof h == "object") {
            const d = jy(a, c, h, s);
            d !== void 0 && (a[c] = d);
          }
      }
  }
}
function jy(s, t, e, i) {
  var n, o;
  if (e != null)
    if (e.isComponent === !0) {
      const a = e.gameObject;
      if (a) {
        const l = a.uuid, c = (n = i[l]) == null ? void 0 : n.clone;
        if (!c) {
          yd && console.log("reference did not change", t, s, e);
          return;
        }
        const h = a.userData.components.indexOf(e);
        if (h >= 0 && c.isObject3D)
          return yd && console.log(t, l), c.userData.components[h];
        console.warn("could not find component", t, e);
      }
    } else if (e.isObject3D === !0) {
      if (t === "gameObject")
        return;
      const a = e;
      if (a) {
        const l = a.uuid, c = (o = i[l]) == null ? void 0 : o.clone;
        if (c)
          return yd && console.log(t, "old", e, "new", c), c;
      }
    } else {
      if (e.isVector4 || e.isVector3 || e.isVector2 || e.isQuaternion || e.isEuler)
        return e.clone();
      if (e.isColor === !0)
        return e.clone();
      if (e.isEventList === !0)
        return e.__internalOnInstantiate(i);
    }
}
var Ga;
((s) => {
  s.baseUrl = "https://networking.needle.tools";
  function i(d) {
    return U_(new Uint8Array(d));
  }
  s.hashMD5 = i;
  function n(d) {
    const u = U_(new Uint8Array(d), { encoding: "binary", asBytes: !0 });
    return btoa(String.fromCharCode(...u));
  }
  s.hashMD5_Base64 = n;
  function o(d) {
    const u = new Uint8Array(d);
    return crypto.subtle.digest("SHA-256", u).then((m) => btoa(String.fromCharCode(...new Uint8Array(m))));
  }
  s.hashSha256 = o;
  function a(d) {
    const u = d.filesize / 1024 / 1024;
    return Vn() ? u < 50 : u < 5;
  }
  s.canUpload = a;
  async function l(d, u) {
    var P;
    const p = s.baseUrl;
    if (p) {
      if (!d.name)
        return console.error("Upload: file name is missing"), null;
    } else
      return console.error("Blob storage base url is not set"), null;
    let m = null;
    d instanceof File ? m = await d.arrayBuffer() : m = d.data;
    const g = m.byteLength, _ = g / 1024 / 1024;
    if (_ > 50)
      return (u == null ? void 0 : u.silent) !== !0 && ve(`File (${_.toFixed(1)}MB) is too large for uploading (see console for details)`), console.warn(`Your file is too large for uploading (${_.toFixed(1)}MB). Max allowed size is 50MB`), null;
    if (!Vn() && _ > 5)
      return (u == null ? void 0 : u.silent) !== !0 && ve('File is too large for uploading. Please get a <a href="https://needle.tools/pricing" target="_blank">commercial license</a> to upload files larger than 5MB'), console.warn(`Your file is too large for uploading (${_.toFixed(1)}MB). Max size is 5MB for non-commercial users. Please get a commercial license at https://needle.tools/pricing for larger files (up to 50MB)`), null;
    if (g < 1)
      return console.warn(`Your file is too small for uploading (${_.toFixed(1)}MB). Min size is 1 byte`), null;
    const y = n(m), b = {
      filename: d.name,
      "Content-Md5": y,
      // "x-amz-checksum-sha256": checksum,
      // "X-Amz-Content-Sha256": checksum,
      "Content-Type": d.type || "application/octet-stream",
      FileSize: g.toString(),
      // enforced by the server
      "Content-Disposition": `attachment; filename="${d.name}"`,
      // enforced by the server
      "x-amz-server-side-encryption": "AES256"
    }, w = await fetch(p + "/api/needle/blob", {
      method: "POST",
      headers: b,
      signal: u == null ? void 0 : u.abort
    }).then((k) => k.json()).catch((k) => (console.error(k), null));
    if (w == null)
      return console.warn("Upload failed..."), null;
    if ("error" in w)
      return console.error(w.error), null;
    if ("upload" in w && w.upload) {
      let k = function(E) {
        var A;
        return (A = u == null ? void 0 : u.onProgress) == null || A.call(null, { progress01: 0, state: "inprogress" }), fetch(E, {
          method: "PUT",
          headers: b,
          body: m,
          signal: u == null ? void 0 : u.abort
        }).then((F) => {
          var U;
          return (U = u == null ? void 0 : u.onProgress) == null || U.call(null, { progress01: 1, state: "finished" }), F;
        }).catch((F) => F);
      };
      console.debug("Uploading file", w.upload);
      let O = !1, M = null;
      for (let E = 0; E < 3; E++)
        try {
          if (O)
            break;
          if ((P = u == null ? void 0 : u.abort) != null && P.aborted)
            return console.debug("Aborted upload"), null;
          const B = await k(w.upload);
          B instanceof Error ? (M = B, await Gn(1e3 * E)) : B.ok && (console.debug("File uploaded successfully"), O = !0);
        } catch (B) {
          console.error(B);
        }
      if (!O)
        return console.error((M == null ? void 0 : M.message) || "Failed to upload file"), null;
    }
    if ("download" in w) {
      const k = p + w.download;
      return console.debug("File found in blob storage", k), {
        key: w.key,
        success: !0,
        download_url: k
      };
    }
    return null;
  }
  s.upload = l;
  function c(d) {
    return `${s.baseUrl}/api/needle/blob/${d}`;
  }
  s.getBlobUrlForKey = c;
  async function h(d, u) {
    var k;
    const p = await fetch(d), m = (k = p.body) == null ? void 0 : k.getReader(), g = p.headers.get("Content-Length"), _ = g ? parseInt(g) : 0;
    if (!m)
      return null;
    let y = 0;
    const b = [];
    for (; ; ) {
      const { done: O, value: M } = await m.read();
      if (M && (b.push(M), y += M.length, u == null || u.call(null, new ProgressEvent("progress", { loaded: y, total: _ }))), O)
        break;
    }
    const w = new Uint8Array(y);
    let P = 0;
    for (const O of b)
      w.set(O, P), P += O.length;
    return w;
  }
  s.download = h;
})(Ga || (Ga = {}));
const $s = x("debugaddressables");
class _O {
  /** @internal */
  constructor(t) {
    r(this, "_context");
    r(this, "_assetReferences", {});
    r(this, "preUpdate", () => {
    });
    this._context = t, this._context.pre_update_callbacks.push(this.preUpdate);
  }
  /** @internal */
  dispose() {
    const t = this._context.pre_update_callbacks.indexOf(this.preUpdate);
    t >= 0 && this._context.pre_update_callbacks.splice(t, 1);
    for (const e in this._assetReferences) {
      const i = this._assetReferences[e];
      i == null || i.unload();
    }
    this._assetReferences = {};
  }
  /**
   * Find a registered AssetReference by its URL
   */
  findAssetReference(t) {
    return this._assetReferences[t] || null;
  }
  /** 
   * Register an asset reference
   * @internal
   */
  registerAssetReference(t) {
    return t.url && (this._assetReferences[t.url] ? console.warn("Asset reference already registered", t) : this._assetReferences[t.url] = t), t;
  }
  /** @internal */
  unregisterAssetReference(t) {
    t.url && delete this._assetReferences[t.url];
  }
}
const Hf = Symbol("assetReference"), Jo = class {
  /** @internal */
  constructor(t, e, i = null) {
    r(this, "_loading");
    r(this, "_asset");
    r(this, "_glbRoot");
    r(this, "_url");
    r(this, "_urlName");
    r(this, "_progressListeners", []);
    r(this, "_hash");
    r(this, "_hashedUri");
    r(this, "_isLoadingRawBinary", !1);
    r(this, "_rawBinary");
    this._url = t;
    const n = t.lastIndexOf("/");
    if (n >= 0) {
      this._urlName = t.substring(n + 1);
      const o = this._urlName.lastIndexOf(".");
      o >= 0 && (this._urlName = this._urlName.substring(0, o));
    } else
      this._urlName = t;
    this._hash = e, t.includes("?v=") ? this._hashedUri = t : this._hashedUri = e ? t + "?v=" + e : t, i !== null && (this.asset = i), FP(this._url, this.onResolvePrefab.bind(this));
  }
  /**
   * Get an AssetReference for a URL to be easily loaded.  
   * AssetReferences are cached so calling this method multiple times with the same arguments will always return the same AssetReference.
   * @param url The URL of the asset to load. The url can be relative or absolute.
   * @param context The context to use for loading the asset  
   * @returns the AssetReference for the URL
   */
  static getOrCreateFromUrl(t, e) {
    if (!e && (e = ee.Current, !e))
      throw new Error('Context is required when sourceId is a string. When you call this method from a component you can call it with "getOrCreate(this, url)" where "this" is the component.');
    const i = e.addressables, n = i.findAssetReference(t);
    if (n)
      return n;
    const o = new Jo(t, e.hash);
    return i.registerAssetReference(o), o;
  }
  /** 
   * Get an AssetReference for a URL to be easily loaded.   
   * AssetReferences are cached so calling this method multiple times with the same arguments will always return the same AssetReference.
   */
  static getOrCreate(t, e, i) {
    if (typeof t == "string") {
      if (!i && (i = ee.Current, !i))
        throw new Error('Context is required when sourceId is a string. When you call this method from a component you can call it with "getOrCreate(this, url)" where "this" is the component.');
    } else
      i = t.context, t = t.sourceId;
    const n = Tr(t, e);
    $s && console.log("GetOrCreate Addressable from", t, e, "FinalPath=", n);
    const o = i.addressables, a = o.findAssetReference(n);
    if (a)
      return a;
    const l = new Jo(n, i.hash);
    return o.registerAssetReference(l), l;
  }
  /** @returns true if this is an AssetReference instance */
  get isAssetReference() {
    return !0;
  }
  /** The loaded asset */
  get asset() {
    return this._glbRoot ?? this._asset;
  }
  set asset(t) {
    this._asset = t;
  }
  /** The url of the loaded asset (or the asset to be loaded) 
   * @deprecated use url */
  get uri() {
    return this._url;
  }
  /** The url of the loaded asset (or the asset to be loaded) */
  get url() {
    return this._url;
  }
  /** The name of the assigned url. This name is deduced from the url and might not reflect the actual name of the asset */
  get urlName() {
    return this._urlName;
  }
  /**
   * @returns true if the uri is a valid URL (http, https, blob)
   */
  get hasUrl() {
    return this._url !== void 0 && (this._url.startsWith("http") || this._url.startsWith("blob:") || this._url.startsWith("www.") || this._url.includes("/"));
  }
  /**  
   * This is the loaded asset root object. If the asset is a glb/gltf file this will be the {@link three#Scene} object.
   */
  get rawAsset() {
    return this._asset;
  }
  async onResolvePrefab(t) {
    return t === this.url && (this.mustLoad && await this.loadAssetAsync(), this.asset) ? this.asset : null;
  }
  get mustLoad() {
    return !this.asset || this.asset.__destroyed === !0 || Wa(this.asset) === !0;
  }
  /**
   * @returns `true` if the asset has been loaded (via preload) or if it exists already (assigned to `asset`) */
  isLoaded() {
    return this._rawBinary || this.asset !== void 0;
  }
  /** frees previously allocated memory and destroys the current `asset` instance (if any) */
  unload() {
    this.asset && ($s && console.log("Unload", this.asset), "scene" in this.asset && this.asset.scene && nn(this.asset.scene, !0, !0), nn(this.asset, !0, !0)), this.asset = null, this._rawBinary = void 0, this._glbRoot = null, this._loading = void 0, ee.Current && ee.Current.addressables.unregisterAssetReference(this);
  }
  /** loads the asset binary without creating an instance */
  async preload() {
    if (!this.mustLoad || this._isLoadingRawBinary)
      return null;
    if (this._rawBinary !== void 0)
      return this._rawBinary;
    this._isLoadingRawBinary = !0, $s && console.log("Preload", this._hashedUri);
    const t = await Ga.download(this._hashedUri, (e) => {
      this.raiseProgressEvent(e);
    });
    return this._rawBinary = (t == null ? void 0 : t.buffer) ?? null, this._isLoadingRawBinary = !1, this._rawBinary;
  }
  // TODO: we need a way to abort loading a resource
  /** Loads the asset and creates one instance (assigned to `asset`)
   * @returns the loaded asset
   */
  async loadAssetAsync(t) {
    if ($s && console.log("loadAssetAsync", this.url), !this.mustLoad)
      return this.asset;
    if (t && this._progressListeners.push(t), this._loading !== void 0)
      return this._loading.then((n) => this.asset);
    const e = ee.Current;
    if (this._rawBinary) {
      if (!(this._rawBinary instanceof ArrayBuffer))
        return console.error("Invalid raw binary data", this._rawBinary), null;
      this._loading = Hn().parseSync(e, this._rawBinary, this.url, null), this.raiseProgressEvent(new ProgressEvent("progress", { loaded: this._rawBinary.byteLength, total: this._rawBinary.byteLength }));
    } else
      $s && console.log("Load async", this.url), this._loading = Hn().loadSync(e, this._hashedUri, this.url, null, (n) => {
        this.raiseProgressEvent(n);
      });
    const i = await this._loading;
    return this._progressListeners.length = 0, this._glbRoot = this.tryGetActualGameObjectRoot(i), this._loading = void 0, i ? (i[Hf] = this, this._glbRoot && (this._glbRoot[Hf] = this), this.asset && (this.asset[Hf] = this), Nd(e), i.scene !== void 0 && (this.asset = i), this.asset) : null;
  }
  /** loads and returns a new instance of `asset` */
  async instantiate(t) {
    return this.onInstantiate(t, !1);
  }
  /** loads and returns a new instance of `asset` - this call is networked so an instance will be created on all connected users */
  async instantiateSynced(t, e = !0) {
    return this.onInstantiate(t, !0, e);
  }
  beginListenDownload(t) {
    this._progressListeners.indexOf(t) < 0 && this._progressListeners.push(t);
  }
  endListenDownload(t) {
    const e = this._progressListeners.indexOf(t);
    e >= 0 && this._progressListeners.splice(e, 1);
  }
  raiseProgressEvent(t) {
    for (const e of this._progressListeners)
      e(this, t);
  }
  async onInstantiate(t, e = !1, i) {
    const n = ee.Current, o = new Qn();
    if (t instanceof L ? o.parent = t : t && (Object.assign(o, t), o.cloneAssign(t)), o.parent || (o.parent = n.scene), this.mustLoad && await this.loadAssetAsync(), $s && console.log("Instantiate", this.url, "parent:", t), this.asset) {
      $s && console.log("Add to scene", this.asset);
      let a = Jo.currentlyInstantiating.get(this.url);
      if (a !== void 0 && a >= 1e4)
        return console.error("Recursive or too many instantiations of " + this.url + " in the same frame (" + a + ")"), null;
      try {
        if (a === void 0 && (a = 0), a += 1, Jo.currentlyInstantiating.set(this.url, a), e) {
          o.context = n;
          const l = this.asset;
          l.guid = this.url;
          const c = lv(l, o, void 0, i);
          if (c)
            return c;
        } else {
          const l = Ha(this.asset, o);
          if (l)
            return l;
        }
      } finally {
        n.post_render_callbacks.push(() => {
          a === void 0 || a < 0 ? a = 0 : a -= 1, Jo.currentlyInstantiating.set(this.url, a);
        });
      }
    } else
      $s && console.warn("Failed to load asset", this.url);
    return null;
  }
  /**
   * try to ignore the intermediate created object
   * because it causes trouble if we instantiate an assetreference per player
   * and call destroy on the player marker root
   * @returns the scene root object if the asset was a glb/gltf
   */
  tryGetActualGameObjectRoot(t) {
    if (t && t.scene) {
      const e = t.scene;
      return e.isGroup && e.children.length === 1 && e.children[0].name + "glb" === e.name ? e.children[0] : e;
    }
    return null;
  }
};
let re = Jo;
r(re, "currentlyInstantiating", /* @__PURE__ */ new Map());
class yO extends rn {
  constructor() {
    super([re], "AssetReferenceSerializer");
  }
  onSerialize(t, e) {
    if (t && t.uri !== void 0 && typeof t.uri == "string")
      return t.uri;
  }
  onDeserialize(t, e) {
    if (typeof t == "string")
      return e.context ? e.gltfId ? re.getOrCreate(e.gltfId, t, e.context) : (console.error("Missing source id"), null) : (console.error("Missing context"), null);
    if (t instanceof L) {
      if (!e.context)
        return console.error("Missing context"), null;
      if (!e.gltfId)
        return console.error("Missing source id"), null;
      const i = t, n = e.context, o = i.guid ?? i.uuid, a = n.addressables.findAssetReference(o);
      if (a)
        return a;
      const l = new re(o, void 0, i);
      return n.addressables.registerAssetReference(l), l;
    }
    return null;
  }
}
new yO();
const bO = Promise.resolve(null), Cc = class {
  constructor(t) {
    r(this, "url");
    r(this, "_bitmap");
    r(this, "_bitmapObject");
    r(this, "loader", null);
    this.url = t;
  }
  static getOrCreate(t) {
    let e = Cc.imageReferences.get(t);
    return e || (e = new Cc(t), Cc.imageReferences.set(t, e)), e;
  }
  dispose() {
    this._bitmapObject && this._bitmapObject.close(), this._bitmap = void 0;
  }
  createHTMLImage() {
    const t = new Image();
    return t.src = this.url, t;
  }
  createTexture() {
    return this.url ? (this.loader || (this.loader = new wa()), this.loader.setCrossOrigin("anonymous"), this.loader.loadAsync(this.url).then((t) => {
      var e;
      return t && !((e = t.name) != null && e.length) && (t.name = this.url.split("/").pop() ?? this.url), t;
    })) : (console.error("Can not load texture without url"), bO);
  }
  /** Loads the bitmap data of the image */
  getBitmap() {
    return this._bitmap ? this._bitmap : (this._bitmap = new Promise((t, e) => {
      const i = document.createElement("img");
      i.addEventListener("load", () => {
        this._bitmap = createImageBitmap(i).then((n) => (this._bitmapObject = n, t(n), n));
      }), i.addEventListener("error", (n) => {
        console.error("Failed to load image:" + this.url, n), t(null);
      }), i.src = this.url;
    }), this._bitmap);
  }
};
let uc = Cc;
r(uc, "imageReferences", /* @__PURE__ */ new Map());
class vO extends rn {
  constructor() {
    super([uc], "ImageReferenceSerializer");
  }
  onSerialize(t, e) {
    return null;
  }
  onDeserialize(t, e) {
    if (typeof t == "string") {
      const i = Tr(e.gltfId, t);
      return uc.getOrCreate(i);
    }
  }
}
new vO();
const Pc = class {
  constructor(t) {
    /** The resolved url to the file */
    r(this, "url");
    r(this, "res");
    this.url = t;
  }
  static getOrCreate(t) {
    let e = Pc.cache.get(t);
    return e || (e = new Pc(t), Pc.cache.set(t, e)), e;
  }
  /** Load the file binary data
   * @returns a promise that resolves to the binary data of the file. Make sure to await this request or use `.then(res => {...})` to get the result.
   */
  async loadRaw() {
    return this.res || (this.res = fetch(this.url)), this.res.then((t) => t.blob());
  }
  /** Load the file as text (if the referenced file is a text file like a .txt or .json file)
   * @returns a promise that resolves to the text data of the file. Make sure to await this request or use `.then(res => {...})` to get the result. If the format is json you can use `JSON.parse(result)` to convert it to a json object
   */
  async loadText() {
    return this.res || (this.res = fetch(this.url)), this.res.then((t) => t.text());
  }
};
let fc = Pc;
r(fc, "cache", /* @__PURE__ */ new Map());
class wO extends rn {
  constructor() {
    super([fc], "FileReferenceSerializer");
  }
  onSerialize(t, e) {
    return null;
  }
  onDeserialize(t, e) {
    if (typeof t == "string") {
      const i = Tr(e.gltfId, t);
      return fc.getOrCreate(i);
    }
  }
}
new wO();
class xO {
  constructor(t) {
    r(this, "context");
    r(this, "mixers", []);
    this.context = t;
  }
  /** @hidden @internal */
  onDestroy() {
    this.mixers.forEach((t) => t.stopAllAction()), this.mixers.length = 0;
  }
  /**
   * Register an animation mixer instance.
   */
  registerAnimationMixer(t) {
    if (!t) {
      console.warn("AnimationsRegistry.registerAnimationMixer called with null or undefined mixer");
      return;
    }
    this.mixers.includes(t) || this.mixers.push(t);
  }
  /**
   * Unregister an animation mixer instance.
   */
  unregisterAnimationMixer(t) {
    if (!t) {
      console.warn("AnimationsRegistry.unregisterAnimationMixer called with null or undefined mixer");
      return;
    }
    const e = this.mixers.indexOf(t);
    e !== -1 && this.mixers.splice(e, 1);
  }
}
class zc {
  /**
   * Tries to get the animation actions from an animation mixer.
   * @param mixer The animation mixer to get the actions from
   * @returns The actions or null if the mixer is invalid
   */
  static tryGetActionsFromMixer(t) {
    const e = t._actions;
    return e || null;
  }
  static tryGetAnimationClipsFromObjectHierarchy(t, e) {
    if (e || (e = new Array()), t)
      t.animations && e.push(...t.animations);
    else
      return e;
    if (t.children)
      for (const i of t.children)
        this.tryGetAnimationClipsFromObjectHierarchy(i, e);
    return e;
  }
  /**
   * Assigns animations from a GLTF file to the objects in the scene.  
   * This method will look for objects in the scene that have animations and assign them to the correct objects.  
   * @param file The GLTF file to assign the animations from
   */
  static assignAnimationsFromFile(t, e) {
    if (!t || !t.animations) {
      console.debug("No animations found in file");
      return;
    }
    for (let n = 0; n < t.animations.length; n++) {
      const o = t.animations[n];
      if (!o.tracks || o.tracks.length <= 0) {
        console.warn("Animation has no tracks");
        continue;
      }
      for (const a in o.tracks) {
        const l = o.tracks[a], c = La.parseTrackName(l.name);
        let h = La.findNode(t.scene, c.nodeName);
        if (!h) {
          const u = l.__objectName ?? l.name.substring(0, l.name.indexOf("."));
          if (h = t.scene.getObjectByProperty("uuid", u), !h)
            continue;
        }
        let d = i(h);
        if (!d) {
          if (!(e != null && e.createAnimationComponent)) {
            console.warn("No AnimationComponent found in parent hierarchy of object and no 'createAnimationComponent' callback was provided in options.");
            continue;
          }
          d = e.createAnimationComponent(t.scene, o);
        }
        d.addClip && d.addClip(o);
      }
    }
    function i(n) {
      var a;
      if (!n)
        return null;
      const o = (a = n.userData) == null ? void 0 : a.components;
      if (o && o.length > 0) {
        for (let l = 0; l < o.length; l++)
          if (o[l].isAnimationComponent === !0)
            return n;
      }
      return i(n.parent);
    }
  }
}
var Sm = /* @__PURE__ */ ((s) => (s.Visible = "application-visible", s.Hidden = "application-hidden", s.MuteChanged = "application-mutechanged", s))(Sm || {});
let Hd = !1;
const fa = [];
function Ir() {
  if (Hd)
    return;
  z() && console.debug("User interaction registered: audio can now be played"), Hd = !0;
  const s = [...fa];
  fa.length = 0, s.forEach((t) => t());
}
document.addEventListener("mousedown", Ir);
document.addEventListener("pointerup", Ir);
document.addEventListener("click", Ir);
document.addEventListener("dragstart", Ir);
document.addEventListener("touchend", Ir);
document.addEventListener("keydown", Ir);
J.onXRSessionStart(() => {
  Ir();
});
const C_ = class extends EventTarget {
  /** @internal */
  constructor(e) {
    super();
    r(this, "_mute", !1);
    r(this, "context");
    r(this, "_isVisible", !0);
    this.context = e, window.addEventListener("visibilitychange", this.onVisiblityChanged.bind(this), !1);
  }
  static get userInteractionRegistered() {
    return Hd;
  }
  /**
   * Register a callback that will be called when the user interacts with the page (click, touch, keypress, etc).  
   * If the user has already interacted with the page, the callback will be called immediately.  
   * This can be used to wait for user interaction before playing audio, for example.
   */
  static registerWaitForInteraction(e) {
    if (e !== null) {
      if (Hd) {
        e();
        return;
      }
      fa.indexOf(e) === -1 && fa.push(e);
    }
  }
  /**
   * Unregister a callback that was previously registered with registerWaitForInteraction.
   */
  static unregisterWaitForInteraction(e) {
    const i = fa.indexOf(e);
    i !== -1 && fa.splice(i, 1);
  }
  /** audio muted? */
  get muted() {
    return this._mute;
  }
  /** set global audio mute */
  set muted(e) {
    e !== this._mute && (this._mute = e, this.dispatchEvent(new Event(
      "application-mutechanged"
      /* MuteChanged */
    )));
  }
  /** @returns true if the document is focused */
  get hasFocus() {
    return document.hasFocus();
  }
  /**
   * @returns true if the application is currently visible (it's tab is active and not minimized)
   */
  get isVisible() {
    return this._isVisible;
  }
  onVisiblityChanged(e) {
    switch (e.target.visibilityState) {
      case "hidden":
        this._isVisible = !1, this.dispatchEvent(new Event(
          "application-hidden"
          /* Hidden */
        ));
        break;
      case "visible":
        this._isVisible = !0, this.dispatchEvent(new Event(
          "application-visible"
          /* Visible */
        ));
        break;
    }
  }
};
let Wn = C_;
/**  @deprecated use Application.registerWaitForInteraction instead */
r(Wn, "registerWaitForAllowAudio", C_.registerWaitForInteraction);
function* Sv(s, t = null) {
  const e = t ? t.time : ee.Current.time, i = e.time;
  for (; e.time - i < s; )
    yield;
}
function* ED(s) {
  for (let t = 0; t < s; t++)
    yield;
}
function* SO(s) {
  let t = !0;
  for (s.then(() => t = !1), s.catch(() => t = !1); t; )
    yield;
}
const By = "NEEDLE_lightmaps", kl = x("debuglightmapsextension") || x("debuglightmaps");
var ao = /* @__PURE__ */ ((s) => (s[s.Lightmap = 0] = "Lightmap", s[s.Skybox = 1] = "Skybox", s[s.Reflection = 2] = "Reflection", s))(ao || {});
class CO {
  constructor(t, e, i) {
    r(this, "parser");
    r(this, "registry");
    r(this, "source");
    this.parser = t, this.registry = e, this.source = i;
  }
  get name() {
    return By;
  }
  afterRoot(t) {
    const e = this.parser.json.extensions;
    if (e) {
      const i = e[By];
      if (i) {
        const n = i.textures;
        return n != null && n.length ? (kl && console.log(i), new Promise(async (o, a) => {
          const l = [];
          for (const h of n)
            if (h.pointer) {
              kl && console.log(h);
              let d = null;
              if (h.pointer.startsWith("/textures/"))
                kl && console.log("Load texture from gltf", h.pointer), d = Og(this.parser, h.pointer).then((u) => this.resolveTexture(h, u));
              else if (typeof h.pointer == "string") {
                kl && console.log("Load texture from path", h.pointer);
                const u = Tr(this.source, h.pointer);
                let p;
                u.endsWith(".exr") ? p = new Ld(this.parser.options.manager) : u.endsWith(".hdr") ? p = new em(this.parser.options.manager) : p = new wa(this.parser.options.manager), d = p.loadAsync(u, void 0).then((m) => this.resolveTexture(h, m));
              } else
                h.pointer;
              d && l.push(d);
            }
          const c = await v0(l);
          c != null && c.anyFailed && z() && console.error("Failed to load lightmap extension", c), o();
        })) : null;
      }
    }
    return null;
  }
  resolveTexture(t, e) {
    const i = e;
    kl && console.log("Lightmap loaded:", i), i != null && i.isTexture && (this.registry ? (i.colorSpace = wr, this.registry.registerTexture(this.source, t.type, i, t.index)) : console.log(ao[t.type], t.pointer, i));
  }
}
const Fy = !!x("debuglightmaps");
class PO {
  constructor(t) {
    r(this, "_context");
    r(this, "_lightmaps", /* @__PURE__ */ new Map());
    this._context = t;
  }
  clear() {
    this._lightmaps.clear();
  }
  registerTexture(t, e, i, n) {
    Fy && console.log("Registering ", ao[e] + ' "' + t + '"', i), this._lightmaps.has(t) || this._lightmaps.set(t, /* @__PURE__ */ new Map());
    const o = this._lightmaps.get(t), a = (o == null ? void 0 : o.get(e)) ?? [];
    a.length < n && (a.length = n + 1), a[n] = i, o == null || o.set(e, a);
  }
  tryGetLightmap(t, e = 0) {
    return this.tryGet(t, ao.Lightmap, e);
  }
  tryGetSkybox(t) {
    return this.tryGet(t, ao.Skybox, 0);
  }
  tryGetReflection(t) {
    return this.tryGet(t, ao.Reflection, 0);
  }
  tryGet(t, e, i) {
    if (!t)
      return Fy && console.warn("Missing source id"), null;
    const n = this._lightmaps.get(t);
    if (!n)
      return null;
    const o = n.get(e);
    return o === void 0 || !(o != null && o.length) || o.length <= i ? null : o[i];
  }
}
Jt.lights_fragment_maps = Jt.lights_fragment_maps.replace("vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );", `
    vec2 lUv = vLightMapUv.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
    vec4 lightMapTexel = texture2D( lightMap, lUv);
    // The range of RGBM lightmaps goes from 0 to 34.49 (5^2.2) in linear space, and from 0 to 5 in gamma space.
    lightMapTexel.rgb *= lightMapTexel.a * 8.; // no idea where that "8" comes from... heuristically derived
    lightMapTexel.a = 1.;
    lightMapTexel = conv_sRGBToLinear(lightMapTexel);
    `);
Jt.lightmap_pars_fragment = `
    #ifdef USE_LIGHTMAP
        uniform sampler2D lightMap;
        uniform float lightMapIntensity;
        uniform vec4 lightmapScaleOffset;
        
        // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
        vec4 conv_sRGBToLinear( in vec4 value ) {
            return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
        }
    #endif
    `;
Jt.lights_fragment_begin = Jt.lights_fragment_begin.replace(
  "irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );",
  `
#if defined(USE_LIGHTMAP)
irradiance += 0.;
#else
irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
#endif`
);
Nx.lightmap.lightmapScaleOffset = { value: new me(1, 1, 0, 0) };
const Gf = x("debugprogressive"), Lh = new Pi(), jh = new wu();
class OO {
  constructor(t) {
    r(this, "context");
    r(this, "_lodsManager");
    this.context = t;
  }
  /**
   * The internal LODs manager. See @needle-tools/gltf-progressive for more information.  
   * @link https://npmjs.com/package/@needle-tools/gltf-progressive
   */
  get manager() {
    return this._lodsManager;
  }
  /**
   * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.  
   * @default 200_000
   */
  get targetTriangleDensity() {
    var t;
    return ((t = this._lodsManager) == null ? void 0 : t.targetTriangleDensity) ?? -1;
  }
  set targetTriangleDensity(t) {
    this._lodsManager && (this._lodsManager.targetTriangleDensity = t);
  }
  /** @internal */
  setRenderer(t) {
    var e;
    (e = this._lodsManager) == null || e.disable(), Hr.removePlugin(this), Hr.addPlugin(this), Hr.debugDrawLine = V.DrawLine, this._lodsManager = Hr.get(t), this._lodsManager.enable();
  }
  disable() {
    var t;
    (t = this._lodsManager) == null || t.disable(), Hr.removePlugin(this);
  }
  /** @internal */
  onAfterUpdatedLOD(t, e, i, n, o) {
    Gf && this.onRenderDebug(i, n, o);
  }
  onRenderDebug(t, e, i) {
    var l, c, h;
    if (!e.geometry || !Ze.hasLODLevelAvailable(e.geometry) && !Ze.hasLODLevelAvailable(e.material))
      return;
    const n = Hr.getObjectLODState(e);
    if (!n)
      return;
    let o = i.mesh_lod;
    const a = i.mesh_lod != n.lastLodLevel_Mesh || i.texture_lod != n.lastLodLevel_Texture;
    if (Gf && e.geometry.boundingSphere) {
      const d = e.geometry.boundingSphere;
      jh.copy(d), jh.applyMatrix4(e.matrixWorld);
      const u = jh.center, p = jh.radius, m = ["#76c43e", "#bcc43e", "#c4ac3e", "#c4673e", "#ff3e3e"];
      if (a)
        V.DrawWireSphere(u, p, m[o], 0.1);
      else {
        const g = ((l = e.geometry.index) == null ? void 0 : l.count) ?? 0, _ = (c = Ze.getMeshLODInformation(e.geometry)) == null ? void 0 : c.lods;
        o = _ ? Math.min((_ == null ? void 0 : _.length) - 1, o) : 0;
        let y = "";
        if (_ && n.lastScreenCoverage > 0)
          for (let P = 0; P < _.length; P++) {
            const k = _[P].density, O = P == _.length - 1;
            y += k.toFixed(0) + ">" + (k / n.lastScreenCoverage).toFixed(0) + (O ? "" : ",");
          }
        const b = _ ? (h = _[o]) == null ? void 0 : h.density : -1;
        let w = "LOD " + i.mesh_lod + `
TEX ` + i.texture_lod;
        if (Gf == "density" && (w += `
` + g + ` tris
` + (b / n.lastScreenCoverage).toFixed(0) + ` dens
` + (n.lastScreenCoverage * 100).toFixed(1) + `% cov
` + (n.lastCentrality * 100).toFixed(1) + `% centr
` + (Lh.min.x.toFixed(2) + "-" + Lh.max.x.toFixed(2) + "x" + Lh.min.y.toFixed(2) + "-" + Lh.max.y.toFixed(2)) + " scr"), n.lastScreenCoverage > 0.1) {
          const P = t, k = P.worldForward, O = P.worldPosition, E = G(k).multiplyScalar(p * 0.7).add(u), B = E.distanceTo(O), A = m[Math.min(m.length - 1, Math.max(0, o))] + "88", F = this.context.domHeight > 0 ? screen.height / this.context.domHeight : 1, U = t.isPerspectiveCamera ? Math.tan(t.fov * Math.PI / 180 / 2) : 1;
          V.DrawLabel(E, w, B * 0.012 * F * U, void 0, 16777215, A);
        }
      }
    }
  }
}
const MO = x("debugplayerview");
var dr = /* @__PURE__ */ ((s) => (s.Browser = "browser", s.Headset = "headset", s.Handheld = "handheld", s))(dr || {});
class RO {
  constructor(t, e) {
    r(this, "userId");
    r(this, "context");
    r(this, "viewDevice", "browser");
    r(this, "removed", !1);
    r(this, "_object");
    this.userId = t, this.context = e;
  }
  get currentObject() {
    return this._object;
  }
  set currentObject(t) {
    this._object = t;
  }
  get isConnected() {
    return this.context.connection.userIsInRoom(this.userId);
  }
}
class kO {
  constructor(t) {
    r(this, "context");
    r(this, "playerViews", /* @__PURE__ */ new Map());
    this.context = t;
  }
  setPlayerView(t, e, i) {
    let n = this.playerViews.get(t);
    n || (n = new RO(t, this.context), this.playerViews.set(t, n)), n.viewDevice = i, n.currentObject = e, n.removed = !1;
  }
  getPlayerView(t) {
    if (!t)
      return;
    if (!this.context.connection.userIsInRoom(t)) {
      this.playerViews.delete(t);
      return;
    }
    return this.playerViews.get(t);
  }
  removePlayerView(t, e) {
    const i = this.playerViews.get(t);
    (i == null ? void 0 : i.viewDevice) === e && (MO && console.log("REMOVE", t), i.removed = !0, this.playerViews.delete(t));
  }
}
new n0();
const Kc = new Uint8Array(4);
Kc[0] = 255;
Kc[1] = 255;
Kc[2] = 255;
Kc[3] = 255;
const TO = new sg(Kc, 1, 1, Su);
function Ag(s, t = 1) {
  const e = "alpha" in s, i = t * t, n = new Uint8Array(4 * i), o = Math.floor(s.r * 255), a = Math.floor(s.g * 255), l = Math.floor(s.b * 255);
  for (let h = 0; h < i; h++) {
    const d = h * 4;
    n[d + 0] = o, n[d + 1] = a, n[d + 2] = l, e ? n[d + 3] = Math.floor(s.alpha * 255) : n[d + 3] = 255;
  }
  const c = new sg(n, t, t);
  return c.needsUpdate = !0, c;
}
function AO(s, t, e, i = 1, n = 3) {
  const a = i * n, l = [s, t, e], c = l.length, h = new Uint8Array(4 * c * a), d = new ae();
  for (let p = 0; p < n; p++) {
    const m = Math.floor(p / n * c), g = $.clamp(m + 1, 0, c - 1), _ = l[m], y = l[g], b = p / n * c % 1;
    d.lerpColors(_, y, b);
    const w = Math.floor(d.r * 255), P = Math.floor(d.g * 255), k = Math.floor(d.b * 255);
    for (let O = 0; O < i; O++) {
      const M = (p * i + O) * 4;
      h[M + 0] = w, h[M + 1] = P, h[M + 2] = k, h[M + 3] = 255;
    }
  }
  const u = new sg(h, i, n);
  return u.needsUpdate = !0, u;
}
function Gd(s, t) {
  const e = s.elements;
  t || (t = []), t.length = 0;
  for (let i = 0; i < 16; i += 4) {
    const n = e[i], o = e[i + 1], a = e[i + 2], l = e[i + 3], c = new me(n, o, a, l);
    t.push(c);
  }
  return t;
}
const qf = [], zy = [];
function EO(s, t) {
  if (qf.length === 0)
    for (let e = 0; e < 27; e++)
      qf.push(0);
  t || (t = qf);
  for (let e = 0; e < 27; e++)
    zy[e] = t[e];
  t = zy, s.unity_SHAr = { value: new me(t[9], t[3], t[6], t[0]) }, s.unity_SHBr = { value: new me(t[12], t[15], t[18], t[21]) }, s.unity_SHAg = { value: new me(t[10], t[4], t[7], t[1]) }, s.unity_SHBg = { value: new me(t[13], t[16], t[19], t[22]) }, s.unity_SHAb = { value: new me(t[11], t[5], t[8], t[2]) }, s.unity_SHBb = { value: new me(t[14], t[17], t[20], t[23]) }, s.unity_SHC = { value: new me(t[24], t[25], t[26], 1) };
}
class IO {
  constructor(t, e, i) {
    r(this, "vertexShader");
    r(this, "fragmentShader");
    r(this, "technique");
    this.vertexShader = t, this.fragmentShader = e, this.technique = i;
  }
}
async function DO(s, t) {
  if (!s)
    return console.error("Can not find technique: no shader data"), null;
  const e = s.programs[t], i = e.vertexShader, n = e.fragmentShader;
  if (i !== void 0 && n !== void 0) {
    const o = s.shaders[i], a = s.shaders[n];
    if (o.uri && a.uri || o.code && a.code) {
      if (!o.code && o.uri && await Uy(o), !a.code && a.uri && await Uy(a), !o.code || !a.code)
        return null;
      const l = s.techniques[t];
      return new IO(o.code, a.code, l);
    }
  }
  return console.error("Shader technique not found", t), null;
}
async function Uy(s) {
  const t = s.uri;
  if (t)
    if (t.endsWith(".glsl")) {
      const i = await new n0().loadAsync(t);
      s.code = i.toString();
    } else
      s.code = LO(s.uri);
}
function LO(s) {
  return decodeURIComponent(Array.prototype.map.call(atob(s), function(t) {
    return "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}
const hn = x("debugenvlight");
var pc = /* @__PURE__ */ ((s) => (s[s.Skybox = 0] = "Skybox", s[s.Trilight = 1] = "Trilight", s[s.Flat = 3] = "Flat", s[s.Custom = 4] = "Custom", s))(pc || {}), Cm = /* @__PURE__ */ ((s) => (s[s.Skybox = 0] = "Skybox", s[s.Custom = 1] = "Custom", s))(Cm || {});
class jO {
  constructor(t) {
    r(this, "context");
    r(this, "_currentLightSettingsId");
    r(this, "_sceneLightSettings");
    r(this, "_timevec4", new me());
    r(this, "__currentReflectionId", null);
    r(this, "_lighting", {});
    this.context = t, this.context.pre_update_callbacks.push(this.preUpdate.bind(this));
  }
  preUpdate() {
    const t = this.context.time;
    this._timevec4.x = t.time, this._timevec4.y = Math.sin(t.time), this._timevec4.z = Math.cos(t.time), this._timevec4.w = t.deltaTime;
  }
  /** Time data used for custom shaders
   * x: time
   * y: sin(time)
   * z: cos(time)
   * w: deltaTime
   */
  get timeVec4() {
    return this._timevec4;
  }
  /** the current environment intensity */
  get environmentIntensity() {
    if (!this._sceneLightSettings || !this._currentLightSettingsId)
      return 1;
    const t = this._sceneLightSettings.get(this._currentLightSettingsId);
    return t ? t.ambientIntensity : 1;
  }
  /** Get all currently registered scene light settings */
  get sceneLightSettings() {
    var t;
    return (t = this._sceneLightSettings) == null ? void 0 : t.values();
  }
  /** set the scene lighting from a specific scene. Will disable any previously enabled lighting settings */
  enable(t) {
    var i;
    t instanceof re && (t = t.url);
    const e = (i = this._sceneLightSettings) == null ? void 0 : i.get(t);
    return e ? (hn && console.log("Enable scene light settings", t, e), t !== this._currentLightSettingsId && this._currentLightSettingsId && this.disable(this._currentLightSettingsId), this._currentLightSettingsId = t, e.enabled = !0, !0) : (hn && console.warn("No light settings found for", t), !1);
  }
  /** disable the lighting of a specific scene, will only have any effect if it is currently active */
  disable(t) {
    var i;
    if (t instanceof re && (t = t.url), t == null)
      return !1;
    const e = (i = this._sceneLightSettings) == null ? void 0 : i.get(t);
    return e ? (hn && console.log("Disable scene light settings", t, e), e.enabled = !1, !0) : !1;
  }
  /** Disables the currently active scene lighting (if any), returns the id of the previously active lighting */
  disableCurrent() {
    if (this._currentLightSettingsId) {
      const t = this._currentLightSettingsId;
      return this.disable(this._currentLightSettingsId), t;
    }
    return null;
  }
  /** @internal */
  internalRegisterSceneLightSettings(t) {
    const e = t.sourceId;
    if (!e) {
      console.error("Missing source id for scene light settings, can not register:", t);
      return;
    }
    hn && console.log("Register " + (t == null ? void 0 : t.sourceId) + " lighting", t), this._sceneLightSettings || (this._sceneLightSettings = /* @__PURE__ */ new Map()), this._sceneLightSettings.set(e, t);
  }
  /** @internal */
  internalUnregisterSceneLightSettings(t) {
    const e = t.sourceId;
    if (!e) {
      console.error("Missing source id for scene light settings, can not unregister:", t);
      return;
    }
    hn && console.log("Unregister " + (t == null ? void 0 : t.sourceId) + " lighting", t), this._sceneLightSettings && this._sceneLightSettings.delete(e);
  }
  /** @internal */
  internalRegisterReflection(t, e) {
    hn && console.log("Register reflection", t, e);
    const i = new BO(this.context, e, 1);
    this._lighting[t] = i;
  }
  /** @internal */
  internalGetReflection(t) {
    return this._lighting[t];
  }
  /** @internal */
  internalEnableReflection(t) {
    var i;
    this.__currentReflectionId = t;
    const e = (i = this._sceneLightSettings) == null ? void 0 : i.get(t);
    switch (hn && console.log("Enable reflection", t, e ? pc[e.ambientMode] : "Unknown ambient mode", e), e == null ? void 0 : e.ambientMode) {
      case 0:
      case 4:
        const n = this.internalGetReflection(t);
        if (n && n.Source) {
          hn && console.log("Setting environment reflection", n);
          const o = this.context.scene, a = n.Source;
          a.mapping = Ms, o.environment = a;
          return;
        } else
          hn && console.warn("Could not find reflection for source", t);
        break;
    }
    if ((e == null ? void 0 : e.environmentReflectionSource) === 1)
      switch (e == null ? void 0 : e.ambientMode) {
        case 1:
          if (e.ambientTrilight) {
            const n = e.ambientTrilight, o = AO(n[0], n[1], n[2], 64, 64);
            o.colorSpace = vn, o.mapping = Ms, this.context.scene.environment = o;
          } else
            console.error("Missing ambient trilight", e.sourceId);
          return;
        case 3:
          if (e.ambientLight) {
            const n = Ag(e.ambientLight, 64);
            n.colorSpace = vn, n.mapping = Ms, this.context.scene.environment = n;
          } else
            console.error("Missing ambientlight", e.sourceId);
          return;
        default:
          return;
      }
  }
  /** @internal */
  internalDisableReflection(t) {
    if (t && t !== this.__currentReflectionId) {
      hn && console.log("Not disabling reflection for", t, "because it is not the current light settings id", this.__currentReflectionId);
      return;
    }
    hn && console.log("Disable reflection", t);
    const e = this.context.scene;
    e.environment = null;
  }
}
class BO {
  // private _sphericalHarmonicsArray?: number[];
  // private _context: Context;
  // private _sphericalHarmonics: SphericalHarmonics3 | null = null;
  // private _ambientScale: number = 1;
  // private _lightProbe?: LightProbe;
  constructor(t, e, i = 1) {
    // get Array(): number[] | undefined { return this._sphericalHarmonicsArray; }
    r(this, "_source");
    this._source = e, e.mapping = Ms;
  }
  get Source() {
    return this._source;
  }
  /* REMOVED, no LightProbe / custom shader lighting support for now
      getSphericalHarmonicsArray(intensityFactor: number = 1): SphericalHarmonicsData | null {
          if (this._sphericalHarmonicsArray?.length && this._source) {
              return { array: this._sphericalHarmonicsArray, texture: this._source, lightProbe: this._lightProbe };
          }
  
          try {
              const reflection = this._source;
              let rt: WebGLCubeRenderTarget | null = null;
              if (reflection) {
                  if (debug) console.log("GENERATING LIGHT PROBE", reflection, this.Source);
                  const size = Math.min(reflection.image.width, 512);
                  const target = new WebGLCubeRenderTarget(size);
                  rt = target.fromEquirectangularTexture(this._context.renderer, reflection);
                  // Not sure why we did assign the resulting texture here again but this causes rendering to break when toggling env lighting (e.g. on website) because this texture will then be set as the scene.environment
                  // this._source = rt.texture;
              }
  
              this._sphericalHarmonicsArray = [];
              if (rt) {
                  const sampledProbe = LightProbeGenerator.fromCubeRenderTarget(this._context.renderer, rt);
                  this._lightProbe = sampledProbe;
                  const lightFactor = (this._ambientScale * (intensityFactor * intensityFactor * Math.PI * .5)) - 1;
                  // console.log(intensityFactor, lightFactor);
                  this._sphericalHarmonics = sampledProbe.sh;
                  this._sphericalHarmonicsArray = this._sphericalHarmonics.toArray();
                  if (this._sphericalHarmonicsArray) {
                      const factor = ((intensityFactor) / (Math.PI * .5));
                      for (let i = 0; i < this._sphericalHarmonicsArray.length; i++) {
                          this._sphericalHarmonicsArray[i] *= factor;
                      }
                      sampledProbe.sh.scale(lightFactor);
                      if (this._source)
                          return { array: this._sphericalHarmonicsArray, texture: this._source, lightProbe: sampledProbe };
                  }
              }
          }
          catch (err) {
              console.error(err);
          }
  
          return null;
      }
      */
}
const Ny = x("timescale");
let Pm = 1;
typeof Ny == "number" && (Pm = Ny);
class FO {
  constructor() {
    r(this, "_time", 0);
    r(this, "_deltaTime", 0);
    r(this, "_deltaTimeUnscaled", 0);
    /** The scale at which time passes. This can be used for slow motion effects or to speed up time. */
    r(this, "timeScale", 1);
    r(this, "_frame", 0);
    r(this, "clock", new $x());
    r(this, "_smoothedFps", 0);
    r(this, "_smoothedDeltaTime", 0);
    r(this, "_fpsSamples", []);
    r(this, "_fpsSampleIndex", 0);
    typeof Pm == "number" && (this.timeScale = Pm);
  }
  /** The time in seconds since the start of Needle Engine. */
  get time() {
    return this._time;
  }
  set time(t) {
    this._time = t;
  }
  /** The time in seconds it took to complete the last frame (Read Only). */
  get deltaTime() {
    return this._deltaTime;
  }
  set deltaTime(t) {
    this._deltaTime = t;
  }
  /** The time in seconds it took to complete the last frame (Read Only). Timescale is not applied. */
  get deltaTimeUnscaled() {
    return this._deltaTimeUnscaled;
  }
  /** same as frameCount */
  get frame() {
    return this._frame;
  }
  set frame(t) {
    this._frame = t;
  }
  /** The total number of frames that have passed (Read Only). Same as frame */
  get frameCount() {
    return this.frame;
  }
  /** The time in seconds it took to complete the last frame (Read Only). */
  get realtimeSinceStartup() {
    return this.clock.elapsedTime;
  }
  /** 
   * @returns {Number} FPS for this frame.   
   * Note that this returns the raw value (e.g. 59.88023952362959) and will fluctuate a lot between frames.  
   * If you want a more stable FPS, use `smoothedFps` instead.
  */
  get fps() {
    return 1 / this.deltaTime;
  }
  /** 
   * Approximated frames per second   
   * @returns the smoothed FPS value over the last 60 frames with decimals.  
  */
  get smoothedFps() {
    return this._smoothedFps;
  }
  /** The smoothed time in seconds it took to complete the last frame (Read Only). */
  get smoothedDeltaTime() {
    return 1 / this._smoothedFps;
  }
  /** Step the time. This is called automatically by the Needle Engine Context.
   * @internal
   */
  update() {
    this.deltaTime = this.clock.getDelta(), this.deltaTime = Math.min(0.1, this.deltaTime), this._deltaTimeUnscaled = this.deltaTime, this.deltaTime <= 0 && (this.deltaTime = 1e-12), this.deltaTime *= this.timeScale, this.frame += 1, this.time += this.deltaTime, this._fpsSamples.length < 60 ? this._fpsSamples.push(this.deltaTime) : this._fpsSamples[this._fpsSampleIndex++ % 60] = this.deltaTime;
    let t = 0;
    for (let e = 0; e < this._fpsSamples.length; e++)
      t += this._fpsSamples[e];
    this._smoothedDeltaTime = t / this._fpsSamples.length, this._smoothedFps = 1 / this._smoothedDeltaTime;
  }
}
let $y = !1;
function Cv(s) {
  $y || ($y = !0, zO(), UO());
}
Cv();
function zO() {
  const s = `
float startCompression = 0.8;
float desaturation = 0.5;
// Patched tonemapping function
vec3 NeutralToneMapping( vec3 color ) {
    color *= toneMappingExposure;
    
    float d = 1. - startCompression;
    // float peak = dot(color, vec3(0.299, 0.587, 0.114));
    float peak = max(color.r, max(color.g, color.b));
    if (peak < startCompression) return color;
    float newPeak = 1. - d * d / (peak + d - startCompression);
    float invPeak = 1. / peak;
    
    float extraBrightness = dot(color * (1. - startCompression * invPeak), vec3(1, 1, 1));
    
    color *= newPeak * invPeak;
    float g = 1. - 3. / (desaturation * extraBrightness + 3.);
    return mix(color, vec3(1, 1, 1), g);
}
`, t = "vec3 NeutralToneMapping( vec3 color ) {", e = `return mix( color, vec3( newPeak ), g );
}`, i = Jt.tonemapping_pars_fragment.indexOf(t), n = Jt.tonemapping_pars_fragment.indexOf(e, i);
  if (i >= 0 && n >= 0) {
    const o = Jt.tonemapping_pars_fragment.substring(i, n + e.length);
    Jt.tonemapping_pars_fragment = Jt.tonemapping_pars_fragment.replace(o, s);
  } else
    z() && console.error("Couldn't find NeutralToneMapping in ShaderChunk.tonemapping_pars_fragment");
}
function UO() {
  const s = `
// 0: Default, 1: Golden, 2: Punchy
#define AGX_LOOK 0        

vec3 userSlope = vec3(1.0);
vec3 userOffset = vec3(0.0);
vec3 userPower = vec3(1.0);
float userSaturation = 1.0;

// Mean error^2: 3.6705141e-06
vec3 _agxDefaultContrastApprox(vec3 x) {
    vec3 x2 = x * x;
    vec3 x4 = x2 * x2;
    
    return  + 15.5     * x4 * x2
            - 40.14    * x4 * x
            + 31.96    * x4
            - 6.868    * x2 * x
            + 0.4298   * x2
            + 0.1191   * x
            - 0.00232;
}

vec3 _agx(vec3 val) {
    const mat3 agx_mat = mat3(
        0.842479062253094, 0.0423282422610123, 0.0423756549057051,
        0.0784335999999992,  0.878468636469772,  0.0784336,
        0.0792237451477643, 0.0791661274605434, 0.879142973793104);
    
    const float min_ev = -12.47393;
    const float max_ev = 4.026069;

    // val = pow(val, vec3(2.2)); 

    // Input transform (inset)
    val = agx_mat * val;
    
    // Log2 space encoding
    val = clamp(log2(val), min_ev, max_ev);
    val = (val - min_ev) / (max_ev - min_ev);
    
    // Apply sigmoid function approximation
    val = _agxDefaultContrastApprox(val);

    return val;
}

vec3 _agxEotf(vec3 val) {
    const mat3 agx_mat_inv = mat3(
        1.19687900512017, -0.0528968517574562, -0.0529716355144438,
        -0.0980208811401368, 1.15190312990417, -0.0980434501171241,
        -0.0990297440797205, -0.0989611768448433, 1.15107367264116);
        
    // Inverse input transform (outset)
    val = agx_mat_inv * val;
    
    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display
    // NOTE: We're linearizing the output here. Comment/adjust when
    // *not* using a sRGB render target
    val = pow(val, vec3(2.2)); 

    return val;
}

vec3 _agxLook(vec3 val) {
    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(val, lw);
    
    // Default
    vec3 offset = vec3(0.0);
    vec3 slope = vec3(1.0);
    vec3 power = vec3(1.0);
    float sat = 1.0;
    
    #if AGX_LOOK == 1
    // Golden
    slope = vec3(1.0, 0.9, 0.5);
    power = vec3(0.8);
    sat = 0.8;
    #elif AGX_LOOK == 2
    // Punchy
    slope = vec3(1.0);
    power = vec3(1.35, 1.35, 1.35);
    sat = 1.4;
    #endif        
    
    // Needle
    slope = vec3(1.05);
    power = vec3(1.10, 1.10, 1.10);
    sat = 1.15;

    // User
    // slope = userSlope;
    // offset = userOffset;
    // power = userPower;
    // sat = userSaturation;
    
    // ASC CDL
    val = pow(val * slope + offset, power);
    return luma + sat * (val - luma);
}


vec3 AgXToneMapping( vec3 color ) {
    // apply AGX
    color *= toneMappingExposure;
    color = _agx(color);
    color = _agxLook(color); // Optional
    color = _agxEotf(color);
    return color;
`, t = "vec3 AgXToneMapping( vec3 color ) {", e = "return color;", i = Jt.tonemapping_pars_fragment.indexOf(t), n = Jt.tonemapping_pars_fragment.indexOf(e, i);
  if (i >= 0 && n >= 0) {
    const o = Jt.tonemapping_pars_fragment.substring(i, n + e.length);
    Jt.tonemapping_pars_fragment = Jt.tonemapping_pars_fragment.replace(o, s);
  } else
    z() && console.error("Couldn't find AgXToneMapping in ShaderChunk.tonemapping_pars_fragment");
}
function Dt(s) {
  const t = document.createElement("span");
  return t.style.maxWidth = "48px", t.style.maxHeight = "48px", t.style.overflow = "hidden", t.classList.add("material-symbols-outlined", "notranslate"), t.setAttribute("translate", "no"), t.innerText = s, t;
}
function NO(s) {
  var e;
  return ((e = s.classList) == null ? void 0 : e.contains("material-symbols-outlined")) || !1;
}
const Bh = /* @__PURE__ */ new Map();
async function Wy(s) {
  const t = "Material Symbols Outlined";
  if (document.fonts.check(`1em '${t}'`) || (console.log("Font not loaded yet"), await document.fonts.ready), Bh.has(s))
    return Bh.get(s);
  const e = document.createElement("canvas"), i = 48;
  e.width = i, e.height = i;
  const n = e.getContext("2d");
  if (n) {
    n.font = `${i}px '${t}'`, n.fillStyle = "black", n.fillText(s, 0, i);
    const o = e.toDataURL(), a = new Fe();
    return a.name = s + " icon", a.image = new Image(), a.image.src = o, a.needsUpdate = !0, Bh.set(s, a), a;
  }
  return Bh.set(s, null), null;
}
const du = class {
  constructor() {
    r(this, "_fullscreenButton");
    r(this, "_muteButton");
    r(this, "_qrButton");
  }
  /** Get access to the default HTML button factory.    
   * Use this to get or create default Needle Engine buttons that can be added to your HTML UI  
   * If you want to create a new factory and create new button instances instead of shared buttons, use `ButtonsFactory.create()` instead
   */
  static getOrCreate() {
    return this._instance || (this._instance = new du()), this._instance;
  }
  /** create a new buttons factory */
  static create() {
    return new du();
  }
  /**
   * Get the fullscreen button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createFullscreenButton} to get or create it
   */
  get fullscreenButton() {
    return this._fullscreenButton;
  }
  /** Create a fullscreen button (or return the existing one if it already exists) */
  createFullscreenButton(t) {
    if (this._fullscreenButton)
      return this._fullscreenButton;
    if (!document.fullscreenEnabled)
      return z() && console.warn("NeedleMenu: Fullscreen button could not be created, device doesn't support the Fullscreen API"), null;
    const e = document.createElement("button");
    this._fullscreenButton = e, e.classList.add("fullscreen-button"), e.title = "Click to enter fullscreen mode";
    const i = Dt("fullscreen"), n = Dt("fullscreen_exit");
    return e.appendChild(i), e.onclick = () => {
      document.fullscreenElement ? document.exitFullscreen() : "webkitRequestFullscreen" in t.domElement && typeof t.domElement.webkitRequestFullscreen == "function" ? t.domElement.webkitRequestFullscreen() : "requestFullscreen" in t.domElement && t.domElement.requestFullscreen();
    }, document.addEventListener("fullscreenchange", () => {
      document.fullscreenElement ? (i.remove(), e.appendChild(n), e.title = "Click to enter fullscreen mode") : (n.remove(), e.appendChild(i), e.title = "Click to exit fullscreen mode");
    }), globalThis.addEventListener("needle-xrsession-start", () => {
      e.style.display = "none";
    }), globalThis.addEventListener("needle-xrsession-end", () => {
      e.style.display = "";
    }), e;
  }
  /** Get the mute button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createMuteButton} to get or create it */
  get muteButton() {
    return this._muteButton;
  }
  /** Create a mute button (or return the existing one if it already exists) */
  createMuteButton(t) {
    if (this._muteButton)
      return this._muteButton;
    const e = document.createElement("button");
    this._muteButton = e, e.classList.add("mute-button"), e.title = "Click to mute/unmute";
    const i = Dt("volume_off"), n = Dt("volume_up");
    return t.application.muted ? e.appendChild(i) : e.appendChild(n), e.onclick = () => {
      t.application.muted ? (i.remove(), e.appendChild(n), t.application.muted = !1) : (n.remove(), e.appendChild(i), t.application.muted = !0);
    }, e;
  }
  /**
   * Get the QR code button (or undefined if it doesn't exist yet). Call {@link ButtonsFactory.createQRCode} to get or create it
   */
  get qrButton() {
    return this._qrButton;
  }
  /** Create a QR code button (or return the existing one if it already exists)
   * The QR code button will show a QR code that can be scanned to open the current page on a phone  
   * The QR code will be generated with the current URL when the button is clicked
   * @returns the QR code button element
   */
  createQRCode() {
    if (this._qrButton)
      return this._qrButton;
    const t = document.createElement("button");
    this._qrButton = t, t.innerText = "QR Code", t.prepend(Dt("qr_code")), t.title = "Scan this QR code with your phone to open this page", this.hideElementDuringXRSession(t);
    const e = document.createElement("div");
    e.style.cssText = `
            position: fixed;
            display: inline-block;
            padding: 1rem;
            background-color: white;
            border-radius: 0.4rem;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.2);
        `;
    const i = document.createElement("div");
    i.classList.add("qr-code-container"), e.appendChild(i), t.addEventListener("click", () => {
      if (e.parentNode)
        return o();
      window.location.href.includes("://localhost") && ve("To access your website from another device in the same local network you have to use the IP address instead of localhost."), n();
    });
    async function n() {
      await a(), document.body.appendChild(e);
      const l = i.getBoundingClientRect(), c = t.getBoundingClientRect();
      e.style.left = c.left + c.width * 0.5 - l.width * 0.5 + "px", c.top < l.height ? e.style.top = `calc(${c.bottom}px + ${e.style.padding} * .6)` : e.style.top = `calc(${c.top - l.height}px - ${e.style.padding} * 2.5)`, e.style.opacity = "0", e.style.pointerEvents = "all", e.style.transition = "opacity 0.2s ease-in-out", setTimeout(() => {
        e.style.opacity = "1", window.addEventListener("click", o, { once: !0 });
      }), window.addEventListener("resize", o), window.addEventListener("scroll", o), document.fullscreenElement ? document.fullscreenElement.appendChild(e) : document.body.appendChild(e);
    }
    function o() {
      e.style.pointerEvents = "none", e.style.transition = "opacity 0.2s", e.style.opacity = "0", setTimeout(() => {
        var l;
        return (l = e.parentNode) == null ? void 0 : l.removeChild(e);
      }, 500), window.removeEventListener("click", o), window.removeEventListener("resize", o), window.removeEventListener("scroll", o);
    }
    async function a() {
      const c = await US({
        text: window.location.href,
        width: 200,
        height: 200
      });
      i.innerHTML = "", i.appendChild(c);
    }
    return t.addEventListener("pointerenter", () => {
      a();
    }, { once: !0 }), t;
  }
  hideElementDuringXRSession(t) {
    bg((e) => {
      t["previous-display"] = t.style.display, t.style.display = "none";
    }), W0((e) => {
      t["previous-display"] != null && (t.style.display = t["previous-display"]);
    });
  }
};
let zn = du;
r(zn, "_instance");
function qd(s, t) {
  const e = (t == null ? void 0 : t.element) || document.head, i = Array.from(e.querySelectorAll(`link[rel=stylesheet][href*='${s}']`));
  if (i.length <= 0) {
    const n = document.createElement("link");
    n.href = s, n.rel = "stylesheet", e.appendChild(n), i.push(n);
  }
  if (t != null && t.loadedCallback)
    for (let n = 0; n < i.length; n++)
      t != null && t.loadedCallback && i[n].addEventListener("load", t.loadedCallback);
}
function Pv() {
  qd("https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap");
}
const Om = "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&display=block", Xd = "needle-logo-element";
class Ov extends HTMLElement {
  constructor() {
    super();
    r(this, "_root");
    r(this, "wrapper");
    r(this, "logoElement", document.createElement("img"));
    r(this, "textElement", document.createElement("span"));
    this._root = this.attachShadow({ mode: "closed" });
    const e = document.createElement("template");
    e.innerHTML = `<style>
        :host {
            position: relative;
            min-width: fit-content;
            /* height: 100%; can not have height 100% because of align-items: stretch; in the parent */
            display: flex;
        }

        .wrapper {
            position: relative;
            display: grid;
            grid-template-columns: auto auto;
            padding: .1rem;
        }
        .wrapper:hover {
            cursor: pointer;
        }
        img {
            width: 95px;
            height: 100%;
            align-self: end;
            margin-left: 0.6rem;
        }
        span {
            font-size: 1rem;
            white-space: nowrap;
        }
        </style>
        <div class="wrapper">
            <img class="logo" src=${FC} />
        </div>
        `, this._root.appendChild(e.content.cloneNode(!0)), this.wrapper = this._root.querySelector(".wrapper"), this._root.appendChild(this.wrapper), this.addEventListener("click", () => {
      globalThis.open("https://needle.tools", "_blank");
    }), this.wrapper.setAttribute("title", "Made with Needle Engine");
  }
  static get elementName() {
    return Xd;
  }
  static create() {
    return document.createElement(Xd);
  }
  setLogoVisible(e) {
    this.logoElement.style.display = e ? "block" : "none";
  }
}
customElements.get(Xd) || customElements.define(Xd, Ov);
const Xf = x("debugspatialmenu");
class $O {
  constructor(t, e) {
    r(this, "_context");
    r(this, "needleMenu");
    r(this, "htmlButtonsMap", /* @__PURE__ */ new Map());
    r(this, "enabled", !0);
    r(this, "userRequestedMenu", !1);
    r(this, "uiisDirty", !1);
    r(this, "_showNeedleLogo");
    r(this, "_wasInXR", !1);
    r(this, "preRender", () => {
      var e;
      if (!this.enabled) {
        (e = this.menu) == null || e.removeFromParent();
        return;
      }
      Xf && X.isDesktop() && this.updateMenu();
      const t = this._context.xr;
      if (!(t != null && t.running)) {
        this._wasInXR && (this._wasInXR = !1, this.onExitXR());
        return;
      }
      this._wasInXR || (this._wasInXR = !0, this.onEnterXR()), this.updateMenu();
    });
    r(this, "_menuTarget", new L());
    r(this, "positionFilter", new O0(90, 0.5));
    r(this, "familyName", "Needle Spatial Menu");
    r(this, "menu");
    r(this, "_poweredByNeedleElement");
    var n;
    this._context = t, this._context.pre_render_callbacks.push(this.preRender), this.needleMenu = e;
    const i = (n = this.needleMenu.shadowRoot) == null ? void 0 : n.querySelector(".options");
    i ? new MutationObserver((a) => {
      if (this.enabled && !(this._context.isInXR == !1 && !Xf))
        for (const l of a)
          l.type === "childList" && (l.addedNodes.forEach((c) => {
            this.createButtonFromHTMLNode(c);
          }), l.removedNodes.forEach((c) => {
            const h = c, d = this.htmlButtonsMap.get(h);
            d && (this.htmlButtonsMap.delete(h), d.remove(), Te.update());
          }));
    }).observe(i, { childList: !0 }) : console.error("Could not find options container in needle menu");
  }
  setEnabled(t) {
    var e;
    this.enabled = t, t || (e = this.menu) == null || e.removeFromParent();
  }
  /** Bring up the spatial menu. This is typically invoked from a button click. 
   * The menu will show at a lower height to be easily accessible.
   * @returns true if the menu was shown, false if it can't be shown because the menu has been disabled.
   */
  setDisplay(t) {
    return this.enabled ? (this.userRequestedMenu = t, !0) : !1;
  }
  onDestroy() {
    const t = this._context.pre_render_callbacks.indexOf(this.preRender);
    t > -1 && this._context.pre_render_callbacks.splice(t, 1);
  }
  markDirty() {
    this.uiisDirty = !0;
  }
  showNeedleLogo(t) {
    this._showNeedleLogo = t;
  }
  onEnterXR() {
    var e;
    const t = (e = this.needleMenu.shadowRoot) == null ? void 0 : e.querySelector(".options");
    t && t.childNodes.forEach((i) => {
      this.createButtonFromHTMLNode(i);
    });
  }
  onExitXR() {
    var t;
    (t = this.menu) == null || t.removeFromParent();
  }
  createButtonFromHTMLNode(t) {
    const e = this.getMenu(), i = this.htmlButtonsMap.get(t);
    if (i) {
      i.add();
      return;
    }
    if (t instanceof HTMLButtonElement) {
      const n = this.createButton(e, t);
      this.htmlButtonsMap.set(t, n), n.add();
    } else
      t instanceof HTMLSlotElement && t.assignedNodes().forEach((n) => {
        this.createButtonFromHTMLNode(n);
      });
  }
  updateMenu() {
    var o, a;
    performance.mark("NeedleSpatialMenu updateMenu start");
    const t = this.getMenu();
    this.handleNeedleWatermark(), this._context.scene.add(t);
    const e = this._context.mainCamera, i = this._context.xr, n = (i == null ? void 0 : i.rigScale) || 1;
    if (e) {
      const l = e.worldPosition, c = e.worldForward.multiplyScalar(-1), h = c.y > 0.6, d = c.y > 0.4, u = (t.visible ? d : h) || this.userRequestedMenu, p = !t.visible && u;
      t.visible = u || X.isDesktop() && Xf, c.multiplyScalar(3 * n), l.add(c), (p || !1) && (t.position.copy(this._menuTarget.position), t.position.y += 0.25, this._menuTarget.position.copy(t.position), this.positionFilter.reset(t.position), t.quaternion.copy(this._menuTarget.quaternion), this.markDirty());
      const g = this._menuTarget.position.distanceTo(l);
      (p || g > 1.5 * n) && (this.ensureRenderOnTop(this.menu), this._menuTarget.position.copy(l), this._context.scene.add(this._menuTarget), Tu(this._menuTarget, this._context.mainCamera, !0, !0), this._menuTarget.removeFromParent()), this.positionFilter.filter(this._menuTarget.position, t.position, this._context.time.time);
      const _ = 5;
      (o = this.menu) == null || o.quaternion.slerp(this._menuTarget.quaternion, this._context.time.deltaTime * _), (a = this.menu) == null || a.scale.setScalar(n);
    }
    this.uiisDirty && (performance.mark("SpatialMenu.update.uiisDirty.start"), this.uiisDirty = !1, Te.update(), performance.mark("SpatialMenu.update.uiisDirty.end"), performance.measure("SpatialMenu.update.uiisDirty", "SpatialMenu.update.uiisDirty.start", "SpatialMenu.update.uiisDirty.end")), performance.mark("NeedleSpatialMenu updateMenu end"), performance.measure("SpatialMenu.update", "NeedleSpatialMenu updateMenu start", "NeedleSpatialMenu updateMenu end");
  }
  ensureRenderOnTop(t, e = 0) {
    t instanceof q && (t.material.depthTest = !1, t.material.depthWrite = !1), t.renderOrder = 1e3 + e * 2;
    for (const i of t.children)
      this.ensureRenderOnTop(i, e + 1);
  }
  get isVisible() {
    var t;
    return (t = this.menu) == null ? void 0 : t.visible;
  }
  getMenu() {
    if (this.menu)
      return this.menu;
    this.ensureFont(), this.menu = new Te.Block({
      boxSizing: "border-box",
      fontFamily: this.familyName,
      height: "auto",
      fontSize: 0.1,
      color: 0,
      lineHeight: 1,
      backgroundColor: 16777215,
      backgroundOpacity: 0.55,
      borderRadius: 1,
      whiteSpace: "pre-wrap",
      flexDirection: "row",
      alignItems: "center",
      padding: new me(0, 0.05, 0, 0.05),
      borderColor: 0,
      borderOpacity: 0.05,
      borderWidth: 5e-3
    });
    const t = R.get("ObjectRaycaster");
    return t && Oa(this.menu, new t()), this.menu;
  }
  handleNeedleWatermark() {
    var t;
    if (!this._poweredByNeedleElement) {
      this._poweredByNeedleElement = new Te.Block({
        width: "auto",
        height: "auto",
        fontSize: 0.05,
        whiteSpace: "pre-wrap",
        flexDirection: "row",
        flexWrap: "wrap",
        justifyContent: "center",
        margin: 0.02,
        borderRadius: 0.02,
        padding: 0.02,
        backgroundColor: 16777215,
        backgroundOpacity: 1
      }), this._poweredByNeedleElement["needle:use_eventsystem"] = !0;
      const e = new Vy(this._context, () => globalThis.open("https://needle.tools", "_self"));
      Oa(this._poweredByNeedleElement, e);
      const i = new Te.Text({
        textContent: "Powered by",
        width: "auto",
        height: "auto"
      }), n = new Te.Text({
        textContent: "needle",
        width: "auto",
        height: "auto",
        fontSize: 0.07,
        margin: new me(0, 0, 0, 0.02)
      });
      this._poweredByNeedleElement.add(i), this._poweredByNeedleElement.add(n), (t = this.menu) == null || t.add(this._poweredByNeedleElement), this.markDirty(), new wa().load("./include/needle/poweredbyneedle.webp", (a) => {
        var c;
        e.allowModifyUI = !1, i.removeFromParent(), n.removeFromParent();
        const l = a.image.width / a.image.height;
        (c = this._poweredByNeedleElement) == null || c.set({
          backgroundImage: a,
          backgroundOpacity: 1,
          width: 0.1 * l,
          height: 0.1
        }), this.markDirty();
      });
    }
    if (this.menu) {
      const e = this.menu.children.indexOf(this._poweredByNeedleElement);
      if (!this._showNeedleLogo && fr())
        e >= 0 && (this._poweredByNeedleElement.removeFromParent(), this.markDirty());
      else {
        this._poweredByNeedleElement.visible = !0, this.menu.add(this._poweredByNeedleElement);
        const i = this.menu.children.indexOf(this._poweredByNeedleElement);
        e !== i && this.markDirty();
      }
    }
  }
  ensureFont() {
    let t = Te.FontLibrary.getFontFamily(this.familyName);
    if (!t) {
      t = Te.FontLibrary.addFontFamily(this.familyName);
      const e = t.addVariant("normal", "normal", "./include/needle/arial-msdf.json", "./include/needle/arial.png");
      e == null || e.addEventListener("ready", () => {
        this.markDirty();
      });
    }
  }
  createButton(t, e) {
    const i = new Te.Block({
      width: "auto",
      height: "auto",
      whiteSpace: "pre-wrap",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "center",
      backgroundColor: 16777215,
      backgroundOpacity: 0,
      padding: 0.02,
      margin: 0.01,
      borderRadius: 0.02,
      cursor: "pointer",
      fontSize: 0.05
    }), n = new Te.Text({
      textContent: "",
      width: "auto",
      justifyContent: "center",
      alignItems: "center",
      backgroundOpacity: 0,
      backgroundColor: 16777215,
      fontFamily: this.familyName,
      color: 0,
      borderRadius: 0.02,
      padding: 0.01
    });
    i.add(n), i["needle:use_eventsystem"] = !0;
    const o = new Vy(this._context, () => e.click());
    return Oa(i, o), new WO(this, t, e, i, n);
  }
}
class WO {
  constructor(t, e, i, n, o) {
    r(this, "menu");
    r(this, "root");
    r(this, "htmlbutton");
    r(this, "spatialContainer");
    r(this, "spatialText");
    r(this, "spatialIcon");
    r(this, "_lastText", "");
    r(this, "_lastTexture");
    this.menu = t, this.root = e, this.htmlbutton = i, this.spatialContainer = n, this.spatialText = o, new MutationObserver((l) => {
      for (const c of l)
        c.type === "attributes" ? c.attributeName === "style" && this.updateVisible() : c.type === "childList" && this.updateText();
    }).observe(i, { attributes: !0, childList: !0 }), this.updateText();
  }
  add() {
    this.spatialContainer.parent != this.root && (this.root.add(this.spatialContainer), this.menu.markDirty(), this.updateVisible(), this.updateText());
  }
  remove() {
    this.spatialContainer.parent && (this.spatialContainer.removeFromParent(), this.menu.markDirty());
  }
  updateVisible() {
    const t = this.spatialContainer.visible;
    this.spatialContainer.visible = this.htmlbutton.style.display !== "none", t !== this.spatialContainer.visible && this.menu.markDirty();
  }
  updateText() {
    let t = "", e = "";
    this.htmlbutton.childNodes.forEach((i) => {
      i.nodeType === Node.TEXT_NODE ? t += i.textContent : i instanceof HTMLElement && NO(i) && i.textContent && (e = i.textContent);
    }), this._lastText !== t && (this._lastText = t, this.spatialText.name = t, this.spatialText.set({ textContent: t }), this.menu.markDirty()), t.length <= 0 ? this.spatialText.parent && (this.spatialText.removeFromParent(), this.menu.markDirty()) : this.spatialText.parent || (this.spatialContainer.add(this.spatialText), this.menu.markDirty()), e && this.createIcon(e);
  }
  async createIcon(t) {
    var i;
    if (!this.spatialIcon) {
      const n = await Wy(t);
      if (n && !this.spatialIcon) {
        const a = new Te.Block({
          width: 0.08,
          height: 0.08,
          backgroundColor: 16777215,
          backgroundImage: n,
          backgroundOpacity: 1,
          margin: new me(0, 5e-3, 0, 0)
        });
        this.spatialIcon = a, this.spatialContainer.add(a), this.menu.markDirty();
      }
    }
    if (t != this._lastTexture) {
      this._lastTexture = t;
      const n = await Wy(t);
      n && ((i = this.spatialIcon) == null || i.set({ backgroundImage: n }), this.menu.markDirty());
    }
    const e = this.spatialContainer.children.indexOf(this.spatialIcon);
    e > 0 && (this.spatialContainer.children.splice(e, 1), this.spatialContainer.children.unshift(this.spatialIcon), this.menu.markDirty());
  }
}
class Vy {
  constructor(t, e) {
    r(this, "isComponent", !0);
    r(this, "enabled", !0);
    r(this, "gameObject");
    r(this, "allowModifyUI", !0);
    r(this, "context");
    r(this, "onclick");
    this.context = t, this.onclick = e;
  }
  get activeAndEnabled() {
    return !0;
  }
  __internalAwake() {
  }
  __internalEnable() {
  }
  __internalDisable() {
  }
  __internalStart() {
  }
  onEnable() {
  }
  onDisable() {
  }
  get element() {
    return this.gameObject;
  }
  onPointerEnter() {
    this.context.input.setCursor("pointer"), this.allowModifyUI && (this.element.set({ backgroundOpacity: 1 }), Te.update());
  }
  onPointerExit() {
    this.context.input.unsetCursor("pointer"), this.allowModifyUI && (this.element.set({ backgroundOpacity: 0 }), Te.update());
  }
  onPointerDown(t) {
    t.use();
  }
  onPointerUp(t) {
    t.use();
  }
  onPointerClick(t) {
    t.use(), this.onclick();
  }
}
const Qo = "needle-menu", mc = x("debugmenu"), Hy = x("debugnoncommercial");
let VO = class {
  constructor(t) {
    r(this, "_context");
    r(this, "_menu");
    r(this, "_spatialMenu");
    r(this, "onPostMessage", (t) => {
      if (t.origin === globalThis.location.origin && typeof t.data == "object") {
        const e = t.data, i = e.type;
        if (i === "needle:menu") {
          const n = e.button;
          if (n) {
            if (!n.label)
              return console.error("NeedleMenu: buttoninfo.label is required");
            if (!n.onclick)
              return console.error("NeedleMenu: buttoninfo.onclick is required");
            const o = document.createElement("button");
            if (o.textContent = n.label, n.icon) {
              const a = Dt(n.icon);
              o.prepend(a);
            }
            n.priority && o.setAttribute("priority", n.priority.toString()), o.onclick = () => {
              if (n.onclick) {
                const a = n.onclick.startsWith("http") || n.onclick.startsWith("www."), l = n.target || "_blank";
                a ? globalThis.open(n.onclick, l) : console.error("NeedleMenu: onclick is not a valid link", n.onclick);
              }
            }, this._menu.appendChild(o);
          } else
            mc && console.error("NeedleMenu: unknown postMessage event", e);
        } else
          mc && console.warn("NeedleMenu: unknown postMessage type", i, e);
      }
    });
    r(this, "onStartXR", (t) => {
      t.session.isScreenBasedAR && (this._menu.previousParent = this._menu.parentNode, this._context.arOverlayElement.appendChild(this._menu), t.session.session.addEventListener("end", this.onExitXR), this._menu.closeFoldout());
    });
    r(this, "onExitXR", () => {
      this._menu.previousParent && (this._menu.previousParent.appendChild(this._menu), delete this._menu.previousParent);
    });
    r(this, "_muteButton");
    r(this, "_fullscreenButton");
    this._menu = Qd.getOrCreate(t.domElement, t), this._context = t, this._spatialMenu = new $O(t, this._menu), window.addEventListener("message", this.onPostMessage), bg(this.onStartXR);
  }
  /** @ignore internal method */
  onDestroy() {
    window.removeEventListener("message", this.onPostMessage), this._menu.remove(), this._spatialMenu.onDestroy();
  }
  /** Experimental: Change the menu position to be at the top or the bottom of the needle engine webcomponent
   * @param position "top" or "bottom"
   */
  setPosition(t) {
    this._menu.setPosition(t);
  }
  /**
   * Call to show or hide the menu.  
   * NOTE: Hiding the menu is a PRO feature and requires a needle engine license. Hiding the menu will not work in production without a license.
   */
  setVisible(t) {
    this._menu.setVisible(t);
  }
  /** When set to false, the Needle Engine logo will be hidden. Hiding the logo requires a needle engine license */
  showNeedleLogo(t) {
    var e;
    this._menu.showNeedleLogo(t), (e = this._spatialMenu) == null || e.showNeedleLogo(t);
  }
  /** When enabled=true the menu will be visible in VR/AR sessions */
  showSpatialMenu(t) {
    this._spatialMenu.setEnabled(t);
  }
  setSpatialMenuVisible(t) {
    this._spatialMenu.setDisplay(t);
  }
  get spatialMenuIsVisible() {
    return this._spatialMenu.isVisible;
  }
  /**
   * Call to add or remove a button to the menu to show a QR code for the current page  
   * If enabled=true then a button will be added to the menu that will show a QR code for the current page when clicked.
   */
  showQRCodeButton(t) {
    if (t === "desktop-only" && (t = !X.isMobileDevice()), t) {
      const e = zn.getOrCreate().createQRCode();
      return e.style.display = "", this._menu.appendChild(e), e;
    } else {
      const e = zn.getOrCreate().qrButton;
      return e && (e.style.display = "none"), e ?? null;
    }
  }
  /** Call to add or remove a button to the menu to mute or unmute the application  
   * Clicking the button will mute or unmute the application
  */
  showAudioPlaybackOption(t) {
    var e;
    if (!t) {
      (e = this._muteButton) == null || e.remove();
      return;
    }
    this._muteButton = zn.getOrCreate().createMuteButton(this._context), this._muteButton.setAttribute("priority", "100"), this._menu.appendChild(this._muteButton);
  }
  showFullscreenOption(t) {
    var e;
    if (!t) {
      (e = this._fullscreenButton) == null || e.remove();
      return;
    }
    this._fullscreenButton = zn.getOrCreate().createFullscreenButton(this._context), this._fullscreenButton && (this._fullscreenButton.setAttribute("priority", "150"), this._menu.appendChild(this._fullscreenButton));
  }
  appendChild(t) {
    return this._menu.appendChild(t);
  }
};
var Gc;
const P_ = class extends HTMLElement {
  constructor() {
    var u, p, m, g, _, y;
    super();
    r(this, "_domElement", null);
    r(this, "_context", null);
    r(this, "_sizeChangeInterval");
    zi(this, Gc, (e) => {
      if (!e.defaultPrevented && e.target == this._domElement && e instanceof PointerEvent && e.button === 0 && this.root.classList.contains("open")) {
        const i = this.foldout.getBoundingClientRect(), n = e;
        n.clientX > i.left && n.clientX < i.right && n.clientY > i.top && n.clientY < i.bottom || this.root.classList.toggle("open", !1);
      }
    });
    r(this, "_userRequestedLogoVisible");
    r(this, "_userRequestedMenuVisible");
    // private _root: ShadowRoot | null = null;
    r(this, "root");
    /** wraps the whole content */
    r(this, "wrapper");
    /** contains the buttons and dynamic elements */
    r(this, "options");
    /** contains the needle-logo html element */
    r(this, "logoContainer");
    r(this, "compactMenuButton");
    r(this, "foldout");
    r(this, "_isHandlingChange", !1);
    r(this, "_didSort", /* @__PURE__ */ new Map());
    r(this, "_lastAvailableWidthChange", 0);
    r(this, "_timeoutHandle", 0);
    r(this, "handleSizeChange", (e, i) => {
      if (!this._domElement)
        return;
      const n = this._domElement.clientWidth;
      if (n < 100) {
        clearTimeout(this._timeoutHandle), this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style");
        return;
      }
      const o = 20 * 2, a = n - o;
      if (!i && Math.abs(a - this._lastAvailableWidthChange) < 1)
        return;
      this._lastAvailableWidthChange = a, clearTimeout(this._timeoutHandle), this._timeoutHandle = setTimeout(() => {
        const h = c();
        h < 0 ? (this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style")) : h > 0 && (this.root.classList.remove("compact"), this.foldout.classList.remove("floating-panel-style"), c() < 0 && (this.root.classList.add("compact"), this.foldout.classList.add("floating-panel-style")));
      }, 5);
      const l = () => this.options.clientWidth + this.logoContainer.clientWidth, c = () => a - l();
    });
    const e = document.createElement("template");
    e.innerHTML = `<style>

        #root {
            position: absolute;
            width: auto;
            max-width: 95%;
            left: 50%;
            transform: translateX(-50%);
            top: min(20px, 10vh);
            padding: 0.3rem;
            display: flex;
            visibility: visible;
            flex-direction: row-reverse; /* if we overflow this should be right aligned so the logo is always visible */
            pointer-events: all;
            z-index: 1000;
        }

        /** hide the menu if it's empty **/
        #root.has-no-options.logo-hidden {
            display: none; 
        }

        /** using a div here because then we can change the class for placement **/
        #root.bottom {
            top: auto;
            bottom: min(30px, 10vh);
        }
        #root.top {
            top: calc(.7rem + env(safe-area-inset-top));
        }
        
        .wrapper {
            position: relative;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: stretch;
            gap: 0px;
            padding: 0 0rem;
        }

        .wrapper > *, .options > button, .options > select, ::slotted(*) {
            position: relative;
            border: none;
            border-radius: 0;
            outline: 1px solid rgba(0,0,0,0);
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 2.3rem;
            max-width: 100%;

            /** basic font settings for all entries **/
            font-size: 1rem;
            font-family: 'Roboto Flex', sans-serif;
            font-optical-sizing: auto;
            font-weight: 500;
            font-weight: 200;
            font-variation-settings: "wdth" 100;
            color: rgb(20,20,20);
        }

        .options > select[multiple]:hover {
            max-height: 300px;
        }

        .floating-panel-style {
            background: rgba(255, 255, 255, .4);
            outline: rgb(0 0 0 / 5%) 1px solid;
            border: 1px solid rgba(255, 255, 255, .1);
            box-shadow: 0px 7px 0.5rem 0px rgb(0 0 0 / 6%), inset 0px 0px 1.3rem rgba(0,0,0,.05);
            border-radius: 1.5rem;
            /** 
             * to make nested background filter work 
             * https://stackoverflow.com/questions/60997948/backdrop-filter-not-working-for-nested-elements-in-chrome 
             **/
            &::before {
                content: '';
                position: absolute;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                z-index: -1;
                border-radius: 1.5rem;
                -webkit-backdrop-filter: blur(8px);
                backdrop-filter: blur(8px);
            }
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        .options {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .options > *, ::slotted(*) {
            max-height: 2.25rem;
            padding: .4rem .5rem;
        }
        
        :host .options > *, ::slotted(*) {
            background: transparent;
            border: none;
            white-space: nowrap;
            transition: all 0.1s linear .02s;
            border-radius: 1.5rem;
            user-select: none;
        }
        :host .options > *:hover, ::slotted(*:hover) {
            cursor: pointer;
            color: black;
            background: rgba(245, 245, 245, .8);
            box-shadow: inset 0 0 1rem rgba(0,0,30,.2);
            outline: rgba(0,0,0,.1) 1px solid;
        }
        :host .options > *:active, ::slotted(*:active) {
            background: rgba(255, 255, 255, .8);
            box-shadow: inset 0px 1px 1px rgba(255,255,255,.5), inset 0 0 2rem rgba(0,0,30,.2), inset 0px 2px 4px rgba(0,0,20,.5);
            transition: all 0.05s linear;
        }
        :host .options > *:focus, ::slotted(*:focus) {
            outline: rgba(255,255,255,.5) 1px solid;
        }
        :host .options > *:focus-visible, ::slotted(*:focus-visible) {
            outline: rgba(0,0,0,.5) 1px solid;
        }

        :host .options > *:disabled, ::slotted(*:disabled) {
            background: rgba(0,0,0,.05);
            color: rgba(60,60,60,.7);
            pointer-events: none;
        }

        button, ::slotted(button) {
            gap: 0.3rem;
        }

        /** XR button animation **/
        :host button.this-mode-is-requested {
            background: repeating-linear-gradient(to right, #fff 0%, #fff 40%, #aaffff 55%, #fff 80%);
            background-size: 200% auto;
            background-position: 0 100%;
            animation: AnimationName .7s ease infinite forwards;
        }
        :host button.other-mode-is-requested {
            opacity: .5;
        }
        
        @keyframes AnimationName {
            0% { background-position: 0% 0 }
            100% { background-position: -200% 0 }
        }




        .logo {
            cursor: pointer;
            padding-left: 0.6rem;
            padding-bottom: .02rem;
            margin-right: 0.5rem;
        }
        .logo-hidden {
            .logo {
                display: none;
            }
        }
        :host .has-options .logo {
            border-left: 1px solid rgba(40,40,40,.4);
            margin-left: 0.3rem;
            margin-right: 0.5rem;
        }

        .logo > span {
            white-space: nowrap;
        }



        /** COMPACT */

        /** Hide the menu button normally **/
        .compact-menu-button { display: none; }
        /** And show it when we're in compact mode **/
        .compact .compact-menu-button {
            position: relative;
            display: block;
            background: none;
            border: none;
            border-radius: 2rem;

            margin: 0;
            padding: 0 .3rem;
            padding-top: .2rem;

            z-index: 100;

            color: #000;

            &:hover {
                background: rgba(255,255,255,.2);
                cursor: pointer;
            }
            &:focus {
                outline: 1px solid rgba(255,255,255,.5);
            }
            &:focus-visible {
                outline: 1px solid rgba(0,0,0,.5);
            }
            & .expanded-click-area {
                position: absolute;
                left: 0;
                right: 0;
                top: 10%;
                bottom: 10%;
                transform: scale(1.8);
            }
        }  
        .has-no-options .compact-menu-button {
            display: none;
        }
        .open .compact-menu-button {
            background: rgba(255,255,255,.2);
        }
        .logo-visible .compact-menu-button { 
            margin-left: .2rem;
        }
        
        /** Open and hide menu **/
        .compact .foldout { 
            display: none;
        }
        .open .options, .open .foldout {
            display: flex;
            justify-content: center;
        }
        .compact .wrapper {
            padding: 0;
        }
        .compact .wrapper, .compact .options {
            height: auto;
            max-height: initial;
            flex-direction: row;
            gap: .12rem;
        }
        .compact .options { 
            flex-wrap: wrap;
            gap: .3rem;
        }
        .compact .top .options {
            height: auto;
            flex-direction: row;
        }
        .compact .bottom .wrapper {
            height: auto;
            flex-direction: column;
        }

        .compact .foldout {
            max-height: min(100ch, calc(100vh - 100px));
            overflow: auto;
            overflow-x: hidden;
            align-items: center;

            position: fixed;
            bottom: calc(100% + 5px);
            z-index: 100;
            width: auto;
            left: .2rem;
            right: .2rem;
            padding: .2rem;

        }
        .compact.logo-hidden .foldout {
            /** for when there's no logo we want to center the foldout **/
            min-width: 24ch;
            margin-left: 50%;
            transform: translateX(calc(-50% - .2rem));
        }
        
        .compact.top .foldout {
            top: calc(100% + 5px);
            bottom: auto;
        }

        ::-webkit-scrollbar {
            max-width: 7px;
            background: rgba(100,100,100,.2);
            border-radius: .2rem;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, .3);
            border-radius: .2rem;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgb(150,150,150);
        }

        .compact .options > *, .compact .options > ::slotted(*) {
            font-size: 1.2rem;
            padding: .6rem .5rem;
            width: 100%;
        }
        .compact.has-options .logo {
            border: none;
            padding-left: 0;
            margin-left: 1rem;
            margin-bottom: .02rem;
        }
        .compact .options {
            /** e.g. if we have a very wide menu item like a select with long option names we don't want to overflow **/
            max-width: 100%;

            & > button, & > select {
                display: flex;
                flex-basis: 100%;
                min-height: 3rem;
            }
            & > button.row2 {
                //border: 1px solid red !important;
                display: flex;
                flex: 1;
                flex-basis: 30%;
            }
        }

        /** If there's really not enough space then just hide all options **/
        @media (max-width: 100px) or (max-height: 100px){
            .foldout {
                display: none !important;
            }
            .compact-menu-button {
                display: none !important;
            }
        }
        
        /* dark mode */
        /*
        @media (prefers-color-scheme: dark) {
            :host {
                background: rgba(0,0,0, .6);
            }
            :host button {
                color: rgba(200,200,200);
            }
            :host button:hover {
                background: rgba(100,100,100, .8);
            }
        }
        */

        </style>
        
        <div id="root" class="logo-visible floating-panel-style bottom">
            <div class="wrapper">
                <div class="foldout">
                    <div class="options" part="options">
                        <slot></slot>
                    </div>
                    <div class="options" part="options">
                        <slot name="end"></slot>
                    </div>
                </div>
                <div style="user-select:none" class="logo">
                    <span class="madewith notranslate">powered by</span>
                </div>
            </div>
            <button class="compact-menu-button">
                <div class="expanded-click-area"></div>
            </button>
        </div>
        `;
    const i = this.attachShadow({ mode: "open" });
    Pv(), qd(Om, { loadedCallback: () => {
      this.handleSizeChange();
    } }), qd(Om, { element: i });
    const n = e.content.cloneNode(!0);
    i == null || i.appendChild(n), this.root = i.querySelector("#root"), this.wrapper = (u = this.root) == null ? void 0 : u.querySelector(".wrapper"), this.options = (p = this.root) == null ? void 0 : p.querySelector(".options"), this.logoContainer = (m = this.root) == null ? void 0 : m.querySelector(".logo"), this.compactMenuButton = (g = this.root) == null ? void 0 : g.querySelector(".compact-menu-button"), this.compactMenuButton.append(Dt("more_vert")), this.foldout = (_ = this.root) == null ? void 0 : _.querySelector(".foldout"), (y = this.root) == null || y.appendChild(this.wrapper), this.wrapper.classList.add("wrapper");
    const o = Ov.create();
    o.style.minHeight = "1rem", this.logoContainer.append(o), this.logoContainer.addEventListener("click", () => {
      globalThis.open("https://needle.tools", "_blank");
    });
    try {
      window.requestAnimationFrame(() => QO((b) => {
        if (b == !0 && Vn() && !Hy) {
          let w = this._userRequestedLogoVisible;
          w === void 0 && (w = !1), this.___onSetLogoVisible(w);
        }
      }));
    } catch (b) {
      console.error("[Needle Menu] License check failed.", b);
    }
    this.compactMenuButton.addEventListener("click", (b) => {
      b.preventDefault(), this.root.classList.toggle("open");
    });
    let a = this._context;
    setTimeout(() => a = this._context);
    let l = 0;
    const c = (b, w) => {
      var P, k, O;
      mc && console.log("Set menu visible", w), a != null && a.isInAR && a.arOverlayElement ? b != a.arOverlayElement && a.arOverlayElement.appendChild(this) : this.parentNode != ((P = this._domElement) == null ? void 0 : P.shadowRoot) && ((O = (k = this._domElement) == null ? void 0 : k.shadowRoot) == null || O.appendChild(this)), this.style.display = w ? "flex" : "none", this.style.visibility = "visible", this.style.opacity = "1";
    };
    let h = !1;
    new MutationObserver((b) => {
      var w;
      if (!h)
        try {
          h = !0, this.onChangeDetected(b);
          const P = this == null ? void 0 : this.parentNode;
          if ((this.style.display != "flex" || this.style.visibility != "visible" || this.style.opacity != "1" || P != ((w = this._domElement) == null ? void 0 : w.shadowRoot)) && !Vn()) {
            const k = l++;
            ui() && this._userRequestedMenuVisible === !1 ? (k === 0 && c(P, this._userRequestedMenuVisible), k === 1 && console.warn("Needle Menu Warning: You need a PRO license to hide the Needle Engine menu → The menu will be visible in your deployed website if you don't have a PRO license. See https://needle.tools/pricing for details.")) : k === 0 ? c(P, !0) : setTimeout(() => c(P, !0), 5);
          }
        } finally {
          h = !1;
        }
    }).observe(this.root, { childList: !0, subtree: !0, attributes: !0 }), mc && this.___insertDebugOptions();
  }
  static create() {
    return document.createElement(Qo, { is: Qo });
  }
  static getOrCreate(e, i) {
    let n = e.querySelector(Qo);
    return !n && e.shadowRoot && (n = e.shadowRoot.querySelector(Qo)), n || (n = window.document.body.querySelector(Qo)), n || (n = P_.create(), e.shadowRoot ? e.shadowRoot.appendChild(n) : e.appendChild(n)), n._domElement = e, n._context = i, n;
  }
  connectedCallback() {
    window.addEventListener("resize", this.handleSizeChange), this.handleMenuVisible(), this._sizeChangeInterval = setInterval(() => this.handleSizeChange(void 0, !0), 5e3), setTimeout(() => {
      var e, i;
      (e = this._domElement) == null || e.addEventListener("resize", this.handleSizeChange), (i = this._domElement) == null || i.addEventListener("click", ue(this, Gc));
    }, 1);
  }
  disconnectedCallback() {
    var e, i;
    window.removeEventListener("resize", this.handleSizeChange), clearInterval(this._sizeChangeInterval), (e = this._domElement) == null || e.removeEventListener("resize", this.handleSizeChange), (i = this._context) == null || i.domElement.removeEventListener("click", ue(this, Gc));
  }
  showNeedleLogo(e) {
    this._userRequestedLogoVisible = e, !(!e && (!Vn() || Hy) && (console.warn("Needle Menu: You need a PRO license to hide the Needle Engine logo."), !ui())) && this.___onSetLogoVisible(e);
  }
  ___onSetLogoVisible(e) {
    this.logoContainer.style.display = "", this.logoContainer.style.opacity = "1", this.logoContainer.style.visibility = "visible", e ? (this.root.classList.remove("logo-hidden"), this.root.classList.add("logo-visible")) : (this.root.classList.remove("logo-visible"), this.root.classList.add("logo-hidden"));
  }
  setPosition(e) {
    if (e !== "top" && e !== "bottom")
      return console.error("NeedleMenu.setPosition: invalid position", e);
    this.root.classList.remove("top", "bottom"), this.root.classList.add(e);
  }
  setVisible(e) {
    this._userRequestedMenuVisible = e, this.style.display = e ? "flex" : "none";
  }
  /**
   * If the menu is in compact mode and the foldout is currently open (to show all menu options) then this will close the foldout
   */
  closeFoldout() {
    this.root.classList.remove("open");
  }
  append(...e) {
    for (const i of e)
      if (typeof i == "string") {
        const n = document.createTextNode(i);
        this.options.appendChild(n);
      } else
        this.options.appendChild(i);
  }
  appendChild(e) {
    var n;
    if (!(e instanceof Node)) {
      const o = document.createElement("button");
      if (o.textContent = e.label, o.onclick = e.onClick, o.setAttribute("priority", ((n = e.priority) == null ? void 0 : n.toString()) ?? "0"), e.title && (o.title = e.title), e.icon) {
        const a = Dt(e.icon);
        e.iconSide === "right" ? o.appendChild(a) : o.prepend(a);
      }
      e.class && o.classList.add(e.class), e = o;
    }
    return this.options.appendChild(e);
  }
  prepend(...e) {
    for (const i of e)
      if (typeof i == "string") {
        const n = document.createTextNode(i);
        this.options.prepend(n);
      } else
        this.options.prepend(i);
  }
  /** Called when any change in the web component is detected (including in children and child attributes) */
  onChangeDetected(e) {
    if (!this._isHandlingChange) {
      this._isHandlingChange = !0;
      try {
        this.handleMenuVisible();
        for (const i of e)
          i.target == this.options && this.onOptionsChildrenChanged(i);
      } finally {
        this._isHandlingChange = !1;
      }
    }
  }
  onOptionsChildrenChanged(e) {
    if (this.root.classList.toggle("has-options", this.hasAnyVisibleOptions), this.root.classList.toggle("has-no-options", !this.hasAnyVisibleOptions), this.handleSizeChange(void 0, !0), e.type === "childList" && e.addedNodes.length > 0) {
      const i = Array.from(this.options.children);
      i.sort((o, a) => {
        const l = parseInt(o.getAttribute("priority") || "0"), c = parseInt(a.getAttribute("priority") || "0");
        return l - c;
      });
      let n = !1;
      for (let o = 0; o < i.length; o++) {
        const a = this.options.children[o], l = i[o];
        if (a !== l) {
          n = !0;
          break;
        }
      }
      if (n)
        for (const o of i)
          this.options.appendChild(o);
    }
  }
  /** checks if the menu has any content and should be rendered at all
   * if we dont have any content and logo then we hide the menu
   */
  handleMenuVisible() {
    mc && console.log("Update VisibleState: Any Content?", this.hasAnyContent), this.hasAnyContent ? this.root.style.display = "" : this.root.style.display = "none", this.root.classList.toggle("has-options", this.hasAnyVisibleOptions), this.root.classList.toggle("has-no-options", !this.hasAnyVisibleOptions);
  }
  /** @returns true if we have any content OR a logo */
  get hasAnyContent() {
    return !!(this.logoContainer.style.display != "none" || this.hasAnyVisibleOptions);
  }
  get hasAnyVisibleOptions() {
    for (let e = 0; e < this.options.children.length; e++) {
      const i = this.options.children[e];
      if (i.tagName === "SLOT") {
        const o = i.assignedNodes();
        for (const a of o)
          if (a instanceof HTMLElement && a.style.display != "none")
            return !0;
      } else if (i.style.display != "none")
        return !0;
    }
    return !1;
  }
  ___insertDebugOptions() {
    window.addEventListener("keydown", (n) => {
      n.key === "p" && this.setPosition(this.root.classList.contains("top") ? "bottom" : "top");
    });
    const e = document.createElement("button");
    e.textContent = "Hide Buttons", e.onclick = () => {
      const n = new Array(this.options.children.length);
      for (let o = 0; o < this.options.children.length; o++)
        n[o] = this.options.children[o];
      for (const o of n)
        this.options.removeChild(o);
      setTimeout(() => {
        for (const o of n)
          this.options.appendChild(o);
      }, 1e3);
    }, this.appendChild(e);
    const i = document.createElement("button");
    i.textContent = "Toggle Logo", i.addEventListener("click", () => {
      this.logoContainer.style.display = this.logoContainer.style.display === "none" ? "" : "none";
    }), this.appendChild(i);
  }
};
let Qd = P_;
Gc = new WeakMap();
customElements.get(Qo) || customElements.define(Qo, Qd);
const st = x("debugcontext"), HO = x("stats"), GO = x("debugactive"), qO = x("debugframerate"), XO = x("debugcoroutine"), DD = {};
class LD {
  constructor() {
    r(this, "name");
    /** for debugging only */
    r(this, "alias");
    /** the hash is used as a seed when initially loading the scene files */
    r(this, "hash");
    /** when true the context will not check if it's visible in the viewport and always update and render */
    r(this, "runInBackground");
    /** the DOM element the context belongs to or is inside of (this does not have to be the canvas. use renderer.domElement if you want to access the dom canvas) */
    r(this, "domElement");
    /** externally owned renderer */
    r(this, "renderer");
    /** externally owned camera */
    r(this, "camera");
    /** externally owned scene */
    r(this, "scene");
  }
}
var Re = /* @__PURE__ */ ((s) => (s[s.Start = -1] = "Start", s[s.EarlyUpdate = 0] = "EarlyUpdate", s[s.Update = 1] = "Update", s[s.LateUpdate = 2] = "LateUpdate", s[s.OnBeforeRender = 3] = "OnBeforeRender", s[s.OnAfterRender = 4] = "OnAfterRender", s[s.PrePhysicsStep = 9] = "PrePhysicsStep", s[s.PostPhysicsStep = 10] = "PostPhysicsStep", s[s.Undefined = -1] = "Undefined", s))(Re || {});
function Eg(s, t) {
  if (!s)
    return;
  if (!s.isComponent) {
    (z() || st) && console.error(`Registered script is not a Needle Engine component. 
The script will be ignored. Please make sure your component extends "Behaviour" imported from "@needle-tools/engine"
`, s);
    return;
  }
  t || (t = ee.Current, st && console.warn("> Registering component without context"));
  const e = t == null ? void 0 : t.new_scripts;
  e.includes(s) || e.push(s);
}
const ke = class {
  constructor(t) {
    /** The name of the context */
    r(this, "name");
    /** An alias for the context */
    r(this, "alias");
    /** When the renderer or camera are managed by an external process (e.g. when running in r3f context). 
     * When this is false you are responsible to call update(timestamp, xframe.  
     * It is also currently assumed that rendering is handled performed by an external process
     * */
    r(this, "isManagedExternally", !1);
    /** set to true to pause the update loop. You can receive an event for it in your components. 
     * Note that script updates will not be called when paused */
    r(this, "isPaused", !1);
    /** When enabled the application will run while not visible on the page */
    r(this, "runInBackground", !1);
    /** 
     * Set to the target framerate you want your application to run in (you can use ?stats to check the fps)
     * Set to undefined if you want to run at the maximum framerate
     */
    r(this, "targetFrameRate");
    /** Use a higher number for more accurate physics simulation.   
     * When undefined physics steps will be 1 for mobile devices and 5 for desktop devices  
     * Set to 0 to disable physics updates
     * TODO: changing physics steps is currently not supported because then forces that we get from the character controller and rigidbody et al are not correct anymore - this needs to be properly tested before making this configureable
    */
    r(this, "physicsSteps", 1);
    /** used to append to loaded assets */
    r(this, "hash");
    /** The `<needle-engine>` web component */
    r(this, "domElement");
    r(this, "_resolutionScaleFactor", 1);
    // domElement.clientLeft etc doesnt return absolute position
    r(this, "_boundingClientRectFrame", -1);
    r(this, "_boundingClientRect", null);
    r(this, "_domX");
    r(this, "_domY");
    /** shorthand for `NeedleXRSession.active`  
     * Automatically set by NeedleXRSession when a XR session is active 
     * @returns the active XR session or null if no session is active
     * */
    r(this, "xr", null);
    r(this, "_xrFrame", null);
    r(this, "_currentFrameEvent", -1);
    r(this, "scene");
    r(this, "renderer");
    r(this, "composer", null);
    // all scripts
    r(this, "scripts", []);
    r(this, "scripts_pausedChanged", []);
    // scripts with update event
    r(this, "scripts_earlyUpdate", []);
    r(this, "scripts_update", []);
    r(this, "scripts_lateUpdate", []);
    r(this, "scripts_onBeforeRender", []);
    r(this, "scripts_onAfterRender", []);
    r(this, "scripts_WithCorroutines", []);
    r(this, "scripts_immersive_vr", []);
    r(this, "scripts_immersive_ar", []);
    r(this, "coroutines", {});
    /** callbacks called once after the context has been created */
    r(this, "post_setup_callbacks", []);
    /** called every frame at the beginning of the frame (after component start events and before earlyUpdate) */
    r(this, "pre_update_callbacks", []);
    /** called every frame before rendering (after all component events) */
    r(this, "pre_render_callbacks", []);
    /** called every frame after rendering (after all component events) */
    r(this, "post_render_callbacks", []);
    /** called every frame befroe update (this list is emptied every frame) */
    r(this, "pre_update_oneshot_callbacks", []);
    r(this, "new_scripts", []);
    r(this, "new_script_start", []);
    r(this, "new_scripts_pre_setup_callbacks", []);
    r(this, "new_scripts_post_setup_callbacks", []);
    r(this, "new_scripts_xr", []);
    /** The main camera component of the scene - this camera is used for rendering */
    r(this, "mainCameraComponent");
    r(this, "_mainCamera", null);
    r(this, "_fallbackCamera", null);
    r(this, "application");
    /** access animation mixer used by components in the scene */
    r(this, "animations");
    /** access timings (current frame number, deltaTime, timeScale, ...) */
    r(this, "time");
    r(this, "input");
    /** access physics related methods (e.g. raycasting). To access the phyiscs engine use `context.physics.engine` */
    r(this, "physics");
    /** access networking methods (use it to send or listen to messages or join a networking backend) */
    r(this, "connection");
    /** 
     * @deprecated AssetDataBase is deprecated
     */
    r(this, "assets");
    r(this, "mainLight", null);
    r(this, "sceneLighting");
    r(this, "addressables");
    r(this, "lightmaps");
    r(this, "players");
    r(this, "lodsManager");
    r(this, "menu");
    r(this, "_sizeChanged", !1);
    r(this, "_isCreated", !1);
    r(this, "_isCreating", !1);
    r(this, "_isVisible", !1);
    r(this, "_stats", HO ? new Z1() : null);
    r(this, "_intersectionObserver", null);
    r(this, "_disposeCallbacks", []);
    /** Clamps the renderer max resolution. If undefined the max resolution is not clamped. Default is undefined */
    r(this, "maxRenderResolution");
    r(this, "_originalCreationArgs");
    r(this, "onUnhandledRejection", (t) => {
      this.onError(t.reason);
    });
    r(this, "_cameraStack", []);
    r(this, "_onBeforeRenderListeners", /* @__PURE__ */ new Map());
    r(this, "_onAfterRenderListeners", /* @__PURE__ */ new Map());
    r(this, "_requireDepthTexture", !1);
    r(this, "_requireColorTexture", !1);
    r(this, "_renderTarget");
    r(this, "_isRendering", !1);
    r(this, "_createId", 0);
    r(this, "_renderlooperrors", 0);
    r(this, "_lastTimestamp", 0);
    r(this, "_accumulatedTime", 0);
    r(this, "_dispatchReadyAfterFrame", !1);
    r(this, "_contextRestoreTries", 0);
    /** returns true if we should return out of the frame loop */
    r(this, "_wasPaused", !1);
    this.name = (t == null ? void 0 : t.name) || "", this.alias = t == null ? void 0 : t.alias, this.domElement = (t == null ? void 0 : t.domElement) || document.body, this.hash = t == null ? void 0 : t.hash, t != null && t.renderer && (this.renderer = t.renderer, this.isManagedExternally = !0), (t == null ? void 0 : t.runInBackground) !== void 0 && (this.runInBackground = t.runInBackground), t != null && t.scene ? this.scene = t.scene : this.scene = new Mi(), t != null && t.camera && (this._mainCamera = t.camera), this.application = new Wn(this), this.time = new FO(), this.input = new WC(this), this.physics = new cc(this), this.connection = new sP(this), this.assets = new vP(), this.sceneLighting = new jO(this), this.addressables = new _O(this), this.lightmaps = new PO(this), this.players = new kO(this), this.menu = new VO(this), this.lodsManager = new OO(this), this.animations = new xO(this);
    const e = () => this._sizeChanged = !0;
    window.addEventListener("resize", e), this._disposeCallbacks.push(() => window.removeEventListener("resize", e));
    const i = new ResizeObserver((n) => this._sizeChanged = !0);
    i.observe(this.domElement), this._disposeCallbacks.push(() => i.disconnect()), this._intersectionObserver = new IntersectionObserver((n) => {
      this._isVisible = n[0].isIntersecting;
    }), this._disposeCallbacks.push(() => {
      var n;
      return (n = this._intersectionObserver) == null ? void 0 : n.disconnect();
    }), fe.register(this);
  }
  /** When a new context is created this is the framerate that will be used by default */
  static get DefaultTargetFrameRate() {
    return ke._defaultTargetFramerate.value;
  }
  /** When a new context is created this is the framerate that will be used by default */
  static set DefaultTargetFrameRate(t) {
    ke._defaultTargetFramerate.value = t;
  }
  /** The default parameters that will be used when creating a new WebGLRenderer.  
   * Modify in global context to change the default parameters for all new contexts.
   * @example
   * ```typescript
   * import { Context } from "@needle-tools/engine";
   * Context.DefaultWebGLRendererParameters.antialias = false;
   * ```
   */
  static get DefaultWebGLRendererParameters() {
    return ke._defaultWebglRendererParameters;
  }
  /** The needle engine version */
  get version() {
    return $n;
  }
  /** The currently active context. Only set during the update loops */
  static get Current() {
    return fe.Current;
  }
  /** @internal this property should not be set by user code */
  static set Current(t) {
    fe.Current = t;
  }
  static get All() {
    return fe.All;
  }
  appendHTMLElement(t) {
    return this.domElement.shadowRoot ? this.domElement.shadowRoot.appendChild(t) : this.domElement.appendChild(t);
  }
  get resolutionScaleFactor() {
    return this._resolutionScaleFactor;
  }
  /** use to scale the resolution up or down of the renderer. default is 1 */
  set resolutionScaleFactor(t) {
    if (t !== this._resolutionScaleFactor && typeof t == "number") {
      if (t <= 0) {
        console.error("Invalid resolution scale factor", t);
        return;
      }
      this._resolutionScaleFactor = t, this.updateSize();
    }
  }
  /** update bounding rects + domX, domY */
  calculateBoundingClientRect() {
    if (this.xr) {
      this._domX = 0, this._domY = 0;
      return;
    }
    this._boundingClientRectFrame !== this.time.frame && (this._boundingClientRectFrame = this.time.frame, this._boundingClientRect = this.domElement.getBoundingClientRect(), this._domX = this._boundingClientRect.x, this._domY = this._boundingClientRect.y);
  }
  /** The width of the `<needle-engine>` element on the website */
  get domWidth() {
    return this.isInAR ? window.innerWidth : this.domElement.clientWidth;
  }
  /** The height of the `<needle-engine>` element on the website */
  get domHeight() {
    return this.isInAR ? window.innerHeight : this.domElement.clientHeight;
  }
  /** the X position of the Needle Engine element on the website */
  get domX() {
    return this.calculateBoundingClientRect(), this._domX;
  }
  /** the Y position of the Needlee Engine element on the website */
  get domY() {
    return this.calculateBoundingClientRect(), this._domY;
  }
  get isInXR() {
    var t, e;
    return ((e = (t = this.renderer) == null ? void 0 : t.xr) == null ? void 0 : e.isPresenting) || !1;
  }
  get xrSessionMode() {
    var t;
    return (t = this.xr) == null ? void 0 : t.mode;
  }
  get isInVR() {
    return this.xrSessionMode === "immersive-vr";
  }
  get isInAR() {
    return this.xrSessionMode === "immersive-ar";
  }
  /** If a XR session is active and in pass through mode (immersive-ar on e.g. Quest) */
  get isInPassThrough() {
    return this.xr ? this.xr.isPassThrough : !1;
  }
  /** access the raw `XRSession` object (shorthand for `context.renderer.xr.getSession()`). For more control use `NeedleXRSession.active` */
  get xrSession() {
    var t, e;
    return (e = (t = this.renderer) == null ? void 0 : t.xr) == null ? void 0 : e.getSession();
  }
  /** @returns the latest XRFrame (if a XRSession is currently active)
   * @link https://developer.mozilla.org/en-US/docs/Web/API/XRFrame
   */
  get xrFrame() {
    return this._xrFrame;
  }
  /** @returns the current WebXR camera while the WebXRManager is active (shorthand for `context.renderer.xr.getCamera()`) */
  get xrCamera() {
    var t, e;
    return this.renderer.xr.isPresenting ? (e = (t = this.renderer) == null ? void 0 : t.xr) == null ? void 0 : e.getCamera() : void 0;
  }
  get arOverlayElement() {
    const t = this.domElement;
    return typeof t.getAROverlayContainer == "function" ? t.getAROverlayContainer() : this.domElement;
  }
  /** Current event of the update cycle */
  get currentFrameEvent() {
    return this._currentFrameEvent;
  }
  /** The main camera of the scene - this camera is used for rendering */
  get mainCamera() {
    if (this._mainCamera)
      return this._mainCamera;
    if (this.mainCameraComponent) {
      const t = this.mainCameraComponent;
      return t.threeCamera || t.buildCamera(), t.threeCamera;
    }
    return this._fallbackCamera || (this._fallbackCamera = new ye(75, this.domWidth / this.domHeight, 0.1, 1e3)), this._fallbackCamera;
  }
  /** Set the main camera of the scene. If set to null the camera of the {@link mainCameraComponent} will be used - this camera is used for rendering */
  set mainCamera(t) {
    this._mainCamera = t;
  }
  /** @deprecated Use sceneLighting */
  get rendererData() {
    return this.sceneLighting;
  }
  get isCreated() {
    return this._isCreated;
  }
  /** calling this function will dispose the current renderer and create a new one */
  createNewRenderer(t) {
    var e, i, n;
    if ((e = this.renderer) == null || e.dispose(), t = { ...ke.DefaultWebGLRendererParameters, ...t }, !t.canvas) {
      const o = (n = (i = this.domElement) == null ? void 0 : i.shadowRoot) == null ? void 0 : n.querySelector("canvas");
      o && (t.canvas = o, st && console.log("Using canvas from shadow root", o));
    }
    st && console.log("Using Renderer Parameters:", t, this.domElement), this.renderer = new kr(t), this.renderer.debug.checkShaderErrors = z() || x("checkshadererrors") === !0, this.renderer.toneMappingExposure = 1, this.renderer.toneMapping = ja, this.renderer.setClearColor(new ae("lightgrey"), 0), this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = Wx, this.renderer.setSize(this.domWidth, this.domHeight), this.renderer.outputColorSpace = vn, this.renderer.nodes = {
      library: new Vx(),
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    }, this.lodsManager.setRenderer(this.renderer), this.input.bindEvents();
  }
  internalOnUpdateVisible() {
    var t, e;
    (t = this._intersectionObserver) == null || t.disconnect(), (e = this._intersectionObserver) == null || e.observe(this.domElement);
  }
  /** will request a renderer size update the next render call (will call updateSize the next update) */
  requestSizeUpdate() {
    this._sizeChanged = !0;
  }
  /** update the renderer and canvas size */
  updateSize(t = !1) {
    var e, i, n;
    if (t || !this.isManagedExternally && ((e = this.renderer.xr) == null ? void 0 : e.isPresenting) === !1) {
      this._sizeChanged = !1;
      const o = this.resolutionScaleFactor;
      let a = this.domWidth * o, l = this.domHeight * o;
      this.maxRenderResolution && (this.maxRenderResolution.x = Math.max(1, this.maxRenderResolution.x), a = Math.min(this.maxRenderResolution.x, a), this.maxRenderResolution.y = Math.max(1, this.maxRenderResolution.y), l = Math.min(this.maxRenderResolution.y, l));
      const c = this.mainCamera;
      this.updateAspect(c), this.renderer.setSize(a, l, !0), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", this.composer && ((i = this.composer.setSize) == null || i.call(this.composer, a, l), "setPixelRatio" in this.composer && typeof this.composer.setPixelRatio == "function" && ((n = this.composer.setPixelRatio) == null || n.call(this.composer, window.devicePixelRatio)));
    }
  }
  updateAspect(t, e, i) {
    if (!t)
      return;
    e === void 0 && (e = this.domWidth), i === void 0 && (i = this.domHeight);
    const n = e / i;
    if (t.isPerspectiveCamera) {
      const o = t, a = o.aspect;
      o.aspect = n, a !== o.aspect && t.updateProjectionMatrix();
    } else if (t.isOrthographicCamera) {
      const o = t, a = o.top - o.bottom, c = a * n / 2, h = a / 2;
      (o.left != -c || o.top != h) && (o.left = -c, o.right = c, o.top = h, o.bottom = -h, t.updateProjectionMatrix());
    }
  }
  /** This will recreate the whole needle engine context and dispose the whole scene content  
   * All content will be reloaded (loading times might be faster due to browser caches)   
   * All scripts will be recreated */
  recreate() {
    this.clear(), this.create(this._originalCreationArgs);
  }
  /** @deprecated use create. This method will be removed in a future version */
  async onCreate(t) {
    return this.create(t);
  }
  async create(t) {
    try {
      this._isCreating = !0, t !== this._originalCreationArgs && (this._originalCreationArgs = Ru(t)), window.addEventListener("unhandledrejection", this.onUnhandledRejection);
      const e = await this.internalOnCreate(t);
      return this._isCreated = e, e;
    } finally {
      window.removeEventListener("unhandledrejection", this.onUnhandledRejection), this._isCreating = !1;
    }
  }
  /** Dispatches an error */
  onError(t) {
    this.domElement.dispatchEvent(new CustomEvent("error", { detail: t }));
  }
  /** Will destroy all scenes and objects in the scene
   */
  clear() {
    var t, e, i, n;
    fe.dispatchCallback(pe.ContextClearing, this), Mn(this, pe.ContextClearing), nn(this.scene, !0, !0), this.scene = new Mi(), (t = this.addressables) == null || t.dispose(), (e = this.lightmaps) == null || e.clear(), (n = (i = this.physics) == null ? void 0 : i.engine) == null || n.clearCaches(), this.lodsManager.disable(), this.isManagedExternally || this.renderer && (this.renderer.renderLists.dispose(), this.renderer.state.reset(), this.renderer.resetState()), fe.dispatchCallback(pe.ContextCleared, this);
  }
  dispose() {
    this.internalOnDestroy();
  }
  /**@deprecated use dispose()  */
  onDestroy() {
    this.internalOnDestroy();
  }
  internalOnDestroy() {
    var t, e;
    ke.Current = this, fe.dispatchCallback(pe.ContextDestroying, this), Mn(this, pe.ContextDestroying), this.clear(), (t = this.renderer) == null || t.setAnimationLoop(null), this.renderer && (this.renderer.setClearAlpha(0), this.renderer.clear(), this.isManagedExternally || (st && console.log("Disposing renderer"), this.renderer.dispose())), this.scene = null, this.renderer = null, this.input.dispose(), this.menu.onDestroy(), this.animations.onDestroy();
    for (const i of this._disposeCallbacks)
      try {
        i();
      } catch (n) {
        console.error("Error in on dispose callback:", n, i);
      }
    (e = this.domElement) != null && e.parentElement && this.domElement.parentElement.removeChild(this.domElement), this._isCreated = !1, fe.dispatchCallback(pe.ContextDestroyed, this), Mn(this, pe.ContextDestroyed), fe.unregister(this), ke.Current === this && (ke.Current = null);
  }
  registerCoroutineUpdate(t, e, i) {
    return typeof (e == null ? void 0 : e.next) != "function" ? (console.error("Registered invalid coroutine function from " + t.name + `
Coroutine functions must be generators: "*myCoroutine() {...}"
Start a coroutine from a component by calling "this.startCoroutine(myCoroutine())"`), e) : (this.coroutines[i] || (this.coroutines[i] = []), this.coroutines[i].push({ comp: t, main: e }), e);
  }
  unregisterCoroutineUpdate(t, e) {
    if (!this.coroutines[e])
      return;
    const i = this.coroutines[e].findIndex((n) => n.main === t);
    i >= 0 && this.coroutines[e].splice(i, 1);
  }
  stopAllCoroutinesFrom(t) {
    for (const e in this.coroutines) {
      const i = this.coroutines[e];
      for (let n = i.length - 1; n >= 0; n--)
        i[n].comp === t && i.splice(n, 1);
    }
  }
  setCurrentCamera(t) {
    var n;
    if (!t)
      return;
    if (t.threeCamera || t.buildCamera(), !t.threeCamera) {
      console.warn("Camera component is missing camera", t);
      return;
    }
    const e = this._cameraStack.indexOf(t);
    e >= 0 && this._cameraStack.splice(e, 1), this._cameraStack.push(t), this.mainCameraComponent = t;
    const i = t.threeCamera;
    i.isPerspectiveCamera && this.updateAspect(i), (n = this.mainCameraComponent) == null || n.applyClearFlagsIfIsActiveCamera();
  }
  removeCamera(t) {
    if (!t)
      return;
    const e = this._cameraStack.indexOf(t);
    if (e >= 0 && this._cameraStack.splice(e, 1), this.mainCameraComponent === t && (this.mainCameraComponent = void 0, this._cameraStack.length > 0)) {
      const i = this._cameraStack[this._cameraStack.length - 1];
      this.setCurrentCamera(i);
    }
  }
  /** use this to subscribe to onBeforeRender events on threejs objects */
  addBeforeRenderListener(t, e) {
    this._onBeforeRenderListeners.has(t.uuid) || (this._onBeforeRenderListeners.set(t.uuid, []), t.onBeforeRender = this._createRenderCallbackWrapper(t, this._onBeforeRenderListeners)), this._onBeforeRenderListeners.get(t.uuid).push(e);
  }
  removeBeforeRenderListener(t, e) {
    if (this._onBeforeRenderListeners.has(t.uuid)) {
      const i = this._onBeforeRenderListeners.get(t.uuid), n = i.indexOf(e);
      n >= 0 && i.splice(n, 1);
    }
  }
  /** use this to subscribe to onAfterRender events on threejs objects */
  addAfterRenderListener(t, e) {
    var i;
    this._onAfterRenderListeners.has(t.uuid) || (this._onAfterRenderListeners.set(t.uuid, []), t.onAfterRender = this._createRenderCallbackWrapper(t, this._onAfterRenderListeners)), (i = this._onAfterRenderListeners.get(t.uuid)) == null || i.push(e);
  }
  removeAfterRenderListener(t, e) {
    if (this._onAfterRenderListeners.has(t.uuid)) {
      const i = this._onAfterRenderListeners.get(t.uuid), n = i.indexOf(e);
      n >= 0 && i.splice(n, 1);
    }
  }
  _createRenderCallbackWrapper(t, e) {
    return (i, n, o, a, l, c) => {
      const h = e.get(t.uuid);
      if (h)
        for (let d = 0; d < h.length; d++) {
          const u = h[d];
          u(i, n, o, a, l, c);
        }
    };
  }
  get isRendering() {
    return this._isRendering;
  }
  setRequireDepth(t) {
    this._requireDepthTexture = t;
  }
  setRequireColor(t) {
    this._requireColorTexture = t;
  }
  get depthTexture() {
    var t;
    return ((t = this._renderTarget) == null ? void 0 : t.depthTexture) || null;
  }
  get opaqueColorTexture() {
    var t;
    return ((t = this._renderTarget) == null ? void 0 : t.texture) || null;
  }
  /** returns true if the dom element is visible on screen */
  get isVisibleToUser() {
    if (this.isInXR)
      return !0;
    if (!this._isVisible)
      return !1;
    const t = getComputedStyle(this.domElement);
    return t.visibility !== "hidden" && t.display !== "none" && t.opacity !== "0";
  }
  async internalOnCreate(t) {
    var l, c, h, d, u, p, m, g;
    const e = ++this._createId;
    st && console.log("Creating context", this.name, t);
    const i = globalThis["needle:dependencies:ready"];
    i instanceof Promise && (st && console.log("Waiting for dependencies to be ready"), await i.catch((_) => {
      if (st || z()) {
        if (Iu("Needle Engine dependencies failed to load. Please check the console for more details"), _ instanceof ReferenceError) {
          let y = "YourComponentName";
          const b = _.message.indexOf("'");
          if (b > 0) {
            const w = _.message.indexOf("'", b + 1);
            if (w > 0) {
              const P = _.message.substring(b + 1, w);
              P.length > 3 && (y = P);
            }
          }
          console.error(`Needle Engine dependencies failed to load:

# Make sure you don't have circular imports in your scripts!

Possible solutions: 
→ Replace @serializable(${y}) in your script with @serializable(Behaviour)
→ If you only need type information try importing the type only, e.g: import { type ${y} }

---`, _);
          return;
        }
        console.error("Needle Engine dependencies failed to load", _);
      }
    }).then(() => {
      st && console.log("Needle Engine dependencies are ready");
    })), this.clear(), this.isManagedExternally === !1 && (this.createNewRenderer(), (l = this.renderer) == null || l.setAnimationLoop(null)), await Gn(1), ke.Current = this, await fe.dispatchCallback(pe.ContextCreationStart, this);
    let n = !0, o;
    try {
      ke.Current = this, t ? o = await this.internalLoadInitialContent(e, t) : o = [];
    } catch (_) {
      console.error(_), n = !1;
    }
    if (!n)
      return this.onError("Failed to load initial content"), !1;
    if (e !== this._createId || (c = t == null ? void 0 : t.abortSignal) != null && c.aborted)
      return !1;
    if (this.internalOnUpdateVisible(), !this.renderer)
      return st && console.warn("Context has no renderer (perhaps it was disconnected?", this.domElement.isConnected), !1;
    !this.isManagedExternally && !this.domElement.shadowRoot && this.domElement.prepend(this.renderer.domElement), ke.Current = this, ke.Current = this;
    for (let _ = 0; _ < this.new_scripts.length; _++) {
      const y = this.new_scripts[_];
      if (y.gameObject !== void 0 && y.gameObject !== null) {
        y.gameObject.userData === void 0 && (y.gameObject.userData = {}), y.gameObject.userData.components === void 0 && (y.gameObject.userData.components = []);
        const b = y.gameObject.userData.components;
        b.includes(y) || b.push(y);
      }
    }
    if (this.post_setup_callbacks)
      for (let _ = 0; _ < this.post_setup_callbacks.length; _++)
        ke.Current = this, await this.post_setup_callbacks[_](this);
    if (!this._mainCamera) {
      ke.Current = this;
      let _ = null;
      Va(this.scene, (y) => {
        const b = y;
        if (b != null && b.isCamera) {
          if (dc(b.gameObject), !b.activeAndEnabled)
            return;
          if (b.tag === "MainCamera")
            return _ = b, !0;
          _ = b;
        }
      }), _ ? this.setCurrentCamera(_) : !fe.dispatchCallback(pe.MissingCamera, this, { files: o }) && !this.mainCamera && !this.isManagedExternally && console.warn("Missing camera in main scene", this);
    }
    this.input.bindEvents(), ke.Current = this, Nd(this), this.physics.engine && ((h = this.physics.engine) == null || h.step(0), (d = this.physics.engine) == null || d.postStep()), !this.isManagedExternally && this.composer && this.mainCamera, this._sizeChanged = !0, this._stats && (this._stats.showPanel(0), this._stats.dom.style.position = "absolute", (u = this.domElement.shadowRoot) == null || u.appendChild(this._stats.dom)), st && rm(this.scene, !0), this.targetFrameRate === void 0 ? (st && console.warn("No target framerate set, using default", ke.DefaultTargetFrameRate), this.targetFrameRate = ke._defaultTargetFramerate) : st && console.log("Target framerate set to", this.targetFrameRate), this._dispatchReadyAfterFrame = !0;
    const a = fe.dispatchCallback(pe.ContextCreated, this, { files: o });
    return a && ("internalSetLoadingMessage" in this.domElement && typeof this.domElement.internalSetLoadingMessage == "function" && ((p = this.domElement) == null || p.internalSetLoadingMessage("finish loading")), await a), (m = t == null ? void 0 : t.abortSignal) != null && m.aborted ? !1 : (Mn(this, pe.ContextCreated), st && console.log("Context Created...", this.renderer, this.renderer.domElement), this._isCreating = !1, !this.isManagedExternally && !((g = t == null ? void 0 : t.abortSignal) != null && g.aborted) && this.restartRenderLoop(), !0);
  }
  async internalLoadInitialContent(t, e) {
    var c, h, d, u;
    const i = new Array();
    if (e.files.length === 0)
      return i;
    const n = [...e.files], o = {
      name: "",
      progress: null,
      index: 0,
      count: n.length
    }, a = Hn(), l = 0;
    for (let p = 0; p < n.length; p++) {
      if ((c = e.abortSignal) != null && c.aborted) {
        st && console.log("Aborting loading because of abort signal");
        break;
      }
      if (t !== this._createId) {
        st && console.log("Aborting loading because create id changed", t, this._createId);
        break;
      }
      const m = n[p];
      (h = e == null ? void 0 : e.onLoadingStart) == null || h.call(this, p, m), st && console.log("Context Load " + m);
      const g = await a.loadSync(this, m, m, l, (_) => {
        var y, b;
        (y = e.abortSignal) != null && y.aborted || (o.name = m, o.progress = _, o.index = p, o.count = n.length, (b = e.onLoadingProgress) == null || b.call(this, o));
      });
      (d = e == null ? void 0 : e.onLoadingFinished) == null || d.call(this, p, m, g ?? null), g ? i.push({
        src: m,
        file: g
      }) : console.warn("Could not load file: " + m);
    }
    if (t !== this._createId || (u = e.abortSignal) != null && u.aborted) {
      st && console.log("Aborting loading because create id changed or abort signal was set", t, this._createId);
      for (const p of i)
        if (p && p.file)
          for (const m of p.file.scenes)
            nn(m, !0, !0);
    } else {
      let p = !1;
      for (const m of i)
        m && m.file && (m.file.scene ? (p = !0, this.scene.add(m.file.scene)) : console.warn("No scene found in loaded file"));
      if (!p) {
        for (const m of i)
          if (m && m.file && "parser" in m.file) {
            let g = 0;
            if (!Array.isArray(m.file.parser.json.materials))
              continue;
            for (let _ = 0; _ < m.file.parser.json.materials.length; _++) {
              const y = await m.file.parser.getDependency("material", _), b = new L();
              b.position.x = _ * 1.1, b.position.y = g, this.scene.add(b), Ar.createPrimitive("ShaderBall", {
                parent: b,
                material: y
              });
            }
            g += 1;
          }
      }
    }
    return i;
  }
  /** Sets the animation loop.   
   * Can not be done while creating the context or when disposed 
   **/
  restartRenderLoop() {
    return this.renderer ? this._isCreating ? (console.warn("Can not start render loop while creating context"), !1) : (this.renderer.setAnimationLoop((t, e) => {
      this.isManagedExternally || this.update(t, e);
    }), !0) : (console.error("Can not start render loop without renderer"), !1);
  }
  /** Performs a full update step including script callbacks, rendering (unless isManagedExternally is set to false) and post render callbacks */
  update(t, e) {
    if (e === void 0 && (e = null), z() || st || OP())
      try {
        performance.mark("update.start"), this.internalStep(t, e), this._renderlooperrors = 0, performance.mark("update.end"), performance.measure("NE Frame", "update.start", "update.end");
      } catch (i) {
        this._renderlooperrors += 1, (z() || st) && (i instanceof Error || i instanceof TypeError) && We("Caught unhandled exception during render-loop - see console for details.", Zi.Error), console.error("Frame #" + this.time.frame + `
`, i), this._renderlooperrors >= 3 && (console.warn("Stopping render loop due to error"), this.renderer.setAnimationLoop(null)), this.domElement.dispatchEvent(new CustomEvent("error", { detail: i }));
      }
    else
      this.internalStep(t, e);
  }
  /** Call to **manually** perform physics steps.   
   * By default the context uses the `physicsSteps` property to perform steps during the update loop   
   * If you just want to increase the accuracy of physics you can instead set the `physicsSteps` property to a higher value
   * */
  updatePhysics(t) {
    this.internalUpdatePhysics(t);
  }
  // TODO: we need to skip after render callbacks if the render loop is managed externally. When changing this we also need to to update the r3f sample
  internalStep(t, e) {
    this.internalOnBeforeRender(t, e) !== !1 && (this.internalOnRender(), this.internalOnAfterRender());
  }
  internalOnBeforeRender(t, e) {
    var n;
    this.renderer.info.autoReset = !0;
    const i = e !== null && this._xrFrame === null;
    if (this._xrFrame = e, i && this.domElement.dispatchEvent(new CustomEvent("xr-session-started", { detail: { context: this, session: this.xrSession, frame: e } })), this._currentFrameEvent = -1, this.isManagedExternally === !1 && this.isInXR === !1 && this.targetFrameRate !== void 0) {
      this._lastTimestamp === 0 && (this._lastTimestamp = t), this._accumulatedTime += (t - this._lastTimestamp) / 1e3, this._lastTimestamp = t;
      let o = this.targetFrameRate;
      if (typeof o == "object" && (o = o.value), this._accumulatedTime < 1 / (o + 1))
        return !1;
      this._accumulatedTime = 0;
    }
    if ((n = this._stats) == null || n.begin(), ke.Current = this, this.onHandlePaused())
      return !1;
    for (ke.Current = this, this.time.update(), qO && console.log("FPS", this.time.smoothedFps.toFixed(0)), Nd(this), pd(this.scene), sv(this), Mn(
      this,
      -1
      /* Start */
    ); this._cameraStack.length > 0 && (!this.mainCameraComponent || this.mainCameraComponent.destroyed); ) {
      this._cameraStack.splice(this._cameraStack.length - 1, 1);
      const o = this._cameraStack[this._cameraStack.length - 1];
      this.setCurrentCamera(o);
    }
    if (this.pre_update_oneshot_callbacks) {
      for (const o in this.pre_update_oneshot_callbacks)
        this.pre_update_oneshot_callbacks[o]();
      this.pre_update_oneshot_callbacks.length = 0;
    }
    if (this.pre_update_callbacks)
      for (const o in this.pre_update_callbacks)
        this.pre_update_callbacks[o]();
    this._currentFrameEvent = 0;
    for (let o = 0; o < this.scripts_earlyUpdate.length; o++) {
      const a = this.scripts_earlyUpdate[o];
      a.activeAndEnabled && a.earlyUpdate !== void 0 && (ke.Current = this, a.earlyUpdate());
    }
    if (this.executeCoroutines(
      0
      /* EarlyUpdate */
    ), Mn(
      this,
      0
      /* EarlyUpdate */
    ), this.onHandlePaused())
      return !1;
    this._currentFrameEvent = 1;
    for (let o = 0; o < this.scripts_update.length; o++) {
      const a = this.scripts_update[o];
      a.activeAndEnabled && a.update !== void 0 && (ke.Current = this, a.update());
    }
    if (this.executeCoroutines(
      1
      /* Update */
    ), Mn(
      this,
      1
      /* Update */
    ), this.onHandlePaused())
      return !1;
    this._currentFrameEvent = 2;
    for (let o = 0; o < this.scripts_lateUpdate.length; o++) {
      const a = this.scripts_lateUpdate[o];
      a.activeAndEnabled && a.lateUpdate !== void 0 && (ke.Current = this, a.lateUpdate());
    }
    if (this.executeCoroutines(
      2
      /* LateUpdate */
    ), Mn(
      this,
      2
      /* LateUpdate */
    ), this.onHandlePaused() || (this.physicsSteps === void 0 && (this.physicsSteps = 1), this.physics.engine && this.physicsSteps > 0 && this.internalUpdatePhysics(this.physicsSteps), this.onHandlePaused()))
      return !1;
    if (this.isVisibleToUser || this.runInBackground) {
      this._currentFrameEvent = 3;
      for (let o = 0; o < this.scripts_onBeforeRender.length; o++) {
        const a = this.scripts_onBeforeRender[o];
        a.activeAndEnabled && a.onBeforeRender !== void 0 && (ke.Current = this, a.onBeforeRender(e));
      }
      if (this.executeCoroutines(
        3
        /* OnBeforeRender */
      ), Mn(
        this,
        3
        /* OnBeforeRender */
      ), this._sizeChanged && this.updateSize(), this.pre_render_callbacks)
        for (const o in this.pre_render_callbacks)
          this.pre_render_callbacks[o](e);
    }
    return !0;
  }
  internalUpdatePhysics(t) {
    if (!this.physics.engine)
      return !1;
    const e = t, i = this.time.deltaTime / e;
    for (let n = 0; n < e; n++)
      this._currentFrameEvent = 9, this.executeCoroutines(
        9
        /* PrePhysicsStep */
      ), this.physics.engine.step(i), this._currentFrameEvent = 10, this.executeCoroutines(
        10
        /* PostPhysicsStep */
      );
    return this.physics.engine.postStep(), !0;
  }
  internalOnRender() {
    this.isManagedExternally || (TP(this), this._currentFrameEvent = -1, J1.update(), this.renderNow(), this._currentFrameEvent = 4);
  }
  internalOnAfterRender() {
    if (this.isVisibleToUser || this.runInBackground) {
      for (let t = 0; t < this.scripts_onAfterRender.length; t++) {
        const e = this.scripts_onAfterRender[t];
        e.activeAndEnabled && e.onAfterRender !== void 0 && (ke.Current = this, e.onAfterRender());
      }
      if (this.executeCoroutines(
        4
        /* OnAfterRender */
      ), Mn(
        this,
        4
        /* OnAfterRender */
      ), this.post_render_callbacks)
        for (const t in this.post_render_callbacks)
          this.post_render_callbacks[t]();
    }
    this._currentFrameEvent = -1, this.connection.sendBufferedMessagesNow(), this._stats && (this._stats.end(), this.time.frameCount % 150 === 0 && console.log(this.renderer.info.render.calls + " DrawCalls", `
Render:`, { ...this.renderer.info.render }, `
Memory:`, { ...this.renderer.info.memory }, `
Target Framerate: ` + this.targetFrameRate)), this._dispatchReadyAfterFrame && (this._dispatchReadyAfterFrame = !1, this.domElement.dispatchEvent(new CustomEvent("ready")), fe.dispatchCallback(pe.ContextFirstFrameRendered, this));
  }
  renderNow(t) {
    var e;
    return !t && (t = this.mainCamera, !t) ? !1 : (this.handleRendererContextLost(), this._isRendering = !0, this.renderRequiredTextures(), this.renderer.toneMapping !== ja && Cv(), this.composer && !this.isInXR ? (t && "setMainCamera" in this.composer && ((e = this.composer.passes[0]) == null ? void 0 : e.mainCamera) != t && this.composer.setMainCamera(t), this.composer.render(this.time.deltaTime)) : t && (this.isInXR && X.isMacOS() && this.renderer.clearDepth(), this.renderer.render(this.scene, t)), this._isRendering = !1, !0);
  }
  handleRendererContextLost() {
    this.time.frame % 10 && this.renderer.getContext().isContextLost() && this._contextRestoreTries++ < 100 && (console.warn("Attempting to recover WebGL context..."), this.renderer.forceContextRestore());
  }
  onHandlePaused() {
    const t = this.evaluatePaused();
    if (this._wasPaused !== t) {
      GO && console.log("Paused?", t, "context:" + this.alias);
      for (let e = 0; e < this.scripts_pausedChanged.length; e++) {
        const i = this.scripts_pausedChanged[e];
        i.activeAndEnabled && i.onPausedChanged !== void 0 && (ke.Current = this, i.onPausedChanged(t, this._wasPaused));
      }
    }
    return this._wasPaused = t, t;
  }
  evaluatePaused() {
    return this.isInXR ? !1 : this.isPaused ? !0 : this.runInBackground ? !1 : !this.isVisibleToUser;
  }
  renderRequiredTextures() {
    if (!this.mainCamera || !this._requireDepthTexture && !this._requireColorTexture)
      return;
    if (!this._renderTarget) {
      if (this._renderTarget = new ks(this.domWidth, this.domHeight), this._requireDepthTexture) {
        const i = new Hx(this.domWidth, this.domHeight);
        this._renderTarget.depthTexture = i;
      }
      this._requireColorTexture && (this._renderTarget.texture = new Fe(), this._renderTarget.texture.generateMipmaps = !1, this._renderTarget.texture.minFilter = Id, this._renderTarget.texture.magFilter = Id, this._renderTarget.texture.format = Su);
    }
    const t = this._renderTarget;
    t.texture && (t.texture.colorSpace = this.renderer.outputColorSpace);
    const e = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(t), this.renderer.render(this.scene, this.mainCamera), this.renderer.setRenderTarget(e);
  }
  executeCoroutines(t) {
    var i;
    if (this.coroutines[t]) {
      const n = this.coroutines[t];
      for (let o = 0; o < n.length; o++)
        try {
          const a = n[o];
          if (!a.comp || a.comp.destroyed || !a.main || a.comp.enabled === !1) {
            XO && console.log("Removing coroutine", a.comp, a.comp.enabled), n.splice(o, 1), --o;
            continue;
          }
          const c = a.chained;
          if (c && c.length > 0) {
            const p = c[c.length - 1].next();
            if (p.done && c.pop(), e(p) && (a.chained || (a.chained = []), a.chained.push(p.value)), !p.done)
              continue;
          }
          const h = a.main.next();
          if (h.done === !0) {
            n.splice(o, 1), --o;
            continue;
          }
          const d = h.value;
          if (e(d)) {
            if (d.next().done)
              continue;
            a.chained || (a.chained = []), a.chained.push(d);
          } else if (d instanceof Promise) {
            const u = d;
            a.chained || (a.chained = []);
            const p = SO(u);
            (i = a.chained) == null || i.push(p);
            continue;
          }
        } catch (a) {
          console.error(a);
        }
    }
    function e(n) {
      return !!(n && n.next && n.return);
    }
  }
};
let ee = ke;
r(ee, "_defaultTargetFramerate", { value: 90, toString() {
  return this.value;
} }), r(ee, "_defaultWebglRendererParameters", {
  antialias: !0,
  alpha: !1,
  // Note: this is due to a bug on OSX devices. See NE-5370
  powerPreference: X.isiOS() || X.isMacOS() ? "default" : "high-performance",
  stencil: !0
  // logarithmicDepthBuffer: true,
  // reverseDepthBuffer: true, // https://github.com/mrdoob/three.js/issues/29770
});
const Qi = x("debuglicense"), Mv = [];
let ur = "basic";
Qi && console.log("License Type: " + ur);
function fr() {
  switch (ur) {
    case "pro":
    case "enterprise":
      return !0;
  }
  return !1;
}
function Rv() {
  switch (ur) {
    case "indie":
      return !0;
  }
  return !1;
}
function Vn() {
  return fr() || Rv();
}
function QO(s) {
  if (fr() || Rv())
    return s(!0);
  Mv.push(s);
}
function YO(s) {
  for (const t of Mv)
    try {
      t(s);
    } catch {
    }
}
fe.registerCallback(pe.ContextRegistered, (s) => {
  JO(s.context), tM(), ZO(s.context);
});
let mo, Mm = !1, Xl = "";
async function KO() {
  if (mo)
    return mo;
  if (ur === "basic")
    try {
      const s = "https://engine.needle.tools/licensing/check?location=" + encodeURIComponent(window.location.href) + "&version=" + $n + "&generator=" + encodeURIComponent(gg), t = await fetch(s, {
        method: "GET"
      }).catch((e) => {
        Qi && console.error("License check failed", e);
      });
      (t == null ? void 0 : t.status) === 200 ? (Mm = !1, Qi && console.log("License check succeeded"), ur = "pro", YO(!0)) : (t == null ? void 0 : t.status) === 403 ? (Mm = !0, Xl = await t.text()) : Qi && console.log("License check failed with status " + (t == null ? void 0 : t.status));
    } catch (s) {
      Qi && console.error("License check failed", s);
    }
  else
    Qi && console.log('Runtime license check is skipped because license is already applied as "' + ur + '"');
}
mo = KO();
async function ZO(s) {
  function t() {
    const n = document.createElement("div");
    n.className = "needle-forbidden", n.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: all;
        zIndex: 2147483647;
        line-height: 1.5;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        `;
    const o = n.style.cssText, a = document.createElement("div");
    n.appendChild(a), a.style.cssText = `
        position: absolute;
        left: 0;
        right: 0;
        top:0;
        bottom: 0;
        padding: 10%;
        color: white;
        font-size: 20px;
        font-family: sans-serif;
        text-align: center;
        pointer-events: all;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: rgba(0,0,0,.3);
        text-shadow: 0 0 2px black;
        `;
    const l = a.style.cssText, c = (Xl == null ? void 0 : Xl.length) > 1 ? Xl : "This web application has been paused.<br/>You might be in violation of the Needle Engine terms of use.<br/>Please contact the Needle support if you think this is a mistake.";
    return a.innerHTML = c, setInterval(() => {
      a.innerHTML !== c && (a.innerHTML = c), a.parentNode !== n && n.appendChild(a), n.style.cssText !== o && (n.style.cssText = o), a.style.cssText !== l && (a.style.cssText = l);
    }, 500), n;
  }
  let e = t();
  const i = e.style.cssText;
  setInterval(() => {
    var n;
    Mm === !0 && (e.style.cssText !== i && (e = t()), s.domElement.shadowRoot ? e.parentNode !== s.domElement.shadowRoot && ((n = s.domElement.shadowRoot) == null || n.appendChild(e)) : e.parentNode != document.body && document.body.appendChild(e));
  }, 500);
}
async function JO(s) {
  try {
    if (Vn() !== !0)
      return Qf(s);
  } catch (t) {
    return Qi && console.log("License check failed", t), Qf(s);
  }
  Qi && Qf(s);
}
async function Qf(s) {
  s.domElement.addEventListener("ready", () => !0), await (mo == null ? void 0 : mo.catch(() => {
  })), !Vn() && eM();
}
let Gy = 0;
async function eM(s) {
  var a;
  const t = Date.now();
  if (t - Gy < 2e3)
    return;
  Gy = t;
  const i = `
        position: relative;
        display: block;
        font-size: 18px;
        background-size: 20px;
        background-position: 10px 5px;
        background-repeat:no-repeat;
        background-image:url('data:image/webp;base64,UklGRrABAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSKEAAAARN6CmbSM4WR7vdARON11EBDq3fLiNbVtVzpMCPlKAEzsx0Y/x+Ovuv4dn0EFE/ydAvz6YggXzgh5sVgXM/zOC/4sii7qgGvB5N7hmuQYwkvazWAu1JPW41FXSHq6pnaQWvqYH18Fc0j1hO/BFTtIeSBlJi5w6qIIO7IOrwhFsB2Yxukif0FTRLpXswHR8MxbslKe9VZsn/Ub5C7YFOpqSTABWUDgg6AAAAFAGAJ0BKiAAIAA+7VyoTqmkpCI3+qgBMB2JbACdMt69DwMIQBLhkTO6XwY00UEDK6cNIDnuNibPf0EgAP7Y1myuiQHLDsF/0h5unrGh6WAbv7aegg2ZMd3uRKfT/3SJztcaujYfTvMXspfCTmYcoO6a+vhC3ss4M8uM58t4siiu59I4aOl59e9Sr6xoxYlHf2v+NnBNpJYeJf8jABQAId/PXuBkLEFkiCucgSGEcfhvajql/j3reCGl0M5/9gQWy7ayNPs+wlvIxFnNfSlfuND4CZOCyxOHhRqOmHN4ULHo3tCSrUNvgAA=');
        background-max-size: 40px;
        margin-bottom: 5px;
        margin-top: .3em;
        margin-bottom: .5em;
        padding: .2em;
        padding-left: 25px;
        border-radius: .5em;
        border: 2px solid rgba(160,160,160,.3);
    `, o = `Needle Engine — No license active, commercial use is not allowed. Visit https://needle.tools/pricing for more information and licensing options! v${$n}`;
  (a = ee.Current) != null && a.xr ? console.log(o) : console.log("%c " + o, i);
}
async function tM() {
  var s;
  if (!window.crossOriginIsolated)
    try {
      const t = "https://needle-engine-analytics-v2-r26roub2hq-lz.a.run.app";
      if (t) {
        Qi && console.log("Analytics backend url", t);
        const e = window.location.href.split("?")[0];
        let i = "api/v2/new/request";
        t.endsWith("/") || (i = "/" + i);
        const n = ur, o = `${t}${i}`;
        Qi && console.log("Sending non-commercial usage message to analytics backend", o);
        const a = {
          license: n,
          url: e,
          hostname: window.location.hostname,
          pathname: window.location.pathname,
          // search: window.location.search,
          // hash: window.location.hash,
          version: $n,
          generator: gg,
          build_time: U0,
          public_key: ud
        }, l = (s = navigator.sendBeacon) == null ? void 0 : s.call(navigator, o, JSON.stringify(a));
        Qi && console.log("Send beacon result", l);
      }
    } catch (t) {
      Qi && console.log("Failed to send non-commercial usage message to analytics backend", t);
    }
}
const Yo = x("debugloading"), Tl = x("debugloadingrendering"), qy = x("debuglicense");
class jD {
  constructor() {
    r(this, "className");
    r(this, "additionalClasses");
  }
}
let Al = 0, Xy;
function kv(s) {
  Yo && console.log(s.progress.loaded.toFixed(0) + "/" + s.progress.total.toFixed(0), s);
  const t = s.count, e = s.progress.total;
  e === 0 || e === void 0 ? (Xy !== s.name && (Al = 0), Xy = s.name, Al += (1 - Al) * 1e-3, Yo && ve("Loading " + s.name + " did not report total size")) : Al = s.progress.loaded / e;
  const i = s.index / t + Al / t;
  return $.clamp01(i);
}
const uu = class {
  /**
   * Creates a new loading view
   * @param owner the element that will contain the loading view (should be the NeedleEngineHTMLElement)
   */
  constructor(t, e) {
    // the raw progress
    r(this, "loadingProgress", 0);
    /** Usually the NeedleEngineHTMLElement */
    r(this, "_element");
    r(this, "_progress", 0);
    r(this, "_allowCustomLoadingElement", !0);
    r(this, "_loadingElement");
    r(this, "_loadingTextContainer", null);
    r(this, "_loadingBar", null);
    r(this, "_messageContainer", null);
    r(this, "_loadingElementOptions");
    r(this, "_progressLoop");
    this._element = t, this._loadingElementOptions = e;
  }
  async onLoadingBegin(t) {
    const e = this._element.shadowRoot || this._element;
    if (Yo && console.warn("Begin Loading"), !this._loadingElement) {
      for (let i = 0; i < e.children.length; i++) {
        const n = e.children[i];
        if (n.classList.contains(uu.LoadingContainerClassName)) {
          if (!this._allowCustomLoadingElement) {
            Yo && console.warn("Remove custom loading container"), e.removeChild(n);
            continue;
          }
          this._loadingElement = this.createLoadingElement(n);
        }
      }
      this._loadingElement || (this._loadingElement = this.createLoadingElement());
    }
    this._progress = 0, this.loadingProgress = 0, this._loadingElement.style.display = "flex", e.appendChild(this._loadingElement), this.smoothProgressLoop(), this.setMessage(t ?? "");
  }
  onLoadingUpdate(t, e) {
    var n;
    if (!((n = this._loadingElement) != null && n.parentNode))
      return;
    let i = 0;
    typeof t == "number" ? i = t : ("index" in t && (i = kv(t)), !e && "name" in t && this.setMessage("loading " + t.name)), this.loadingProgress = i, e && this.setMessage(e), this.updateDisplay();
  }
  onLoadingFinished() {
    Yo && console.warn("Finished Loading"), Tl || (this.loadingProgress = 1, this.onDoneLoading());
  }
  setMessage(t) {
    this._messageContainer && (this._messageContainer.innerText = t);
  }
  smoothProgressLoop() {
    if (this._progressLoop)
      return;
    let t = 1 / 12;
    Tl && (t = 1 / 500, typeof Tl == "number" && (t *= Tl)), this._progressLoop = setInterval(() => {
      this.loadingProgress >= 0.95 && !Tl && (t = 0.9), this._progress = $.lerp(this._progress, this.loadingProgress, t * this.loadingProgress), this.updateDisplay();
    }, t);
  }
  onDoneLoading() {
    this._loadingElement && (Yo && console.log("Hiding loading element"), this._loadingElement.style.display = "none", this._loadingElement.remove()), this._progressLoop && clearInterval(this._progressLoop), this._progressLoop = null;
  }
  updateDisplay() {
    const t = this._progress, e = (t * 100).toFixed(0) + "%";
    this._loadingBar && (this._loadingBar.style.width = t * 100 + "%"), this._loadingTextContainer && (this._loadingTextContainer.textContent = e);
  }
  createLoadingElement(t) {
    var m, g;
    Yo && !t && console.log("Creating loading element"), this._loadingElement = t || document.createElement("div");
    let e = this._element.getAttribute("loading-style");
    (!e || e === "auto") && (window.matchMedia("(prefers-color-scheme: dark)").matches ? e = "dark" : e = "light");
    const i = fr();
    if (!t && (this._loadingElement.style.position = "absolute", this._loadingElement.style.width = "100%", this._loadingElement.style.height = "100%", this._loadingElement.style.left = "0", this._loadingElement.style.top = "0", e === "light" ? this._loadingElement.style.backgroundColor = "#ddd" : this._loadingElement.style.backgroundColor = "#222", this._loadingElement.style.display = "flex", this._loadingElement.style.alignItems = "center", this._loadingElement.style.justifyContent = "center", this._loadingElement.style.zIndex = Number.MAX_SAFE_INTEGER.toString(), this._loadingElement.style.flexDirection = "column", this._loadingElement.style.pointerEvents = "none", this._loadingElement.style.color = "white", this._loadingElement.style.fontFamily = 'system-ui, Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', this._loadingElement.style.fontSize = "1rem", e === "light" ? this._loadingElement.style.color = "rgba(0,0,0,.6)" : this._loadingElement.style.color = "rgba(255,255,255,.3)", i && this._element)) {
      const _ = this._element.getAttribute("loading-background-color");
      _ && (this._loadingElement.style.backgroundColor = _);
      const y = this._element.getAttribute("loading-text-color");
      y && (this._loadingElement.style.color = y);
    }
    const n = ((m = this._loadingElementOptions) == null ? void 0 : m.className) ?? uu.LoadingContainerClassName;
    if (this._loadingElement.classList.add(n), (g = this._loadingElementOptions) != null && g.additionalClasses)
      for (const _ of this._loadingElementOptions.additionalClasses)
        this._loadingElement.classList.add(_);
    const o = document.createElement("div");
    this._loadingElement.appendChild(o);
    const a = document.createElement("img"), l = 120;
    if (a.style.width = `${l}px`, a.style.height = `${l}px`, a.style.paddingTop = "20px", a.style.paddingBottom = "10px", a.style.margin = "0px", a.style.userSelect = "none", a.style.objectFit = "contain", a.style.transition = "transform 1.5s ease-out, opacity .3s ease-in-out", a.style.transform = "translateY(30px)", a.style.opacity = "0.05", setTimeout(() => {
      a.style.opacity = "1", a.style.transform = "translateY(0px)";
    }, 1), a.src = IC, i && this._element) {
      const _ = this._element.getAttribute("loading-logo-src");
      _ && (a.src = _);
    }
    o.appendChild(a);
    const c = document.createElement("div");
    c.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        opacity: 0;
        transition: opacity 1s ease-in-out 4s;
        `, setTimeout(() => {
      c.style.opacity = "1";
    }, 1), this._loadingElement.appendChild(c);
    const h = document.createElement("div"), d = 100;
    h.style.display = "flex", h.style.width = d + "%", h.style.height = "3px", h.style.position = "absolute", h.style.left = "0", h.style.bottom = "0px", h.style.opacity = "0", h.style.transition = "opacity 1s ease-in-out 2s", setTimeout(() => {
      h.style.opacity = "1";
    }, 1), e === "light" ? h.style.backgroundColor = "rgba(0,0,0,.2)" : h.style.backgroundColor = "rgba(255,255,255,.2)", this._loadingElement.appendChild(h), this._loadingBar = document.createElement("div"), h.appendChild(this._loadingBar);
    const u = function(_) {
      return $.lerp(0, d, _) + "%";
    };
    if (this._loadingBar.style.background = `linear-gradient(90deg, #204f49 ${u(0)}, #0BA398 ${u(0.3)}, #66A22F ${u(0.6)}, #D7DB0A ${u(1)})`, this._loadingBar.style.backgroundAttachment = "fixed", this._loadingBar.style.width = "0%", this._loadingBar.style.height = "100%", i && this._element) {
      const _ = this._element.getAttribute("primary-color"), y = this._element.getAttribute("secondary-color");
      _ && y ? this._loadingBar.style.background = `linear-gradient(90deg, ${_} ${u(0)}, ${y} ${u(1)})` : _ ? this._loadingBar.style.background = _ : y && (this._loadingBar.style.background = y);
    }
    this._loadingTextContainer = document.createElement("div"), this._loadingTextContainer.style.display = "flex", this._loadingTextContainer.style.justifyContent = "center", this._loadingTextContainer.style.marginTop = ".2rem", c.appendChild(this._loadingTextContainer);
    const p = document.createElement("div");
    if (this._messageContainer = p, p.style.display = "flex", p.style.fontSize = ".8rem", p.style.paddingTop = ".1rem", p.style.justifyContent = "center", c.appendChild(p), i && this._element) {
      const _ = this._element.getAttribute("loading-text-color");
      _ && (p.style.color = _);
    }
    return this.handleRuntimeLicense(this._loadingElement), this._loadingElement;
  }
  async handleRuntimeLicense(t) {
    let e = Vn();
    if (e)
      return;
    qy && console.log("Loading UI has commercial license?", e);
    const i = document.createElement("div");
    i.style.paddingTop = ".6em", i.style.fontSize = ".8em", i.style.textTransform = "uppercase", i.innerText = `NEEDLE ENGINE NON COMMERCIAL VERSION
CLICK HERE TO GET A LICENSE`, i.style.cursor = "pointer", i.style.userSelect = "none", i.style.textAlign = "center", i.style.pointerEvents = "all", i.addEventListener("click", () => window.open("https://needle.tools/pricing", "_self")), i.style.opacity = "0", t.appendChild(i), !z() && mo && (qy && console.log("Waiting for runtime license check"), await mo, e = Vn()), !e && (i.style.transition = "opacity .5s ease-in-out", i.style.opacity = "1");
  }
};
let xd = uu;
r(xd, "LoadingContainerClassName", "loading");
const El = x("debugoverlay"), Tv = "ar", iM = "quit-ar";
class nM {
  constructor() {
    r(this, "arContainer", null);
    r(this, "currentSession", null);
    r(this, "_createdAROnlyElements", []);
    r(this, "_reparentedObjects", []);
    r(this, "contentElement", null);
    r(this, "originalDomOverlayParent", null);
    r(this, "requestEndAR", () => {
      this.onRequestedEndAR();
    });
  }
  get ARContainer() {
    return this.arContainer;
  }
  onBegin(t, e, i) {
    var n;
    if (this.currentSession = i, this.arContainer = e, X.isMozillaXR()) {
      const o = t.domElement.children;
      for (let a = 0; a < (o == null ? void 0 : o.length); a++) {
        const l = o[a];
        if (!l || l === this.arContainer)
          return;
        this._reparentedObjects.push({ el: l, previousParent: l.parentElement }), (n = this.arContainer) == null || n.appendChild(l);
      }
      e ? (this.originalDomOverlayParent = e.parentNode, this.originalDomOverlayParent && (console.log("Reparent DOM Overlay to body", e, e.style.display), e.style.display = "", e.style.visibility = "", document.body.appendChild(e))) : console.warn("WebXRViewer: No DOM Overlay found");
    }
    this.ensureQuitARButton(this.arContainer);
  }
  onEnd(t) {
    var e;
    for (const i of this._createdAROnlyElements)
      i.remove && i.remove();
    for (const i of this._reparentedObjects) {
      const n = i.el;
      (e = i.previousParent) == null || e.appendChild(n);
    }
    this._reparentedObjects.length = 0, X.isMozillaXR() && setTimeout(() => {
      var a;
      const i = t.renderer.domElement;
      i && ((a = t.domElement.shadowRoot) == null || a.prepend(i));
      const n = document.querySelectorAll("*");
      for (var o = 0; o < n.length; o++) {
        const l = n[o];
        l && l._displayChanged !== void 0 && l._displayWas !== void 0 && (l.style.display = l._displayWas);
      }
    }, 10);
  }
  createOverlayContainer(t) {
    if (this.contentElement)
      return this.contentElement;
    El && console.log("Setup overlay container");
    const e = t.shadowRoot.querySelector(".content");
    this.contentElement = e;
    const i = t.shadowRoot.querySelector(".overlay-content");
    return i && e.appendChild(i), El && !X.isMobileDevice() && this.ensureQuitARButton(e), e;
  }
  onRequestedEndAR() {
    this.currentSession && (this.currentSession.end(), this.currentSession = null);
  }
  ensureQuitARButton(t) {
    const e = document.createElement("slot");
    e.setAttribute("name", "quit-ar"), this.appendElement(e, t), this._createdAROnlyElements.push(e), e.style.pointerEvents = "auto";
    const i = document.querySelector(`.${iM}`);
    if (i) {
      i.addEventListener("click", this.requestEndAR), El && i.addEventListener("click", () => console.log("Clicked quit-ar button"));
      return;
    }
    e.addEventListener("click", this.requestEndAR), El && e.addEventListener("click", () => console.log("Clicked fallback close button"));
    const n = document.createElement("div");
    n.style.cssText = `
            position: fixed;
            top: 0;
            right: 0;
            z-index: 600;
            pointer-events: all;
        `, this.appendElement(n, e);
    var o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o.classList.add("quit-ar-button"), o.setAttribute("width", "40px"), o.setAttribute("height", "40px"), o.style.cssText = `
            background: rgba(255, 255, 255, .4);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,.3);
            outline: 1px solid rgba(255, 255, 255, .6);
            display: flex;
            justify-content: center;
            align-items: center;
        `, n.appendChild(o);
    var a = document.createElementNS("http://www.w3.org/2000/svg", "path");
    a.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), a.setAttribute("stroke", "#000000"), a.setAttribute("stroke-width", "2px"), a.style.cssText = `
            /**filter: drop-shadow(0 0px 1.2px rgba(0,0,0,.7));**/
        `, o.appendChild(a), El && console.log("Created fallback close button", o, t);
  }
  appendElement(t, e) {
    return e.shadowRoot ? e.shadowRoot.appendChild(t) : e.appendChild(t);
  }
}
const sM = x("debugdecoders");
let Yf = null;
function Av() {
  if (!Yf) {
    const s = hg(null);
    Yf = { dracoLoader: s.dracoLoader, ktx2Loader: s.ktx2Loader, meshoptDecoder: s.meshoptDecoder };
  }
  return Yf;
}
function Qy(s) {
  s !== void 0 && typeof s == "string" && q1(s);
}
function Yy(s) {
  if (s !== void 0 && typeof s == "string" && s !== "js") {
    const t = Av();
    sM && console.log("Setting draco decoder type to", s), t.dracoLoader.setDecoderConfig({ type: s });
  }
}
function Ky(s) {
  s !== void 0 && typeof s == "string" && X1(s);
}
function Nu(s, t) {
  const e = Av();
  return t.renderer ? e.ktx2Loader.detectSupport(t.renderer) : console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures will probably fail"), H1(s), s.dracoLoader || s.setDRACOLoader(e.dracoLoader), s.ktx2Loader || s.setKTX2Loader(e.ktx2Loader), s.meshoptDecoder || s.setMeshoptDecoder(e.meshoptDecoder), G1(s, {
    progressive: !0
  }), s;
}
const Ka = function(s) {
  return f(s);
}, f = function(s) {
  if (s === void 0 && (s = null), !Array.isArray(s))
    s = Zy(s);
  else
    for (let t = 0; t < s.length; t++) {
      const e = s[t];
      s[t] = Zy(e);
    }
  return function(t, e) {
    if (!t) {
      console.error("Found @serializable decorator without a target");
      return;
    }
    typeof e != "string" && (e = e.name), Object.getOwnPropertyDescriptor(t, "$serializedTypes") || (t.$serializedTypes = {});
    const i = t.$serializedTypes = t.$serializedTypes || {};
    i[e] = s;
  };
};
function Zy(s) {
  var t, e;
  switch ((e = (t = s == null ? void 0 : s.prototype) == null ? void 0 : t.constructor) == null ? void 0 : e.name) {
    case "Number":
    case "String":
    case "Boolean":
      return null;
  }
  return s;
}
class S extends L {
  constructor() {
    super(...arguments);
    /**
     * Unique identifier for this GameObject
     */
    r(this, "guid");
  }
  /**
   * Checks if a GameObject has been destroyed
   * @param go The GameObject to check
   * @returns True if the GameObject has been destroyed
   */
  static isDestroyed(e) {
    return Wa(e);
  }
  /**
   * Sets the active state of a GameObject
   * @param go The GameObject to modify
   * @param active Whether the GameObject should be active
   * @param processStart Whether to process the start callbacks if being activated
   */
  static setActive(e, i, n = !0) {
    e && (bd(e, i), pd(e), i && n && sv(ee.Current, e));
  }
  /**
   * Checks if the GameObject itself is active (same as go.visible)
   * @param go The GameObject to check
   * @returns True if the GameObject is active
   */
  static isActiveSelf(e) {
    return Yc(e);
  }
  /**
   * Checks if the GameObject is active in the hierarchy (e.g. if any parent is invisible or not in the scene it will be false)
   * @param go The GameObject to check
   * @returns True if the GameObject is active in the hierarchy
   */
  static isActiveInHierarchy(e) {
    return uO(e);
  }
  /**
   * Marks a GameObject to be rendered using instancing
   * @param go The GameObject to mark
   * @param instanced Whether the GameObject should use instanced rendering
   */
  static markAsInstancedRendered(e, i) {
    fO(e, i);
  }
  /**
   * Checks if a GameObject is using instanced rendering
   * @param instance The GameObject to check
   * @returns True if the GameObject is using instanced rendering
   */
  static isUsingInstancing(e) {
    return kg(e);
  }
  /**
   * Executes a callback for all components of the provided type on the provided object and its children
   * @param instance Object to run the method on
   * @param cb Callback to run on each component, "return undefined;" to continue and "return <anything>;" to break the loop
   * @param recursive If true, the method will be run on all children as well
   * @returns The last return value of the callback
   */
  static foreachComponent(e, i, n = !0) {
    return Va(e, i, n);
  }
  /**
   * Creates a new instance of the provided object that will be replicated to all connected clients
   * @param instance Object to instantiate
   * @param opts Options for the instantiation
   * @returns The newly created instance or null if creation failed
   */
  static instantiateSynced(e, i) {
    return e ? lv(e, i) : null;
  }
  static instantiate(e, i = null) {
    return "isAssetReference" in e, Ha(e, i);
  }
  /**
   * Destroys an object on all connected clients (if in a networked session)
   * @param instance Object to destroy
   * @param context Optional context to use
   * @param recursive If true, all children will be destroyed as well
   */
  static destroySynced(e, i, n = !0) {
    if (!e)
      return;
    const o = e;
    i = i ?? ee.Current, ju(o, i.connection, n);
  }
  /**
   * Destroys an object
   * @param instance Object to destroy
   * @param recursive If true, all children will be destroyed as well. Default: true
   */
  static destroy(e, i = !0) {
    return nn(e, i);
  }
  /**
   * Adds an object to parent and ensures all components are properly registered
   * @param instance Object to add
   * @param parent Parent to add the object to
   * @param context Optional context to use
   */
  static add(e, i, n) {
    if (!(!e || !i)) {
      if (e === i) {
        console.warn("Can not add object to self", e);
        return;
      }
      n || (n = ee.Current), i.add(e), bd(e, !0), pd(e), n ? S.foreachComponent(e, (o) => {
        Cg(o, n), !o.__internalDidAwakeAndStart && n.new_script_start.includes(o) === !1 && n.new_script_start.push(o);
      }, !0) : console.warn("Missing context");
    }
  }
  /**
   * Removes the object from its parent and deactivates all of its components
   * @param instance Object to remove
   */
  static remove(e) {
    var i;
    e && ((i = e.parent) == null || i.remove(e), bd(e, !1), pd(e), S.foreachComponent(e, (n) => {
      MP(n);
    }, !0));
  }
  /**
   * Invokes a method on all components including children (if a method with that name exists)
   * @param go GameObject to invoke the method on
   * @param functionName Name of the method to invoke
   * @param args Arguments to pass to the method
   */
  static invokeOnChildren(e, i, ...n) {
    this.invoke(e, i, !0, n);
  }
  /**
   * Invokes a method on all components that have a method matching the provided name
   * @param go GameObject to invoke the method on
   * @param functionName Name of the method to invoke
   * @param children Whether to invoke on children as well
   * @param args Arguments to pass to the method
   */
  static invoke(e, i, n = !1, ...o) {
    e && this.foreachComponent(e, (a) => {
      const l = a[i];
      l && typeof l == "function" && (l == null || l.call(a, ...o));
    }, n);
  }
  /** @deprecated use `addComponent` */
  // eslint-disable-next-line deprecation/deprecation
  static addNewComponent(e, i, n, o = !0) {
    return en(e, i, n, { callAwake: o });
  }
  /**
   * Adds a new component (or moves an existing component) to the provided object
   * @param go Object to add the component to
   * @param instanceOrType If an instance is provided it will be moved to the new object, if a type is provided a new instance will be created
   * @param init Optional init object to initialize the component with
   * @param opts Optional options for adding the component
   * @returns The added or moved component
   */
  static addComponent(e, i, n, o) {
    return en(e, i, n, o);
  }
  /**
   * Moves a component to a new object
   * @param go GameObject to move the component to
   * @param instance Component to move
   * @returns The moved component
   */
  static moveComponent(e, i) {
    return en(e, i);
  }
  /**
   * Removes a component from its object
   * @param instance Component to remove
   * @returns The removed component
   */
  static removeComponent(e) {
    return gv(e.gameObject, e), e;
  }
  /**
   * Gets or adds a component of the specified type
   * @param go GameObject to get or add the component to
   * @param typeName Constructor of the component type
   * @returns The existing or newly added component
   */
  static getOrAddComponent(e, i) {
    return Bu(e, i);
  }
  /**
   * Gets a component on the provided object
   * @param go GameObject to get the component from
   * @param typeName Constructor of the component type
   * @returns The component if found, otherwise null
   */
  static getComponent(e, i) {
    return e === null ? null : Ya(e, i);
  }
  /**
   * Gets all components of the specified type on the provided object
   * @param go GameObject to get the components from
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponents(e, i, n = null) {
    return e === null ? n ?? [] : Fu(e, i, n);
  }
  /**
   * Finds an object or component by its unique identifier
   * @param guid Unique identifier to search for
   * @param hierarchy Root object to search in
   * @returns The found GameObject or Component, or null/undefined if not found
   */
  static findByGuid(e, i) {
    return bv(e, i);
  }
  /**
   * Finds the first object of the specified component type in the scene
   * @param typeName Constructor of the component type
   * @param context Context or root object to search in
   * @param includeInactive Whether to include inactive objects in the search
   * @returns The first matching component if found, otherwise null
   */
  static findObjectOfType(e, i, n = !0) {
    return Uu(e, i ?? ee.Current, n);
  }
  /**
   * Finds all objects of the specified component type in the scene
   * @param typeName Constructor of the component type
   * @param context Context or root object to search in
   * @returns Array of matching components
   */
  static findObjectsOfType(e, i) {
    const n = [];
    return dO(e, n, i), n;
  }
  /**
   * Gets a component of the specified type in the gameObject's children hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @returns The first matching component if found, otherwise null
   */
  static getComponentInChildren(e, i) {
    return zu(e, i);
  }
  /**
   * Gets all components of the specified type in the gameObject's children hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponentsInChildren(e, i, n = null) {
    return Qc(e, i, n ?? void 0);
  }
  /**
   * Gets a component of the specified type in the gameObject's parent hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @returns The first matching component if found, otherwise null
   */
  static getComponentInParent(e, i) {
    return Vd(e, i);
  }
  /**
   * Gets all components of the specified type in the gameObject's parent hierarchy
   * @param go GameObject to search in
   * @param typeName Constructor of the component type
   * @param arr Optional array to populate with the components
   * @returns Array of components
   */
  static getComponentsInParent(e, i, n = null) {
    return Mg(e, i, n);
  }
  /**
   * Gets all components on the gameObject
   * @param go GameObject to get components from
   * @returns Array of all components
   */
  static getAllComponents(e) {
    var o;
    const i = (o = e.userData) == null ? void 0 : o.components;
    return i ? [...i] : [];
  }
  /**
   * Iterates through all components on the gameObject
   * @param go GameObject to iterate components on
   * @returns Generator yielding each component
   */
  static *iterateComponents(e) {
    var n;
    const i = (n = e == null ? void 0 : e.userData) == null ? void 0 : n.components;
    if (i && Array.isArray(i))
      for (let o = 0; o < i.length; o++)
        yield i[o];
  }
}
const Oc = class {
  /** @internal */
  constructor(t) {
    r(this, "__context");
    r(this, "__name");
    /**
     * Reference to the GameObject this component is attached to
     * This is a three.js Object3D with additional GameObject functionality
     */
    r(this, "gameObject");
    /**
     * Unique identifier for this component instance,
     * used for finding and tracking components
     */
    r(this, "guid", "invalid");
    /**
     * Identifier for the source asset that created this component.
     * For example, URL to the glTF file this component was loaded from
     */
    r(this, "sourceId");
    /** @internal */
    r(this, "__didAwake", !1);
    /** @internal */
    r(this, "__didStart", !1);
    /** @internal */
    r(this, "__didEnable", !1);
    /** @internal */
    r(this, "__isEnabled");
    /** @internal */
    r(this, "__destroyed", !1);
    // EventTarget implementation:
    /** 
     * Storage for event listeners registered to this component
     * @private
     */
    r(this, "_eventListeners", /* @__PURE__ */ new Map());
    this.__didAwake = !1, this.__didStart = !1, this.__didEnable = !1, this.__isEnabled = void 0, this.__destroyed = !1, this._internalInit(t);
  }
  /** 
   * Indicates whether this object is a component
   * @internal 
   */
  get isComponent() {
    return !0;
  }
  /**
   * The context this component belongs to, providing access to the runtime environment
   * including physics, timing utilities, camera, and scene
   */
  get context() {
    return this.__context ?? ee.Current;
  }
  set context(t) {
    this.__context = t;
  }
  /**
   * Shorthand accessor for the current scene from the context
   * @returns The scene this component belongs to
   */
  get scene() {
    return this.context.scene;
  }
  /**
   * The layer value of the GameObject this component is attached to
   * Used for visibility and physics filtering
   */
  get layer() {
    var t, e;
    return (e = (t = this.gameObject) == null ? void 0 : t.userData) == null ? void 0 : e.layer;
  }
  /**
   * The name of the GameObject this component is attached to
   * Used for debugging and finding objects
   */
  get name() {
    var t, e;
    return (t = this.gameObject) != null && t.name ? this.gameObject.name : (e = this.gameObject) == null ? void 0 : e.userData.name;
  }
  set name(t) {
    this.gameObject ? (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.name = t, this.__name = t) : this.__name = t;
  }
  /**
   * The tag of the GameObject this component is attached to
   * Used for categorizing objects and efficient lookup
   */
  get tag() {
    var t;
    return (t = this.gameObject) == null ? void 0 : t.userData.tag;
  }
  set tag(t) {
    this.gameObject && (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.tag = t);
  }
  /**
   * Indicates whether the GameObject is marked as static
   * Static objects typically don't move and can be optimized by the engine
   */
  get static() {
    var t;
    return (t = this.gameObject) == null ? void 0 : t.userData.static;
  }
  set static(t) {
    this.gameObject && (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.static = t);
  }
  // get hideFlags(): HideFlags {
  //     return this.gameObject?.hideFlags;
  // }
  /**
   * Checks if this component is currently active (enabled and part of an active GameObject hierarchy)
   * Components that are inactive won't receive lifecycle method calls
   * @returns True if the component is enabled and all parent GameObjects are active
   */
  get activeAndEnabled() {
    return !(this.destroyed || this.__isEnabled === !1 || !this.__isActiveInHierarchy);
  }
  get __isActive() {
    return this.gameObject.visible;
  }
  get __isActiveInHierarchy() {
    if (!this.gameObject)
      return !1;
    const t = this.gameObject[po];
    return t === void 0 ? !0 : t;
  }
  set __isActiveInHierarchy(t) {
    this.gameObject && (this.gameObject[po] = t);
  }
  /**
   * Called once when the component becomes active for the first time.
   * This is the first lifecycle callback to be invoked
   */
  awake() {
  }
  /**
   * Called every time the component becomes enabled or active in the hierarchy.
   * Invoked after {@link awake} and before {@link start}.
   */
  onEnable() {
  }
  /**
   * Called every time the component becomes disabled or inactive in the hierarchy.
   * Invoked when the component or any parent GameObject becomes invisible
   */
  onDisable() {
  }
  /**
   * Called when the component is destroyed.
   * Use for cleanup operations like removing event listeners
   */
  onDestroy() {
    this.__destroyed = !0;
  }
  /**
   * Starts a coroutine that can yield to wait for events.
   * Coroutines allow for time-based sequencing of operations without blocking.
   * Coroutines are based on generator functions, a JavaScript language feature. 
   * 
   * @param routine Generator function to start
   * @param evt Event to register the coroutine for (default: FrameEvent.Update)
   * @returns The generator function that can be used to stop the coroutine
   * @example
   * Time-based sequencing of operations
   * ```ts
   * *myCoroutine() {
   *   yield WaitForSeconds(1); // wait for 1 second
   *   yield WaitForFrames(10); // wait for 10 frames
   *   yield new Promise(resolve => setTimeout(resolve, 1000)); // wait for a promise to resolve
   * }
   * ```
   * @example
   * Coroutine that logs a message every 5 frames
   * ```ts
   * onEnable() {
   *   this.startCoroutine(this.myCoroutine());
   * }
   * private *myCoroutine() {
   *   while(this.activeAndEnabled) {
   *     console.log("Hello World", this.context.time.frame);
   *     // wait for 5 frames
   *     for(let i = 0; i < 5; i++) yield;
   *   }
   * }
   * ```
   */
  startCoroutine(t, e = Re.Update) {
    return this.context.registerCoroutineUpdate(this, t, e);
  }
  /**
   * Stops a coroutine that was previously started with startCoroutine
   * @param routine The routine to be stopped
   * @param evt The frame event the routine was registered with
   */
  stopCoroutine(t, e = Re.Update) {
    this.context.unregisterCoroutineUpdate(t, e);
  }
  /**
   * Checks if this component has been destroyed
   * @returns True if the component or its GameObject has been destroyed
   */
  get destroyed() {
    return this.__destroyed;
  }
  /**
   * Destroys this component and removes it from its GameObject
   * After destruction, the component will no longer receive lifecycle callbacks
   */
  destroy() {
    this.__destroyed || this.__internalDestroy();
  }
  /** @internal */
  get __internalDidAwakeAndStart() {
    return this.__didAwake && this.__didStart;
  }
  /** @internal */
  __internalNewInstanceCreated(t) {
    return this.__didAwake = !1, this.__didStart = !1, this.__didEnable = !1, this.__isEnabled = void 0, this.__destroyed = !1, this._internalInit(t), this;
  }
  /**
   * Initializes component properties from an initialization object
   * @param init Object with properties to copy to this component
   * @internal
   */
  _internalInit(t) {
    if (typeof t == "object")
      for (const e of Object.keys(t)) {
        const i = t[e];
        typeof i != "function" && (this[e] = i);
      }
  }
  /** @internal */
  __internalAwake() {
    this.__didAwake || (this.__didAwake = !0, this.awake());
  }
  /** @internal */
  __internalStart() {
    this.__didStart || (this.__didStart = !0, this.start && this.start());
  }
  /** @internal */
  __internalEnable(t) {
    return this.__destroyed ? (z() && console.warn("[Needle Engine Dev] Trying to enable destroyed component"), !1) : this.__didAwake ? this.__didEnable ? (t !== !0 && (this.__isEnabled = !0), !1) : (this.__didEnable = !0, this.__isEnabled = !0, this.onEnable(), !0) : !1;
  }
  /** @internal */
  __internalDisable(t) {
    if (this.__didAwake) {
      if (!this.__didEnable) {
        t !== !0 && (this.__isEnabled = !1);
        return;
      }
      this.__didEnable = !1, this.__isEnabled = !1, this.onDisable();
    }
  }
  /** @internal */
  __internalDestroy() {
    var t;
    this.__destroyed || (this.__destroyed = !0, this.__didAwake && ((t = this.onDestroy) == null || t.call(this), this.dispatchEvent(new CustomEvent("destroyed", { detail: this }))), hO(this));
  }
  /**
   * Controls whether this component is enabled
   * Disabled components don't receive lifecycle callbacks
   */
  get enabled() {
    return typeof this.__isEnabled == "boolean" ? this.__isEnabled : !0;
  }
  set enabled(t) {
    if (this.__destroyed) {
      z() && console.warn(`[Needle Engine Dev] Trying to ${t ? "enable" : "disable"} destroyed component`);
      return;
    }
    if (typeof t == "number" && (t >= 0.5 ? t = !0 : t = !1), !this.__didAwake) {
      this.__isEnabled = t;
      return;
    }
    t ? this.__internalEnable() : this.__internalDisable();
  }
  /**
   * Gets the position of this component's GameObject in world space.    
   * Note: This is equivalent to calling `this.gameObject.worldPosition`
   */
  get worldPosition() {
    return ie(this.gameObject);
  }
  /**
   * Sets the position of this component's GameObject in world space
   * @param val The world position vector to set
   */
  set worldPosition(t) {
    yt(this.gameObject, t);
  }
  /**
   * Sets the position of this component's GameObject in world space using individual coordinates
   * @param x X-coordinate in world space
   * @param y Y-coordinate in world space
   * @param z Z-coordinate in world space
   */
  setWorldPosition(t, e, i) {
    Fa(this.gameObject, t, e, i);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as a quaternion
   * Note: This is equivalent to calling `this.gameObject.worldQuaternion`
   */
  get worldQuaternion() {
    return Ce(this.gameObject);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using a quaternion
   * @param val The world rotation quaternion to set
   */
  set worldQuaternion(t) {
    wn(this.gameObject, t);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using quaternion components
   * @param x X component of the quaternion
   * @param y Y component of the quaternion
   * @param z Z component of the quaternion
   * @param w W component of the quaternion
   */
  setWorldQuaternion(t, e, i, n) {
    R0(this.gameObject, t, e, i, n);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as Euler angles (in radians)
   */
  get worldEuler() {
    return k0(this.gameObject);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using Euler angles (in radians)
   * @param val The world rotation Euler angles to set
   */
  set worldEuler(t) {
    T0(this.gameObject, t);
  }
  /**
   * Gets the rotation of this component's GameObject in world space as Euler angles (in degrees)  
   * Note: This is equivalent to calling `this.gameObject.worldRotation`
   */
  get worldRotation() {
    return this.gameObject.worldRotation;
  }
  /**
   * Sets the rotation of this component's GameObject in world space using Euler angles (in degrees)
   * @param val The world rotation vector to set (in degrees)
   */
  set worldRotation(t) {
    this.setWorldRotation(t.x, t.y, t.z, !0);
  }
  /**
   * Sets the rotation of this component's GameObject in world space using individual Euler angles
   * @param x X-axis rotation
   * @param y Y-axis rotation
   * @param z Z-axis rotation
   * @param degrees Whether the values are in degrees (true) or radians (false)
   */
  setWorldRotation(t, e, i, n = !0) {
    Eu(this.gameObject, t, e, i, n);
  }
  /**
   * Gets the forward direction vector (0,0,-1) of this component's GameObject in world space
   */
  get forward() {
    return Oc._forward.set(0, 0, -1).applyQuaternion(this.worldQuaternion);
  }
  /**
   * Gets the right direction vector (1,0,0) of this component's GameObject in world space
   */
  get right() {
    return Oc._right.set(1, 0, 0).applyQuaternion(this.worldQuaternion);
  }
  /**
   * Gets the up direction vector (0,1,0) of this component's GameObject in world space
   */
  get up() {
    return Oc._up.set(0, 1, 0).applyQuaternion(this.worldQuaternion);
  }
  /**
   * Registers an event listener for the specified event type
   * @param type The event type to listen for
   * @param listener The callback function to execute when the event occurs
   */
  addEventListener(t, e) {
    this._eventListeners[t] = this._eventListeners[t] || [], this._eventListeners[t].push(e);
  }
  /**
   * Removes a previously registered event listener
   * @param type The event type the listener was registered for
   * @param listener The callback function to remove
   */
  removeEventListener(t, e) {
    if (!this._eventListeners[t])
      return;
    const i = this._eventListeners[t].indexOf(e);
    i >= 0 && this._eventListeners[t].splice(i, 1);
  }
  /**
   * Dispatches an event to all registered listeners
   * @param evt The event object to dispatch
   * @returns Always returns false (standard implementation of EventTarget)
   */
  dispatchEvent(t) {
    if (!t || !this._eventListeners[t.type])
      return !1;
    const e = this._eventListeners[t.type];
    for (let i = 0; i < e.length; i++)
      e[i](t);
    return !1;
  }
};
let I = Oc;
r(I, "_forward", new v()), r(I, "_right", new v()), r(I, "_up", new v());
const BD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Behaviour: I,
  Component: I,
  GameObject: S
}, Symbol.toStringTag, { value: "Module" }));
var oM = Object.defineProperty, rM = Object.getOwnPropertyDescriptor, Ev = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? rM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && oM(t, e, n), n;
};
class $u extends I {
  constructor() {
    super(...arguments);
    r(this, "from");
    r(this, "to");
    r(this, "width", 0);
    r(this, "centered", !0);
    r(this, "_centerPos");
  }
  awake() {
    this._centerPos = new v();
  }
  update() {
    if (!this.from || !this.to)
      return;
    const e = ie(this.from).clone(), i = ie(this.to).clone(), n = e.distanceTo(i);
    this._centerPos.copy(e), this._centerPos.add(i), this._centerPos.multiplyScalar(0.5), yt(this.gameObject, this.centered ? this._centerPos : e), this.gameObject.lookAt(ie(this.to).clone()), this.gameObject.scale.set(this.width, this.width, n);
  }
}
Ev([
  f(S)
], $u.prototype, "from", 2);
Ev([
  f(S)
], $u.prototype, "to", 2);
var aM = Object.defineProperty, lM = Object.getOwnPropertyDescriptor, Dr = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? lM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && aM(t, e, n), n;
};
const Ws = x("debuganimation");
let Iv = class {
  constructor() {
    r(this, "x");
    r(this, "y");
  }
};
class ti extends I {
  constructor() {
    super(...arguments);
    r(this, "playAutomatically", !0);
    r(this, "randomStartTime", !0);
    r(this, "minMaxSpeed");
    r(this, "minMaxOffsetNormalized");
    r(this, "loop", !0);
    r(this, "clampWhenFinished", !1);
    r(this, "_tempAnimationClipBeforeGameObjectExisted", null);
    r(this, "_tempAnimationsArray");
    r(this, "mixer");
    r(this, "_actions");
    r(this, "_handles");
  }
  get isAnimationComponent() {
    return !0;
  }
  addClip(e) {
    this.animations || (this.animations = []), this.animations.push(e);
  }
  /**
   * The time in seconds of the first running animation action
   * @default 0
   */
  get time() {
    if (this.actions) {
      for (const e of this.actions)
        if (e.isRunning())
          return e.time;
    }
    return 0;
  }
  set time(e) {
    if (this.actions)
      for (const i of this.actions)
        i.time = e;
  }
  /**
   * Get the first animation clip in the animations array
   */
  get clip() {
    var e;
    return (e = this.animations) != null && e.length ? this.animations[0] : null;
  }
  /**
   * Set the first animation clip in the animations array
   */
  set clip(e) {
    if (!this.__didAwake) {
      Ws && console.warn("Assign clip during serialization", e), this._tempAnimationClipBeforeGameObjectExisted = e;
      return;
    }
    e && (this.gameObject.animations || (this.gameObject.animations = []), !this.animations.includes(e) && (this.animations.length > 0 ? this.animations.splice(0, 0, e) : this.animations.push(e)));
  }
  set clips(e) {
    this.animations = e;
  }
  set animations(e) {
    e == null || !Array.isArray(e) || (this.gameObject ? this.gameObject.animations = e : this._tempAnimationsArray = e);
  }
  get animations() {
    return this.gameObject.animations || this._tempAnimationsArray || [];
  }
  /**
   * The animation actions
   */
  get actions() {
    return this._actions;
  }
  set actions(e) {
    this._actions = e;
  }
  /** @internal */
  awake() {
    this.mixer = void 0, Ws && console.log("Animation Awake", this.name, this), this._tempAnimationsArray && (this.animations = this._tempAnimationsArray, this._tempAnimationsArray = void 0), this._tempAnimationClipBeforeGameObjectExisted && (this.clip = this._tempAnimationClipBeforeGameObjectExisted, this._tempAnimationClipBeforeGameObjectExisted = null), this.actions = [], this._handles = [];
  }
  /** @internal */
  onEnable() {
    var e;
    if (this.playAutomatically && ((e = this.animations) == null ? void 0 : e.length) > 0) {
      const i = Math.floor(Math.random() * this.animations.length), n = this.animations[i];
      this.play(i, {
        exclusive: !0,
        fadeDuration: 0,
        startTime: this.randomStartTime ? Math.random() * n.duration : 0,
        loop: this.loop,
        clampWhenFinished: this.clampWhenFinished
      });
    }
  }
  /** @internal */
  update() {
    this.mixer && (this.mixer.update(this.context.time.deltaTime), this._handles.forEach((e) => e.update()));
  }
  /** @internal */
  onDisable() {
    this.mixer && this.mixer.stopAllAction();
  }
  /** @internal */
  onDestroy() {
    this.context.animations.unregisterAnimationMixer(this.mixer);
  }
  /** Get an animation action by the animation clip name */
  getAction(e) {
    var i;
    return ((i = this.actions) == null ? void 0 : i.find((n) => n.getClip().name === e)) || null;
  }
  /** Is any animation playing? */
  get isPlaying() {
    if (this.actions) {
      for (let e = 0; e < this.actions.length; e++)
        if (this.actions[e].isRunning())
          return !0;
    }
    return !1;
  }
  /** Stops all currently playing animations */
  stopAll(e) {
    if (this.actions)
      for (const i of this.actions)
        e != null && e.fadeDuration ? i.fadeOut(e.fadeDuration) : i.stop();
  }
  /**
   * Stops a specific animation clip or index. If clip is undefined then all animations will be stopped
   */
  stop(e, i) {
    if (e === void 0) {
      this.stopAll();
      return;
    } else if (typeof e == "number") {
      if (e >= this.animations.length) {
        Ws && console.log("No animation at index", e);
        return;
      }
      e = this.animations[e];
    } else
      typeof e == "string" && (e = this.animations.find((o) => o.name === e));
    if (!e) {
      console.error("Could not find clip", e);
      return;
    }
    const n = this.actions.find((o) => o.getClip() === e);
    if (!n) {
      console.error("Could not find action", e);
      return;
    }
    i != null && i.fadeDuration ? n.fadeOut(i.fadeDuration) : n.stop();
  }
  /**
   * Pause all animations or a specific animation clip or index
   * @param clip optional animation clip, index or name, if undefined all animations will be paused
   * @param unpause if true, the animation will be resumed
   */
  pause(e, i = !1) {
    if (e === void 0) {
      for (const o of this.actions)
        o.paused = !i;
      return;
    } else if (typeof e == "number") {
      if (e >= this.animations.length) {
        Ws && console.log("No animation at index", e);
        return;
      }
      e = this.animations[e];
    } else
      typeof e == "string" && (e = this.animations.find((o) => o.name === e));
    if (!e) {
      console.error("Could not find clip", e);
      return;
    }
    const n = this.actions.find((o) => o.getClip() === e);
    if (!n) {
      console.error("Could not find action", e);
      return;
    }
    n.paused = !i;
  }
  /**
   * Resume all paused animations.   
   * Note that this will not fade animations in or out and just unpause previous animations. If an animation was faded out which means it's not running anymore, it will not be resumed.
   */
  resume() {
    for (const e of this.actions)
      e.paused = !1;
  }
  /**
   * Play an animation clip or an clip at the specified index.
   * @param clipOrNumber the animation clip, index or name to play. If undefined, the first animation in the animations array will be played
   * @param options the play options. Use to set the fade duration, loop, speed, start time, end time, clampWhenFinished
   * @returns a promise that resolves when the animation is finished (note that it will not resolve if the animation is looping)
   */
  play(e = 0, i) {
    if (Ws && console.log("PLAY", e), this.ensureMixer(), !this.mixer) {
      Ws && console.warn("Missing mixer", this);
      return;
    }
    e === void 0 && (e = 0);
    let n = e;
    if (typeof e == "number") {
      if (e >= this.animations.length) {
        Ws && console.log("No animation at index", e);
        return;
      }
      n = this.animations[e];
    } else
      typeof e == "string" && (n = this.animations.find((a) => a.name === e));
    if (!n) {
      console.error("Could not find clip", e);
      return;
    }
    i || (i = {});
    for (const a of this.actions)
      if (a.getClip() === n)
        return this.internalOnPlay(a, i);
    if (!n.tracks) {
      console.warn("Clip is no AnimationClip", n);
      return;
    }
    const o = this.mixer.clipAction(n);
    return this.actions.push(o), this.internalOnPlay(o, i);
  }
  internalOnPlay(e, i) {
    var n = this.actions.find((l) => l === e);
    if (n === e && n.isRunning() && n.time < n.getClip().duration) {
      const l = this.tryFindHandle(e);
      if (n.paused && (n.paused = !1), l)
        return l.waitForFinish();
    }
    if (i.loop === void 0 && (i.loop = this.loop), i.clampWhenFinished === void 0 && (i.clampWhenFinished = this.clampWhenFinished), i.minMaxOffsetNormalized === void 0 && this.randomStartTime && (i.minMaxOffsetNormalized = this.minMaxOffsetNormalized), i.minMaxSpeed === void 0 && (i.minMaxSpeed = this.minMaxSpeed), (i == null ? void 0 : i.exclusive) ?? !0)
      for (const l of this.actions)
        l != n && (i.fadeDuration ? l.fadeOut(i.fadeDuration) : l.stop());
    if (i != null && i.fadeDuration && e.fadeIn(i.fadeDuration), e.enabled = !0, (i == null ? void 0 : i.startTime) != null)
      e.time = i.startTime;
    else if (i != null && i.minMaxOffsetNormalized && i.minMaxOffsetNormalized.x != 0 && i.minMaxOffsetNormalized.y != 0) {
      const l = e.getClip();
      e.time = $.lerp(i.minMaxOffsetNormalized.x, i.minMaxOffsetNormalized.y, Math.random()) * l.duration;
    } else
      e.time >= e.getClip().duration && (e.time = 0);
    i != null && i.minMaxSpeed ? e.timeScale = $.lerp(i.minMaxSpeed.x, i.minMaxSpeed.y, Math.random()) : e.timeScale = (i == null ? void 0 : i.speed) ?? 1, (i == null ? void 0 : i.loop) != null ? e.loop = i.loop ? Gx : Kp : e.loop = Kp, i != null && i.clampWhenFinished && (e.clampWhenFinished = !0), e.paused = !1, e.play(), Ws && console.log("PLAY", e.getClip().name, e);
    const a = new cM(e, this.mixer, i, (l) => {
      this._handles.splice(this._handles.indexOf(a), 1);
    });
    return this._handles.push(a), a.waitForFinish();
  }
  tryFindHandle(e) {
    for (const i of this._handles)
      if (i.action === e)
        return i;
  }
  ensureMixer() {
    if (!this.mixer) {
      const e = "animationMixer";
      this.gameObject[e] && (this.mixer = this.gameObject[e]), (!this.mixer || !this.mixer.clipAction) && (this.mixer = new og(this.gameObject), this.gameObject[e] = this.mixer);
    }
    this.context.animations.registerAnimationMixer(this.mixer);
  }
}
Dr([
  f()
], ti.prototype, "playAutomatically", 2);
Dr([
  f()
], ti.prototype, "randomStartTime", 2);
Dr([
  f(Iv)
], ti.prototype, "minMaxSpeed", 2);
Dr([
  f(Iv)
], ti.prototype, "minMaxOffsetNormalized", 2);
Dr([
  f()
], ti.prototype, "loop", 2);
Dr([
  f()
], ti.prototype, "clampWhenFinished", 2);
Dr([
  f(uo)
], ti.prototype, "clips", 1);
class cM {
  constructor(t, e, i, n) {
    r(this, "mixer");
    r(this, "action");
    r(this, "promise", null);
    r(this, "_options");
    r(this, "_resolveCallback", null);
    r(this, "_resolvedOrRejectedCallback");
    // private onLoop = (_evt: MixerEvent) => {
    // }
    r(this, "onFinished", (t) => {
      t.action === this.action && this.onResolve();
    });
    this.action = t, this.mixer = e, this._resolvedOrRejectedCallback = n, this._options = i;
  }
  waitForFinish() {
    return this.promise ? this.promise : (this.promise = new Promise((t) => {
      this._resolveCallback = t;
    }), this.mixer.addEventListener("finished", this.onFinished), this.promise);
  }
  update() {
    this._options && this._options.endTime !== void 0 && this.action.time > this._options.endTime && (this._options.loop === !0 ? this.action.time = this._options.startTime ?? 0 : (this.action.time = this._options.endTime, this.action.timeScale = 0, this.onResolve()));
  }
  onResolve() {
    var t, e;
    this.dispose(), (t = this._resolvedOrRejectedCallback) == null || t.call(this, this), (e = this._resolveCallback) == null || e.call(this, this.action);
  }
  dispose() {
    this.mixer.removeEventListener("finished", this.onFinished);
  }
}
const Sd = Symbol("objectIsAnimatedData");
function Jy(s, t, e) {
  if (!s)
    return;
  if (s[Sd] === void 0) {
    if (!e)
      return;
    s[Sd] = /* @__PURE__ */ new Set();
  }
  const i = s[Sd];
  e ? i.add(t) : i.has(t) && i.delete(t);
}
function hM(s) {
  if (!s)
    return !1;
  const t = s[Sd];
  return t !== void 0 && t.size > 0;
}
class zD {
  constructor() {
    r(this, "_context");
  }
  get context() {
    return this._context ?? ee.Current;
  }
  get isStateMachineBehaviour() {
    return !0;
  }
}
class Fh {
  constructor(t, e, i, n) {
    /** The name of the animation */
    r(this, "name");
    /** The hash of the name */
    r(this, "nameHash");
    /** The normalized time of the animation */
    r(this, "normalizedTime");
    /** The length of the animation */
    r(this, "length");
    /** The current speed of the animation */
    r(this, "speed");
    /** The current action playing. It can be used to modify the action */
    r(this, "action");
    /**
     * If the state has any transitions
     */
    r(this, "hasTransitions");
    var o;
    this.name = t.name, this.nameHash = t.hash, this.normalizedTime = e, this.length = i, this.speed = n, this.action = t.motion.action || null, this.hasTransitions = ((o = t.transitions) == null ? void 0 : o.length) > 0 || !1;
  }
}
function dM(s, t) {
  return {
    name: "Empty",
    isLooping: !1,
    guid: (t == null ? void 0 : t.generateUUID()) ?? Cs.generateUUID(),
    index: -1,
    clip: new uo(s, 0, [])
  };
}
var Go = /* @__PURE__ */ ((s) => (s[s.If = 1] = "If", s[s.IfNot = 2] = "IfNot", s[s.Greater = 3] = "Greater", s[s.Less = 4] = "Less", s[s.Equals = 6] = "Equals", s[s.NotEqual = 7] = "NotEqual", s))(Go || {}), Dv = /* @__PURE__ */ ((s) => (s[s.Float = 1] = "Float", s[s.Int = 3] = "Int", s[s.Bool = 4] = "Bool", s[s.Trigger = 9] = "Trigger", s))(Dv || {});
const at = x("debuganimatorcontroller"), zh = x("debugrootmotion");
class yn {
  constructor(t) {
    r(this, "_speed", 1);
    /**
     * The normalized time (0-1) to start playing the first state at.
     * This affects the initial state when the animator is first enabled.
     */
    r(this, "normalizedStartOffset", 0);
    /**
     * The Animator component this controller is bound to.
     */
    r(this, "animator");
    /**
     * The data model describing the animation states and transitions.
     */
    r(this, "model");
    r(this, "_mixer");
    r(this, "_activeState");
    r(this, "_activeStates", []);
    /**
     * These actions have been active previously but not faded out because we entered a state that has no real animation - no duration. In which case we hold the previously active actions until they are faded out.
     */
    r(this, "_heldActions", []);
    // https://docs.unity3d.com/Manual/RootMotion.html
    r(this, "rootMotionHandler");
    this.model = t, at && console.log(this);
  }
  /**
   * Creates an AnimatorController from a set of animation clips.
   * Each clip becomes a state in the controller's state machine.
   * 
   * @param clips - The animation clips to use for creating states
   * @param options - Configuration options for the controller including looping behavior and transitions
   * @returns A new AnimatorController instance
   */
  static createFromClips(t, e = { looping: !1, autoTransition: !0, transitionDuration: 0 }) {
    const i = [];
    for (let a = 0; a < t.length; a++) {
      const l = t[a], c = [];
      if (e.autoTransition !== !1) {
        const d = e.transitionDuration ?? 0, u = d / l.duration;
        let p = a;
        (e.autoTransition === void 0 || e.autoTransition === !0) && (p = (a + 1) % t.length), c.push({
          exitTime: 1 - u,
          offset: 0,
          duration: d,
          hasExitTime: !0,
          destinationState: p,
          conditions: []
        });
      }
      const h = {
        name: l.name,
        hash: a,
        // by using the index it's easy for users to call play(2) to play the clip at index 2
        motion: {
          name: l.name,
          clip: l,
          isLooping: (e == null ? void 0 : e.looping) ?? !1
        },
        transitions: c,
        behaviours: []
      };
      i.push(h);
    }
    const n = {
      name: "AnimatorController",
      guid: new Bt(Date.now()).generateUUID(),
      parameters: [],
      layers: [{
        name: "Base Layer",
        stateMachine: {
          defaultState: 0,
          states: i
        }
      }]
    };
    return new yn(n);
  }
  /**
   * Plays an animation state by name or hash.
   * 
   * @param name - The name or hash identifier of the state to play
   * @param layerIndex - The layer index (defaults to 0)
   * @param normalizedTime - The normalized time to start the animation from (0-1)
   * @param durationInSec - Transition duration in seconds
   */
  play(t, e = -1, i = Number.NEGATIVE_INFINITY, n = 0) {
    if (e < 0)
      e = 0;
    else if (e >= this.model.layers.length) {
      console.warn("invalid layer");
      return;
    }
    const a = this.model.layers[e].stateMachine;
    for (const l of a.states)
      if (l.name === t || l.hash === t) {
        at && console.log("transition to ", l), this.transitionTo(l, n, i);
        return;
      }
    console.warn("Could not find " + t + " to play");
  }
  /**
   * Resets the controller to its initial state.
   */
  reset() {
    this.setStartTransition();
  }
  /**
   * Sets a boolean parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param value - The boolean value to set
   */
  setBool(t, e) {
    var n, o;
    const i = typeof t == "string" ? "name" : "hash";
    return (o = (n = this.model) == null ? void 0 : n.parameters) == null ? void 0 : o.filter((a) => a[i] === t).forEach((a) => a.value = e);
  }
  /**
   * Gets a boolean parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The boolean value of the parameter, or false if not found
   */
  getBool(t) {
    var i, n, o;
    const e = typeof t == "string" ? "name" : "hash";
    return ((o = (n = (i = this.model) == null ? void 0 : i.parameters) == null ? void 0 : n.find((a) => a[e] === t)) == null ? void 0 : o.value) ?? !1;
  }
  /**
   * Sets a float parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param val - The float value to set
   * @returns True if the parameter was found and set, false otherwise
   */
  setFloat(t, e) {
    var o, a;
    const i = typeof t == "string" ? "name" : "hash", n = (a = (o = this.model) == null ? void 0 : o.parameters) == null ? void 0 : a.filter((l) => l[i] === t);
    return n.forEach((l) => l.value = e), (n == null ? void 0 : n.length) > 0;
  }
  /**
   * Gets a float parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The float value of the parameter, or 0 if not found
   */
  getFloat(t) {
    var i, n, o;
    const e = typeof t == "string" ? "name" : "hash";
    return ((o = (n = (i = this.model) == null ? void 0 : i.parameters) == null ? void 0 : n.find((a) => a[e] === t)) == null ? void 0 : o.value) ?? 0;
  }
  /**
   * Sets an integer parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @param val - The integer value to set
   */
  setInteger(t, e) {
    var n, o;
    const i = typeof t == "string" ? "name" : "hash";
    return (o = (n = this.model) == null ? void 0 : n.parameters) == null ? void 0 : o.filter((a) => a[i] === t).forEach((a) => a.value = e);
  }
  /**
   * Gets an integer parameter value by name or hash.
   * 
   * @param name - The name or hash identifier of the parameter
   * @returns The integer value of the parameter, or 0 if not found
   */
  getInteger(t) {
    var i, n, o;
    const e = typeof t == "string" ? "name" : "hash";
    return ((o = (n = (i = this.model) == null ? void 0 : i.parameters) == null ? void 0 : n.find((a) => a[e] === t)) == null ? void 0 : o.value) ?? 0;
  }
  /**
   * Sets a trigger parameter to active (true).
   * Trigger parameters are automatically reset after they are consumed by a transition.
   * 
   * @param name - The name or hash identifier of the trigger parameter
   */
  setTrigger(t) {
    var i, n;
    at && console.log("SET TRIGGER", t);
    const e = typeof t == "string" ? "name" : "hash";
    return (n = (i = this.model) == null ? void 0 : i.parameters) == null ? void 0 : n.filter((o) => o[e] === t).forEach((o) => o.value = !0);
  }
  /**
   * Resets a trigger parameter to inactive (false).
   * 
   * @param name - The name or hash identifier of the trigger parameter
   */
  resetTrigger(t) {
    var i, n;
    const e = typeof t == "string" ? "name" : "hash";
    return (n = (i = this.model) == null ? void 0 : i.parameters) == null ? void 0 : n.filter((o) => o[e] === t).forEach((o) => o.value = !1);
  }
  /**
   * Gets the current state of a trigger parameter.
   * 
   * @param name - The name or hash identifier of the trigger parameter
   * @returns The boolean state of the trigger, or false if not found
   */
  getTrigger(t) {
    var i, n, o;
    const e = typeof t == "string" ? "name" : "hash";
    return ((o = (n = (i = this.model) == null ? void 0 : i.parameters) == null ? void 0 : n.find((a) => a[e] === t)) == null ? void 0 : o.value) ?? !1;
  }
  /**
   * Checks if the controller is currently in a transition between states.
   * 
   * @returns True if a transition is in progress, false otherwise
   */
  isInTransition() {
    return this._activeStates.length > 1;
  }
  /** Set the speed of the animator controller. Larger values will make the animation play faster. */
  setSpeed(t) {
    this._speed = t;
  }
  /**
   * Finds an animation state by name or hash.
   * @deprecated Use findState instead
   * 
   * @param name - The name or hash identifier of the state to find
   * @returns The found state or null if not found
   */
  FindState(t) {
    return this.findState(t);
  }
  /**
   * Finds an animation state by name or hash.
   * 
   * @param name - The name or hash identifier of the state to find
   * @returns The found state or null if not found
   */
  findState(t) {
    if (!t)
      return null;
    if (Array.isArray(this.model.layers)) {
      for (const e of this.model.layers)
        for (const i of e.stateMachine.states)
          if (i.name === t || i.hash == t)
            return i;
    }
    return null;
  }
  /**
   * Gets information about the current playing animation state.
   * 
   * @returns An AnimatorStateInfo object with data about the current state, or null if no state is active
   */
  getCurrentStateInfo() {
    if (!this._activeState)
      return null;
    const t = this._activeState.motion.action;
    if (!t)
      return null;
    const e = this._activeState.motion.clip.duration, i = e <= 0 ? 0 : Math.abs(t.time / e);
    return new Fh(this._activeState, i, e, this._speed);
  }
  /**
   * Gets the animation action currently playing.
   * 
   * @returns The current animation action, or null if no action is playing
   */
  get currentAction() {
    if (!this._activeState)
      return null;
    const t = this._activeState.motion.action;
    return t || null;
  }
  /**
   * Gets the engine context from the bound animator.
   */
  get context() {
    var t;
    return (t = this.animator) == null ? void 0 : t.context;
  }
  /**
   * Gets the animation mixer used by this controller.
   */
  get mixer() {
    return this._mixer;
  }
  /**
   * Cleans up resources used by this controller.
   * Stops all animations and unregisters the mixer from the animation system.
   */
  dispose() {
    var t;
    if (this._mixer.stopAllAction(), this.animator) {
      this._mixer.uncacheRoot(this.animator.gameObject);
      for (const e of this._activeStates)
        e.motion.clip && this.mixer.uncacheAction(e.motion.clip, this.animator.gameObject);
    }
    (t = this.context) == null || t.animations.unregisterAnimationMixer(this._mixer);
  }
  // applyRootMotion(obj: Object3D) {
  //     // this.internalApplyRootMotion(obj);
  // }
  /**
   * Binds this controller to an animator component.
   * Creates a new animation mixer and sets up animation actions.
   * 
   * @param animator - The animator to bind this controller to
   */
  bind(t) {
    var e, i;
    t ? this.animator !== t && (this._mixer && (this._mixer.stopAllAction(), (e = this.context) == null || e.animations.unregisterAnimationMixer(this._mixer)), this.animator = t, this._mixer = new og(this.animator.gameObject), (i = this.context) == null || i.animations.registerAnimationMixer(this._mixer), this.createActions(this.animator)) : console.error("AnimatorController.bind: animator is null");
  }
  /**
   * Creates a deep copy of this controller.
   * Clones the model data but does not copy runtime state.
   * 
   * @returns A new AnimatorController instance with the same configuration
   */
  clone() {
    if (typeof this.model == "string")
      return console.warn("AnimatorController has not been resolved, can not create model from string", this.model), null;
    at && console.warn("AnimatorController clone()", this.model);
    const t = Ru(this.model, (i, n, o) => o == null ? !0 : !(o.type === "Object3D" || o.isObject3D === !0 || hC(o) || o.tracks !== void 0 || o instanceof yn));
    return console.assert(t !== this.model), new yn(t);
  }
  /**
   * Updates the controller's state machine and animations.
   * Called each frame by the animator component.
   * 
   * @param weight - The weight to apply to the animations (for blending)
   */
  update(t) {
    var i, n;
    if (!this.animator)
      return;
    this.evaluateTransitions(), this.updateActiveStates(t);
    const e = this.animator.context.time.deltaTime;
    this.animator.applyRootMotion && ((i = this.rootMotionHandler) == null || i.onBeforeUpdate(t)), this._mixer.update(e), this.animator.applyRootMotion && ((n = this.rootMotionHandler) == null || n.onAfterUpdate(t));
  }
  /**
   * Gets the currently active animation state.
   * 
   * @returns The active state or undefined if no state is active
   */
  get activeState() {
    return this._activeState;
  }
  updateActiveStates(t) {
    for (let e = 0; e < this._activeStates.length; e++) {
      const i = this._activeStates[e], n = i.motion;
      if (!n.action)
        this._activeStates.splice(e, 1), e--;
      else {
        const o = n.action;
        o.weight = t, o.getEffectiveWeight() <= 0 && !o.isRunning() && (at && console.debug("REMOVE", i.name, o.getEffectiveWeight(), o.isRunning(), o.isScheduled()), this._activeStates.splice(e, 1), e--);
      }
    }
  }
  setStartTransition() {
    var t;
    this.model.layers.length > 1 && (at || z()) && console.warn("Multiple layers are not supported yet " + ((t = this.animator) == null ? void 0 : t.name));
    for (const e of this.model.layers) {
      const i = e.stateMachine;
      i.defaultState === void 0 && (at && console.warn("AnimatorController default state is undefined, will assign state 0 as default", e), i.defaultState = 0);
      const n = i.states[i.defaultState];
      this.transitionTo(n, 0, this.normalizedStartOffset);
      break;
    }
  }
  evaluateTransitions() {
    var o;
    let t = !1;
    if (!this._activeState) {
      if (this.setStartTransition(), !this._activeState)
        return;
      t = !0;
    }
    const e = this._activeState, i = e.motion.action;
    for (const a of e.transitions) {
      if (!a.hasExitTime && a.conditions.length <= 0)
        continue;
      let l = !0;
      for (const c of a.conditions)
        if (!this.evaluateCondition(c)) {
          l = !1;
          break;
        }
      if (l)
        if (i) {
          const c = e.motion.clip.duration, h = c <= 0 ? 1 : Math.abs(i.time / c);
          let d = a.exitTime;
          i.timeScale < 0 && (d = 1 - d);
          let u = !1;
          if (a.hasExitTime ? i.timeScale > 0 ? u = h >= a.exitTime : i.timeScale < 0 && (u = 1 - h >= a.exitTime) : u = !0, u) {
            for (const p of a.conditions) {
              const m = this.model.parameters.find((g) => g.name === p.parameter);
              (m == null ? void 0 : m.type) === Dv.Trigger && m.value && (m.value = !1);
            }
            if (i.clampWhenFinished = !0, at) {
              const p = this.getState(a.destinationState, 0);
              console.log(`Transition to ${a.destinationState} / ${p == null ? void 0 : p.name}`, a, `
Timescale: ` + i.timeScale, `
Normalized time: ` + h.toFixed(3), `
Exit Time: ` + d, a.hasExitTime);
            }
            this.transitionTo(a.destinationState, a.duration, a.offset);
            return;
          }
        } else {
          this.transitionTo(a.destinationState, a.duration, a.offset);
          return;
        }
    }
    i && this.setTimescale(i, e);
    let n = !1;
    if (e.motion.isLooping && i && (i.time >= i.getClip().duration ? (n = !0, i.reset(), i.time = 0, i.play()) : i.time <= 0 && i.timeScale < 0 && (n = !0, i.reset(), i.time = i.getClip().duration, i.play())), !n && e && !t && i && this.animator && e.behaviours) {
      const a = i == null ? void 0 : i.getClip().duration, l = i.time / a, c = new Fh(this._activeState, l, a, this._speed);
      for (const h of e.behaviours)
        h.instance && ((o = h.instance.onStateUpdate) == null || o.call(h.instance, this.animator, c, 0));
    }
  }
  setTimescale(t, e) {
    let i = e.speed ?? 1;
    e.speedParameter && (i *= this.getFloat(e.speedParameter)), i !== void 0 && (t.timeScale = i * this._speed);
  }
  getState(t, e) {
    return typeof t == "number" && (t == -1 && (t = this.model.layers[e].stateMachine.defaultState, t === void 0 && (at && console.warn("AnimatorController default state is undefined: ", this.model, "Layer: " + e), t = 0)), t = this.model.layers[e].stateMachine.states[t]), t;
  }
  releaseHeldActions(t) {
    for (const e of this._heldActions)
      e.fadeOut(t);
    this._heldActions.length = 0;
  }
  transitionTo(t, e, i) {
    var d, u, p, m, g, _, y, b;
    if (!this.animator)
      return;
    const n = 0;
    if (t = this.getState(t, n), !(t != null && t.motion) || !t.motion.clip || !(t.motion.clip instanceof uo))
      return;
    const o = this._activeState === t;
    if (o) {
      const w = t.motion;
      if (!w.action_loopback && w.clip) {
        const P = this.rootMotionHandler ? this.animator.gameObject.matrix.clone() : null;
        this._mixer.uncacheAction(w.clip, this.animator.gameObject), P && P.decompose(this.animator.gameObject.position, this.animator.gameObject.quaternion, this.animator.gameObject.scale), w.action_loopback = this.createAction(w.clip);
      }
    }
    if ((d = this._activeState) != null && d.behaviours && this._activeState.motion.action) {
      const w = (u = this._activeState) == null ? void 0 : u.motion.clip.duration, P = this._activeState.motion.action.time / w, k = new Fh(this._activeState, P, w, this._speed);
      for (const O of this._activeState.behaviours)
        (m = (p = O.instance) == null ? void 0 : p.onStateExit) == null || m.call(O.instance, this.animator, k, n);
    }
    const a = (g = this._activeState) == null ? void 0 : g.motion.action;
    o && (t.motion.action = t.motion.action_loopback, t.motion.action_loopback = a);
    const l = this._activeState;
    this._activeState = t;
    const c = (_ = t.motion) == null ? void 0 : _.action, h = t.motion.clip;
    if ((h == null ? void 0 : h.duration) <= 0 && h.tracks.length <= 0 ? a && this._heldActions.push(a) : a && (a.fadeOut(e), this.releaseHeldActions(e)), c) {
      if (i = Math.max(0, Math.min(1, i)), t.cycleOffsetParameter) {
        let P = this.getFloat(t.cycleOffsetParameter);
        typeof P == "number" ? (P < 0 && (P += 1), i += P, i %= 1) : at && console.warn("AnimatorController cycle offset parameter is not a number", t.cycleOffsetParameter);
      } else
        typeof t.cycleOffset == "number" && (i += t.cycleOffset, i %= 1);
      c.isRunning() && c.stop(), c.reset(), c.enabled = !0, this.setTimescale(c, t);
      const w = t.motion.clip.duration;
      if (c.time = o ? 0 : i * w, c.timeScale < 0 && (c.time = w - c.time), c.clampWhenFinished = !0, c.setLoop(Kp, 0), e > 0 ? c.fadeIn(e) : c.weight = 1, c.play(), this.rootMotionHandler && this.rootMotionHandler.onStart(c), this._activeStates.includes(t) || this._activeStates.push(t), this._activeState.behaviours) {
        const P = new Fh(t, i, w, this._speed);
        for (const k of this._activeState.behaviours)
          (b = (y = k.instance) == null ? void 0 : y.onStateEnter) == null || b.call(k.instance, this.animator, P, n);
      }
    } else
      at && (t.__warned_no_motion || (t.__warned_no_motion = !0, console.warn("No action", t.motion, this)));
    at && console.log("TRANSITION FROM " + (l == null ? void 0 : l.name) + " TO " + t.name, e, a, c, c == null ? void 0 : c.getEffectiveTimeScale(), c == null ? void 0 : c.getEffectiveWeight(), c == null ? void 0 : c.isRunning(), c == null ? void 0 : c.isScheduled(), c == null ? void 0 : c.paused);
  }
  createAction(t) {
    var i, n;
    if (this._mixer.existingAction(t) && this._mixer.uncacheAction(t, (i = this.animator) == null ? void 0 : i.gameObject), (n = this.animator) != null && n.applyRootMotion) {
      this.rootMotionHandler || (this.rootMotionHandler = new uM(this));
      const o = this.animator.gameObject;
      return this.rootMotionHandler.createClip(this._mixer, o, t);
    } else
      return this._mixer.clipAction(t);
  }
  evaluateCondition(t) {
    const e = this.model.parameters.find((i) => i.name === t.parameter);
    if (!e)
      return !1;
    switch (t.mode) {
      case Go.If:
        return e.value === !0;
      case Go.IfNot:
        return e.value === !1;
      case Go.Greater:
        return e.value > t.threshold;
      case Go.Less:
        return e.value < t.threshold;
      case Go.Equals:
        return e.value === t.threshold;
      case Go.NotEqual:
        return e.value !== t.threshold;
    }
    return !1;
  }
  createActions(t) {
    var e, i, n, o;
    at && console.log("AnimatorController createActions", this.model);
    for (const a of this.model.layers) {
      const l = a.stateMachine;
      for (let c = 0; c < l.states.length; c++) {
        const h = l.states[c];
        h.transitions || (h.transitions = []);
        for (const d of h.transitions)
          d.conditions || (d.conditions = []);
        if (h.motion || (at && console.warn("No motion", h), h.motion = dM(h.name)), this.animator && h.motion.clips) {
          const d = (e = h.motion.clips) == null ? void 0 : e.find((u) => {
            var p, m;
            return u.node.name === ((m = (p = this.animator) == null ? void 0 : p.gameObject) == null ? void 0 : m.name);
          });
          d ? h.motion.clip = d.clip : (at || z()) && console.warn('Could not find clip for animator "' + ((n = (i = this.animator) == null ? void 0 : i.gameObject) == null ? void 0 : n.name) + '"', h.motion.clips.map((u) => u.node.name));
        }
        if (!h.motion.clip) {
          at && console.warn("No clip assigned to state", h);
          const d = new uo(void 0, void 0, []);
          h.motion.clip = d;
        }
        if ((o = h.motion) != null && o.clip) {
          const d = h.motion.clip;
          if (d instanceof uo) {
            const u = this.createAction(d);
            h.motion.action = u;
          } else
            (at || z()) && console.warn("No valid animationclip assigned", h);
        }
        if (h.behaviours && Array.isArray(h.behaviours))
          for (const d of h.behaviours) {
            if (!(d != null && d.typeName))
              continue;
            const u = R.get(d.typeName);
            if (u) {
              const p = new u();
              p.isStateMachineBehaviour && (p._context = this.context ?? void 0, $a(p, d.properties), d.instance = p), at && console.log("Created animator controller behaviour", h.name, d.typeName, d.properties, p);
            } else
              (at || z()) && console.warn("Could not find AnimatorBehaviour type: " + d.typeName);
          }
      }
    }
  }
  /**
   * Yields all animation actions managed by this controller.
   * Iterates through all states in all layers and returns their actions.
   */
  *enumerateActions() {
    if (this.model.layers)
      for (const t of this.model.layers) {
        const e = t.stateMachine;
        for (let i = 0; i < e.states.length; i++) {
          const n = e.states[i];
          n != null && n.motion && (n.motion.action && (yield n.motion.action), n.motion.action_loopback && (yield n.motion.action_loopback));
        }
      }
  }
  // private findRootBone(obj: Object3D): Object3D | null {
  //     if (this.animationRoot) return this.animationRoot;
  //     if (obj.type === "Bone") {
  //         this.animationRoot = obj as Bone;
  //         return this.animationRoot;
  //     }
  //     if (obj.children) {
  //         for (const ch of obj.children) {
  //             const res = this.findRootBone(ch);
  //             if (res) return res;
  //         }
  //     }
  //     return null;
  // }
}
class eb {
  constructor(t, e) {
    r(this, "track");
    r(this, "createdInterpolant");
    r(this, "originalEvaluate");
    r(this, "customEvaluate");
    this.track = t;
    const i = t, n = i.createInterpolant.bind(t);
    i.createInterpolant = () => (i.createInterpolant = n, this.createdInterpolant = n(), this.originalEvaluate = this.createdInterpolant.evaluate.bind(this.createdInterpolant), this.customEvaluate = (o) => {
      if (!this.originalEvaluate)
        return;
      const a = this.originalEvaluate(o);
      return e(o, a);
    }, this.createdInterpolant.evaluate = this.customEvaluate, this.createdInterpolant);
  }
  dispose() {
    this.createdInterpolant && this.originalEvaluate && (this.createdInterpolant.evaluate = this.originalEvaluate), this.track = void 0, this.createdInterpolant = null, this.originalEvaluate = void 0, this.customEvaluate = void 0;
  }
}
const ht = class {
  constructor(t, e, i, n, o) {
    r(this, "_action");
    r(this, "root");
    r(this, "clip");
    r(this, "positionWrapper", null);
    r(this, "rotationWrapper", null);
    r(this, "context");
    r(this, "positionChange", new v());
    r(this, "rotationChange", new W());
    r(this, "_prevTime", 0);
    if (this.context = t, this.root = e, this.clip = i, ht.firstKeyframeRotation[this.cacheId] || (ht.firstKeyframeRotation[this.cacheId] = new W()), o) {
      const a = o.values;
      ht.firstKeyframeRotation[this.cacheId].set(a[0], a[1], a[2], a[3]);
    }
    ht.spaceRotation[this.cacheId] || (ht.spaceRotation[this.cacheId] = new W()), ht.effectiveSpaceRotation[this.cacheId] || (ht.effectiveSpaceRotation[this.cacheId] = new W()), ht.clipOffsetRotation[this.cacheId] = new W(), o && ht.clipOffsetRotation[this.cacheId].set(o.values[0], o.values[1], o.values[2], o.values[3]).invert(), this.handlePosition(i, n), this.handleRotation(i, o);
  }
  set action(t) {
    this._action = t;
  }
  get action() {
    return this._action;
  }
  get cacheId() {
    return this.root.uuid;
  }
  onStart(t) {
    if (t.getClip() !== this.clip)
      return;
    ht.lastObjRotation[this.cacheId] || (ht.lastObjRotation[this.cacheId] = this.root.quaternion.clone());
    const e = ht.lastObjRotation[this.cacheId];
    if (ht.spaceRotation[this.cacheId].copy(e), zh) {
      const i = new jt().setFromQuaternion(e);
      console.log("START", this.clip.name, $.toDegrees(i.y), this.root.position.z);
    }
  }
  getClipRotationOffset() {
    return ht.clipOffsetRotation[this.cacheId];
  }
  handlePosition(t, e) {
    if (e) {
      const i = this.root;
      zh && i.add(new Oi()), ht.lastObjPosition[this.cacheId] || (ht.lastObjPosition[this.cacheId] = this.root.position.clone());
      const n = new v(), o = new v();
      this.positionWrapper = new eb(e, (a, l) => {
        const c = this.action.getEffectiveWeight();
        return zh && i.position.length() > 8 && i.position.set(0, i.position.y, 0), a > this._prevTime && (n.set(l[0], l[1], l[2]), n.sub(o), n.multiplyScalar(c), n.applyQuaternion(this.getClipRotationOffset()), n.applyQuaternion(i.quaternion), this.positionChange.copy(n)), o.fromArray(l), this._prevTime = a, l[0] = 0, l[1] = 0, l[2] = 0, l;
      });
    }
  }
  handleRotation(t, e) {
    if (e) {
      if (zh) {
        const a = e.values, l = new jt().setFromQuaternion(new W(a[0], a[1], a[2], a[3]));
        console.log(t.name, e.name, "FIRST ROTATION IN TRACK", $.toDegrees(l.y));
        const c = e.values.length - 4, h = new W().set(a[c], a[c + 1], a[c + 2], a[c + 3]), d = new jt().setFromQuaternion(h);
        console.log(t.name, e.name, "LAST ROTATION IN TRACK", $.toDegrees(d.y));
      }
      let i = 0;
      const n = new W(), o = new W();
      this.rotationWrapper = new eb(e, (a, l) => (a > i && (o.set(l[0], l[1], l[2], l[3]), n.invert(), o.multiply(n), this.rotationChange.copy(o)), n.fromArray(l), i = a, l[0] = 0, l[1] = 0, l[2] = 0, l[3] = 1, l));
    }
  }
  // private lastPos: Vector3 = new Vector3();
  onBeforeUpdate(t) {
    this.positionChange.set(0, 0, 0), this.rotationChange.set(0, 0, 0, 1);
  }
  onAfterUpdate(t) {
    return !this.action || (t *= this.action.getEffectiveWeight(), t <= 0) ? !1 : (this.positionChange.multiplyScalar(t), this.rotationChange.slerp(ht.identityQuaternion, 1 - t), !0);
  }
};
let kn = ht;
r(kn, "lastObjPosition", {}), r(kn, "lastObjRotation", {}), // we remove the first keyframe rotation from the space rotation when updating
r(kn, "firstKeyframeRotation", {}), // this is used to rotate the space on clip end / start (so the transform direction is correct)
r(kn, "spaceRotation", {}), r(kn, "effectiveSpaceRotation", {}), r(kn, "clipOffsetRotation", {}), r(kn, "identityQuaternion", new W());
class uM {
  constructor(t) {
    r(this, "controller");
    r(this, "handler", []);
    r(this, "root");
    r(this, "basePosition", new v());
    r(this, "baseQuaternion", new W());
    r(this, "baseRotation", new jt());
    r(this, "summedPosition", new v());
    r(this, "summedRotation", new W());
    this.controller = t;
  }
  createClip(t, e, i) {
    this.root = e, e && "name" in e && e.name;
    const n = this.findRootTrack(i, ".position"), o = this.findRootTrack(i, ".quaternion"), a = new kn(this.controller.context, e, i, n, o);
    this.handler.push(a);
    const l = t.clipAction(i);
    return a.action = l, l;
  }
  onStart(t) {
    for (const e of this.handler)
      e.onStart(t);
  }
  onBeforeUpdate(t) {
    this.basePosition.copy(this.root.position), this.baseQuaternion.copy(this.root.quaternion);
    for (const e of this.handler)
      e.onBeforeUpdate(t);
  }
  onAfterUpdate(t) {
    if (!(t <= 0)) {
      this.root.position.copy(this.basePosition), this.root.quaternion.copy(this.baseQuaternion), this.summedPosition.set(0, 0, 0), this.summedRotation.set(0, 0, 0, 1);
      for (const e of this.handler)
        e.onAfterUpdate(t) && (this.summedPosition.add(e.positionChange), this.summedRotation.multiply(e.rotationChange));
      this.root.position.add(this.summedPosition), this.root.quaternion.multiply(this.summedRotation);
    }
  }
  findRootTrack(t, e) {
    const i = t.tracks;
    if (!i)
      return null;
    for (const n of i)
      if (n.name.endsWith(e))
        return n;
    return null;
  }
}
class fM extends rn {
  onSerialize(t, e) {
  }
  onDeserialize(t, e) {
    if (e.type === yn && (t == null ? void 0 : t.__type) === "AnimatorController")
      return new yn(t);
  }
}
new fM(yn);
var pM = Object.defineProperty, mM = Object.getOwnPropertyDescriptor, Wu = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? mM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && pM(t, e, n), n;
};
const Ni = x("debuganimator");
class zt extends I {
  constructor() {
    super(...arguments);
    r(this, "applyRootMotion", !1);
    r(this, "hasRootMotion", !1);
    r(this, "keepAnimatorControllerStateOnDisable", !1);
    r(this, "_parametersAreDirty", !1);
    r(this, "_isDirty", !1);
    r(this, "_speed", 1);
    r(this, "_normalizedStartOffset", 0);
    r(this, "_animatorController", null);
    // Why do we jump through hoops like this? It's because of the PlayableDirector and animation tracks
    // they NEED to use the same mixer when binding/creating the animation clips
    // so when the playable director runs it takes over updating the mixer for blending and then calls the runtimeAnimatorController.update
    // so they effectively share the same mixer. There might be cases still where not the same mixer is being used but then the animation track prints an error in dev
    r(this, "_initializeWithRuntimeAnimatorController");
  }
  /** 
   * Identifies this component as an animation component in the engine
   */
  get isAnimationComponent() {
    return !0;
  }
  set runtimeAnimatorController(e) {
    var i;
    this._animatorController && this._animatorController.model === e || (e ? e instanceof yn ? (e.animator && e.animator !== this && (console.warn("AnimatorController can not be bound to multiple animators", (i = e.model) == null ? void 0 : i.name), e.model || console.error("AnimatorController has no model"), e = new yn(e.model)), this._animatorController = e, this._animatorController.bind(this)) : (Ni && console.log("Assign animator controller", e, this), this._animatorController = new yn(e), this.__didAwake && this._animatorController.bind(this)) : this._animatorController = null);
  }
  /**
   * Gets the current animator controller instance
   * @returns The current animator controller or null if none is assigned
   */
  get runtimeAnimatorController() {
    return this._animatorController;
  }
  /** 
   * Retrieves information about the current animation state
   * @returns The current state information, or undefined if no state is playing
   */
  getCurrentStateInfo() {
    var e;
    return (e = this.runtimeAnimatorController) == null ? void 0 : e.getCurrentStateInfo();
  }
  /** 
   * The currently playing animation action that can be used to modify animation properties
   * @returns The current animation action, or null if no animation is playing
   */
  get currentAction() {
    var e;
    return ((e = this.runtimeAnimatorController) == null ? void 0 : e.currentAction) || null;
  }
  /** 
   * Indicates whether animation parameters have been modified since the last update
   * @returns True if parameters have been changed
   */
  get parametersAreDirty() {
    return this._parametersAreDirty;
  }
  /** 
   * Indicates whether the animator state has changed since the last update
   * @returns True if the animator has been changed
   */
  get isDirty() {
    return this._isDirty;
  }
  /**@deprecated use play() */
  Play(e, i = -1, n = Number.NEGATIVE_INFINITY, o = 0) {
    this.play(e, i, n, o);
  }
  /** 
   * Plays an animation on the animator
   * @param name The name or hash of the animation to play
   * @param layer The layer to play the animation on (-1 for default layer)
   * @param normalizedTime The time position to start playing (0-1 range, NEGATIVE_INFINITY for current position)
   * @param transitionDurationInSec The duration of the blend transition in seconds
   */
  play(e, i = -1, n = Number.NEGATIVE_INFINITY, o = 0) {
    var a;
    (a = this.runtimeAnimatorController) == null || a.play(e, i, n, o), this._isDirty = !0;
  }
  /**@deprecated use reset */
  Reset() {
    this.reset();
  }
  /** 
   * Resets the animator controller to its initial state
   */
  reset() {
    var e;
    (e = this._animatorController) == null || e.reset(), this._isDirty = !0;
  }
  /**@deprecated use setBool */
  SetBool(e, i) {
    this.setBool(e, i);
  }
  /**
   * Sets a boolean parameter in the animator
   * @param name The name or hash of the parameter
   * @param value The boolean value to set
   */
  setBool(e, i) {
    var n, o;
    Ni && console.log("setBool", e, i), ((n = this.runtimeAnimatorController) == null ? void 0 : n.getBool(e)) !== i && (this._parametersAreDirty = !0), (o = this.runtimeAnimatorController) == null || o.setBool(e, i);
  }
  /**@deprecated use getBool */
  GetBool(e) {
    return this.getBool(e);
  }
  /**
   * Gets a boolean parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the boolean parameter, or false if not found
   */
  getBool(e) {
    var n;
    const i = ((n = this.runtimeAnimatorController) == null ? void 0 : n.getBool(e)) ?? !1;
    return Ni && console.log("getBool", e, i), i;
  }
  /**
   * Toggles a boolean parameter between true and false
   * @param name The name or hash of the parameter
   */
  toggleBool(e) {
    this.setBool(e, !this.getBool(e));
  }
  /**@deprecated use setFloat */
  SetFloat(e, i) {
    this.setFloat(e, i);
  }
  /**
   * Sets a float parameter in the animator
   * @param name The name or hash of the parameter
   * @param val The float value to set
   */
  setFloat(e, i) {
    var n, o;
    ((n = this.runtimeAnimatorController) == null ? void 0 : n.getFloat(e)) !== i && (this._parametersAreDirty = !0), Ni && console.log("setFloat", e, i), (o = this.runtimeAnimatorController) == null || o.setFloat(e, i);
  }
  /**@deprecated use getFloat */
  GetFloat(e) {
    return this.getFloat(e);
  }
  /**
   * Gets a float parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the float parameter, or -1 if not found
   */
  getFloat(e) {
    var n;
    const i = ((n = this.runtimeAnimatorController) == null ? void 0 : n.getFloat(e)) ?? -1;
    return Ni && console.log("getFloat", e, i), i;
  }
  /**@deprecated use setInteger */
  SetInteger(e, i) {
    this.setInteger(e, i);
  }
  /**
   * Sets an integer parameter in the animator
   * @param name The name or hash of the parameter
   * @param val The integer value to set
   */
  setInteger(e, i) {
    var n, o;
    ((n = this.runtimeAnimatorController) == null ? void 0 : n.getInteger(e)) !== i && (this._parametersAreDirty = !0), Ni && console.log("setInteger", e, i), (o = this.runtimeAnimatorController) == null || o.setInteger(e, i);
  }
  /**@deprecated use getInteger */
  GetInteger(e) {
    return this.getInteger(e);
  }
  /**
   * Gets an integer parameter from the animator
   * @param name The name or hash of the parameter
   * @returns The value of the integer parameter, or -1 if not found
   */
  getInteger(e) {
    var n;
    const i = ((n = this.runtimeAnimatorController) == null ? void 0 : n.getInteger(e)) ?? -1;
    return Ni && console.log("getInteger", e, i), i;
  }
  /**@deprecated use setTrigger */
  SetTrigger(e) {
    this.setTrigger(e);
  }
  /**
   * Activates a trigger parameter in the animator
   * @param name The name or hash of the trigger parameter
   */
  setTrigger(e) {
    var i;
    this._parametersAreDirty = !0, Ni && console.log("setTrigger", e), (i = this.runtimeAnimatorController) == null || i.setTrigger(e);
  }
  /**@deprecated use resetTrigger */
  ResetTrigger(e) {
    this.resetTrigger(e);
  }
  /**
   * Resets a trigger parameter in the animator
   * @param name The name or hash of the trigger parameter
   */
  resetTrigger(e) {
    var i;
    this._parametersAreDirty = !0, Ni && console.log("resetTrigger", e), (i = this.runtimeAnimatorController) == null || i.resetTrigger(e);
  }
  /**@deprecated use getTrigger */
  GetTrigger(e) {
    this.getTrigger(e);
  }
  /**
   * Gets the state of a trigger parameter from the animator
   * @param name The name or hash of the trigger parameter
   * @returns The state of the trigger parameter
   */
  getTrigger(e) {
    var n;
    const i = (n = this.runtimeAnimatorController) == null ? void 0 : n.getTrigger(e);
    return Ni && console.log("getTrigger", e, i), i;
  }
  /**@deprecated use isInTransition */
  IsInTransition() {
    return this.isInTransition();
  }
  /** 
   * Checks if the animator is currently in a transition between states
   * @returns True if the animator is currently blending between animations
   */
  isInTransition() {
    var e;
    return ((e = this.runtimeAnimatorController) == null ? void 0 : e.isInTransition()) ?? !1;
  }
  /**@deprecated use setSpeed */
  SetSpeed(e) {
    return this.setSpeed(e);
  }
  /**
   * Sets the playback speed of the animator
   * @param speed The new playback speed multiplier
   */
  setSpeed(e) {
    var i;
    e !== this._speed && (Ni && console.log("setSpeed", e), this._speed = e, ((i = this._animatorController) == null ? void 0 : i.animator) == this && this._animatorController.setSpeed(e));
  }
  /** 
   * Sets a random playback speed between the min and max values
   * @param minMax Object with x (minimum) and y (maximum) speed values
   */
  set minMaxSpeed(e) {
    var i;
    this._speed = $.lerp(e.x, e.y, Math.random()), ((i = this._animatorController) == null ? void 0 : i.animator) == this && this._animatorController.setSpeed(this._speed);
  }
  /**
   * Sets a random normalized time offset for animations between min (x) and max (y) values
   * @param minMax Object with x (min) and y (max) values for the offset range
   */
  set minMaxOffsetNormalized(e) {
    var i;
    this._normalizedStartOffset = $.lerp(e.x, e.y, Math.random()), ((i = this.runtimeAnimatorController) == null ? void 0 : i.animator) == this && (this.runtimeAnimatorController.normalizedStartOffset = this._normalizedStartOffset);
  }
  awake() {
    Ni && console.log("ANIMATOR", this.name, this), this.gameObject && this.initializeRuntimeAnimatorController();
  }
  initializeRuntimeAnimatorController(e = !1) {
    const i = e || this.runtimeAnimatorController !== this._initializeWithRuntimeAnimatorController;
    if (this.runtimeAnimatorController && i) {
      const n = this.runtimeAnimatorController.clone();
      this._initializeWithRuntimeAnimatorController = n, n ? (console.assert(this.runtimeAnimatorController !== n), this.runtimeAnimatorController = n, console.assert(this.runtimeAnimatorController === n), this.runtimeAnimatorController.bind(this), this.runtimeAnimatorController.setSpeed(this._speed), this.runtimeAnimatorController.normalizedStartOffset = this._normalizedStartOffset) : console.warn("Could not clone animator controller", this.runtimeAnimatorController);
    }
  }
  onDisable() {
    var e;
    this.keepAnimatorControllerStateOnDisable || (e = this._animatorController) == null || e.reset();
  }
  onBeforeRender() {
    this._isDirty = !1, this._parametersAreDirty = !1, !hM(this.gameObject) && this._animatorController && this._animatorController.update(1);
  }
}
Wu([
  f()
], zt.prototype, "applyRootMotion", 2);
Wu([
  f()
], zt.prototype, "hasRootMotion", 2);
Wu([
  f()
], zt.prototype, "keepAnimatorControllerStateOnDisable", 2);
Wu([
  f()
], zt.prototype, "runtimeAnimatorController", 1);
const tb = Symbol("previous-visibility"), _a = class extends ks {
  /**
   * Render the scene to the texture
   * @param scene The scene to render
   * @param camera The camera to render from
   * @param renderer The renderer or effectcomposer to use
   */
  render(t, e, i) {
    if ("addPass" in i)
      this._unsupported_effectcomposer_warning || (console.warn("RenderTexture.render() does not yet support EffectComposer"), this._unsupported_effectcomposer_warning = !0);
    else if (i instanceof kr) {
      this.onBeforeRender();
      const o = i.getRenderTarget(), a = i.xr.enabled;
      i.xr.enabled = !1, i.setRenderTarget(this), i.clear(!0, !0, !0), i.render(t, e), i.setRenderTarget(o), i.xr.enabled = a, this.onAfterRender();
    }
  }
  onBeforeRender() {
    _a._userSet.clear();
    const t = tv(this.texture, !0, null, _a._userSet);
    for (const e of t)
      e instanceof q && (e[tb] = e.visible, e.visible = !1);
  }
  onAfterRender() {
    for (const t of _a._userSet)
      t instanceof q && (t.visible = t[tb]);
    _a._userSet.clear();
  }
};
let pr = _a;
r(pr, "_userSet", /* @__PURE__ */ new Set());
var gM = Object.defineProperty, _M = Object.getOwnPropertyDescriptor, Zc = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? _M(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && gM(t, e, n), n;
};
const Uh = x("debuggroundprojection");
class Ls extends I {
  constructor() {
    super(...arguments);
    r(this, "applyOnAwake", !1);
    r(this, "autoFit", !0);
    r(this, "_radius", 50);
    r(this, "_height", 3);
    r(this, "_arblending", 0);
    r(this, "_lastBackground");
    r(this, "_lastRadius");
    r(this, "_lastHeight");
    r(this, "_projection");
    r(this, "_watcher");
    r(this, "_needsTextureUpdate", !1);
    r(this, "_blurrynessShader", null);
    r(this, "_lastBlurriness", -1);
  }
  set radius(e) {
    this._radius = e, this._projection && this.updateProjection();
  }
  get radius() {
    return this._radius;
  }
  set height(e) {
    this._height = e, this._projection && this.updateProjection();
  }
  get height() {
    return this._height;
  }
  set arBlending(e) {
    this._arblending = e, this._needsTextureUpdate = !0;
  }
  get arBlending() {
    return this._arblending;
  }
  /** @internal */
  awake() {
    this.applyOnAwake && this.updateAndCreate();
  }
  /** @internal */
  onEnable() {
    this.context.time.frameCount > 0 && this.applyOnAwake && this.updateAndCreate(), this._watcher || (this._watcher = new fo(this.context.scene, "background"), this._watcher.subscribeWrite((e) => {
      Uh && console.log("Background changed", this.context.scene.background), this._needsTextureUpdate = !0;
    }));
  }
  /** @internal */
  onDisable() {
    var e, i;
    (e = this._watcher) == null || e.revoke(), (i = this._projection) == null || i.removeFromParent();
  }
  /** @internal */
  onEnterXR() {
    this.activeAndEnabled && (this._needsTextureUpdate = !0, this.updateProjection());
  }
  /** @internal */
  async onLeaveXR() {
    this.activeAndEnabled && (await ku(1), this.updateProjection());
  }
  /** @internal */
  onBeforeRender() {
    this._projection && this.scene.backgroundRotation && this._projection.rotation.copy(this.scene.backgroundRotation), this.context.scene.backgroundBlurriness !== void 0 && this._lastBlurriness != this.context.scene.backgroundBlurriness && this.context.scene.backgroundBlurriness > 1e-3 ? this.updateProjection() : this._needsTextureUpdate && this.context.scene.background instanceof Fe && this.updateBlurriness(this.context.scene.background, this.context.scene.backgroundBlurriness);
  }
  updateAndCreate() {
    var e;
    this.updateProjection(), (e = this._watcher) == null || e.apply();
  }
  /**
   * Updates the ground projection. This is called automatically when the environment or settings change.
   */
  updateProjection() {
    var a, l, c, h, d, u;
    if (!this.context.scene.background) {
      (a = this._projection) == null || a.removeFromParent();
      return;
    }
    const e = this.context.scene.background;
    if (!(e instanceof Fe)) {
      (l = this._projection) == null || l.removeFromParent();
      return;
    }
    if (((c = this.context.xr) != null && c.isPassThrough || (h = this.context.xr) != null && h.isAR) && this.arBlending === 0) {
      (d = this._projection) == null || d.removeFromParent();
      return;
    }
    if (!this.gameObject || this.destroyed)
      return;
    let i = !0;
    const n = 0, o = e !== this._lastBackground || this._height !== this._lastHeight || this._radius !== this._lastRadius;
    if (!this._projection || o) {
      Uh && console.log("Create/Update Ground Projection", e.name), (u = this._projection) == null || u.removeFromParent();
      try {
        this._projection = new Ba(e, this._height, this._radius, 64);
      } catch (p) {
        console.error("Error creating three GroundProjection", p);
        return;
      }
      this._projection.position.y = this._height - n, this._projection.name = "GroundProjection", E0(this._projection, !1);
    } else
      i = !1;
    if (this._projection.parent || this.gameObject.add(this._projection), this.autoFit && i) {
      this._projection.updateWorldMatrix(!0, !0);
      const p = ki(this.context.scene.children, [this._projection]), m = p.min.y;
      if (m < 1 / 0) {
        const g = G();
        g.x = p.min.x + (p.max.x - p.min.x) * 0.5;
        const _ = Ke(this.gameObject).x;
        g.y = m + this._height * _ - n, g.z = p.min.z + (p.max.z - p.min.z) * 0.5, yt(this._projection, g);
      }
      Uh && V.DrawWireBox3(p, 65280, 5);
    }
    this.context.scene.backgroundBlurriness > 1e-3 && this._needsTextureUpdate && this.updateBlurriness(e, this.context.scene.backgroundBlurriness), this._lastBackground = e, this._lastHeight = this._height, this._lastRadius = this._radius, this._needsTextureUpdate = !1;
  }
  updateBlurriness(e, i) {
    var o;
    if (this._projection) {
      if (!e)
        return;
    } else
      return;
    this._needsTextureUpdate = !1, Uh && console.log("Update Blurriness", i), this._blurrynessShader ?? (this._blurrynessShader = new bn({
      name: "GroundProjectionBlurriness",
      uniforms: {
        map: { value: e },
        blurriness: { value: i },
        blending: { value: 0 },
        alphaFactor: { value: 1 }
      },
      vertexShader: yM,
      fragmentShader: bM
    })), this._blurrynessShader.depthWrite = !1, this._blurrynessShader.uniforms.map.value = e, this._blurrynessShader.uniforms.blurriness.value = 1, this._lastBlurriness = i, e.needsUpdate = !0;
    const n = this._projection.material.transparent;
    this._projection.material.transparent = (((o = this.context.xr) == null ? void 0 : o.isAR) === !0 && this.arBlending > 1e-6) ?? !1, this._projection.material.transparent ? this._blurrynessShader.uniforms.blending.value = this.arBlending : this._blurrynessShader.uniforms.blending.value = 0, this.context.isInPassThrough ? this._blurrynessShader.uniforms.alphaFactor.value = 0.95 : this._blurrynessShader.uniforms.alphaFactor.value = 1, n !== this._projection.material.transparent && (this._projection.material.needsUpdate = !0), this._projection.material.map = pn.copyTexture(e, this._blurrynessShader), this._projection.material.depthTest = !0, this._projection.material.depthWrite = !1;
  }
}
Zc([
  f()
], Ls.prototype, "applyOnAwake", 2);
Zc([
  f()
], Ls.prototype, "autoFit", 2);
Zc([
  f()
], Ls.prototype, "radius", 1);
Zc([
  f()
], Ls.prototype, "height", 1);
Zc([
  f()
], Ls.prototype, "arBlending", 1);
const yM = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`, bM = `
  uniform sampler2D map;
  uniform float blurriness;
  uniform float alphaFactor;
  uniform float blending;
  varying vec2 vUv;

  const float PI = 3.14159265359;

  // Gaussian function
  float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * PI) * sigma);
  }

  // Custom smoothstep function for desired falloff
  float customSmoothstep(float edge0, float edge1, float x) {
    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
  }

  void main() {
    vec2 center = vec2(0.0, 0.0);
    vec2 pos = vUv;
    pos.x = 0.0; // Only consider vertical distance
    float distance = length(pos - center);
    
    // Calculate blur amount based on custom falloff
    float blurAmount = customSmoothstep(0.5, 1.0, distance * 2.0);
    blurAmount = clamp(blurAmount, 0.0, 1.0); // Ensure blur amount is within valid range

    // Gaussian blur
    vec2 pixelSize = 1.0 / vec2(textureSize(map, 0));
    vec4 color = vec4(0.0);
    float totalWeight = 0.0;
    int blurSize = int(60.0 * min(1.0, blurriness) * blurAmount); // Adjust blur size based on distance and blurriness
    float lodLevel = log2(float(blurSize)) * 0.5; // Compute LOD level

    for (int x = -blurSize; x <= blurSize; x++) {
        for (int y = -blurSize; y <= blurSize; y++) {
            vec2 offset = vec2(float(x), float(y)) * pixelSize * blurAmount;
            float weight = gaussian(length(vec2(float(x), float(y))), 1000.0 * blurAmount); // Use a fixed sigma value
            color += textureLod(map, vUv + offset, lodLevel) * weight;
            totalWeight += weight;
        }
    }

    color = totalWeight > 0.0 ? color / totalWeight : texture2D(map, vUv);

    gl_FragColor = color;

    float brightness = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));
    float stepFactor = blending - brightness * .1;
    gl_FragColor.a = pow(1.0 - blending * customSmoothstep(0.35 * stepFactor, 0.45 * stepFactor, distance), 5.);
    gl_FragColor.a *= alphaFactor;
    // gl_FragColor.rgb = vec3(1.0);

    // #include <tonemapping_fragment>
    // #include <colorspace_fragment>
    
    // Uncomment to visualize blur amount
    // gl_FragColor = vec4(blurAmount, 0.0, 0.0, 1.0);
  }
`;
var vM = Object.defineProperty, wM = Object.getOwnPropertyDescriptor, Ig = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? wM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && vM(t, e, n), n;
};
class Za extends I {
  constructor() {
    super(...arguments);
    r(this, "constraintActive", !0);
    r(this, "locked", !1);
    r(this, "sources", []);
  }
}
Ig([
  f()
], Za.prototype, "constraintActive", 2);
Ig([
  f()
], Za.prototype, "locked", 2);
Ig([
  f(L)
], Za.prototype, "sources", 2);
function xM(s, t) {
  return Ds(s, pe.ContextCreated, t), () => Po(s, pe.ContextCreated);
}
function UD(s, t) {
  return Ds(s, pe.ContextClearing, t), () => Po(s, pe.ContextClearing);
}
function ND(s, t) {
  return Ds(s, pe.ContextDestroying, t), () => Po(s, pe.ContextDestroying);
}
function SM(s, t) {
  return Ds(s, Re.Start, t), () => Po(s, Re.Start);
}
function CM(s, t) {
  return Ds(s, Re.Update, t), () => Po(s, Re.Update);
}
function $D(s, t) {
  return Ds(s, Re.OnBeforeRender, t), () => Po(s, Re.OnBeforeRender);
}
function WD(s, t) {
  return Ds(s, Re.OnAfterRender, t), () => Po(s, Re.OnAfterRender);
}
let mr = class {
  constructor() {
    r(this, "bb", null);
    r(this, "bb_pos", 0);
  }
  __init(t, e) {
    return this.bb_pos = t, this.bb = e, this;
  }
  x() {
    return this.bb.readFloat32(this.bb_pos);
  }
  y() {
    return this.bb.readFloat32(this.bb_pos + 4);
  }
  z() {
    return this.bb.readFloat32(this.bb_pos + 8);
  }
  static sizeOf() {
    return 12;
  }
  static createVec3(t, e, i, n) {
    return t.prep(4, 12), t.writeFloat32(n), t.writeFloat32(i), t.writeFloat32(e), t.offset();
  }
};
class Lv {
  constructor() {
    r(this, "bb", null);
    r(this, "bb_pos", 0);
  }
  __init(t, e) {
    return this.bb_pos = t, this.bb = e, this;
  }
  position(t) {
    return (t || new mr()).__init(this.bb_pos, this.bb);
  }
  rotation(t) {
    return (t || new mr()).__init(this.bb_pos + 12, this.bb);
  }
  scale(t) {
    return (t || new mr()).__init(this.bb_pos + 24, this.bb);
  }
  static sizeOf() {
    return 36;
  }
  static createTransform(t, e, i, n, o, a, l, c, h, d) {
    return t.prep(4, 36), t.prep(4, 12), t.writeFloat32(d), t.writeFloat32(h), t.writeFloat32(c), t.prep(4, 12), t.writeFloat32(l), t.writeFloat32(a), t.writeFloat32(o), t.prep(4, 12), t.writeFloat32(n), t.writeFloat32(i), t.writeFloat32(e), t.offset();
  }
}
class vs {
  constructor() {
    r(this, "bb", null);
    r(this, "bb_pos", 0);
  }
  __init(t, e) {
    return this.bb_pos = t, this.bb = e, this;
  }
  static getRootAsSyncedTransformModel(t, e) {
    return (e || new vs()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsSyncedTransformModel(t, e) {
    return t.setPosition(t.position() + f0), (e || new vs()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  guid(t) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__string(this.bb_pos + e, t) : null;
  }
  /**
   * if the transform interpolation should be fast, this is true when the send interval is low and we want to have snappy transforms
   */
  fast() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  transform(t) {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? (t || new Lv()).__init(this.bb_pos + e, this.bb) : null;
  }
  /**
   * if the server should not save this info
   */
  dontSave() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startSyncedTransformModel(t) {
    t.startObject(4);
  }
  static addGuid(t, e) {
    t.addFieldOffset(0, e, 0);
  }
  static addFast(t, e) {
    t.addFieldInt8(1, +e, 0);
  }
  static addTransform(t, e) {
    t.addFieldStruct(2, e, 0);
  }
  static addDontSave(t, e) {
    t.addFieldInt8(3, +e, 0);
  }
  static endSyncedTransformModel(t) {
    return t.endObject();
  }
  static finishSyncedTransformModelBuffer(t, e) {
    t.finish(e);
  }
  static finishSizePrefixedSyncedTransformModelBuffer(t, e) {
    t.finish(e, void 0, !0);
  }
}
var D;
((s) => {
  ((t) => {
    t.MAYBEMODULE = null;
    const e = [];
    function i() {
      return t.MODULE ? Promise.resolve(t.MODULE) : new Promise((o) => {
        e.push(o);
      });
    }
    t.ready = i;
    async function n() {
      if (t.MODULE)
        return t.MODULE;
      const o = await import("./rapier.js");
      return t.MODULE = o, t.MAYBEMODULE = o, e.forEach((a) => a(o)), e.length = 0, o;
    }
    t.load = n;
  })(s.RAPIER_PHYSICS || (s.RAPIER_PHYSICS = {})), ((t) => {
    t.MAYBEMODULE = null;
    const e = [];
    function i() {
      return t.MODULE ? Promise.resolve(t.MODULE) : new Promise((o) => {
        e.push(o);
      });
    }
    t.ready = i;
    async function n() {
      if (t.MODULE)
        return t.MODULE;
      const o = await import("./postprocessing.js").then((a) => a.index);
      return t.MODULE = o, t.MAYBEMODULE = o, e.forEach((a) => a(o)), e.length = 0, o;
    }
    t.load = n;
  })(s.POSTPROCESSING || (s.POSTPROCESSING = {})), ((t) => {
    t.MAYBEMODULE = null;
    const e = [];
    function i() {
      return t.MODULE ? Promise.resolve(t.MODULE) : new Promise((o) => {
        e.push(o);
      });
    }
    t.ready = i;
    async function n() {
      if (t.MODULE)
        return t.MODULE;
      const o = await import("./postprocessing.js").then((a) => a.N8AO);
      return t.MODULE = o, t.MAYBEMODULE = o, e.forEach((a) => a(o)), e.length = 0, o;
    }
    t.load = n;
  })(s.POSTPROCESSING_AO || (s.POSTPROCESSING_AO = {}));
})(D || (D = {}));
var Ot = /* @__PURE__ */ ((s) => (s[s.Average = 0] = "Average", s[s.Multiply = 1] = "Multiply", s[s.Minimum = 2] = "Minimum", s[s.Maximum = 3] = "Maximum", s))(Ot || {}), Dg = /* @__PURE__ */ ((s) => (s[s.Discrete = 0] = "Discrete", s[s.Continuous = 1] = "Continuous", s))(Dg || {}), nt = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.FreezePositionX = 2] = "FreezePositionX", s[s.FreezePositionY = 4] = "FreezePositionY", s[s.FreezePositionZ = 8] = "FreezePositionZ", s[s.FreezePosition = 14] = "FreezePosition", s[s.FreezeRotationX = 16] = "FreezeRotationX", s[s.FreezeRotationY = 32] = "FreezeRotationY", s[s.FreezeRotationZ = 64] = "FreezeRotationZ", s[s.FreezeRotation = 112] = "FreezeRotation", s[s.FreezeAll = 126] = "FreezeAll", s))(nt || {}), Ql = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.X = 2] = "X", s[s.Y = 4] = "Y", s[s.Z = 8] = "Z", s[s.All = -1] = "All", s))(Ql || {});
const Nt = function(s, t) {
  return function(e, i, n) {
    PM(e, i, n, s, t);
  };
};
function PM(s, t, e, i, n) {
  if (!n && !i && !s.onValidate)
    return;
  if (e !== void 0) {
    console.error("Invalid usage of validate decorator. Only fields can be validated.", s, t, e), We("Invalid usage of validate decorator. Only fields can be validated. Property: " + t, Zi.Error);
    return;
  }
  let o = "";
  if (typeof t == "string" ? o = t : o = t.name, s.__internalAwake) {
    const a = Symbol(o), l = s.__internalAwake;
    s.__internalAwake = function() {
      var c;
      if (!this.onValidate) {
        z() && console.warn('Usage of @validate decorate detected but there is no onValidate method in your class: "' + ((c = s.constructor) == null ? void 0 : c.name) + '"');
        return;
      }
      if (this[a] === void 0) {
        this[a] = this[o];
        const h = this[o];
        if (h instanceof oe || h instanceof v || h instanceof me || h instanceof W) {
          const d = this[o];
          fg(d, () => {
            this.onValidate(o);
          });
        }
        Object.defineProperty(this, o, {
          set: function(d) {
            var u;
            if (this[vm] === !0)
              this[a] = d;
            else {
              i == null || i.call(this, d);
              const p = this[a];
              this[a] = d, (u = this.onValidate) == null || u.call(this, o, p);
            }
          },
          get: function() {
            return n == null || n.call(this), this[a];
          }
        });
      }
      l.call(this);
    };
  }
}
const HD = function(s) {
  return function(t, e, i) {
    let n = "";
    typeof e == "string" ? n = e : n = e.name;
    const o = s.prototype, a = Object.getOwnPropertyDescriptor(o, n);
    if (!(a != null && a.value)) {
      console.warn("Can not apply prefix: type does not have method named", e, s);
      return;
    }
    const l = a.value, c = t[n];
    Object.defineProperty(o, n, {
      value: function(...h) {
        const d = c == null ? void 0 : c.call(this, ...h);
        if (d instanceof Promise) {
          d.then((u) => {
            if (u !== !1)
              return l.call(this, ...h);
          });
          return;
        }
        if (d !== !1)
          return l.call(this, ...h);
      }
    });
  };
};
var OM = Object.defineProperty, MM = Object.getOwnPropertyDescriptor, Ti = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? MM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && OM(t, e, n), n;
};
class RM {
  constructor(t, e) {
    r(this, "positionChanged", !1);
    r(this, "rotationChanged", !1);
    r(this, "position");
    r(this, "quaternion");
    r(this, "_positionKeys", ["x", "y", "z"]);
    r(this, "_quaternionKeys", ["_x", "_y", "_z", "_w"]);
    r(this, "mute", !1);
    r(this, "context");
    r(this, "obj");
    r(this, "_positionWatch");
    r(this, "_rotationWatch");
    this.context = e, this.obj = t;
  }
  get isDirty() {
    return this.positionChanged || this.rotationChanged;
  }
  reset(t = !1) {
    if (this.positionChanged = !1, this.rotationChanged = !1, this.mute = !1, t) {
      if (this.position)
        for (const e of this._positionKeys)
          delete this.position[e];
      if (this.quaternion)
        for (const e of this._quaternionKeys)
          delete this.quaternion[e];
    }
  }
  syncValues() {
    for (const t of this._positionKeys)
      this.position[t] = this.obj.position[t];
    for (const t of this._quaternionKeys)
      this.quaternion[t] = this.obj.quaternion[t];
  }
  applyValues() {
    if (this.positionChanged && this.position)
      for (const t of this._positionKeys) {
        const e = this.position[t];
        e !== void 0 && (this.obj.position[t] = e);
      }
    if (this.rotationChanged && this.quaternion)
      for (const t of this._quaternionKeys) {
        const e = this.quaternion[t];
        e !== void 0 && (this.obj.quaternion[t] = e);
      }
  }
  start(t, e) {
    this.reset(), t && (this._positionWatch || (this._positionWatch = new fo(this.obj.position, ["x", "y", "z"])), this._positionWatch.apply(), this.position = {}, this._positionWatch.subscribeWrite((o, a) => {
      var c;
      if ((c = this.context.physics.engine) != null && c.isUpdating || this.mute)
        return;
      const l = this.position[a];
      Math.abs(l - o) < 1e-5 || (this.position[a] = o, this.positionChanged = !0);
    })), e && (this._rotationWatch || (this._rotationWatch = new fo(this.obj.quaternion, ["_x", "_y", "_z", "_w"])), this._rotationWatch.apply(), this.quaternion = {}, this._rotationWatch.subscribeWrite((o, a) => {
      var c;
      if ((c = this.context.physics.engine) != null && c.isUpdating || this.mute)
        return;
      const l = this.quaternion[a];
      Math.abs(l - o) < 1e-5 || (this.quaternion[a] = o, this.rotationChanged = !0);
    }));
    const i = this.obj.matrixWorld.multiplyMatrices.bind(this.obj.matrixWorld), n = new se();
    this.obj.matrixWorld.multiplyMatrices = (o, a) => {
      var l;
      return (l = this.context.physics.engine) != null && l.isUpdating || this.mute || n.equals(o) || (this.positionChanged = !0, this.rotationChanged = !0, n.copy(o)), i(o, a);
    };
  }
  stop() {
    var t, e;
    (t = this._positionWatch) == null || t.revoke(), (e = this._rotationWatch) == null || e.revoke();
  }
}
var Bp;
const Cd = (Bp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "autoMass", !0);
    r(this, "_mass", 0);
    r(this, "useGravity", !0);
    r(this, "centerOfMass", new v(0, 0, 0));
    r(this, "constraints", nt.None);
    r(this, "isKinematic", !1);
    r(this, "drag", 0);
    r(this, "angularDrag", 1);
    r(this, "detectCollisions", !0);
    r(this, "sleepThreshold", 0.01);
    r(this, "collisionDetectionMode", Dg.Discrete);
    r(this, "_gravityScale", 1);
    r(this, "dominanceGroup", 0);
    r(this, "_propertiesChanged", !1);
    r(this, "_currentVelocity", new v());
    r(this, "_smoothedVelocity", new v());
    r(this, "_smoothedVelocityGetter", new v());
    r(this, "_lastPosition", new v());
    r(this, "_watch");
  }
  get isRigidbody() {
    return !0;
  }
  set mass(t) {
    t !== this._mass && (this._mass = t, this._propertiesChanged = !0, this.__didAwake && (this.autoMass = !1));
  }
  get mass() {
    var t, e;
    return this.autoMass ? ((e = (t = this.context.physics.engine) == null ? void 0 : t.getBody(this)) == null ? void 0 : e.mass()) ?? -1 : this._mass;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionX() {
    return (this.constraints & nt.FreezePositionX) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionY() {
    return (this.constraints & nt.FreezePositionY) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockPositionZ() {
    return (this.constraints & nt.FreezePositionZ) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationX() {
    return (this.constraints & nt.FreezeRotationX) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationY() {
    return (this.constraints & nt.FreezeRotationY) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  get lockRotationZ() {
    return (this.constraints & nt.FreezeRotationZ) !== 0;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionX(t) {
    t ? this.constraints |= nt.FreezePositionX : this.constraints &= ~nt.FreezePositionX;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionY(t) {
    t ? this.constraints |= nt.FreezePositionY : this.constraints &= ~nt.FreezePositionY;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockPositionZ(t) {
    t ? this.constraints |= nt.FreezePositionZ : this.constraints &= ~nt.FreezePositionZ;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationX(t) {
    t ? this.constraints |= nt.FreezeRotationX : this.constraints &= ~nt.FreezeRotationX;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationY(t) {
    t ? this.constraints |= nt.FreezeRotationY : this.constraints &= ~nt.FreezeRotationY;
  }
  /** @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#locking-translationsrotations */
  set lockRotationZ(t) {
    t ? this.constraints |= nt.FreezeRotationZ : this.constraints &= ~nt.FreezeRotationZ;
  }
  /** Gravity is such a common force that it is implemented as a special case (even if it could easily be implemented by the user using force application). Note however that a change of gravity won't automatically wake-up the sleeping bodies so keep in mind that you may want to wake them up manually before a gravity change.   
   * 
   * It is possible to change the way gravity affects a specific rigid-body by setting the rigid-body's gravity scale to a value other than 1.0. The magnitude of the gravity applied to this body will be multiplied by this scaling factor. Therefore, a gravity scale set to 0.0 will disable gravity for the rigid-body whereas a gravity scale set to 2.0 will make it twice as strong. A negative value will flip the direction of the gravity for this rigid-body.
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#gravity
   */
  set gravityScale(t) {
    this._gravityScale = t;
  }
  get gravityScale() {
    return this._gravityScale;
  }
  awake() {
    this._watch = void 0, this._propertiesChanged = !1;
  }
  onEnable() {
    this._watch || (this._watch = new RM(this.gameObject, this.context)), this._watch.start(!0, !0), this.startCoroutine(this.beforePhysics(), Re.LateUpdate), z() && (globalThis.true ? D.RAPIER_PHYSICS.ready().then(async () => {
      var t;
      await ku(3), (t = this.context.physics.engine) != null && t.getBody(this) || console.warn(`Rigidbody could not be created. Ensure "${this.name}" has a Collider component.`);
    }) : console.warn("Rigidbody could not be created: Rapier physics are explicitly disabled."));
  }
  onDisable() {
    var t, e;
    (t = this._watch) == null || t.stop(), (e = this.context.physics.engine) == null || e.removeBody(this);
  }
  onDestroy() {
    var t;
    (t = this.context.physics.engine) == null || t.removeBody(this);
  }
  onValidate() {
    this._propertiesChanged = !0;
  }
  // need to do this right before updating physics to prevent rendered object glitching through physical bodies
  *beforePhysics() {
    var t, e, i, n;
    for (; ; )
      this._propertiesChanged && (this._propertiesChanged = !1, (t = this.context.physics.engine) == null || t.updateProperties(this)), (e = this._watch) != null && e.isDirty ? (this._watch.mute = !0, this._watch.applyValues(), (i = this.context.physics.engine) == null || i.updateBody(this, this._watch.positionChanged, this._watch.rotationChanged), this._watch.reset()) : (n = this._watch) == null || n.syncValues(), this.captureVelocity(), yield;
  }
  /** Teleport the rigidbody to a new position in the world.   
   * Will reset forces before setting the object world position 
   * @param pt The new position to teleport the object to (world space)
   * @param localspace When true the object will be teleported in local space, otherwise in world space
   * */
  teleport(t, e = !0) {
    var i;
    (i = this._watch) == null || i.reset(!0), e ? this.gameObject.position.set(t.x, t.y, t.z) : this.setWorldPosition(t.x, t.y, t.z), this.resetForcesAndTorques(), this.resetVelocities();
  }
  resetForces(t = !0) {
    var e;
    (e = this.context.physics.engine) == null || e.resetForces(this, t);
  }
  resetTorques(t = !0) {
    var e;
    (e = this.context.physics.engine) == null || e.resetTorques(this, t);
  }
  resetVelocities() {
    this.setVelocity(0, 0, 0), this.setAngularVelocity(0, 0, 0);
  }
  resetForcesAndTorques() {
    this.resetForces(), this.resetTorques();
  }
  /** When a dynamic rigid-body doesn't move (or moves very slowly) during a few seconds, it will be marked as sleeping by the physics pipeline. Rigid-bodies marked as sleeping are no longer simulated by the physics engine until they are woken up. That way the physics engine doesn't waste any computational resources simulating objects that don't actually move. They are woken up automatically whenever another non-sleeping rigid-body starts interacting with them (either with a joint, or with one of its attached colliders generating contacts).  
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#sleeping */
  wakeUp() {
    var t;
    (t = this.context.physics.engine) == null || t.wakeup(this);
  }
  get isSleeping() {
    var t;
    return (t = this.context.physics.engine) == null ? void 0 : t.isSleeping(this);
  }
  /** Call to force an update of the rigidbody properties in the physics engine */
  updateProperties() {
    var t;
    return this._propertiesChanged = !1, (t = this.context.physics.engine) == null ? void 0 : t.updateProperties(this);
  }
  /** Forces affect the rigid-body's acceleration whereas impulses affect the rigid-body's velocity 
   * the acceleration change is equal to the force divided by the mass:
   * @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  applyForce(t, e, i = !0) {
    var n;
    this._propertiesChanged && this.updateProperties(), (n = this.context.physics.engine) == null || n.addForce(this, t, i);
  }
  /** Forces affect the rigid-body's acceleration whereas impulses affect the rigid-body's velocity 
   * the velocity change is equal to the impulse divided by the mass  
   * @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  applyImpulse(t, e = !0) {
    var i;
    this._propertiesChanged && this.updateProperties(), (i = this.context.physics.engine) == null || i.applyImpulse(this, t, e);
  }
  /** @link see https://rapier.rs/docs/user_guides/javascript/rigid_bodies#forces-and-impulses */
  setForce(t, e, i, n = !0) {
    var o, a, l;
    (o = this.context.physics.engine) == null || o.resetForces(this, n), typeof t == "number" ? (e ?? (e = 0), i ?? (i = 0), (a = this.context.physics.engine) == null || a.addForce(this, { x: t, y: e, z: i }, n)) : (l = this.context.physics.engine) == null || l.addForce(this, t, n);
  }
  /** The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the center-of-mass of the rigid-body. This method returns the current linear velocity of the rigid-body. 
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#velocity */
  getVelocity() {
    var e;
    const t = (e = this.context.physics.engine) == null ? void 0 : e.getLinearVelocity(this);
    return t ? (this._currentVelocity.x = t.x, this._currentVelocity.y = t.y, this._currentVelocity.z = t.z, this._currentVelocity) : this._currentVelocity.set(0, 0, 0);
  }
  setVelocity(t, e, i, n = !0) {
    var o, a;
    if (t instanceof v) {
      const l = t;
      (o = this.context.physics.engine) == null || o.setLinearVelocity(this, l, n);
      return;
    }
    e === void 0 || i === void 0 || (a = this.context.physics.engine) == null || a.setLinearVelocity(this, { x: t, y: e, z: i }, n);
  }
  /** The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the center-of-mass of the rigid-body. This method returns the current angular velocity of the rigid-body. 
   * @link https://rapier.rs/docs/user_guides/javascript/rigid_bodies#velocity */
  getAngularVelocity() {
    var e;
    const t = (e = this.context.physics.engine) == null ? void 0 : e.getAngularVelocity(this);
    return t ? (this._currentVelocity.x = t.x, this._currentVelocity.y = t.y, this._currentVelocity.z = t.z, this._currentVelocity) : this._currentVelocity.set(0, 0, 0);
  }
  setAngularVelocity(t, e, i, n = !0) {
    var o, a;
    if (typeof t == "object") {
      const l = t;
      (o = this.context.physics.engine) == null || o.setAngularVelocity(this, l, n);
      return;
    }
    if (e === void 0 || i === void 0 || typeof e == "boolean") {
      console.warn("setAngularVelocity expects either a Vec3 or 3 numbers");
      return;
    }
    (a = this.context.physics.engine) == null || a.setAngularVelocity(this, { x: t, y: e, z: i }, n);
  }
  setTorque(t, e, i) {
    typeof t == "number" ? this.setAngularVelocity(t, e, i) : this.setAngularVelocity(t);
  }
  /** 
   * Returns the rigidbody velocity smoothed over ~ 10 frames
   */
  get smoothedVelocity() {
    return this._smoothedVelocityGetter.copy(this._smoothedVelocity), this._smoothedVelocityGetter.multiplyScalar(1 / this.context.time.deltaTime);
  }
  /**d
   * @deprecated not used anymore and will be removed in a future update
   */
  setBodyFromGameObject(t = null) {
  }
  captureVelocity() {
    const t = this.gameObject.matrixWorld;
    Cd.tempPosition.setFromMatrixPosition(t);
    const e = Cd.tempPosition.sub(this._lastPosition);
    this._lastPosition.copy(Cd.tempPosition), this._smoothedVelocity.lerp(e, this.context.time.deltaTime / 0.1);
  }
}, r(Bp, "tempPosition", new v()), Bp);
let _e = Cd;
Ti([
  Nt()
], _e.prototype, "autoMass", 2);
Ti([
  f()
], _e.prototype, "mass", 1);
Ti([
  Nt(),
  f()
], _e.prototype, "useGravity", 2);
Ti([
  f(v)
], _e.prototype, "centerOfMass", 2);
Ti([
  Nt(),
  f()
], _e.prototype, "constraints", 2);
Ti([
  Nt(),
  f()
], _e.prototype, "isKinematic", 2);
Ti([
  Nt(),
  f()
], _e.prototype, "drag", 2);
Ti([
  Nt(),
  f()
], _e.prototype, "angularDrag", 2);
Ti([
  Nt(),
  f()
], _e.prototype, "detectCollisions", 2);
Ti([
  Nt(),
  f()
], _e.prototype, "sleepThreshold", 2);
Ti([
  Nt(),
  f()
], _e.prototype, "collisionDetectionMode", 2);
Ti([
  Nt()
], _e.prototype, "_gravityScale", 2);
Ti([
  Nt()
], _e.prototype, "dominanceGroup", 2);
new v();
new v();
const Ks = x("debugsync"), Uc = "STRS";
q0(Uc, vs.getRootAsSyncedTransformModel);
const Rn = new ug();
function jv(s, t, e = !0) {
  Rn.clear();
  const i = Rn.createString(s);
  vs.startSyncedTransformModel(Rn), vs.addGuid(Rn, i), vs.addFast(Rn, e);
  const n = t.worldPosition, o = t.worldEuler, a = t.gameObject.scale;
  vs.addTransform(Rn, Lv.createTransform(Rn, n.x, n.y, n.z, o.x, o.y, o.z, a.x, a.y, a.z));
  const l = vs.endSyncedTransformModel(Rn);
  return Rn.finish(l, Uc), Rn.asUint8Array();
}
let Rm = 0, gc = 0;
CM((s) => {
  var i;
  const e = ((i = s.connection.currentServerUrl) == null ? void 0 : i.includes("glitch")) ? 10 : 40;
  gc = Math.floor(Rm / e), Rm = 0, Ks && gc > 0 && console.log("Sync Transform Fast Interval", gc);
});
class As extends I {
  constructor() {
    super(...arguments);
    // public autoOwnership: boolean = true;
    /** When true, overrides physics behavior when this object is owned by the local user */
    r(this, "overridePhysics", !0);
    /** Whether to smoothly interpolate position changes when receiving updates */
    r(this, "interpolatePosition", !0);
    /** Whether to smoothly interpolate rotation changes when receiving updates */
    r(this, "interpolateRotation", !0);
    /** When true, sends updates at a higher frequency, useful for fast-moving objects */
    r(this, "fastMode", !1);
    /** When true, notifies other clients when this object is destroyed */
    r(this, "syncDestroy", !1);
    // private _state!: SyncedTransformModel;
    r(this, "_model", null);
    r(this, "_needsUpdate", !0);
    r(this, "rb", null);
    r(this, "_wasKinematic", !1);
    r(this, "_receivedDataBefore", !1);
    r(this, "_targetPosition");
    r(this, "_targetRotation");
    r(this, "_receivedFastUpdate", !1);
    r(this, "_shouldRequestOwnership", !1);
    r(this, "joinedRoomCallback", null);
    r(this, "receivedDataCallback", null);
    r(this, "tempEuler", new jt());
    r(this, "receivedUpdate", !1);
    r(this, "lastPosition");
    r(this, "lastRotation");
    r(this, "lastScale");
  }
  /** 
   * Requests ownership of this object on the network.
   * You need to be connected to a room for this to work.
   */
  requestOwnership() {
    Ks && console.log("Request ownership"), this._model ? this._model.requestOwnership() : (this._shouldRequestOwnership = !0, this._needsUpdate = !0);
  }
  /**
   * Checks if this client has ownership of the object
   * @returns true if this client has ownership, false if not, undefined if ownership state is unknown
   */
  hasOwnership() {
    var e;
    return ((e = this._model) == null ? void 0 : e.hasOwnership) ?? void 0;
  }
  /**
   * Checks if the object is owned by any client
   * @returns true if the object is owned, false if not, undefined if ownership state is unknown
   */
  isOwned() {
    var e;
    return (e = this._model) == null ? void 0 : e.isOwned;
  }
  /** @internal */
  awake() {
    Ks && console.log("new instance", this.guid, this), this._receivedDataBefore = !1, this._targetPosition = new v(), this._targetRotation = new W(), this.lastPosition = new v(), this.lastRotation = new W(), this.lastScale = new v(), this.rb = S.getComponentInChildren(this.gameObject, _e), this.rb && (this._wasKinematic = this.rb.isKinematic), this.receivedUpdate = !0, this._model = new X0(this.context.connection, this.guid), this.context.connection.isConnected && this.tryGetLastState(), this.joinedRoomCallback = this.tryGetLastState.bind(this), this.context.connection.beginListen(ne.JoinedRoom, this.joinedRoomCallback), this.receivedDataCallback = this.onReceivedData.bind(this), this.context.connection.beginListenBinary(Uc, this.receivedDataCallback);
  }
  /** @internal */
  onDestroy() {
    this.syncDestroy && av(this.guid, this.context.connection), this._model = null, this.context.connection.stopListen(ne.JoinedRoom, this.joinedRoomCallback), this.context.connection.stopListenBinary(Uc, this.receivedDataCallback);
  }
  /**
   * Attempts to retrieve and apply the last known network state for this transform
   */
  tryGetLastState() {
    const e = this.context.connection.tryGetState(this.guid);
    e && this.onReceivedData(e);
  }
  /**
   * Handles incoming network data for this transform
   * @param data The model containing transform information
   */
  onReceivedData(e) {
    var i;
    if (!this.destroyed && typeof e.guid == "function" && e.guid() === this.guid) {
      Ks && console.log("new data", this.context.connection.connectionId, this.context.time.frameCount, this.guid, e), this.receivedUpdate = !0, this._receivedFastUpdate = e.fast();
      const n = e.transform();
      if (n) {
        _n.markDirty(this.gameObject, !0);
        const o = n.position();
        o && (this.interpolatePosition && ((i = this._targetPosition) == null || i.set(o.x(), o.y(), o.z())), (!this.interpolatePosition || !this._receivedDataBefore) && this.setWorldPosition(o.x(), o.y(), o.z()));
        const a = n.rotation();
        a && (this.tempEuler.set(a.x(), a.y(), a.z()), this.interpolateRotation && this._targetRotation.setFromEuler(this.tempEuler), (!this.interpolateRotation || !this._receivedDataBefore) && T0(this.gameObject, this.tempEuler));
        const l = n.scale();
        l && this.gameObject.scale.set(l.x(), l.y(), l.z());
      }
      this._receivedDataBefore = !0;
    }
  }
  /** 
   * @internal 
   * Initializes tracking of position and rotation when component is enabled
   */
  onEnable() {
    this.lastPosition.copy(this.worldPosition), this.lastRotation.copy(this.worldQuaternion), this.lastScale.copy(this.gameObject.scale), this._needsUpdate = !0, this._model && this._model.updateIsOwned();
  }
  /** 
   * @internal 
   * Releases ownership when component is disabled
   */
  onDisable() {
    this._model && this._model.freeOwnership();
  }
  /** 
   * @internal 
   * Handles transform synchronization before each render frame
   * Sends updates when owner, receives and applies updates when not owner
   */
  onBeforeRender() {
    if (!this.activeAndEnabled || !this.context.connection.isConnected)
      return;
    if (!this.context.connection.isInRoom || !this._model) {
      Ks && console.log("no model or room", this.name, this.guid, this.context.connection.isInRoom);
      return;
    }
    this._shouldRequestOwnership && (this._shouldRequestOwnership = !1, this._model.requestOwnership());
    const e = this.worldPosition, i = this.worldQuaternion, n = this.gameObject.scale;
    if (this._model.isOwned && !this.receivedUpdate) {
      const l = this._model.hasOwnership || this.fastMode ? 1e-4 : 1e-3;
      (e.distanceTo(this.lastPosition) > l || i.angleTo(this.lastRotation) > l || n.distanceTo(this.lastScale) > l) && (this._model.hasOwnership ? this._needsUpdate = !0 : (Ks && console.log(this.guid, "reset because not owned but", this.gameObject.name, this.lastPosition), this.worldPosition = this.lastPosition, e.copy(this.lastPosition), this.worldQuaternion = this.lastRotation, i.copy(this.lastRotation), this.gameObject.scale.copy(this.lastScale), _n.markDirty(this.gameObject, !0), this._needsUpdate = !1));
    }
    if (this._model && !this._model.hasOwnership && this._model.isOwned && this._receivedDataBefore) {
      const c = this._receivedFastUpdate || this.fastMode ? 0.5 : 0.3;
      let h = !1;
      if (this.interpolatePosition && this._targetPosition) {
        const d = this.worldPosition;
        d.lerp(this._targetPosition, c), this.worldPosition = d, h = !0;
      }
      if (this.interpolateRotation && this._targetRotation) {
        const d = this.worldQuaternion;
        d.slerp(this._targetRotation, c), this.worldQuaternion = d, h = !0;
      }
      h && _n.markDirty(this.gameObject, !0);
    }
    if (this.receivedUpdate = !1, this.lastPosition.copy(e), this.lastRotation.copy(i), this.lastScale.copy(n), !this._model || !this._model || this._model.hasOwnership === void 0 || !this._model.hasOwnership)
      return;
    this.rb && this.overridePhysics && this._wasKinematic !== void 0 && (Ks && console.log("reset kinematic", this.rb.name, this._wasKinematic), this.rb.isKinematic = this._wasKinematic);
    const o = 10, a = this.rb || this.fastMode;
    if (this._needsUpdate && (this.context.time.frameCount % o === 0 || a)) {
      if (Rm++, a && gc > 0 && this.context.time.frameCount % gc !== 0)
        return;
      Ks && console.log("send update", this.context.connection.connectionId, this.guid, this.gameObject.name, this.gameObject.guid), this._needsUpdate = !1;
      const l = jv(this.guid, this, !!a);
      this.context.connection.sendBinary(l);
    }
  }
}
const kM = x("debugshadowcomponents");
m0.prototype.interactable = {
  get() {
    return this.interactive;
  },
  set(s) {
    this.interactable = s;
  }
};
const Yi = Symbol("shadowDomOwner");
class xn extends I {
  constructor() {
    super(...arguments);
    r(this, "_shadowComponent", null);
    r(this, "_controlsChildLayout", !0);
    r(this, "_root");
    // private _intermediate?: Object3D;
    r(this, "_parentComponent");
  }
  /** Is this object on the root of the UI hierarchy ? */
  isRoot() {
    var e;
    return ((e = this.Root) == null ? void 0 : e.gameObject) === this.gameObject;
  }
  /** Access the parent canvas component */
  get canvas() {
    const e = this.Root;
    return e != null && e.isCanvas ? e : null;
  }
  /** @deprecated use `canvas` */
  get Canvas() {
    return this.canvas;
  }
  /** Mark the UI dirty which will trigger an THREE-Mesh-UI update */
  markDirty() {
    di.markUIDirty(this.context);
  }
  /** the underlying three-mesh-ui */
  get shadowComponent() {
    return this._shadowComponent;
  }
  set shadowComponent(e) {
    this._shadowComponent = e;
  }
  get controlsChildLayout() {
    return this._controlsChildLayout;
  }
  set controlsChildLayout(e) {
    this._controlsChildLayout = e, this.shadowComponent && (this.shadowComponent.autoLayout = e);
  }
  get Root() {
    return this._root === void 0 && (this._root = S.getComponentInParent(this.gameObject, Vu)), this._root;
  }
  __internalNewInstanceCreated(e) {
    return super.__internalNewInstanceCreated(e), this.shadowComponent = null, this._root = void 0, this._parentComponent = void 0, this;
  }
  onEnable() {
    super.onEnable();
  }
  /** Add a three-mesh-ui object to the UI hierarchy 
   * @param container the three-mesh-ui object to add
   * @param parent the parent component to add the object to
  */
  addShadowComponent(e, i) {
    var a;
    if (!e)
      return;
    this.removeShadowComponent();
    const n = this.isRoot() ? this.gameObject : this.gameObject.parent;
    if (this._parentComponent = S.getComponentInParent(n, xn), !this._parentComponent) {
      console.warn(`Component "${this.name}" doesn't have a UI parent anywhere. Do you have an UI element outside a Canvas? UI components must be a child of a Canvas component`, this);
      return;
    }
    e.name = this.name + " (" + (this.constructor.name ?? "UI") + ")", e.autoLayout = this._parentComponent.controlsChildLayout, e[Yi] = this, this.setShadowComponentOwner(e);
    let o = !1;
    if (((a = this.Root) == null ? void 0 : a.gameObject) === this.gameObject)
      this.gameObject.add(e);
    else {
      const l = this._parentComponent.shadowComponent;
      l && (l == null || l.add(e), o = !0);
    }
    this.shadowComponent = e, i && i.shadowComponent && this.shadowComponent && i.shadowComponent.add(this.shadowComponent), Xc && e.add(new Oi(0.5)), this.onAfterAddedToScene(), o && MS(), kM && console.warn("Added shadow component", this.shadowComponent);
  }
  setShadowComponentOwner(e) {
    if (e && (e[Yi] === void 0 || e[Yi] === this) && (e[Yi] = this, e.children))
      for (const i of e.children)
        this.setShadowComponentOwner(i);
  }
  traverseOwnedShadowComponents(e, i, n) {
    if (e && e[Yi] === i) {
      n(e);
      for (const o of e.children)
        this.traverseOwnedShadowComponents(o, i, n);
    }
  }
  /** Remove the underlying UI object from the hierarchy */
  removeShadowComponent() {
    this.shadowComponent && this.shadowComponent.removeFromParent();
  }
  onAfterAddedToScene() {
  }
  setInteractable(e) {
    this.shadowComponent && (this.shadowComponent.interactable = e);
  }
}
class Vu extends xn {
  awake() {
    super.awake();
  }
}
class Hu {
  constructor(t, e) {
    /** the original event */
    r(this, "event");
    /** 
     * mouse button 0 === LEFT, 1 === MIDDLE, 2 === RIGHT 
     * */
    r(this, "button");
    r(this, "buttonName");
    r(this, "_used", !1);
    r(this, "_propagationStopped", !1);
    /**@ignore internal flag, pointer captured (we dont want to see it in intellisense) */
    r(this, "z__pointer_ctured", !1);
    /**@ignore internal flag, pointer capture released */
    r(this, "z__pointer_cture_rleased", !1);
    /** Who initiated this event */
    r(this, "inputSource");
    /** The object this event hit or interacted with */
    r(this, "object");
    /** The world position of this event */
    r(this, "point");
    /** The object-space normal of this event */
    r(this, "normal");
    /** */
    r(this, "face");
    /** The distance of the hit point from the origin */
    r(this, "distance");
    /** The instance ID of an object hit by a raycast (if a instanced object was hit) */
    r(this, "instanceId");
    /** The three intersection */
    r(this, "intersection");
    r(this, "isDown");
    r(this, "isUp");
    r(this, "isPressed");
    r(this, "isClick");
    r(this, "isDoubleClick");
    r(this, "input");
    this.event = e, this.input = t, this.button = e.button;
  }
  /** the index of the used device   
   * mouse and touch are always 0, controller is the gamepad index or XRController index
  */
  get deviceIndex() {
    return this.event.deviceIndex;
  }
  /** a combination of the pointerId + button to uniquely identify the exact input (e.g. LeftController:Button0 = 0, RightController:Button1 = 101) */
  get pointerId() {
    return this.event.pointerId;
  }
  get pressure() {
    return this.event.pressure;
  }
  /** @returns `true` when `use()` has been called. Default: false */
  get used() {
    return this._used;
  }
  /** mark this event to be used */
  use() {
    this._used || (this._used = !0, this.event.use());
  }
  get propagationStopped() {
    return this._propagationStopped;
  }
  /** Call this method to stop immediate propagation on the `event` object.   
   * WARNING: this is currently equivalent to stopImmediatePropagation   
   */
  stopPropagation() {
    this._propagationStopped = !0, this.event.stopImmediatePropagation();
  }
  /** Call this method to stop immediate propagation on the `event` object.   
   */
  stopImmediatePropagation() {
    this._propagationStopped = !0, this.event.stopImmediatePropagation();
  }
  /** Call this method in `onPointerDown` or `onPointerMove` to receive onPointerMove events for this pointerId even when the pointer has left the object until you call `releasePointerCapture` or when the pointerUp event happens 
  */
  setPointerCapture() {
    this.z__pointer_ctured = !0;
  }
  /** call this method in `onPointerDown` or `onPointerMove` to stop receiving onPointerMove events */
  releasePointerCapture() {
    this.z__pointer_cture_rleased = !0;
  }
  /** Returns the input target ray mode e.g. "screen" for 2D mouse and touch events */
  get mode() {
    return this.event.mode;
  }
  clone() {
    const t = new Hu(this.input, this.event);
    return Object.assign(t, this), t;
  }
  /**@deprecated use use() */
  Use() {
    this.use();
  }
  /**@deprecated use stopPropagation() */
  StopPropagation() {
    this.event.stopImmediatePropagation();
  }
}
function km(s, t) {
  return S.foreachComponent(s, (i) => {
    if (!i.enabled)
      return;
    const n = i;
    if (t)
      switch (t) {
        case "pointerdown":
          if (n.onPointerDown)
            return !0;
          break;
        case "pointerup":
          if (n.onPointerUp || n.onPointerClick)
            return !0;
          break;
        case "pointermove":
          if (n.onPointerEnter || n.onPointerExit || n.onPointerMove)
            return !0;
          break;
      }
    else if (n.onPointerDown || n.onPointerUp || n.onPointerEnter || n.onPointerExit || n.onPointerClick)
      return !0;
  }, !1) === !0;
}
const ss = new Array();
class io {
  constructor(t, e, i, n) {
    /**
     * When the CallInfo is enabled it will be invoked when the EventList is invoked
     */
    r(this, "enabled", !0);
    /**
     * The target object to invoke the method on OR the function to invoke
     */
    r(this, "target");
    r(this, "methodName");
    /**
     * The arguments to invoke this method with
     */
    r(this, "arguments");
    this.target = t, this.methodName = e || null, this.arguments = i, n != null && (this.enabled = n);
  }
  get canClone() {
    return this.target instanceof Object;
  }
  invoke(...t) {
    if (this.enabled !== !1) {
      if (typeof this.target == "function")
        this.arguments ? (ss.length = 0, t !== void 0 && t.length > 0 && ss.push(...t), ss.push(...this.arguments), this.target(...this.arguments), ss.length = 0) : this.target(...t);
      else if (this.methodName != null) {
        const e = this.target[this.methodName];
        typeof e == "function" ? this.arguments ? (ss.length = 0, t !== void 0 && t.length > 0 && ss.push(...t), ss.push(...this.arguments), e.call(this.target, ...ss), ss.length = 0) : e.call(this.target, ...t) : this.arguments ? this.target[this.methodName] = this.arguments[0] || t[0] : this.target[this.methodName] = t[0];
      }
    }
  }
}
const TM = (s) => /^[A-Z]*$/.test(s);
class Lg extends Event {
  constructor() {
    super(...arguments);
    //implements ArrayLike<T> {
    r(this, "args");
  }
}
class xe {
  constructor(t) {
    /** checked during instantiate to create a new instance */
    r(this, "isEventList", !0);
    r(this, "target");
    r(this, "key");
    r(this, "_isInvoking", !1);
    // TODO: can we make functions serializable?
    r(this, "methods", []);
    r(this, "_methodsCopy", []);
    if (this.methods = [], Array.isArray(t))
      for (const e of t)
        e instanceof io ? this.methods.push(e) : typeof e == "function" && this.methods.push(new io(e));
    else
      typeof t == "function" && this.methods.push(new io(t));
  }
  /**
   * @internal Used by the Needle Engine instantiate call to remap the event listeners to the new instance
   */
  __internalOnInstantiate(t) {
    var n;
    const e = new Array();
    for (let o = 0; o < this.methods.length; o++) {
      const a = this.methods[o];
      if (!(a.target instanceof Function)) {
        const l = a.target;
        let c = l == null ? void 0 : l.uuid;
        if (l && (c = l.guid), c) {
          const h = t[c];
          if (h) {
            const d = (n = a.arguments) == null ? void 0 : n.map((u) => u instanceof Object && u.uuid ? t[u.uuid] : u != null && u.isComponent ? t[u.guid] : u);
            e.push(new io(h.clone, a.methodName, d, a.enabled));
          } else
            z() && console.warn("Could not find target for event listener");
        }
      }
    }
    return new xe(e);
  }
  // TODO: serialization should not take care of the args but instead give them to the eventlist directly
  // so we can handle passing them on here instead of in the serializer
  // this would also allow us to pass them on to the component EventTarget
  /** set an event target to try invoke the EventTarget dispatchEvent when this EventList is invoked */
  setEventTarget(t, e) {
    if (this.key = t, this.target = e, this.key !== void 0) {
      let i = "", n = !1;
      for (const o of this.key)
        n && TM(o) && (i += "-"), n = !0, i += o.toLowerCase();
      this.key = i;
    }
  }
  /** How many callback methods are subscribed to this event */
  get listenerCount() {
    var t;
    return ((t = this.methods) == null ? void 0 : t.length) ?? 0;
  }
  /** If the event is currently being invoked */
  get isInvoking() {
    return this._isInvoking;
  }
  static from(...t) {
    return new xe(t);
  }
  /** Invoke all the methods that are subscribed to this event */
  invoke(...t) {
    var e;
    if (this._isInvoking)
      return console.warn("Circular event invocation detected. Please check your event listeners for circular references.", this), !1;
    if (((e = this.methods) == null ? void 0 : e.length) <= 0)
      return !1;
    this._isInvoking = !0;
    try {
      this._methodsCopy.length = 0, this._methodsCopy.push(...this.methods);
      for (const i of this._methodsCopy)
        i.invoke(...t);
      if (typeof this.target == "object" && typeof this.key == "string") {
        const i = this.target.dispatchEvent;
        if (typeof i == "function") {
          const n = new Lg(this.key);
          n.args = t, i.call(this.target, n);
        }
      }
    } finally {
      this._isInvoking = !1, this._methodsCopy.length = 0;
    }
    return !0;
  }
  /** Add a new event listener to this event */
  addEventListener(t) {
    return this.methods.push(new io(t)), t;
  }
  removeEventListener(t) {
    if (t)
      for (let e = this.methods.length - 1; e >= 0; e--)
        this.methods[e].target === t && (this.methods[e].enabled = !1, this.methods.splice(e, 1));
  }
  removeAllEventListeners() {
    this.methods.length = 0;
  }
}
class AM extends rn {
  constructor() {
    super([ae, we], "ColorSerializer");
  }
  onDeserialize(t) {
    if (t != null)
      return t.a !== void 0 ? new we(t.r, t.g, t.b, t.a) : t.alpha !== void 0 ? new we(t.r, t.g, t.b, t.alpha) : new ae(t.r, t.g, t.b);
  }
  onSerialize(t) {
    if (t != null)
      return t.a !== void 0 ? { r: t.r, g: t.g, b: t.b, a: t.a } : { r: t.r, g: t.g, b: t.b };
  }
}
const GD = new AM();
class EM extends rn {
  constructor() {
    super([jt], "EulerSerializer");
  }
  onDeserialize(t, e) {
    if (t != null) {
      if (t.order)
        return new jt(t.x, t.y, t.z, t.order);
      if (t.x != null)
        return new jt(t.x, t.y, t.z);
    }
  }
  onSerialize(t, e) {
    return { x: t.x, y: t.y, z: t.z, order: t.order };
  }
}
const qD = new EM();
class IM extends rn {
  constructor() {
    super(L, "ObjectSerializer");
  }
  onSerialize(t, e) {
    if (e.objectToNode !== void 0 && t.uuid) {
      const i = e.objectToNode[t.uuid];
      return gt && console.log(i, t.name, t.uuid), { node: i };
    }
  }
  onDeserialize(t, e) {
    var i, n, o;
    if (typeof t == "string") {
      if (t.endsWith(".glb") || t.endsWith(".gltf")) {
        if (e.serializable instanceof Array && e.serializable.includes(re))
          return;
        z() && ve("Detected wrong usage of @serializable with Object3D or GameObject. Instead you should use AssetReference here! Please see the console for details.");
        const a = (n = (i = e.target) == null ? void 0 : i.constructor) == null ? void 0 : n.name;
        console.warn(`Wrong usage of @serializable detected in your script "${a}"

It looks like you used @serializable(Object3D) or @serializable(GameObject) for a prefab or scene reference which is exported to a separate glTF file.

To fix this please change your code to:

@serializable(AssetReference)
${e.path}! : AssetReference;
\0`);
      }
      return;
    }
    if (t) {
      if (t.node !== void 0 && e.nodeToObject) {
        const a = e.nodeToObject[t.node];
        return gt && console.log("Deserialized object reference?", t, a, e == null ? void 0 : e.nodeToObject), a || console.warn("Did not find node: " + t.node, e.nodeToObject, e.object), a;
      } else if (t.guid) {
        if (!e.context) {
          console.error("Missing context");
          return;
        }
        let a;
        const l = (o = e.gltf) == null ? void 0 : o.scene;
        return l && (a = S.findByGuid(t.guid, l)), a || (a = S.findByGuid(t.guid, e.context.scene)), a ? (a && a.isComponent === !0 && (gt && console.warn("Deserialized object reference is a component"), a = a.gameObject), gt && console.log("Deserialized object reference?", t, a, e == null ? void 0 : e.nodeToObject)) : ((z() || gt) && console.warn("Could not resolve object reference", e.path, t, e.target, e.context.scene), t.could_not_resolve = !0), a;
      }
    }
  }
}
const DM = new IM();
class LM extends rn {
  constructor() {
    super([I, I], "ComponentSerializer");
  }
  onSerialize(t, e) {
    if (t != null && t.guid)
      return { guid: t.guid };
  }
  onDeserialize(t, e) {
    var i;
    if (t != null && t.guid) {
      if (t.___persistentAsset) {
        gt && console.log("Skipping component deserialization because it's a persistent asset", t);
        return;
      }
      const n = e.path;
      gt && console.log(t.guid, e.root, e.object, e.target);
      let o = this.findObjectForGuid(t.guid, e.root);
      if (o || e.context && (o = this.findObjectForGuid(t.guid, (i = e.context) == null ? void 0 : i.scene), o))
        return o;
      (z() || gt) && console.warn('Could not resolve component reference: "' + n + '" using guid ' + t.guid, e.target), t.could_not_resolve = !0;
      return;
    }
  }
  findObjectForGuid(t, e) {
    if (e.guid === t)
      return e;
    const i = S.foreachComponent(e, (n) => {
      if (n.guid === t)
        return n;
    }, !1);
    if (i !== void 0)
      return i;
    for (let n = 0; n < e.children.length; n++) {
      const o = e.children[n], a = this.findObjectForGuid(t, o);
      if (a)
        return a;
    }
  }
}
const Kf = new LM();
class jM extends rn {
  constructor() {
    super([xe]);
  }
  onSerialize(t, e) {
    console.log("TODO: SERIALIZE EVENT");
  }
  onDeserialize(t, e) {
    var i, n, o;
    if (typeof t == "function")
      return new xe([new io(t, null, [], !0)]);
    if (t && t.type === "EventList") {
      gt && console.log("DESERIALIZE EVENT", t);
      const a = new Array();
      if (t.calls && Array.isArray(t.calls))
        for (const h of t.calls) {
          let d = function(m) {
            if (typeof m == "object") {
              let g = DM.onDeserialize(m, e);
              if (g || (g = Kf.onDeserialize(m, e)), g)
                return g;
            }
            return m;
          };
          gt && console.log(h);
          let u = Kf.findObjectForGuid(h.target, e.root);
          !u && ((i = e.context) != null && i.scene) && (u = Kf.findObjectForGuid(h.target, (n = e.context) == null ? void 0 : n.scene));
          const p = ((o = h.method) == null ? void 0 : o.length) > 0;
          if (u && p) {
            const m = () => {
              const _ = h.method[0].toUpperCase() + h.method.slice(1);
              if (typeof u[_] == "function") {
                console.warn(`EventList method:
Could not find method ${h.method} on object ${u.name}. Please rename ${h.method} to ${_}?
`, u[_], `
 in script: `, u), ve("EventList methods must start with lowercase letter, see console for details");
                return;
              } else
                console.warn(`EventList method:
Could not find method ${h.method} on object ${u.name}`, u, typeof u[h.method]);
            };
            if (typeof u[h.method] != "function") {
              let _ = !1, y = u;
              for (; y; ) {
                const b = Object.getOwnPropertyDescriptor(y, h.method);
                if (b && (b.writable === !0 || b.set)) {
                  _ = !0;
                  break;
                }
                y = Object.getPrototypeOf(y);
              }
              !_ && (z() || gt) && m();
            }
          }
          if (u) {
            let m = h.argument;
            if (m !== void 0 ? m = d(m) : h.arguments !== void 0 && (m = h.arguments.map(d)), !u[h.method])
              console.warn(`EventList method not found: "${h.method}" on ${u == null ? void 0 : u.name}`);
            else {
              m !== void 0 && !Array.isArray(m) && (m = [m]);
              const _ = new io(u, h.method, m, h.enabled);
              a.push(_);
            }
          } else
            z() && console.warn("[Debug] EventList: Could not find event listener in scene", h, e.object, t);
        }
      const l = new xe(a);
      gt && console.log(l);
      const c = e.target;
      return c !== void 0 && e.path !== void 0 && l.setEventTarget(e.path, c), l;
    }
  }
  // private createEventMethod(target: object, methodName: string, args?: any): Function | undefined {
  //     return function (...forwardedArgs: any[]) {
  //         const method = target[methodName];
  //         if (typeof method === "function") {
  //             if (args !== undefined) {
  //                 // we now have support for creating event methods with multiple arguments
  //                 // an argument can not be an array right now - so if we receive an array we assume it's the array of arguments that we want to call the method with
  //                 // this means ["test", true] will invoke the method like this: myFunction("test", true) 
  //                 if (Array.isArray(args))
  //                     method?.call(target, ...args);
  //                 // in any other case (when we just have one argument) we just call the method with the argument
  //                 // we can not use ...args by default becaue that would break string arguments (it would then just use the first character)
  //                 else
  //                     method?.call(target, args);
  //             }
  //             else // support invoking EventList with any number of arguments (if none were declared in unity)
  //                 method?.call(target, ...forwardedArgs);
  //         }
  //         else // the target "method" can be a property too
  //         {
  //             target[methodName] = args;
  //         }
  //     };
  // }
}
const XD = new jM(), Yd = /* @__PURE__ */ new WeakMap(), BM = Fe.prototype.clone;
Fe.prototype.clone = function() {
  const s = BM.call(this);
  return Yd.has(s) || Yd.set(s, this), s;
};
class FM extends rn {
  constructor() {
    super([pr, ks]);
  }
  onSerialize(t, e) {
  }
  onDeserialize(t, e) {
    if (t instanceof Fe && e.type === pr) {
      let i = t;
      Yd.has(i) && (i = Yd.get(i)), i.isRenderTargetTexture = !0, i.flipY = !0, i.offset.y = 1, i.repeat.y = -1, i.needsUpdate = !0, i.mipmaps = [], i instanceof qx && (i.isCompressedTexture = !1, i.format = Su);
      const n = new pr(i.image.width, i.image.height, {
        colorSpace: wr
      });
      return n.texture = i, n;
    }
  }
}
new FM();
class zM extends rn {
  constructor() {
    super([URL]);
  }
  onSerialize(t, e) {
    return null;
  }
  onDeserialize(t, e) {
    if (typeof t == "string" && t.length > 0)
      return Tr(e.gltfId, t);
  }
}
new zM();
var UM = Object.defineProperty, NM = Object.getOwnPropertyDescriptor, $M = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? NM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && UM(t, e, n), n;
};
class qa extends I {
  awake() {
    di.createIfNoneExists(this.context);
  }
  onEnable() {
    var t;
    (t = di.get(this.context)) == null || t.register(this);
  }
  onDisable() {
    var t;
    (t = di.get(this.context)) == null || t.unregister(this);
  }
}
class sn extends qa {
  constructor() {
    super(...arguments);
    r(this, "targets", null);
    r(this, "raycastHits", []);
    r(this, "ignoreSkinnedMeshes", !1);
  }
  start() {
    this.targets = [this.gameObject];
  }
  performRaycast(e = null) {
    if (!this.targets)
      return null;
    e ?? (e = new Ts()), e.targets = this.targets, e.results = this.raycastHits, e.useAcceleratedRaycast = !0;
    const i = e.testObject;
    this.ignoreSkinnedMeshes && (e.testObject = (o) => o instanceof Os ? "continue in children" : i ? i(o) : !0);
    const n = this.context.physics.raycast(e);
    return e.testObject = i, n;
  }
}
$M([
  f()
], sn.prototype, "ignoreSkinnedMeshes", 2);
class jg extends sn {
  // eventCamera: Camera | null = null;
  // ignoreReversedGraphics: boolean = false;
  // rootRaycaster: GraphicRaycaster | null = null;
  constructor() {
    super(), this.ignoreSkinnedMeshes = !0;
  }
}
const O_ = class extends qa {
  performRaycast(t) {
    if (!J.active || !O_.allow || !(t != null && t.ray))
      return null;
    const e = t.ray.origin, i = 0.015;
    return this.context.physics.sphereOverlap(e, i, !1, !0);
  }
};
let gr = O_;
/**
 * Use to disable SpatialGrabRaycaster globally
 */
r(gr, "allow", !0);
class Bv {
  /** returns the real object when dealing with shadow UI */
  static getObject(t) {
    const e = t[Yi];
    return e && (e.isComponent === !0 ? t = e.gameObject : t = e), t;
  }
  static isInteractable(t, e) {
    if (e && (e.canvasGroup = void 0, e.graphic = void 0), t == null || !t.visible || (t = this.getObject(t), !t.visible))
      return !1;
    const i = this.tryFindCanvasGroup(t);
    if ((i == null ? void 0 : i.isCanvasGroup) === !0 && (e && (e.canvasGroup = i), i.blocksRaycasts === !1 || i.interactable === !1))
      return !1;
    const n = Va(t, (o) => {
      if (o.isGraphic === !0)
        return o;
    }, !1);
    return e && (n == null ? void 0 : n.isGraphic) === !0 && (e.graphic = n), !((n == null ? void 0 : n.raycastTarget) === !1 || (n == null ? void 0 : n.layer) === 2);
  }
  static tryFindCanvasGroup(t) {
    if (!t)
      return null;
    const e = Va(t, (i) => {
      const n = i;
      if (n.blocksRaycasts !== void 0 && n.interactable !== void 0)
        return n;
    }, !1);
    return e !== void 0 ? e : this.tryFindCanvasGroup(t.parent);
  }
}
function Bg(s) {
  const t = s[Yi];
  return t || (s.parent ? Bg(s.parent) : null);
}
function WM(s) {
  return s.isUI === !0 || typeof s[Yi] == "object";
}
function Kd(s, t) {
  if (!s)
    return;
  const e = s.material;
  if ((e == null ? void 0 : e.isMaterial) === !0) {
    const i = s.parent;
    i && i.isText, e.side = t.doubleSided ?? !0 ? Ri : xo, e.shadowSide = t.doubleSided ? Ri : xo, s.castShadow = t.castShadows ? t.castShadows : !1, s.receiveShadow = t.receiveShadows ? t.receiveShadows : !1;
  }
  for (const i of s.children)
    Kd(i, t);
}
function ra(s, t, e) {
  s[t] === void 0 && console.warn("Field", t, "is undefined on", s);
  const i = Proxy.revocable(s[t], {
    // get(target, prop, receiver) {
    //     return Reflect.get(target, prop, receiver);
    // },
    set(a, l, c, h) {
      const d = a[l], u = Reflect.set(a, l, c, h);
      return e(c, d), u;
    }
  }), n = i.revoke, o = s[t];
  return i.revoke = () => {
    s[t] = o, n();
  }, s[t] = i.proxy, i;
}
const ib = Symbol("Scheduled action");
function VM(s, t, e = Re.OnBeforeRender) {
  let i = s[ib];
  i || (i = s[ib] = {});
  const n = t.name;
  i[e] || (i[e] = {});
  const o = i[e];
  if (o[n])
    return;
  function* l() {
    t == null || t.call(s), o[n] = null;
  }
  const c = s.startCoroutine(l(), e);
  o[n] = c;
}
const Zs = x("debugeventsystem");
var Tm = /* @__PURE__ */ ((s) => (s.BeforeHandleInput = "BeforeHandleInput", s.AfterHandleInput = "AfterHandleInput", s))(Tm || {});
xM((s) => {
  di.createIfNoneExists(s);
});
class di extends I {
  constructor() {
    super(...arguments);
    r(this, "raycaster", []);
    /**
     * all pointers that have pressed something
     * 
     * key: pointerId
     * value: object that was pressed, data of the pointer event, handlers that are releavant to the event
    */
    r(this, "pressedByID", /* @__PURE__ */ new Map());
    /**
     * all hovered objects
     * 
     * key: pointerId
     * value: object that is hovered, data of the pointer event
     */
    r(this, "hoveredByID", /* @__PURE__ */ new Map());
    /**
     * Handle an pointer event from the input system
     */
    r(this, "onPointerEvent", (e) => {
      if (e === void 0 || e.propagationStopped || e.defaultPrevented || e.used)
        return;
      const i = new Hu(this.context.input, e);
      this._currentPointerEventName = e.type, i.inputSource = this.context.input, i.isClick = e.isClick, i.isDoubleClick = e.isDoubleClick, i.isDown = e.type == Ne.PointerDown, i.isUp = e.type == Ne.PointerUp, i.isPressed = this.context.input.getPointerPressed(e.pointerId), Zs && (i.isDown ? console.log("DOWN", i.pointerId) : i.isUp && console.log("UP", i.pointerId), i.isClick && console.log("CLICK", i.pointerId));
      const n = new Ts();
      e.hasRay ? n.ray = e.ray : n.screenPoint = this.context.input.getPointerPositionRC(e.pointerId);
      const o = this.performRaycast(n);
      if (o) {
        for (const l of o)
          l.event = e, e.intersections.push(l);
        e.origin.onPointerHits && e.origin.onPointerHits({
          sender: this,
          event: e,
          hits: o
        });
      }
      Zs && i.isClick && We("EventSystem: " + i.pointerId + " - " + this.context.time.frame + " - Up:" + i.isUp + ", Down:" + i.isDown);
      const a = {
        sender: this,
        args: i,
        hasActiveUI: this.currentActiveMeshUIComponents.length > 0
      };
      this.dispatchEvent(new CustomEvent("BeforeHandleInput", { detail: a })), this.handleIntersections(o, i), this.dispatchEvent(new CustomEvent("AfterHandleInput", { detail: a }));
    });
    r(this, "_sortedHits", []);
    /** 
     * cache for objects that we want to raycast against. It's cleared before each call to performRaycast invoking raycasters
     */
    r(this, "_testObjectsCache", /* @__PURE__ */ new Map());
    /** that's the raycaster that is CURRENTLY being used for raycasting (the shouldRaycastObject method uses this) */
    r(this, "_currentlyActiveRaycaster", null);
    r(this, "_currentPointerEventName", null);
    /** 
     * Checks if an object that we encounter has an event component and if it does, we add it to our objects cache
     * If it doesnt we tell our raycasting system to ignore it and continue in the child hierarchy
     * We do this to avoid raycasts against objects that are not going to be used by the event system
     * Because there's no component callback to be invoked anyways. 
     * This is especially important to avoid expensive raycasts against SkinnedMeshes
     * 
     * Further optimizations would be to check what type of event we're dealing with
     * For example if an event component has only an onPointerClick method we don't need to raycast during movement events
     * */
    r(this, "shouldRaycastObject", (e) => {
      var a;
      const i = e && "getComponent" in e ? e.getComponent(qa) : null;
      if (i && i != this._currentlyActiveRaycaster)
        return !1;
      let n = null;
      if (WM(e) && (n = (a = e[Yi]) == null ? void 0 : a.gameObject), this._testObjectsCache.has(e) || n && this._testObjectsCache.has(n))
        return this._testObjectsCache.get(e) === !1 ? "continue in children" : !0;
      {
        let l = km(e, this._currentPointerEventName);
        if (!l && n && (l = km(n, this._currentPointerEventName)), l) {
          this._testObjectsCache.set(e, !0);
          for (const c of e.children)
            this.shouldRaycastObject_AddToYesCache(c);
          return !0;
        }
        return this._testObjectsCache.set(e, !1), "continue in children";
      }
    });
    r(this, "_sortingBuffer", []);
    r(this, "_noDepthTestingResults", []);
    r(this, "out", {});
    /** the list of component handlers that requested pointerCapture for a specific pointerId */
    r(this, "_capturedPointer", {});
    r(this, "pointerEnterSymbol", Symbol("pointerEnter"));
    r(this, "pointerExitSymbol", Symbol("pointerExit"));
    r(this, "currentActiveMeshUIComponents", []);
  }
  //@ts-ignore
  static ensureUpdateMeshUI(e, i, n = !1) {
    no.update(e, i, n);
  }
  static markUIDirty(e) {
    no.markDirty();
  }
  static createIfNoneExists(e) {
    e.scene.getComponent(di) || e.scene.addComponent(di);
  }
  static get(e) {
    return this.createIfNoneExists(e), e.scene.getComponent(di);
  }
  /** Get the currently active event system */
  static get instance() {
    return this.get(ee.Current);
  }
  register(e) {
    var i;
    e && this.raycaster && !this.raycaster.includes(e) && ((i = this.raycaster) == null || i.push(e));
  }
  unregister(e) {
    var n, o;
    const i = (n = this.raycaster) == null ? void 0 : n.indexOf(e);
    i !== void 0 && i !== -1 && ((o = this.raycaster) == null || o.splice(i, 1));
  }
  get hasActiveUI() {
    return this.currentActiveMeshUIComponents.length > 0;
  }
  get isHoveringObjects() {
    return this.hoveredByID.size > 0;
  }
  awake() {
    this.gameObject !== this.context.scene && (this.enabled = !1);
  }
  start() {
    this.context.scene.getComponent(qa) || this.context.scene.addComponent(sn);
  }
  onEnable() {
    this.context.input.addEventListener(Ne.PointerDown, this.onPointerEvent), this.context.input.addEventListener(Ne.PointerUp, this.onPointerEvent), this.context.input.addEventListener(Ne.PointerMove, this.onPointerEvent);
  }
  onDisable() {
    this.context.input.removeEventListener(Ne.PointerDown, this.onPointerEvent), this.context.input.removeEventListener(Ne.PointerUp, this.onPointerEvent), this.context.input.removeEventListener(Ne.PointerMove, this.onPointerEvent);
  }
  onBeforeRender() {
    this.resetMeshUIStates();
  }
  shouldRaycastObject_AddToYesCache(e) {
    this._testObjectsCache.set(e, !0);
    for (const i of e.children)
      this.shouldRaycastObject_AddToYesCache(i);
  }
  /** the raycast filter is always overriden */
  performRaycast(e) {
    if (!this.raycaster)
      return null;
    this._testObjectsCache.clear(), this._sortedHits.length = 0, e || (e = new Ts()), e.testObject = this.shouldRaycastObject;
    for (const i of this.raycaster) {
      if (!i.activeAndEnabled)
        continue;
      this._currentlyActiveRaycaster = i;
      const n = i.performRaycast(e);
      this._currentlyActiveRaycaster = null, n && n.length > 0 && this._sortedHits.push(...n);
    }
    return this._sortedHits.sort((i, n) => i.distance - n.distance), this._sortedHits;
  }
  assignHitInformation(e, i) {
    i ? (e.intersection = i, e.point = i.point, e.normal = i.normal, e.face = i.face, e.distance = i.distance, e.instanceId = i.instanceId) : (e.intersection = void 0, e.point = void 0, e.normal = void 0, e.face = void 0, e.distance = void 0, e.instanceId = void 0);
  }
  handleIntersections(e, i) {
    var o;
    if (e != null && e.length) {
      e = this.sortCandidates(e);
      for (const a of e) {
        if (i.event.immediatePropagationStopped)
          return !1;
        if (this.assignHitInformation(i, a), this.handleEventOnObject(a.object, i))
          return !0;
      }
    }
    this.assignHitInformation(i, e == null ? void 0 : e[0]), this.invokePointerCapture(i);
    const n = this.hoveredByID.get(i.pointerId);
    return n && this.propagatePointerExit(n.obj, n.data, null), this.hoveredByID.delete(i.pointerId), i.isUp && ((o = this.pressedByID.get(i.pointerId)) == null || o.handlers.forEach((a) => this.invokeOnPointerUp(i, a)), this.pressedByID.delete(i.pointerId)), !1;
  }
  sortCandidates(e) {
    this._sortingBuffer.length = 0, this._noDepthTestingResults.length = 0;
    for (let i = 0; i < e.length; i++) {
      const n = e[i], o = n.object;
      if (o.material && o.material.depthTest === !1) {
        this._noDepthTestingResults.push(n);
        continue;
      }
      this._sortingBuffer.push(n);
    }
    for (const i of this._sortingBuffer)
      this._noDepthTestingResults.push(i);
    return this._noDepthTestingResults;
  }
  /** 
   * Handle hit result by preparing all needed information before propagation.
   * Then calling propagate.
   */
  handleEventOnObject(e, i) {
    if (!this.testIsVisible(e))
      return i.isClick && Zs && console.log("not allowed", e), !1;
    if (i.pointerId === void 0)
      return Zs && console.error("Event without pointer can't be handled", i), !1;
    i.object = e;
    const n = e.parent, o = i.isClick ?? !1;
    let a = null;
    if (n && n.isUI) {
      const u = (i.isPressed || i.isClick) ?? !1;
      if (n[Yi]) {
        const p = n[Yi].gameObject;
        if (p) {
          if (!Bv.isInteractable(p, this.out))
            return !1;
          a = this.out.canvasGroup ?? null, this.handleMeshUIIntersection(e, u), e = p;
        }
      }
    }
    o && Zs && console.log(this.context.time.frame, e);
    const l = this.hoveredByID.get(i.pointerId), c = l == null ? void 0 : l.obj;
    c !== e && c && this.propagatePointerExit(c, l.data, e);
    const d = this.hoveredByID.get(i.pointerId);
    if (d ? (d.obj = e, d.data = i) : this.hoveredByID.set(i.pointerId, { obj: e, data: i }), i.isDown) {
      const u = this.pressedByID.get(i.pointerId);
      u ? (u.obj = e, u.data = i) : this.pressedByID.set(i.pointerId, { obj: e, data: i, handlers: /* @__PURE__ */ new Set() });
    }
    return (a === null || a.interactable) && this.handleMainInteraction(e, i, c ?? null), !0;
  }
  /**
   * Propagate up in hiearchy and call the callback for each component that is possibly a handler
   */
  propagate(e, i) {
    for (; e; )
      S.foreachComponent(e, (n) => {
        i(n);
      }, !1), e = e.parent;
  }
  /**
   * Propagate up in hierarchy and call handlers based on the pointer event data
   */
  handleMainInteraction(e, i, n) {
    const o = this.pressedByID.get(i.pointerId), a = n !== e;
    let l = !0;
    switch (i.event.pointerType) {
      case "mouse":
      case "touch":
        const c = this.context.input.getPointerPositionLastFrame(i.pointerId), h = this.context.input.getPointerPosition(i.pointerId);
        l = c && !$.approximately(c, h);
        break;
    }
    this.propagate(e, (c) => {
      var d;
      const h = c;
      h.interactable !== !1 && (!h.activeAndEnabled || !h.enabled || (h.onPointerEnter && a && this.handlePointerEnter(h, i), i.isDown && h.onPointerDown && (h.onPointerDown(i), o == null || o.handlers.add(h), this.handlePointerCapture(i, h)), h.onPointerMove && (l && h.onPointerMove(i), this.handlePointerCapture(i, h)), i.isUp && (h.onPointerUp && (this.invokeOnPointerUp(i, h), o == null || o.handlers.delete(h)), h.onPointerExit && ((d = i.event) == null ? void 0 : d.pointerType) === vg.Touch && (this.handlePointerExit(h, i), this.hoveredByID.delete(i.pointerId))), i.isClick && h.onPointerClick && h.onPointerClick(i)));
    }), i.isUp && (o == null || o.handlers.forEach((c) => {
      this.invokeOnPointerUp(i, c);
    }), this.pressedByID.delete(i.pointerId));
  }
  /** Propagate up in hierarchy and call onPointerExit */
  propagatePointerExit(e, i, n) {
    this.propagate(e, (o) => {
      if (!o.gameObject || o.destroyed)
        return;
      const a = o;
      if (a.onPointerExit || a.onPointerEnter) {
        if (n && this.isChild(n, o.gameObject))
          return;
        this.handlePointerExit(a, i);
      }
    });
  }
  /** handles onPointerUp - this will also release the pointerCapture */
  invokeOnPointerUp(e, i) {
    var n;
    (n = i.onPointerUp) == null || n.call(i, e), this.releasePointerCapture(e, i);
  }
  /** Responsible for invoking onPointerEnter (and updating onPointerExit). We invoke onPointerEnter once per active pointerId */
  handlePointerEnter(e, i) {
    e.onPointerEnter && this.updatePointerState(e, i.pointerId, this.pointerEnterSymbol, !0) && e.onPointerEnter(i), this.updatePointerState(e, i.pointerId, this.pointerExitSymbol, !1);
  }
  /** Responsible for invoking onPointerExit (and updating onPointerEnter). We invoke onPointerExit once per active pointerId */
  handlePointerExit(e, i) {
    e.onPointerExit && this.updatePointerState(e, i.pointerId, this.pointerExitSymbol, !0) && e.onPointerExit(i), this.updatePointerState(e, i.pointerId, this.pointerEnterSymbol, !1);
  }
  /** updates the pointer state list for a component
   * @param comp the component to update
   * @param pointerId the pointerId to update
   * @param symbol the symbol to use for the state
   * @param add if true, the pointerId is added to the state list, if false the pointerId will be removed
   */
  updatePointerState(e, i, n, o) {
    let a = e[n];
    if (o)
      return a && a.includes(i) ? !1 : (a = a || [], a.push(i), e[n] = a, !0);
    {
      if (!a || !a.includes(i))
        return !1;
      const l = a.indexOf(i);
      return l !== -1 && a.splice(l, 1), !0;
    }
  }
  /** check if the event was marked to be captured: if yes add the current component to the captured list */
  handlePointerCapture(e, i) {
    if (e.z__pointer_ctured) {
      e.z__pointer_ctured = !1;
      const n = e.pointerId;
      if (i.onPointerMove) {
        const o = this._capturedPointer[n] || [];
        o.push(i), this._capturedPointer[n] = o;
      } else
        z() && !i.z__warned_no_pointermove && (i.z__warned_no_pointermove = !0, console.warn("PointerCapture was requested but the component doesn't implement onPointerMove. It will not receive any pointer events"));
    } else
      e.z__pointer_cture_rleased && (e.z__pointer_cture_rleased = !1, this.releasePointerCapture(e, i));
  }
  /** removes the component from the pointer capture list */
  releasePointerCapture(e, i) {
    const n = e.pointerId;
    if (this._capturedPointer[n]) {
      const o = this._capturedPointer[n].indexOf(i);
      o !== -1 && (this._capturedPointer[n].splice(o, 1), Zs && console.log("released pointer capture", n, i, this._capturedPointer));
    }
  }
  /** invoke the pointerMove event on all captured handlers */
  invokePointerCapture(e) {
    var i;
    if (e.event.type === Ne.PointerMove) {
      const n = e.pointerId, o = this._capturedPointer[n];
      if (o) {
        Zs && console.log("Captured", n, o);
        for (let a = 0; a < o.length; a++) {
          const l = o[a];
          if (l.destroyed) {
            o.splice(a, 1), a--;
            continue;
          }
          (i = l.onPointerMove) == null || i.call(l, e);
        }
      }
    }
  }
  isChild(e, i) {
    return !e || !i ? !1 : e === i ? !0 : e.parent ? this.isChild(e.parent, i) : !1;
  }
  handleMeshUiObjectWithoutShadowDom(e, i) {
    return !e || !e.isUI ? !0 : this.handleMeshUIIntersection(e, i);
  }
  handleMeshUIIntersection(e, i) {
    const n = no.updateState(e, i);
    return n && this.currentActiveMeshUIComponents.push(n), n !== null;
  }
  resetMeshUIStates() {
    if (this.context.input.getPointerPressedCount() > 0 && no.resetLastSelected(), !(!this.currentActiveMeshUIComponents || this.currentActiveMeshUIComponents.length <= 0)) {
      for (let e = 0; e < this.currentActiveMeshUIComponents.length; e++) {
        const i = this.currentActiveMeshUIComponents[e];
        no.resetState(i);
      }
      this.currentActiveMeshUIComponents.length = 0;
    }
  }
  testIsVisible(e) {
    return e ? S.isActiveSelf(e) ? this.testIsVisible(e.parent) : !1 : !0;
  }
}
class no {
  static markDirty() {
    this.needsUpdate = !0;
  }
  static update(t, e, i = !1) {
    if (i) {
      t.update();
      return;
    }
    const n = e.time.frameCount;
    for (const o of this.lastUpdateFrame)
      if (o.context === e) {
        if (n === o.frame)
          return;
        o.frame = n;
        let a = this.needsUpdate || n < 1;
        o.nextUpdate <= n && (a = !0), a && (Zs && console.log("Update threemeshui"), this.needsUpdate = !1, o.nextUpdate = n + 60, t.update());
        return;
      }
    this.lastUpdateFrame = [{ context: e, frame: n, nextUpdate: n + 60 }], t.update(), this.needsUpdate = !1;
  }
  static updateState(t, e) {
    let i = null;
    if (t && (i = this.findBlockOrTextInParent(t), i && i !== this.lastSelected)) {
      if (i.interactable === !1)
        return null;
      this.needsUpdate = !0;
    }
    return i;
  }
  static resetLastSelected() {
    const t = this.lastSelected;
    t && (this.lastSelected = null, this.resetState(t));
  }
  static resetState(t) {
    t && (this.needsUpdate = !0);
  }
  static findBlockOrTextInParent(t) {
    return t ? t.isBlock || t.isText ? t : this.findBlockOrTextInParent(t.parent) : null;
  }
}
r(no, "lastSelected", null), r(no, "lastUpdateFrame", []), r(no, "needsUpdate", !1);
var HM = Object.defineProperty, GM = Object.getOwnPropertyDescriptor, ze = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? GM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && HM(t, e, n), n;
};
const Vs = x("debugorbit"), Zf = x("freecam"), Nh = x("debugcamerafit"), $h = x("smoothcam"), qM = { LEFT: "", UP: "", RIGHT: "", BOTTOM: "" };
let Jf;
class Zd extends CustomEvent {
  constructor(t, e) {
    super("target-reached", {
      detail: {
        controls: t,
        type: e
      }
    });
  }
}
class be extends I {
  constructor() {
    super(...arguments);
    r(this, "autoTarget", !0);
    r(this, "autoFit", !1);
    r(this, "enableRotate", !0);
    r(this, "autoRotate", !1);
    r(this, "autoRotateSpeed", 1);
    r(this, "minAzimuthAngle", 1 / 0);
    r(this, "maxAzimuthAngle", 1 / 0);
    r(this, "minPolarAngle", 0);
    r(this, "maxPolarAngle", Math.PI);
    r(this, "enableKeys", !1);
    r(this, "enableDamping", !0);
    r(this, "dampingFactor", 0.1);
    r(this, "enableZoom", !0);
    r(this, "minZoom", 0);
    r(this, "maxZoom", 1 / 0);
    r(this, "zoomSpeed", 1);
    /**
     * Set to true to enable zooming to the cursor position.  
     * @default false
     */
    r(this, "zoomToCursor", !1);
    r(this, "enablePan", !0);
    r(this, "lookAtConstraint", null);
    r(this, "lookAtConstraint01", 1);
    r(this, "allowInterrupt", !0);
    r(this, "middleClickToFocus", !0);
    r(this, "doubleClickToFocus", !0);
    r(this, "clickBackgroundToFitScene", 2);
    /** 
     * @internal If true debug information will be logged to the console
     * @default false
     */
    r(this, "debugLog", !1);
    r(this, "targetLerpDuration", 1);
    r(this, "_controls", null);
    r(this, "_cameraObject", null);
    r(this, "_lookTargetLerpActive", !1);
    r(this, "_lookTargetStartPosition", new v());
    r(this, "_lookTargetEndPosition", new v());
    r(this, "_lookTargetLerp01", 0);
    r(this, "_lookTargetLerpDuration", 0);
    r(this, "_cameraLerpActive", !1);
    r(this, "_cameraStartPosition", new v());
    r(this, "_cameraEndPosition", new v());
    r(this, "_cameraLerp01", 0);
    r(this, "_cameraLerpDuration", 0);
    r(this, "_fovLerpActive", !1);
    r(this, "_fovLerpStartValue", 0);
    r(this, "_fovLerpEndValue", 0);
    r(this, "_fovLerp01", 0);
    r(this, "_fovLerpDuration", 0);
    r(this, "_inputs", 0);
    r(this, "_enableTime", 0);
    // use to disable double click when double clicking on UI
    r(this, "_startedListeningToKeyEvents", !1);
    r(this, "_eventSystem");
    r(this, "_afterHandleInputFn");
    r(this, "_camera", null);
    r(this, "_syncedTransform");
    r(this, "_didSetTarget", 0);
    r(this, "targetElement", null);
    r(this, "_activePointerEvents");
    r(this, "_lastTimeClickOnBackground", -1);
    r(this, "_clickOnBackgroundCount", 0);
    r(this, "_onPointerDown", (e) => {
      this._activePointerEvents.push(e);
    });
    r(this, "_onPointerDownLate", (e) => {
      e.used && this._controls && (this._controls.enabled = !1);
    });
    r(this, "_onPointerUp", (e) => {
      for (let i = this._activePointerEvents.length - 1; i >= 0; i--) {
        const n = this._activePointerEvents[i];
        if (n.pointerId === e.pointerId && n.button === e.button) {
          this._activePointerEvents.splice(i, 1);
          break;
        }
      }
      if (this.clickBackgroundToFitScene > 0 && e.isClick && e.button === 0) {
        if (e.hasRay || e.intersections.push(...this.context.physics.raycast()), e.intersections.length <= 0) {
          const i = this.context.time.time - this._lastTimeClickOnBackground;
          this._lastTimeClickOnBackground = this.context.time.time, this.clickBackgroundToFitScene <= 1 || i < this.clickBackgroundToFitScene * 0.15 ? (this._clickOnBackgroundCount += 1, this._clickOnBackgroundCount >= this.clickBackgroundToFitScene - 1 && this.fitCamera(this.context.scene.children, {
            immediate: !1
          })) : this._clickOnBackgroundCount = 0;
        }
        Vs && console.log(this.clickBackgroundToFitScene, e.intersections.length, this._clickOnBackgroundCount);
      }
    });
    r(this, "_onPointerUpLate", (e) => {
      this.doubleClickToFocus && e.isDoubleClick && !e.used && this.setTargetFromRaycast();
    });
    r(this, "_orbitStartAngle", 0);
    r(this, "onControlsChangeStarted", () => {
      this._controls && (this._orbitStartAngle = this._controls.getAzimuthalAngle() + this._controls.getPolarAngle()), this._syncedTransform && this._syncedTransform.requestOwnership();
    });
    r(this, "onControlsChangeEnded", () => {
      if (this._controls && this.autoTarget) {
        const i = this._controls.getAzimuthalAngle() + this._controls.getPolarAngle() - this._orbitStartAngle;
        Math.abs(i) < 0.01 ? (Vs && console.debug("OrbitControls: No movement detected, updating target now"), this.updateTargetNow()) : Vs && console.debug("OrbitControls: Movement detected", i);
      }
    });
    r(this, "_shouldDisable", !1);
    r(this, "__onPreRender", () => {
      const e = this.context.pre_render_callbacks.indexOf(this.__onPreRender);
      e >= 0 && this.context.pre_render_callbacks.splice(e, 1), this.autoFit && (this.autoFit = !1, this.fitCamera({
        centerCamera: "y",
        immediate: !0,
        objects: this.scene.children
      }));
    });
    r(this, "_haveAttachedKeyboardEvents", !1);
  }
  /**
   * @inheritdoc
   */
  get isCameraController() {
    return !0;
  }
  /** The underlying three.js OrbitControls.   
   * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls}
   * @returns {@type ThreeOrbitControls | null}
  */
  get controls() {
    return this._controls;
  }
  /** The object being controlled by the OrbitControls (usually the camera)  
   * See {@link https://threejs.org/docs/#examples/en/controls/OrbitControls.object}
   * @returns {@type Object3D | null}
  */
  get controllerObject() {
    return this._cameraObject;
  }
  /** Register callback when user starts interacting with the orbit controls */
  onStartInteraction(e) {
    var i;
    (i = this.controls) == null || i.addEventListener("start", e);
  }
  /** 
   * @deprecated use `targetLerpDuration` instead  
   * ~~The speed at which the camera target and the camera will be lerping to their destinations (if set via script or user input)~~ 
   * */
  get targetLerpSpeed() {
    return 5;
  }
  set targetLerpSpeed(e) {
    this.targetLerpDuration = 1 / e;
  }
  /** @internal */
  awake() {
    Vs && console.debug("OrbitControls", this), this._didSetTarget = 0, this._startedListeningToKeyEvents = !1;
  }
  /** @internal */
  start() {
    this._eventSystem = di.get(this.context) ?? void 0, this._eventSystem && (this._afterHandleInputFn = this.afterHandleInput.bind(this), this._eventSystem.addEventListener(Tm.AfterHandleInput, this._afterHandleInputFn));
  }
  /** @internal */
  onDestroy() {
    var e, i;
    (e = this._controls) == null || e.dispose(), (i = this._eventSystem) == null || i.removeEventListener(Tm.AfterHandleInput, this._afterHandleInputFn);
  }
  /** @internal */
  onEnable() {
    this._didSetTarget = 0, this._enableTime = this.context.time.time;
    const e = S.getComponent(this.gameObject, Pe);
    this._camera = e;
    let i = e == null ? void 0 : e.threeCamera;
    if (!i && this.gameObject instanceof ye && (i = this.gameObject), i && Z_(i, this, !0), !this._controls && i instanceof L) {
      this._cameraObject = i;
      const n = this.targetElement ?? this.context.renderer.domElement, o = i == null ? void 0 : i.quaternion.clone();
      this._controls = new c0(i, n), i == null || i.quaternion.copy(o), Jf === void 0 && (Jf = { ...this._controls.keys });
      const a = ie(i), l = this.gameObject.worldForward, c = 2.5, h = a.clone().sub(l.multiplyScalar(c));
      this._controls.target.copy(h);
    }
    if (this._controls)
      if (Zf && (this.enablePan = !0, this.enableZoom = !0, this.middleClickToFocus = !0, X.isMobileDevice() && (this.doubleClickToFocus = !0)), this._controls.addEventListener("start", this.onControlsChangeStarted), this._controls.addEventListener("end", this.onControlsChangeEnded), !this._startedListeningToKeyEvents && this.enableKeys)
        this._startedListeningToKeyEvents = !0, this._controls.listenToKeyEvents(this.context.domElement);
      else
        try {
          this._controls.stopListenToKeyEvents();
        } catch {
        }
    this._syncedTransform = S.getComponent(this.gameObject, As) ?? void 0, this.context.pre_render_callbacks.push(this.__onPreRender), this._activePointerEvents = [], this.context.input.addEventListener("pointerdown", this._onPointerDown, { queue: vi.Early }), this.context.input.addEventListener("pointerdown", this._onPointerDownLate, { queue: vi.Late }), this.context.input.addEventListener("pointerup", this._onPointerUp, { queue: vi.Early }), this.context.input.addEventListener("pointerup", this._onPointerUpLate, { queue: vi.Late });
  }
  /** @internal */
  onDisable() {
    var e;
    if ((e = this._camera) != null && e.threeCamera && Z_(this._camera.threeCamera, this, !1), this._controls) {
      this._controls.enabled = !1, this._controls.autoRotate = !1, this._controls.removeEventListener("start", this.onControlsChangeStarted), this._controls.removeEventListener("end", this.onControlsChangeEnded);
      try {
        this._controls.stopListenToKeyEvents();
      } catch {
      }
      this._startedListeningToKeyEvents = !1;
    }
    this._activePointerEvents.length = 0, this.context.input.removeEventListener("pointerdown", this._onPointerDown), this.context.input.removeEventListener("pointerdown", this._onPointerDownLate), this.context.input.removeEventListener("pointerup", this._onPointerUp), this.context.input.removeEventListener("pointerup", this._onPointerUpLate);
  }
  updateTargetNow() {
    var o, a, l;
    const e = new wo((o = this._cameraObject) == null ? void 0 : o.worldPosition, (a = this._cameraObject) == null ? void 0 : a.worldForward.multiplyScalar(-1)), i = this.context.physics.raycastFromRay(e), n = i.length > 0 ? i[0] : void 0;
    n && n.distance > this.minZoom && n.distance < this.maxZoom && (Vs && V.DrawWireSphere(n.point, 0.1, 16711680, 2), (l = this._controls) == null || l.target.copy(i[0].point));
  }
  afterHandleInput(e) {
    e.detail.args.pointerId === 0 && (e.detail.args.isDown ? this._controls && this._eventSystem && (this._shouldDisable = this._eventSystem.hasActiveUI) : (!e.detail.args.isPressed || e.detail.args.isUp) && (this._shouldDisable = !1));
  }
  /** @internal */
  onBeforeRender() {
    var i, n, o, a;
    if (!this._controls)
      return;
    if (this._cameraObject !== this.context.mainCamera) {
      this._controls.enabled = !1;
      return;
    }
    if (this._controls.enabled = !0, (this.context.input.getPointerDown(1) || this.context.input.getPointerDown(2) || this.context.input.mouseWheelChanged || this.context.input.getPointerPressed(0) && ((i = this.context.input.getPointerPositionDelta(0)) != null && i.length()) || 0 > 0.1) && (this._inputs += 1), this._inputs > 0 && this.allowInterrupt && (this.enableRotate && (this.autoRotate = !1), this._cameraLerpActive = !1, this._lookTargetLerpActive = !1), this._inputs = 0, this.autoTarget && this._didSetTarget++ === 0) {
      const l = S.getComponent(this.gameObject, Pe);
      if (l && !this.setLookTargetFromConstraint()) {
        this.debugLog && console.log("NO TARGET");
        const c = ie(l.threeCamera), h = Math.max(0.01, c.length()), d = new v(0, 0, -h).applyMatrix4(l.threeCamera.matrixWorld);
        this.setLookTargetPosition(d, !0);
      }
      if (!this.setLookTargetFromConstraint()) {
        const c = new Ts();
        c.screenPoint = new oe(0, 0), c.lineThreshold = 0.1;
        const h = this.context.physics.raycast(c);
        h.length > 0 && this.setLookTargetPosition(h[0].point, !0), Nh && console.log("OrbitControls hits", ...h);
      }
    }
    if (this.middleClickToFocus && this.context.input.getPointerClicked(1) && this.setTargetFromRaycast(), this._lookTargetLerpActive || this._cameraLerpActive || this._fovLerpActive) {
      if (this._cameraLerpActive && this._cameraObject)
        if (this._cameraLerp01 += this.context.time.deltaTime / this._cameraLerpDuration, this._cameraLerp01 >= 1)
          this._cameraObject.position.copy(this._cameraEndPosition), this._cameraLerpActive = !1, this.dispatchEvent(new Zd(this, "camera"));
        else {
          const l = $.easeInOutCubic(this._cameraLerp01);
          this._cameraObject.position.lerpVectors(this._cameraStartPosition, this._cameraEndPosition, l);
        }
      if (this._lookTargetLerpActive)
        if (this._lookTargetLerp01 += this.context.time.deltaTime / this._lookTargetLerpDuration, this._lookTargetLerp01 >= 1)
          this._controls.target.copy(this._lookTargetEndPosition), this._lookTargetLerpActive = !1, this.dispatchEvent(new Zd(this, "lookat"));
        else {
          const l = $.easeInOutCubic(this._lookTargetLerp01);
          this._controls.target.lerpVectors(this._lookTargetStartPosition, this._lookTargetEndPosition, l);
        }
      if (this._fovLerpActive && this._cameraObject) {
        const l = this._cameraObject;
        if (this._fovLerp01 += this.context.time.deltaTime / this._fovLerpDuration, this._fovLerp01 >= 1)
          l.fov = this._fovLerpEndValue, this._fovLerpActive = !1;
        else {
          const c = $.easeInOutCubic(this._fovLerp01);
          l.fov = $.lerp(this._fovLerpStartValue, this._fovLerpEndValue, c);
        }
        l.updateProjectionMatrix();
      }
    }
    if (this._controls) {
      if (this.debugLog && (this._controls.domElement = this.context.renderer.domElement), this._controls.enabled = !this._shouldDisable && this._camera === this.context.mainCameraComponent && !this.context.isInXR && !this._activePointerEvents.some((l) => l.used), this._controls.keys = this.enableKeys ? Jf : qM, this._controls.autoRotate = this.autoRotate, this._controls.autoRotateSpeed = this.autoRotateSpeed, this._controls.enableZoom = this.enableZoom, this._controls.zoomSpeed = this.zoomSpeed, this._controls.zoomToCursor = this.zoomToCursor, this._controls.enableDamping = this.enableDamping, this._controls.dampingFactor = this.dampingFactor, this._controls.enablePan = this.enablePan, this._controls.enableRotate = this.enableRotate, this._controls.minAzimuthAngle = this.minAzimuthAngle, this._controls.maxAzimuthAngle = this.maxAzimuthAngle, this._controls.minPolarAngle = this.minPolarAngle, this._controls.maxPolarAngle = this.maxPolarAngle, Zf || (((o = (n = this._camera) == null ? void 0 : n.threeCamera) == null ? void 0 : o.type) === "PerspectiveCamera" ? (this._controls.minDistance = this.minZoom, this._controls.maxDistance = this.maxZoom, this._controls.minZoom = 0, this._controls.maxZoom = 1 / 0) : (this._controls.minDistance = 0, this._controls.maxDistance = 1 / 0, this._controls.minZoom = this.minZoom, this._controls.maxZoom = this.maxZoom)), typeof $h == "number" || $h === !0) {
        this._controls.enableDamping = !0;
        const l = typeof $h == "number" ? $h : 0.99;
        this._controls.dampingFactor = Math.max(1e-3, 1 - Math.min(1, l));
      }
      this.allowInterrupt || (this._lookTargetLerpActive && (this._controls.enablePan = !1), this._cameraLerpActive && (this._controls.enableRotate = !1, this._controls.autoRotate = !1), (this._lookTargetLerpActive || this._cameraLerpActive) && (this._controls.enableZoom = !1)), this.context.isInXR || (!Zf && ((a = this.lookAtConstraint) != null && a.locked) && this.setLookTargetFromConstraint(0, this.lookAtConstraint01), this._controls.update(this.context.time.deltaTime), Vs && V.DrawWireSphere(this._controls.target, 0.1, 65280));
    }
  }
  /** 
   * Sets camera target position and look direction using a raycast in forward direction of the object.  
   * 
   * @param source The object to raycast from. If a camera is passed in the camera position will be used as the source.
   * @param immediateOrDuration If true the camera target will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
   * 
   * This is useful for example if you want to align your camera with an object in your scene (or another camera). Simply pass in this other camera object
   * @returns true if the target was set successfully
   */
  setCameraAndLookTarget(e, i = !1) {
    if (!e)
      return z() && console.warn("[OrbitControls] setCameraAndLookTarget target is null"), !1;
    if (!(e instanceof L) && !(e instanceof Pe))
      return z() && console.warn("[OrbitControls] setCameraAndLookTarget target is not an Object3D or Camera"), !1;
    e instanceof Pe && (e = e.gameObject);
    const n = e.worldPosition, o = e.worldForward, a = new wo(n, o.multiplyScalar(-1));
    return Vs && V.DrawRay(a.origin, a.direction, 16711680, 10), this.setTargetFromRaycast(a, i) || this.setLookTargetPosition(a.at(2, G()), i), this.setCameraTargetPosition(n, i), !0;
  }
  /** Moves the camera to position smoothly. 
   * @param position The position in local space of the controllerObject to move the camera to. If null the camera will stop lerping to the target.
   * @param immediateOrDuration If true the camera will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
  */
  setCameraTargetPosition(e, i = !1) {
    var n;
    e && (e instanceof L && (e = ie(e)), this._cameraEndPosition || (this._cameraEndPosition = new v()), this._cameraEndPosition.copy(e), i === !0 ? (this._cameraLerpActive = !1, this._cameraObject && this._cameraObject.position.copy(this._cameraEndPosition)) : this._cameraObject && (this._cameraLerpActive = !0, this._cameraLerp01 = 0, this._cameraStartPosition.copy((n = this._cameraObject) == null ? void 0 : n.position), typeof i == "number" ? this._cameraLerpDuration = i : this._cameraLerpDuration = this.targetLerpDuration));
  }
  // public setCameraTargetRotation(rotation: Vector3 | Euler | Quaternion, immediateOrDuration: boolean | number = false): void {
  //     if (!this._cameraObject) return;
  //     if (typeof immediateOrDuration === "boolean") immediateOrDuration = immediateOrDuration ? 0 : this.targetLerpDuration;
  //     const ray = new Ray(this._cameraObject.worldPosition, getTempVector(0, 0, 1));
  //     // if the camera is in the middle of lerping we use the end position for the raycast
  //     if (immediateOrDuration > 0 && this._cameraEndPosition && this._cameraLerpActive) {
  //         ray.origin = getTempVector(this._cameraEndPosition)
  //     }
  //     if (rotation instanceof Vector3) {
  //         rotation = new Euler().setFromVector3(rotation);
  //     }
  //     if (rotation instanceof Euler) {
  //         rotation = new Quaternion().setFromEuler(rotation);
  //     }
  //     ray.direction.applyQuaternion(rotation);
  //     ray.direction.multiplyScalar(-1);
  //     const hits = this.context.physics.raycastFromRay(ray);
  //     if (hits.length > 0) {
  //         this.setCameraTargetPosition(hits[0].point, immediateOrDuration);
  //     }
  //     else {
  //         this.setLookTargetPosition(ray.at(2, getTempVector()));
  //     }
  // }
  /** True while the camera position is being lerped */
  get cameraLerpActive() {
    return this._cameraLerpActive;
  }
  /** Call to stop camera position lerping */
  stopCameraLerp() {
    this._cameraLerpActive = !1;
  }
  setFieldOfView(e, i = !1) {
    var o;
    if (!this._controls || typeof e != "number")
      return;
    const n = (o = this._camera) == null ? void 0 : o.threeCamera;
    n && (i === !0 ? n.fov = e : (this._fovLerpActive = !0, this._fovLerp01 = 0, this._fovLerpStartValue = n.fov, this._fovLerpEndValue = e, typeof i == "number" ? this._fovLerpDuration = i : this._fovLerpDuration = this.targetLerpDuration));
  }
  /** Moves the camera look-at target to a position smoothly. 
   * @param position The position in world space to move the camera target to. If null the camera will stop lerping to the target.
   * @param immediateOrDuration If true the camera target will move immediately to the new position, otherwise it will lerp. If a number is passed in it will be used as the duration of the lerp.
  */
  setLookTargetPosition(e = null, i = !1) {
    this._controls && e && (e instanceof L && (e = ie(e)), this._lookTargetEndPosition.copy(e), this._didSetTarget++, Vs && (console.warn("OrbitControls: setLookTargetPosition", e, i), V.DrawWireSphere(this._lookTargetEndPosition, 0.2, 16711680, 2)), i === !0 ? this._controls.target.copy(this._lookTargetEndPosition) : (this._lookTargetLerpActive = !0, this._lookTargetLerp01 = 0, this._lookTargetStartPosition.copy(this._controls.target), typeof i == "number" ? this._lookTargetLerpDuration = i : this._lookTargetLerpDuration = this.targetLerpDuration));
  }
  /** True while the camera look target is being lerped */
  get lookTargetLerpActive() {
    return this._lookTargetLerpActive;
  }
  /** Call to stop camera look target lerping */
  stopLookTargetLerp() {
    this._lookTargetLerpActive = !1;
  }
  /** Sets the look at target from an assigned lookAtConstraint source by index 
   * @param index The index of the source to use
   * @param t The interpolation factor between the current look at target and the new target
  */
  setLookTargetFromConstraint(e = 0, i = 1) {
    var o, a;
    if (!this._controls || ((o = this.lookAtConstraint) == null ? void 0 : o.enabled) === !1)
      return !1;
    const n = (a = this.lookAtConstraint) == null ? void 0 : a.sources;
    if (n && n.length > 0) {
      const l = n[e];
      if (l)
        return l.getWorldPosition(this._lookTargetEndPosition), this.lerpLookTarget(this._lookTargetEndPosition, i), !0;
    }
    return !1;
  }
  /** @deprecated use `controls.target.lerp(position, delta)` */
  lerpTarget(e, i) {
    return this.lerpLookTarget(e, i);
  }
  lerpLookTarget(e, i) {
    this._controls && (i >= 1 ? this._controls.target.copy(e) : this._controls.target.lerp(e, i));
  }
  setTargetFromRaycast(e, i = !1) {
    if (!this.controls)
      return !1;
    const n = e ? this.context.physics.raycastFromRay(e) : this.context.physics.raycast();
    for (const o of n)
      if (o.distance > 0 && S.isActiveInHierarchy(o.object)) {
        const a = Bg(o.object);
        if (a) {
          const l = a.canvas;
          if (l != null && l.screenspace)
            break;
        }
        return this.setLookTargetPosition(o.point, i), !0;
      }
    return !1;
  }
  fitCamera(e, i) {
    var Z, T;
    if (this.context.isInXR)
      return;
    let n;
    if (Array.isArray(e) ? n = e : e && "type" in e ? n = e.children : e && "objects" in e && (n = e == null ? void 0 : e.objects, i = e), n && !Array.isArray(n) && (n = n.children), (!Array.isArray(n) || n && n.length <= 0) && (n = this.context.scene.children), !Array.isArray(n) || n.length <= 0) {
      console.warn("No objects to fit camera to...");
      return;
    }
    const o = this._cameraObject, a = this._controls;
    if (!o || !a) {
      console.warn("No camera or controls found to fit camera to objects...");
      return;
    }
    i || (i = {});
    const { immediate: l = !1, centerCamera: c = "y", cameraNearFar: h = "auto", fitOffset: d = 1.1, fov: u = o == null ? void 0 : o.fov } = i, p = new v(), m = new v(), g = ki(n, void 0, (T = (Z = this._camera) == null ? void 0 : Z.threeCamera) == null ? void 0 : T.layers), _ = g.clone();
    o.updateMatrixWorld(), o.updateProjectionMatrix(), g.getCenter(m);
    const y = new v();
    if (g.getSize(y), g.applyMatrix4(o.matrixWorldInverse), g.getSize(p), g.setFromCenterAndSize(m, p), Number.isNaN(p.x) || Number.isNaN(p.y) || Number.isNaN(p.z)) {
      console.warn("Camera fit size resultet in NaN", o, g, [...n]);
      return;
    }
    if (p.length() <= 1e-10) {
      Nh && console.warn("Camera fit size is zero", g, [...n]);
      return;
    }
    const b = i.fov || o.fov, w = 2 * Math.atan(Math.tan(b * Math.PI / 360 / 2) * o.aspect) / Math.PI * 360, P = p.y / (2 * Math.atan(Math.PI * b / 360)), k = p.x / (2 * Math.atan(Math.PI * w / 360)), O = d * Math.max(P, k) + p.z / 2;
    Nh && console.log("Fit camera to objects", { fitHeightDistance: P, fitWidthDistance: k, distance: O, verticalFov: b, horizontalFov: w }), this.maxZoom = O * 10, this.minZoom = O * 0.01;
    const M = 0.05, E = m.clone();
    if (E.y -= p.y * M, this.setLookTargetPosition(E, l), this.setFieldOfView(i.fov, l), h == null || h == "auto") {
      const j = S.findObjectOfType(Ls), H = j ? j.radius : 0, Y = Math.max(y.x, y.y, y.z, H);
      o.near = O / 100, o.far = Y + O * 10, j && (this.maxZoom = Math.max(Math.min(this.maxZoom, H * 0.5), O));
    }
    const B = a.getDistance();
    B < this.minZoom && (this.minZoom = B * 0.9), B > this.maxZoom && (this.maxZoom = B * 1.1), o.updateMatrixWorld(), o.updateProjectionMatrix();
    const A = ie(o), F = m.clone();
    F.sub(A), c === "y" && (F.y = 0), F.normalize(), F.multiplyScalar(O), c === "y" && (F.y += -M * 4 * O);
    let U = m.clone().sub(F);
    if (o.parent && (U = o.parent.worldToLocal(U)), this.setCameraTargetPosition(U, l), Nh) {
      const j = new Kb(g);
      this.context.scene.add(j), A0(j, Au(o)), setTimeout(() => {
        this.context.scene.remove(j);
      }, 1e4), V.DrawWireBox3(_, 65280, 10), this._haveAttachedKeyboardEvents || (this._haveAttachedKeyboardEvents = !0, document.body.addEventListener("keydown", (H) => {
        if (H.code === "KeyF") {
          let Y;
          this._cameraObject instanceof ye && (Y = Math.random() * Math.random() * 170 + 10), this.fitCamera({ objects: n, fitOffset: d, immediate: !1, fov: Y });
        }
        H.code === "KeyV" && this._cameraObject instanceof ye && (this._cameraObject.fov = 60);
      }));
    }
    a.update();
  }
}
ze([
  f()
], be.prototype, "autoTarget", 2);
ze([
  f()
], be.prototype, "autoFit", 2);
ze([
  f()
], be.prototype, "enableRotate", 2);
ze([
  f()
], be.prototype, "autoRotate", 2);
ze([
  f()
], be.prototype, "autoRotateSpeed", 2);
ze([
  f()
], be.prototype, "minAzimuthAngle", 2);
ze([
  f()
], be.prototype, "maxAzimuthAngle", 2);
ze([
  f()
], be.prototype, "minPolarAngle", 2);
ze([
  f()
], be.prototype, "maxPolarAngle", 2);
ze([
  f()
], be.prototype, "enableKeys", 2);
ze([
  f()
], be.prototype, "enableDamping", 2);
ze([
  f()
], be.prototype, "dampingFactor", 2);
ze([
  f()
], be.prototype, "enableZoom", 2);
ze([
  f()
], be.prototype, "minZoom", 2);
ze([
  f()
], be.prototype, "maxZoom", 2);
ze([
  f()
], be.prototype, "zoomSpeed", 2);
ze([
  f()
], be.prototype, "enablePan", 2);
ze([
  f(Za)
], be.prototype, "lookAtConstraint", 2);
ze([
  f()
], be.prototype, "lookAtConstraint01", 2);
ze([
  f()
], be.prototype, "allowInterrupt", 2);
ze([
  f()
], be.prototype, "middleClickToFocus", 2);
ze([
  f()
], be.prototype, "doubleClickToFocus", 2);
ze([
  f()
], be.prototype, "clickBackgroundToFitScene", 2);
ze([
  f()
], be.prototype, "targetLerpDuration", 2);
var XM = Object.defineProperty, QM = Object.getOwnPropertyDescriptor, ni = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? QM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && XM(t, e, n), n;
}, _r = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Skybox = 1] = "Skybox", s[s.SolidColor = 2] = "SolidColor", s[s.Uninitialized = 4] = "Uninitialized", s))(_r || {});
const Js = x("debugcam"), nb = x("debugscreenpointtoray");
var od;
const Yl = (od = class extends I {
  constructor() {
    super(...arguments);
    r(this, "_nearClipPlane", 0.1);
    r(this, "_farClipPlane", 1e3);
    r(this, "orthographic", !1);
    r(this, "orthographicSize", 5);
    r(this, "ARBackgroundAlpha", 0);
    r(this, "_cullingMask", 4294967295);
    r(this, "_backgroundBlurriness");
    r(this, "_backgroundIntensity");
    r(this, "_backgroundRotation");
    r(this, "_environmentIntensity");
    r(this, "_targetTexture", null);
    r(this, "_backgroundColor");
    r(this, "_fov");
    r(this, "_cam", null);
    r(this, "_clearFlags", 2);
    r(this, "_skybox");
    r(this, "_frustum");
    r(this, "_projScreenMatrix", new se());
  }
  /**
   * Returns whether this component is a camera
   * @returns {boolean} Always returns true
   */
  get isCamera() {
    return !0;
  }
  /** 
   * Gets or sets the camera's aspect ratio (width divided by height).
   * For perspective cameras, this directly affects the camera's projection matrix.
   * When set, automatically updates the projection matrix.
   */
  get aspect() {
    return this._cam instanceof ye ? this._cam.aspect : this.context.domWidth / this.context.domHeight;
  }
  set aspect(t) {
    this._cam instanceof ye && this._cam.aspect !== t && (this._cam.aspect = t, this._cam.updateProjectionMatrix());
  }
  /**
   * Gets or sets the camera's field of view in degrees for perspective cameras.
   * When set, automatically updates the projection matrix.
   */
  get fieldOfView() {
    return this._cam instanceof ye ? this._cam.fov : this._fov;
  }
  set fieldOfView(t) {
    const e = this.fieldOfView != t;
    if (this._fov = t, e && this._cam && this._cam instanceof ye) {
      if (this._fov === void 0) {
        console.warn("Can not set undefined fov on PerspectiveCamera");
        return;
      }
      this._cam.fov = this._fov, this._cam.updateProjectionMatrix();
    }
  }
  /**
   * Gets or sets the camera's near clipping plane distance.
   * Objects closer than this distance won't be rendered.
   * When set, automatically updates the projection matrix.
   */
  get nearClipPlane() {
    return this._nearClipPlane;
  }
  set nearClipPlane(t) {
    const e = this._nearClipPlane != t;
    this._nearClipPlane = t, this._cam && (e || this._cam.near != t) && (this._cam.near = t, this._cam.updateProjectionMatrix());
  }
  /**
   * Gets or sets the camera's far clipping plane distance.
   * Objects farther than this distance won't be rendered.
   * When set, automatically updates the projection matrix.
   */
  get farClipPlane() {
    return this._farClipPlane;
  }
  set farClipPlane(t) {
    const e = this._farClipPlane != t;
    this._farClipPlane = t, this._cam && (e || this._cam.far != t) && (this._cam.far = t, this._cam.updateProjectionMatrix());
  }
  /**
   * Applies both the camera's near and far clipping planes and updates the projection matrix.
   * This ensures rendering occurs only within the specified distance range.
   */
  applyClippingPlane() {
    this._cam && (this._cam.near = this._nearClipPlane, this._cam.far = this._farClipPlane, this._cam.updateProjectionMatrix());
  }
  get clearFlags() {
    return this._clearFlags;
  }
  set clearFlags(t) {
    if (typeof t == "string")
      switch (t) {
        case "skybox":
          t = 1;
          break;
        case "solidcolor":
          t = 2;
          break;
        default:
          t = 0;
          break;
      }
    t !== this._clearFlags && (this._clearFlags = t, this.applyClearFlagsIfIsActiveCamera());
  }
  set cullingMask(t) {
    this._cullingMask = t, this._cam && (this._cam.layers.mask = t);
  }
  get cullingMask() {
    return this._cam ? this._cam.layers.mask : this._cullingMask;
  }
  /**
   * Sets only a specific layer to be active for rendering by this camera.
   * This is equivalent to calling `layers.set(val)` on the three.js camera object.
   * @param val The layer index to set active
   */
  set cullingLayer(t) {
    this.cullingMask = (1 << t | 0) >>> 0;
  }
  set backgroundBlurriness(t) {
    t !== this._backgroundBlurriness && (t === void 0 ? this._backgroundBlurriness = void 0 : this._backgroundBlurriness = Math.min(Math.max(t, 0), 1), this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundBlurriness() {
    return this._backgroundBlurriness;
  }
  set backgroundIntensity(t) {
    t !== this._backgroundIntensity && (t === void 0 ? this._backgroundIntensity = void 0 : this._backgroundIntensity = Math.min(Math.max(t, 0), 10), this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundIntensity() {
    return this._backgroundIntensity;
  }
  set backgroundRotation(t) {
    t !== this._backgroundRotation && (t === void 0 ? this._backgroundRotation = void 0 : this._backgroundRotation = t, this.applyClearFlagsIfIsActiveCamera());
  }
  get backgroundRotation() {
    return this._backgroundRotation;
  }
  set environmentIntensity(t) {
    this._environmentIntensity = t;
  }
  get environmentIntensity() {
    return this._environmentIntensity;
  }
  get backgroundColor() {
    return this._backgroundColor ?? null;
  }
  set backgroundColor(t) {
    t && (this._backgroundColor || (this._backgroundColor = new we(1, 1, 1, 1)), this._backgroundColor.copy(t), (!("alpha" in t) || t.alpha === void 0) && (this._backgroundColor.alpha = 1), this.applyClearFlagsIfIsActiveCamera());
  }
  set targetTexture(t) {
    this._targetTexture = t;
  }
  get targetTexture() {
    return this._targetTexture;
  }
  /**
   * Gets the three.js camera object. Creates one if it doesn't exist yet.
   * @returns {PerspectiveCamera | OrthographicCamera} The three.js camera object
   * @deprecated Use {@link threeCamera} instead
   */
  get cam() {
    return this.threeCamera;
  }
  /**
   * Gets the three.js camera object. Creates one if it doesn't exist yet.
   * @returns {PerspectiveCamera | OrthographicCamera} The three.js camera object
   */
  get threeCamera() {
    return this.activeAndEnabled && this.buildCamera(), this._cam;
  }
  /**
   * Converts screen coordinates to a ray in world space.
   * Useful for implementing picking or raycasting from screen to world.
   * 
   * @param x The x screen coordinate
   * @param y The y screen coordinate
   * @param ray Optional ray object to reuse instead of creating a new one
   * @returns {Ray} A ray originating from the camera position pointing through the screen point
   */
  screenPointToRay(t, e, i) {
    const n = this.threeCamera, o = Yl._origin;
    o.set(t, e, -1), this.context.input.convertScreenspaceToRaycastSpace(o), nb && console.log("screenPointToRay", t.toFixed(2), e.toFixed(2), "now:", o.x.toFixed(2), o.y.toFixed(2), "isInXR:" + this.context.isInXR), o.z = -1, o.unproject(n);
    const a = Yl._direction.set(o.x, o.y, o.z), l = ie(n);
    return a.sub(l), a.normalize(), i ? (i.set(l, a), i) : new wo(l.clone(), a.clone());
  }
  /**
   * Gets the camera's view frustum for culling and visibility checks.
   * Creates the frustum if it doesn't exist and returns it.
   * 
   * @returns {Frustum} The camera's view frustum
   */
  getFrustum() {
    return this._frustum || (this._frustum = new I_(), this.updateFrustum()), this._frustum;
  }
  /**
   * Forces an update of the camera's frustum.
   * This is automatically called every frame in onBeforeRender.
   */
  updateFrustum() {
    this._frustum || (this._frustum = new I_()), this._frustum.setFromProjectionMatrix(this.getProjectionScreenMatrix(this._projScreenMatrix, !0), this.context.renderer.coordinateSystem);
  }
  /**
   * Gets this camera's projection-screen matrix.
   * 
   * @param target Matrix4 object to store the result in
   * @param forceUpdate Whether to force recalculation of the matrix
   * @returns {Matrix4} The requested projection screen matrix
   */
  getProjectionScreenMatrix(t, e) {
    return e && this._projScreenMatrix.multiplyMatrices(this.threeCamera.projectionMatrix, this.threeCamera.matrixWorldInverse), t === this._projScreenMatrix ? t : t.copy(this._projScreenMatrix);
  }
  /** @internal */
  awake() {
    nb && window.addEventListener("pointerdown", (t) => {
      const e = t.clientX, i = t.clientY;
      console.log("touch", e.toFixed(2), i.toFixed(2));
      const n = this.screenPointToRay(e, i), o = "#" + Math.floor(Math.random() * 16777215).toString(16);
      V.DrawRay(n.origin, n.direction, o, 10);
    });
  }
  /** @internal */
  onEnable() {
    Js && console.log(`Camera enabled: "${this.name}". ClearFlags=${_r[this._clearFlags]}`, this), this.buildCamera(), (this.tag == "MainCamera" || !this.context.mainCameraComponent) && (this.context.setCurrentCamera(this), KM(this)), this.applyClearFlagsIfIsActiveCamera({ applySkybox: !0 });
  }
  /** @internal */
  onDisable() {
    this.context.removeCamera(this);
  }
  /** @internal */
  onBeforeRender() {
    if (this._cam && (this._frustum && this.updateFrustum(), this._clearFlags === 2 && this.applyClearFlagsIfIsActiveCamera(), this._targetTexture)) {
      this.context.isManagedExternally && (this._warnedAboutExternalRenderer || (this._warnedAboutExternalRenderer = !0, console.warn("Rendering with external renderer is not supported yet. This may not work or throw errors. Please remove the the target texture from your camera: " + this.name, this.targetTexture))), this.context.composer;
      const t = this.context.renderer;
      if (t) {
        const e = this.context.mainCameraComponent;
        this.applyClearFlags(), this._targetTexture.render(this.context.scene, this._cam, t), e == null || e.applyClearFlags();
      }
    }
  }
  /** 
   * Creates a three.js camera object if it doesn't exist yet and sets its properties.
   * This is called internally when accessing the {@link threeCamera} property.
   */
  buildCamera() {
    if (this._cam)
      return;
    const t = this.gameObject.isCamera;
    let e = null;
    if (t ? (e = this.gameObject, e == null || e.layers.enableAll(), e instanceof ye && (this._fov = e.fov)) : e = this.gameObject.children[0], e && e.isCamera)
      e instanceof ye && (this._fov && (e.fov = this._fov), e.near = this._nearClipPlane, e.far = this._farClipPlane, e.updateProjectionMatrix());
    else if (!this.orthographic)
      e = new ye(this.fieldOfView, window.innerWidth / window.innerHeight, this._nearClipPlane, this._farClipPlane), this.fieldOfView && (e.fov = this.fieldOfView), this.gameObject.add(e);
    else {
      const i = this.orthographicSize * 100;
      e = new rg(window.innerWidth / -i, window.innerWidth / i, window.innerHeight / i, window.innerHeight / -i, this._nearClipPlane, this._farClipPlane), this.gameObject.add(e);
    }
    this._cam = e, this._cam.layers.mask = this._cullingMask, this.tag == "MainCamera" && this.context.setCurrentCamera(this);
  }
  /**
   * Applies clear flags if this is the active main camera.
   * @param opts Options for applying clear flags
   */
  applyClearFlagsIfIsActiveCamera(t) {
    this.context.mainCameraComponent === this && this.applyClearFlags(t);
  }
  /**
   * Applies this camera's clear flags and related settings to the renderer.
   * This controls how the background is rendered (skybox, solid color, transparent).
   * @param opts Options for applying clear flags
   */
  applyClearFlags(t) {
    var e;
    if (!this._cam) {
      Js && console.log("Camera does not exist (apply clear flags)");
      return;
    }
    if (this.fieldOfView = this._fov, Js) {
      const i = `Camera "${this.name}" clear flags: ${_r[this._clearFlags]}`;
      console.debug(i);
    }
    switch (this._clearFlags) {
      case 0:
        return;
      case 1:
        if (Yl.backgroundShouldBeTransparent(this.context) && (!this.ARBackgroundAlpha || this.ARBackgroundAlpha < 1e-3)) {
          this.context.scene.background = null, this.context.renderer.setClearColor(0, 0);
          return;
        }
        (!this.scene.background || !this._skybox || (t == null ? void 0 : t.applySkybox) === !0) && this.applySceneSkybox(), this._backgroundBlurriness !== void 0 ? this.context.scene.backgroundBlurriness = this._backgroundBlurriness : Js && console.warn(`Camera "${this.name}" has no background blurriness`), this._backgroundIntensity !== void 0 && (this.context.scene.backgroundIntensity = this._backgroundIntensity), this._backgroundRotation !== void 0 ? this.context.scene.backgroundRotation = this._backgroundRotation : Js && console.warn(`Camera "${this.name}" has no background intensity`);
        break;
      case 2:
        if (this._backgroundColor) {
          let i = this._backgroundColor.alpha;
          Yl.backgroundShouldBeTransparent(this.context) && (i = this.ARBackgroundAlpha ?? 0), this.context.scene.background = null, (e = this.context.xr) != null && e.isVR ? this.context.renderer.setClearColor(iC(this._backgroundColor).convertLinearToSRGB()) : this.context.renderer.setClearColor(this._backgroundColor, i);
        } else
          Js && console.warn(`Camera "${this.name}" has no background color`, this);
        break;
      case 4:
        this.context.scene.background = null, this.context.renderer.setClearColor(0, 0);
        break;
    }
  }
  /**
   * Applies the skybox texture to the scene background.
   */
  applySceneSkybox() {
    this._skybox || (this._skybox = new YM(this)), this._skybox.apply();
  }
  /**
   * Determines if the background should be transparent when in passthrough AR mode.
   * 
   * @param context The current rendering context
   * @returns {boolean} True when in XR on a pass through device where the background should be invisible
   */
  static backgroundShouldBeTransparent(t) {
    var o, a, l, c;
    const e = (o = t.renderer.xr) == null ? void 0 : o.getSession();
    if (!e)
      return !1;
    if (typeof e._transparent == "boolean")
      return e._transparent;
    const i = e.environmentBlendMode;
    Js && We("Environment blend mode: " + i + " on " + navigator.userAgent);
    let n = i === "additive" || i === "alpha-blend";
    return t.isInAR && i === "opaque" && ((a = navigator.userAgent) != null && a.includes("OculusBrowser") || (l = navigator.userAgent) != null && l.includes("Mozilla") && ((c = navigator.userAgent) != null && c.includes("Mobile WebXRViewer/v2"))) && (n = !0), e._transparent = n, n;
  }
}, r(od, "_origin", new v()), r(od, "_direction", new v()), od);
let Pe = Yl;
ni([
  f()
], Pe.prototype, "aspect", 1);
ni([
  f()
], Pe.prototype, "fieldOfView", 1);
ni([
  f()
], Pe.prototype, "nearClipPlane", 1);
ni([
  f()
], Pe.prototype, "farClipPlane", 1);
ni([
  f()
], Pe.prototype, "clearFlags", 1);
ni([
  f()
], Pe.prototype, "orthographic", 2);
ni([
  f()
], Pe.prototype, "orthographicSize", 2);
ni([
  f()
], Pe.prototype, "ARBackgroundAlpha", 2);
ni([
  f()
], Pe.prototype, "cullingMask", 1);
ni([
  f()
], Pe.prototype, "backgroundBlurriness", 1);
ni([
  f()
], Pe.prototype, "backgroundIntensity", 1);
ni([
  f(jt)
], Pe.prototype, "backgroundRotation", 1);
ni([
  f()
], Pe.prototype, "environmentIntensity", 1);
ni([
  f(we)
], Pe.prototype, "backgroundColor", 1);
ni([
  f(pr)
], Pe.prototype, "targetTexture", 1);
class YM {
  constructor(t) {
    r(this, "_camera");
    r(this, "_skybox");
    this._camera = t;
  }
  get context() {
    var t;
    return (t = this._camera) == null ? void 0 : t.context;
  }
  /**
   * Applies the skybox texture to the scene background.
   * Retrieves the texture based on the camera's source ID.
   */
  apply() {
    this._skybox = this.context.lightmaps.tryGetSkybox(this._camera.sourceId), this._skybox ? this.context.scene.background !== this._skybox && (Js && console.log(`Camera "${this._camera.name}" set skybox`, this._camera, this._skybox), this._skybox.mapping = Ms, this.context.scene.background = this._skybox) : this._did_log_failed_to_find_skybox || (this._did_log_failed_to_find_skybox = !0, console.warn(`Camera "${this._camera.name}" has no skybox texture. ${this._camera.sourceId}`));
  }
}
function KM(s) {
  x("freecam") && s.context.mainCameraComponent === s && S.getOrAddComponent(s.gameObject, be);
}
class lo extends I {
  constructor() {
    super(...arguments);
    r(this, "_listener", null);
    r(this, "onInteraction", () => {
      this.destroyed || this.listener == null || this.addListenerIfItExists();
    });
  }
  /**
   * Gets the existing Three.js {@link three#AudioListener} instance or creates a new one if it doesn't exist.
   * This listener is responsible for capturing audio in the 3D scene.
   * @returns The {@link three#AudioListener} instance
   */
  get listener() {
    return this._listener == null && (this._listener = new Xx()), this._listener;
  }
  /**
   * Registers for interaction events and initializes the audio listener
   * when this component is enabled.
   * @internal
   */
  onEnable() {
    Wn.registerWaitForInteraction(this.onInteraction), this.addListenerIfItExists();
  }
  /**
   * Cleans up event registrations and removes the audio listener
   * when this component is disabled.
   * @internal
   */
  onDisable() {
    Wn.unregisterWaitForInteraction(this.onInteraction), this.removeListenerIfItExists();
  }
  addListenerIfItExists() {
    const e = this._listener;
    if (!e || e != null && e.parent)
      return;
    const i = this.context.mainCameraComponent || S.getComponentInParent(this.gameObject, Pe);
    i != null && i.threeCamera ? i.threeCamera.add(e) : this.gameObject.add(e), e.filter ? (e.gain.connect(e.filter), e.filter.connect(e.context.destination)) : e.gain.connect(e.context.destination);
  }
  removeListenerIfItExists() {
    const e = this._listener;
    e && (e.removeFromParent(), e.filter && e.filter.disconnect(), e.gain && e.gain.disconnect());
  }
}
var ZM = Object.defineProperty, JM = Object.getOwnPropertyDescriptor, Sn = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? JM(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && ZM(t, e, n), n;
};
const Et = x("debugaudio"), eo = class extends I {
  constructor() {
    super(...arguments);
    r(this, "clip", "");
    r(this, "playOnAwake", !1);
    r(this, "preload", !1);
    r(this, "playInBackground", !0);
    r(this, "_spatialBlend", 0);
    r(this, "_minDistance", 1);
    r(this, "_maxDistance", 100);
    r(this, "_volume", 1);
    r(this, "rollOffMode", 0);
    r(this, "_loop", !1);
    r(this, "sound", null);
    r(this, "helper", null);
    r(this, "wasPlaying", !1);
    r(this, "audioLoader", null);
    r(this, "shouldPlay", !1);
    // set this from audio context time, used to set clip offset when setting "time" property
    // there is maybe a better way to set a audio clip current time?!
    r(this, "_lastClipStartedLoading", null);
    r(this, "_audioElement", null);
    r(this, "onVisibilityChanged", () => {
      switch (document.visibilityState) {
        case "hidden":
          (this.playInBackground === !1 || X.isMobileDevice()) && (this.wasPlaying = this.isPlaying, this.isPlaying && this.pause());
          break;
        case "visible":
          Et && console.log("visible", this.enabled, this.playOnAwake, !this.isPlaying, eo.userInteractionRegistered, this.wasPlaying), this.enabled && this.playOnAwake && !this.isPlaying && eo.userInteractionRegistered && this.wasPlaying && this.play();
          break;
      }
    });
    r(this, "onApplicationMuteChanged", () => {
      var t, e;
      this.context.application.muted ? (t = this.sound) == null || t.setVolume(0) : (e = this.sound) == null || e.setVolume(this.volume);
    });
    r(this, "createAudio", (t) => {
      Et && console.log("AudioBuffer finished loading", t);
      const e = this.Sound;
      if (!e) {
        Et && console.warn("Failed getting sound?", this.name);
        return;
      }
      e.isPlaying && e.stop(), t && e.setBuffer(t), e.loop = this._loop, this.context.application.muted ? e.setVolume(0) : e.setVolume(this.volume), e.autoplay = this.shouldPlay && eo.userInteractionRegistered, this.applySpatialDistanceSettings(), e.isPlaying && e.stop(), eo.registerWaitForAllowAudio(this.__onAllowAudioCallback);
    });
    r(this, "__onAllowAudioCallback", () => {
      this.shouldPlay && this.play();
    });
    r(this, "_lastContextTime", 0);
    r(this, "_hasEnded", !0);
    r(this, "_needUpdateSpatialDistanceSettings", !1);
  }
  /**
   * Checks if the user has interacted with the page to allow audio playback.
   * Audio playback often requires a user gesture first due to browser autoplay policies.
   * This is the same as calling {@link Application.userInteractionRegistered}.
   * 
   * @returns Whether user interaction has been registered to allow audio playback
   */
  static get userInteractionRegistered() {
    return Wn.userInteractionRegistered;
  }
  /**
   * Registers a callback that will be executed once the user has interacted with the page,
   * allowing audio playback to begin.
   * This is the same as calling {@link Application.registerWaitForInteraction}.
   * 
   * @param cb - The callback function to execute when user interaction is registered
   */
  static registerWaitForAllowAudio(t) {
    Wn.registerWaitForInteraction(t);
  }
  /**
   * Indicates whether the audio is currently playing.
   * 
   * @returns True if the audio is playing, false otherwise
   */
  get isPlaying() {
    var t;
    return ((t = this.sound) == null ? void 0 : t.isPlaying) ?? !1;
  }
  /**
   * The total duration of the current audio clip in seconds.
   * 
   * @returns Duration in seconds or undefined if no clip is loaded
   */
  get duration() {
    var t, e;
    return (e = (t = this.sound) == null ? void 0 : t.buffer) == null ? void 0 : e.duration;
  }
  /**
   * The current playback position as a normalized value between 0 and 1.
   * Can be set to seek to a specific position in the audio.
   */
  get time01() {
    var e;
    const t = this.duration;
    return t && this.sound ? ((e = this.sound) == null ? void 0 : e.context.currentTime) / t : 0;
  }
  set time01(t) {
    const e = this.duration;
    e && this.sound && (this.time = t * e);
  }
  /**
   * The current playback position in seconds.
   * Can be set to seek to a specific time in the audio.
   */
  get time() {
    var t, e;
    return (t = this.sound) != null && t.source ? ((e = this.sound.source) == null ? void 0 : e.context.currentTime) - this._lastContextTime + this.sound.offset : 0;
  }
  set time(t) {
    if (this.sound) {
      if (t === this.sound.offset)
        return;
      const e = this.isPlaying;
      this.stop(), this.sound.offset = t, e && this.play();
    }
  }
  get loop() {
    return this.sound && (this._loop = this.sound.getLoop()), this._loop;
  }
  set loop(t) {
    this._loop = t, this.sound && this.sound.setLoop(t);
  }
  get spatialBlend() {
    return this._spatialBlend;
  }
  set spatialBlend(t) {
    t !== this._spatialBlend && (this._spatialBlend = t, this._needUpdateSpatialDistanceSettings = !0);
  }
  get minDistance() {
    return this._minDistance;
  }
  set minDistance(t) {
    this._minDistance !== t && (this._minDistance = t, this._needUpdateSpatialDistanceSettings = !0);
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set maxDistance(t) {
    this._maxDistance !== t && (this._maxDistance = t, this._needUpdateSpatialDistanceSettings = !0);
  }
  get volume() {
    return this._volume;
  }
  set volume(t) {
    this._volume = t, this.sound && !this.context.application.muted && (Et && console.log(this.name, "audio set volume", t), this.sound.setVolume(t));
  }
  set pitch(t) {
    this.sound && this.sound.setPlaybackRate(t);
  }
  get pitch() {
    return this.sound ? this.sound.getPlaybackRate() : 1;
  }
  /**
   * Returns the underlying {@link PositionalAudio} object, creating it if necessary.
   * The audio source needs a user interaction to be initialized due to browser autoplay policies.
   * 
   * @returns The three.js PositionalAudio object or null if unavailable
   */
  get Sound() {
    var t;
    if (!this.sound && eo.userInteractionRegistered) {
      let e = this.gameObject.getComponent(lo) ?? this.context.mainCamera.getComponent(lo) ?? Uu(lo, this.context, !1);
      !e && this.context.mainCamera && (e = this.context.mainCamera.addComponent(lo)), e != null && e.listener ? (this.sound = new Qx(e.listener), (t = this.gameObject) == null || t.add(this.sound)) : Et && console.warn("No audio listener found in scene - can not play audio");
    }
    return this.sound;
  }
  // This is a hacky workaround to get the PositionalAudio behave like a 2D audio source
  // private _listener: AudioListener | null = null;
  // private _originalSoundMatrixWorldFunction: Function | null = null;
  // private _onSoundMatrixWorld = (force: boolean) => {
  //     if (this._spatialBlend > .05) {
  //         if (this._originalSoundMatrixWorldFunction) {
  //             this._originalSoundMatrixWorldFunction.call(this.sound, force);
  //         }
  //     }
  //     else {
  //         // we use another object's matrix world function (but bound to the positional audio)
  //         // this is just a little trick to prevent calling the PositionalAudio's updateMatrixWorld function
  //         this.gameObject.updateMatrixWorld?.call(this.sound, force);
  //         if (this.sound && this._listener) {
  //             this.sound.gain.connect(this._listener.listener.getInput());
  //             // const pos = getTempVector().setFromMatrixPosition(this._listener.gameObject.matrixWorld);
  //             // const ctx = this.sound.context;
  //             // const delay = this._listener.listener.timeDelta;
  //             // const time = ctx.currentTime ;
  //             // this.sound.panner.positionX.setValueAtTime(pos.x, time);
  //             // this.sound.panner.positionY.setValueAtTime(pos.y, time);
  //             // this.sound.panner.positionZ.setValueAtTime(pos.z, time);
  //             // this.sound.panner.orientationX.setValueAtTime(0, time);
  //             // this.sound.panner.orientationY.setValueAtTime(0, time);
  //             // this.sound.panner.orientationZ.setValueAtTime(-1, time);
  //         }
  //     }
  // }
  /**
   * Indicates whether the audio source is queued to play when possible.
   * This may be true before user interaction has been registered.
   * 
   * @returns Whether the audio source intends to play
   */
  get ShouldPlay() {
    return this.shouldPlay;
  }
  /**
   * Returns the Web Audio API context associated with this audio source.
   * 
   * @returns The {@link AudioContext} or null if not available
   */
  get audioContext() {
    var t;
    return (t = this.sound) == null ? void 0 : t.context;
  }
  /** @internal */
  awake() {
    Et && console.log(this), this.audioLoader = new Zp(), this.playOnAwake && (this.shouldPlay = !0), this.preload && typeof this.clip == "string" && this.audioLoader.load(this.clip, this.createAudio, () => {
    }, console.error);
  }
  /** @internal */
  onEnable() {
    this.sound && this.gameObject.add(this.sound), eo.userInteractionRegistered ? this.playOnAwake && this.context.application.isVisible && this.play() : eo.registerWaitForAllowAudio(() => {
      this.enabled && !this.destroyed && this.shouldPlay && this.onNewClip(this.clip);
    }), globalThis.addEventListener("visibilitychange", this.onVisibilityChanged), this.context.application.addEventListener(Sm.MuteChanged, this.onApplicationMuteChanged);
  }
  /** @internal */
  onDisable() {
    globalThis.removeEventListener("visibilitychange", this.onVisibilityChanged), this.context.application.removeEventListener(Sm.MuteChanged, this.onApplicationMuteChanged), this.pause();
  }
  applySpatialDistanceSettings() {
    const t = this.sound;
    if (!t)
      return;
    this._needUpdateSpatialDistanceSettings = !1;
    const e = $.lerp(10 * this._maxDistance / Math.max(1e-4, this.spatialBlend), this._minDistance, this.spatialBlend);
    switch (Et && console.log(this.name, this._minDistance, this._maxDistance, this.spatialBlend, "Ref distance=" + e), t.setRefDistance(e), t.setMaxDistance(Math.max(0.01, this._maxDistance)), this.rollOffMode) {
      case 0:
        t.setDistanceModel("exponential");
        break;
      case 1:
        t.setDistanceModel("linear");
        break;
      case 2:
        console.warn("Custom rolloff for AudioSource is not supported: " + this.name);
        break;
    }
    this.spatialBlend > 0 ? Et && !this.helper && (this.helper = new eS(t, t.getRefDistance()), t.add(this.helper)) : this.helper && this.helper.parent && this.helper.removeFromParent();
  }
  async onNewClip(t) {
    if (t && (this.clip = t), typeof t == "string")
      if (Et && console.log(t), t.endsWith(".mp3") || t.endsWith(".wav")) {
        if (this.audioLoader || (this.audioLoader = new Zp()), this.shouldPlay = !0, this._lastClipStartedLoading === t) {
          Et && console.log("Is currently loading:", this._lastClipStartedLoading, this);
          return;
        }
        this._lastClipStartedLoading = t, Et && console.log("load audio", t);
        const e = await this.audioLoader.loadAsync(t).catch(console.error);
        this._lastClipStartedLoading = null, e && this.createAudio(e);
      } else
        console.warn("Unsupported audio clip type", t);
    else
      this.shouldPlay = !0, this.createAudio();
  }
  /**
   * Plays the audio clip or media stream.
   * If no argument is provided, plays the currently assigned clip.
   * 
   * @param clip - Optional audio clip or {@link MediaStream} to play
   */
  play(t = void 0) {
    var i, n, o;
    !t && this.clip && (t = this.clip), t !== void 0 && typeof t != "string" && !(t instanceof MediaStream) && (z() && console.warn("Called play on AudioSource with unknown argument type:", t + `
Using the assigned clip instead:`, this.clip), t = this.clip);
    let e = !this.sound || t && t !== this.clip;
    if (typeof t == "string" && !this.audioLoader && (e = !0), (t instanceof MediaStream || typeof t == "string") && (this.clip = t), e) {
      this.shouldPlay = !0, this.onNewClip(t);
      return;
    }
    if (this.shouldPlay = !0, this._hasEnded = !1, Et && console.log("play", (i = this.sound) == null ? void 0 : i.getVolume(), this.sound), this.sound && !this.sound.isPlaying) {
      const a = this.context.application.muted;
      a && this.sound.setVolume(0), (n = this.gameObject) == null || n.add(this.sound), this.clip instanceof MediaStream ? (this.sound.setMediaStreamSource(this.clip), this._audioElement || (this._audioElement = document.createElement("audio"), this._audioElement.style.display = "none"), this._audioElement.parentNode || (o = this.context.domElement.shadowRoot) == null || o.append(this._audioElement), this._audioElement.srcObject = this.clip, this._audioElement.autoplay = !1) : (this._audioElement && this._audioElement.remove(), this.sound.play(a ? 0.1 : 0));
    }
  }
  /**
   * Pauses audio playback while maintaining the current position.
   * Use play() to resume from the paused position.
   */
  pause() {
    var t, e;
    Et && console.log("Pause", this), this._hasEnded = !0, this.shouldPlay = !1, this.sound && this.sound.isPlaying && this.sound.source && (this._lastContextTime = (t = this.sound) == null ? void 0 : t.context.currentTime, this.sound.pause()), (e = this._audioElement) == null || e.remove();
  }
  /**
   * Stops audio playback completely and resets the playback position to the beginning.
   * Unlike pause(), calling play() after stop() will start from the beginning.
   */
  stop() {
    var t, e;
    Et && console.log("Pause", this), this._hasEnded = !0, this.shouldPlay = !1, this.sound && this.sound.source && (this._lastContextTime = (t = this.sound) == null ? void 0 : t.context.currentTime, Et && console.log(this._lastContextTime), this.sound.stop()), (e = this._audioElement) == null || e.remove();
  }
  /** @internal */
  update() {
    this.helper && (this.isPlaying && this.helper.update(), this.helper.visible = this.isPlaying), this._needUpdateSpatialDistanceSettings && this.applySpatialDistanceSettings(), this.sound && !this.sound.isPlaying && this.shouldPlay && !this._hasEnded && (this._hasEnded = !0, Et && console.log("Audio clip ended", this.clip), this.dispatchEvent(new CustomEvent("ended", { detail: this })));
  }
};
let qe = eo;
Sn([
  f(URL)
], qe.prototype, "clip", 2);
Sn([
  f()
], qe.prototype, "playOnAwake", 2);
Sn([
  f()
], qe.prototype, "preload", 2);
Sn([
  f()
], qe.prototype, "playInBackground", 2);
Sn([
  f()
], qe.prototype, "loop", 1);
Sn([
  f()
], qe.prototype, "spatialBlend", 1);
Sn([
  f()
], qe.prototype, "minDistance", 1);
Sn([
  f()
], qe.prototype, "maxDistance", 1);
Sn([
  f()
], qe.prototype, "volume", 1);
Sn([
  f()
], qe.prototype, "pitch", 1);
Sn([
  f()
], qe.prototype, "rollOffMode", 2);
const eR = x("debugavatar"), un = class extends I {
  constructor() {
    super(...arguments);
    r(this, "connectionId");
    r(this, "avatar");
  }
  static getAvatar(e) {
    return e >= 0 && e < un.instances.length ? un.instances[e] : null;
  }
  static onAvatarMarkerCreated(e) {
    return un._onNewAvatarMarkerAdded.push(e), e;
  }
  static onAvatarMarkerDestroyed(e) {
    return un._onAvatarMarkerDestroyed.push(e), e;
  }
  awake() {
    un.instances.push(this), eR && console.log(this);
    for (const e of un._onNewAvatarMarkerAdded)
      e({ avatarMarker: this, gameObject: this.gameObject });
  }
  onDestroy() {
    un.instances.splice(un.instances.indexOf(this), 1);
    for (const e of un._onAvatarMarkerDestroyed)
      e({ avatarMarker: this, gameObject: this.gameObject });
  }
  isLocalAvatar() {
    return this.connectionId === this.context.connection.connectionId;
  }
};
let _t = un;
r(_t, "instances", []), r(_t, "_onNewAvatarMarkerAdded", []), r(_t, "_onAvatarMarkerDestroyed", []);
class go {
  static Add(t, e, i = null) {
    if (e) {
      for (const n of this.Pois)
        if (n.obj === e)
          return;
      this.Pois.push({ obj: e, avatar: i }), this.LastChangeTime = t.time.time;
    }
  }
  static Remove(t, e) {
    var i;
    if (e) {
      for (const n of this.Pois)
        if (n.obj === e) {
          this.Pois.splice(this.Pois.indexOf(n), 1), this.LastChangeTime = (t == null ? void 0 : t.time.time) ?? ((i = ee.Current) == null ? void 0 : i.time.time);
          return;
        }
    }
  }
}
r(go, "Pois", []), r(go, "LastChangeTime", 0);
class tR {
  constructor() {
    r(this, "guid");
    r(this, "position", new v());
  }
}
class Jd extends I {
  constructor() {
    super(...arguments);
    // that target to copy positions into
    r(this, "target", null);
    r(this, "avatar", null);
    r(this, "_model", null);
    r(this, "_targetModel", new tR());
    r(this, "_currentTargetObject", null);
    r(this, "_lastUpdateTime", 0);
    r(this, "_lookDuration", 0);
    r(this, "_lastPoiChangedTime", 0);
  }
  set controlledTarget(e) {
    this.target = e;
    const i = R.get("MoveRandom");
    if (i && this.target) {
      const n = S.getComponent(this.target, i);
      n && n.destroy();
    }
  }
  awake() {
    if (this.avatar = S.getComponentInParent(this.gameObject, _t), this.avatar) {
      const e = S.getComponentInParent(this.gameObject, _t);
      this._model = new X0(this.context.connection, this.guid), e != null && e.isLocalAvatar && this._model.requestOwnership();
    }
    this.context.connection.beginListen("avatar-look-target-changed", (e) => {
      var i;
      this.target && e && e.guid === ((i = this.avatar) == null ? void 0 : i.guid) && yt(this.target, e.position);
    });
  }
  update() {
    var i;
    if ((!this.context.connection.isConnected || (i = this._model) != null && i.hasOwnership) && (go.LastChangeTime !== this._lastPoiChangedTime && (this._lastPoiChangedTime = go.LastChangeTime, this._lookDuration = 0), this.selectTarget(), this._currentTargetObject && this.context.time.frameCount % 10 === 0 && this.target)) {
      const n = ie(this._currentTargetObject);
      yt(this.target, n), this.context.connection.isConnected && this.avatar && (this.context.connection.send("avatar-look-target-changed", this._targetModel), this._targetModel.guid = this.avatar.guid, this._targetModel.position.copy(n));
    }
  }
  selectTarget() {
    if (this.context.time.time - this._lastUpdateTime > this._lookDuration) {
      this._lastUpdateTime = this.context.time.time, this._lookDuration = Math.random() * 0.5 + 0.2;
      const i = go.Pois;
      if (i.length > 0) {
        const n = i[Math.floor(Math.random() * i.length)];
        if (n && n.obj) {
          if (n.avatar && n.avatar === this.avatar)
            return;
          this._currentTargetObject = n.obj;
        }
      }
    }
  }
}
var Fg = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.DontExport = 1] = "DontExport", s))(Fg || {});
function iR(s) {
  return s && s.isComponent;
}
const QD = Symbol("object"), ep = new tn(() => new v(), 20);
class nR {
  /** @internal */
  constructor(t, e, i, n, o, a) {
    r(this, "_point");
    r(this, "_normal");
    r(this, "_tangentVelocity");
    /** the distance of the collision point */
    r(this, "distance");
    /** the impulse velocity */
    r(this, "impulse");
    r(this, "friction");
    this._point = t, this.distance = e, this._normal = i, this.impulse = n, this.friction = o, this._tangentVelocity = a;
  }
  /** worldspace point */
  get point() {
    return ep.get().set(this._point.x, this._point.y, this._point.z);
  }
  /** worldspace normal */
  get normal() {
    return ep.get().set(this._normal.x, this._normal.y, this._normal.z);
  }
  /** worldspace tangent */
  get tangentVelocity() {
    return ep.get().set(this._tangentVelocity.x, this._tangentVelocity.y, this._tangentVelocity.z);
  }
}
class sR {
  /** @internal */
  constructor(t, e, i) {
    /** The contact points of this collision. Contains information about positions, normals, distance, friction, impulse... */
    r(this, "contacts");
    /** the gameobject this collision event belongs to (e.g. if onCollisionEnter is called then `me` is the same as `this.gameObject`) */
    r(this, "me");
    r(this, "_collider");
    r(this, "_gameObject");
    this.me = t, this._collider = e, this._gameObject = e.gameObject, this.contacts = i;
  }
  /** the other collider the collision happened with */
  get collider() {
    return this._collider;
  }
  /** the other object the collision happened with */
  get gameObject() {
    return this._gameObject;
  }
  /** the other rigidbody we hit, null if none attached */
  get rigidBody() {
    var t;
    return (t = this.collider) == null ? void 0 : t.attachedRigidbody;
  }
}
class oR {
  constructor(t, e) {
    r(this, "object");
    r(this, "collider");
    this.object = t, this.collider = e;
  }
}
const Ye = x("debugnetworkingstreams");
var xs = /* @__PURE__ */ ((s) => (s.Connected = "peer-user-connected", s.StreamReceived = "receive-stream", s.StreamEnded = "call-ended", s.Disconnected = "peer-user-disconnected", s.UserJoined = "user-joined", s))(xs || {});
class Fv {
  constructor(t, e) {
    r(this, "type", "call-ended");
    r(this, "userId");
    r(this, "direction");
    this.userId = t, this.direction = e;
  }
}
class rR {
  constructor(t, e, i) {
    r(this, "type", "receive-stream");
    r(this, "userId");
    r(this, "stream");
    r(this, "target");
    this.userId = t, this.stream = e, this.target = i;
  }
}
class aR {
  constructor(t, e) {
    /** the peer handle id */
    r(this, "guid");
    r(this, "peerId");
    // internal so server doesnt save it to persistent storage
    r(this, "dontSave", !0);
    this.guid = t.id, this.peerId = e;
  }
}
var lR = /* @__PURE__ */ ((s) => (s.Incoming = "incoming", s.Outgoing = "outgoing", s))(lR || {});
class cR extends ag {
  constructor(e, i, n, o = null) {
    super();
    r(this, "peerId");
    r(this, "userId");
    r(this, "direction");
    r(this, "call");
    r(this, "_stream", null);
    r(this, "_isDisposed", !1);
    this.peerId = i.peer, this.userId = e, this.call = i, this.direction = n, this._stream = o, i.on("stream", (a) => {
      if (Ye && console.log("Receive stream", `
Audio:`, a.getAudioTracks(), `
Video:`, a.getVideoTracks()), this._stream = a, n === "incoming") {
        const l = new rR(e, a, this);
        this.dispatchEvent(l);
      }
    }), i.on("close", () => {
      this.dispatchEvent(new Fv(e, n));
    });
  }
  get stream() {
    return this._stream;
  }
  close() {
    this._isDisposed || (this._isDisposed = !0, this.call.close(), Ss(this._stream));
  }
  get isOpen() {
    var e;
    return ((e = this.call.peerConnection) == null ? void 0 : e.connectionState) === "connected";
  }
  get isOpening() {
    var e;
    return ((e = this.call.peerConnection) == null ? void 0 : e.connectionState) === "connecting";
  }
  get isClosed() {
    return !this.isOpen || this._isDisposed;
  }
}
function sb(s) {
  return s = s.replace("a=fmtp:111 minptime=10;useinbandfec=1", "a=fmtp:111 ptime=5;useinbandfec=1;stereo=1;maxplaybackrate=48000;maxaveragebitrat=128000;sprop-stereo=1"), s;
}
const ya = class extends ag {
  constructor(e, i) {
    super();
    r(this, "updateCalls", () => {
      var e;
      for (let i = this._incomingCalls.length - 1; i >= 0; i--) {
        const n = this._incomingCalls[i];
        n.isClosed && !n.isOpening && this._incomingCalls.splice(i, 1);
      }
      for (let i = this._outgoingCalls.length - 1; i >= 0; i--) {
        const n = this._outgoingCalls[i];
        let o = !1;
        n.isClosed && !n.isOpening && ((e = n.stream) != null && e.active ? Ye && console.warn("!!! Stream is still active, don't remove call", n.userId, "Your id: " + this.context.connection.connectionId) : (Ye && console.warn("!!! Remove closed call", n.userId), o = !0)), this.context.connection.userIsInRoom(n.userId) === !1 && (Ye && console.warn("!!! User is not in room anymore, remove call", n.userId), o = !0), o && (n.close(), this._outgoingCalls.splice(i, 1));
      }
    });
    r(this, "id");
    r(this, "context");
    r(this, "_incomingCalls", []);
    r(this, "_outgoingCalls", []);
    r(this, "_peer");
    r(this, "_enabled", !1);
    r(this, "_enabledPeer", !1);
    r(this, "onConnectRoomFn", this.onConnectRoom.bind(this));
    /**
     * Emitted when a connection to the PeerServer is established. You may use the peer before this is emitted, but messages to the server will be queued. id is the brokering ID of the peer (which was either provided in the constructor or assigned by the server).
     * @param id ID of the peer 
    */
    r(this, "onPeerConnect", (e) => {
      if (Ye && console.log("PEER opened as", e), e === null) {
        console.error("Peer connection failed", e);
        return;
      }
      this.context.connection.send("peer-user-connected", new aR(this, e));
    });
    /** Emitted when the peer is destroyed and can no longer accept or create any new connections. At this time, the peer's connections will all be closed. */
    r(this, "onPeerClose", () => {
      Ye && console.log("PEER closed"), this.updateCalls();
    });
    /** Emitted when the peer is disconnected from the signalling server, either manually or because the connection to the signalling server was lost. */
    r(this, "onPeerDisconnected", () => {
      Ye && console.log("PEER disconnected"), this.updateCalls();
    });
    /**
     * Errors on the peer are almost always fatal and will destroy the peer. Errors from the underlying socket and PeerConnections are forwarded here.
     */
    r(this, "onPeerError", (e) => {
      Ye && console.error("PEER error", e);
    });
    r(this, "onPeerReceivingCall", (e) => {
      e.answer(void 0, {
        sdpTransform: (i) => sb(i)
      }), this.registerCall(e, "incoming", null);
    });
    this.context = e, this.id = i, this.setupPeer(), navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
  }
  static getOrCreate(e, i) {
    if (ya.instances.has(i))
      return ya.instances.get(i);
    const n = new ya(e, i);
    return ya.instances.set(i, n), n;
  }
  getMyPeerId() {
    if (this.context.connection.connectionId)
      return this.getPeerIdFromUserId(this.context.connection.connectionId);
  }
  getPeerIdFromUserId(e) {
    return this.id + "-" + e;
  }
  getUserIdFromPeerId(e) {
    return e.substring(this.id.length + 1);
  }
  makeCall(e, i) {
    var a;
    if (!(i != null && i.id)) {
      Ye ? console.warn("Can not make a call: mediastream has no id or is undefined") : console.debug("Can not make a call: mediastream has no id or is undefined");
      return;
    }
    const n = {
      metadata: {
        userId: this.context.connection.connectionId,
        streamId: i.id
      },
      sdpTransform: (l) => sb(l)
    }, o = (a = this._peer) == null ? void 0 : a.call(e, i, n);
    if (o) {
      const l = this.registerCall(o, "outgoing", i);
      return Ye && console.warn(`📞 CALL ${e}`, `
Outgoing:`, this._outgoingCalls, `
Incoming:`, this._incomingCalls), l;
    } else
      Ye && console.error("Failed to make call", e, i, this._peer);
  }
  closeAll() {
    for (const e of this._incomingCalls)
      e.close();
    for (const e of this._outgoingCalls)
      e.close();
    this.updateCalls();
  }
  get peer() {
    return this._peer;
  }
  get incomingCalls() {
    return this._incomingCalls;
  }
  // private onUserJoinedOrLeftRoomFn: Function = this.onUserJoinedOrLeftRoom.bind(this);
  // private onPeerConnectFn: (id) => void = this.onPeerConnect.bind(this);
  // private onPeerReceiveCallFn: (call) => void = this.onPeerReceivingCall.bind(this);
  // private _connectionPeerIdMap : Map<string, string> = new Map();
  enable() {
    this._enabled || (this._enabled = !0, this.context.connection.beginListen(ne.JoinedRoom, this.onConnectRoomFn), this.subscribePeerEvents());
  }
  disable() {
    this._enabled && (this._enabled = !1, this.context.connection.stopListen(ne.JoinedRoom, this.onConnectRoomFn), this.unsubscribePeerEvents());
  }
  onConnectRoom() {
    this.setupPeer();
  }
  // private onUserJoinedOrLeftRoom(_: UserJoinedOrLeftRoomModel): void {
  // };
  setupPeer() {
    if (this.context.connection.connectionId && !this._enabledPeer) {
      if (this._enabledPeer = !0, !this._peer) {
        const e = this.getMyPeerId();
        e ? this._peer = ZC(e) : console.error("Failed to setup peerjs because we dont have a connection id", this.context.connection.connectionId);
      }
      this._enabled && this.subscribePeerEvents();
    }
  }
  subscribePeerEvents() {
    this._peer && (this._peer.on("open", this.onPeerConnect), this._peer.on("close", this.onPeerClose), this._peer.on("call", this.onPeerReceivingCall), this._peer.on("disconnected", this.onPeerDisconnected), this._peer.on("error", this.onPeerError));
  }
  unsubscribePeerEvents() {
    this._peer && (this._peer.off("open", this.onPeerConnect), this._peer.off("close", this.onPeerClose), this._peer.off("call", this.onPeerReceivingCall), this._peer.off("disconnected", this.onPeerDisconnected), this._peer.off("error", this.onPeerError));
  }
  registerCall(e, i, n) {
    const o = e.metadata;
    (!o || !o.userId) && console.error("Missing call metadata", e);
    const a = o.userId;
    i === "incoming" && Ye ? console.warn("← Receive call from", e.metadata, e.connectionId) : Ye && console.warn("→ Make call to", e.metadata);
    const l = i === "incoming" ? this._incomingCalls : this._outgoingCalls, c = new cR(a, e, i, n);
    return l.push(c), e.on("error", (h) => {
      console.error("Call error", h);
    }), e.on("close", () => {
      Ye && console.log("Call ended", e.metadata);
      const h = l.indexOf(c);
      h !== -1 && l.splice(h, 1), c.close(), this.dispatchEvent(new Fv(a, i));
    }), c.addEventListener("call-ended", (h) => {
      this.dispatchEvent(h);
    }), i === "incoming" && (c.addEventListener("receive-stream", (h) => {
      this.dispatchEvent(h);
    }), e.on("stream", () => {
      Ye && console.log("Received stream for call", e.metadata);
      let h = 0;
      const d = setInterval(() => {
        const u = h === 0;
        !c.isOpen && u && (Ye && console.warn("Close call because stream is not active", e.metadata), h += 1, clearInterval(d), c.close());
      }, 2e3);
    })), c;
  }
  // private onRemotePeerConnect(user: PeerUserConnectedModel) {
  //     console.log("other user connected", user);
  // }
};
let Ma = ya;
r(Ma, "instances", /* @__PURE__ */ new Map());
class Gu extends ag {
  constructor(e, i) {
    super();
    r(this, "context");
    r(this, "peer");
    // private _receiveVideoStreamListeners: Array<(info: IncomingStreamArgs) => void> = [];
    r(this, "_sendingStreams", /* @__PURE__ */ new Map());
    /**
     * If true, will log debug information
     */
    r(this, "debug", !1);
    // private onConnectRoomFn: Function = this.onConnectRoom.bind(this);
    // private onUserConnectedFn: Function = this.onUserConnected.bind(this);
    // private onUserLeftFn: Function = this.onUserLeft.bind(this);
    r(this, "_enabled", !1);
    r(this, "_tickIntervalId");
    /* for webpack */
    r(this, "tick", () => {
      this.updateSendingCalls();
    });
    // private onUserJoinedPeer = (evt) => {
    //     if (!this.context.connection.isConnected && evt.userId) {
    //         this.startCallWithUserIfNotAlready(evt.userId);
    //     }
    // }
    // When either we ourselves OR someone else is joining the room we want to make sure to re-establish all calls
    // and if the user that joined is not yet receiving our video stream we want to start a stream with them
    // https://github.com/needle-tools/needle-tiny/issues/697#issuecomment-1510425539
    r(this, "onJoinedRoom", (e) => {
      this._sendingStreams.size > 0 && (this.debug && console.warn(`${e != null && e.userId ? `User ${e.userId}` : "You"} joined room`, e, this._sendingStreams.size), this.updateSendingCalls());
    });
    /** This is when the local user leaves the room */
    r(this, "onLeftRoom", (e) => {
      this.debug && console.warn(`${(e == null ? void 0 : e.userId) || "You"} left room`, e), this.stopCallsToUsersThatAreNotInTheRoomAnymore(), this.peer.closeAll();
    });
    r(this, "onCallStreamReceived", (e) => {
      this.debug && console.log("Call with " + e.userId + " started"), this.dispatchEvent({ type: "receive-stream", target: this, stream: e.stream, userId: e.userId }), this.debug && this.debugLogCurrentState();
    });
    r(this, "onCallEnded", (e) => {
      this.debug && console.log("Call with " + e.userId + " ended"), this.dispatchEvent(e), this.debug && this.debugLogCurrentState();
    });
    r(this, "onUserConnected", (e) => {
      if (this.peer.id === e.guid) {
        this.debug && console.log("PEER USER CONNECTED", e.guid, e, this._sendingStreams.size);
        const i = this._sendingStreams.keys().next().value;
        this.peer.makeCall(e.peerId, i);
      } else
        Ye && console.log("Unknown user connected", e.guid, e.peerId);
    });
    r(this, "onUserLeft", (e) => {
      this.debug && console.log("User left room: " + e.userId), this.stopCallsToUsersThatAreNotInTheRoomAnymore();
    });
    if (iR(e)) {
      const n = e;
      e = n.context, i = Ma.getOrCreate(n.context, n.guid);
    } else
      typeof i == "string" && (i = Ma.getOrCreate(e, i));
    if (e) {
      if (!(e instanceof ee))
        throw new Error("Failed to create NetworkedStreams because context is not an instance of Context");
    } else
      throw new Error("Failed to create NetworkedStreams because context is undefined");
    if (!i)
      throw new Error("Failed to create NetworkedStreams because peer is undefined");
    this.context = e, this.peer = i, Ye && (this.debug = !0);
  }
  /**
   * Create a new NetworkedStreams instance
   */
  static create(e, i) {
    const n = Ma.getOrCreate(e.context, i || e.context.connection.connectionId || e.guid);
    return new Gu(e.context, n);
  }
  startSendingStream(e) {
    this._sendingStreams.has(e) ? console.warn("Received start sending stream with stream that is already being sent") : (this._sendingStreams.set(e, []), this.updateSendingCalls());
  }
  stopSendingStream(e) {
    if (e) {
      const i = this._sendingStreams.get(e);
      if (i) {
        for (const n of i)
          n.close();
        i.length = 0;
      }
      this._sendingStreams.delete(e), i && this.debug && this.debugLogCurrentState();
    }
    this.updateSendingCalls();
  }
  get enabled() {
    return this._enabled;
  }
  enable() {
    this._enabled || (this._enabled = !0, this.peer.enable(), this.peer.addEventListener("receive-stream", this.onCallStreamReceived), this.peer.addEventListener("call-ended", this.onCallEnded), this.context.connection.beginListen("peer-user-connected", this.onUserConnected), this.context.connection.beginListen(ne.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ne.UserJoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ne.UserLeftRoom, this.onUserLeft), this.context.connection.beginListen(ne.LeftRoom, this.onLeftRoom), this._tickIntervalId = setInterval(this.tick, 5e3));
  }
  disable() {
    this._enabled && (this._enabled = !1, this.peer.disable(), this.peer.removeEventListener("receive-stream", this.onCallStreamReceived), this.peer.removeEventListener("call-ended", this.onCallEnded), this.context.connection.stopListen("peer-user-connected", this.onUserConnected), this.context.connection.stopListen(ne.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ne.UserJoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ne.UserLeftRoom, this.onUserLeft), this.context.connection.stopListen(ne.LeftRoom, this.onLeftRoom), this._tickIntervalId != null && (clearInterval(this._tickIntervalId), this._tickIntervalId = void 0));
  }
  updateSendingCalls() {
    const e = this.context.connection.connectionId;
    for (const i of this._sendingStreams.keys()) {
      const n = this._sendingStreams.get(i) || [];
      for (const o of this.context.connection.usersInRoom()) {
        if (o === e)
          continue;
        const a = this.peer.getPeerIdFromUserId(o);
        if (n.find((c) => {
          var h;
          return c.peerId === a && c.direction === "outgoing" && !c.isClosed && ((h = c.stream) == null ? void 0 : h.active);
        }))
          Ye && console.debug("Already have a call with user " + o + " / peer " + a);
        else {
          const c = this.peer.makeCall(a, i);
          c && n.push(c);
        }
      }
      this._sendingStreams.set(i, n);
    }
    this.stopCallsToUsersThatAreNotInTheRoomAnymore();
  }
  // private startCallWithUserIfNotAlready(userId: string) {
  //     for (const stream of this._sendingVideoStreams.keys()) {
  //         const calls = this._sendingVideoStreams.get(stream) || [];
  //         const existing = calls.find(c => c.userId === userId);
  //         if (!existing || existing.stream?.active === false) {
  //             if (this.debug) console.log("Starting call to", userId)
  //             const handle = this.peer.makeCall(this.peer.getPeerIdFromUserId(userId), stream);
  //             if (handle) {
  //                 calls.push(handle);
  //                 return true;
  //             }
  //         }
  //     }
  //     return false;
  // }
  stopCallsToUsersThatAreNotInTheRoomAnymore() {
    for (const e of this._sendingStreams.keys()) {
      const i = this._sendingStreams.get(e);
      if (i)
        for (let n = i.length - 1; n >= 0; n--) {
          const o = i[n];
          this.context.connection.userIsInRoom(o.userId) ? Ye && (this.context.connection.connectionId === o.userId ? console.warn(`You are still in the room [${n}] ${o.userId}`) : console.log(`User is still in room [${n}] ${o.userId}`)) : (Ye && console.log(`Remove call ${[n]} to user that is not in room anymore ${o.userId}`), o.close(), i.splice(n, 1));
        }
    }
    this.peer.updateCalls(), this.debug && this.debugLogCurrentState();
  }
  debugLogCurrentState() {
    console.warn(`You (${this.context.connection.connectionId}) are currently sending ${this._sendingStreams.size} and receiving ${this.peer.incomingCalls.length} calls (${this.peer.incomingCalls.map((e) => e.userId).join(", ")})`, this.peer.incomingCalls);
  }
  // const call = peer.call(peerId, stream);
}
function Ss(s) {
  if (s && s instanceof MediaStream)
    for (const t of s.getTracks())
      t.stop();
}
var hR = Object.defineProperty, dR = Object.getOwnPropertyDescriptor, zg = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? dR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && hR(t, e, n), n;
};
const uR = "noVoip", fR = x("debugvoip");
class Lr extends I {
  constructor() {
    super(...arguments);
    r(this, "autoConnect", !0);
    r(this, "runInBackground", !0);
    r(this, "createMenuButton", !0);
    /**
     * When enabled debug messages will be printed to the console. This is useful for debugging audio issues. You can also append ?debugvoip to the URL to enable this.
     */
    r(this, "debug", !1);
    r(this, "_net");
    r(this, "_menubutton");
    /** Set via the mic button (e.g. when the websocket connection closes and rejoins but the user was muted before we don't want to enable VOIP again automatically) */
    r(this, "_allowSending", !0);
    r(this, "_outputStream", null);
    // we have to wait for the user to connect to a room when "auto connect" is enabled
    r(this, "onJoinedRoom", async () => {
      this.debug && console.log("VOIP: Joined room"), await Gn(300), this.autoConnect && !this.isSending && this._allowSending && this.connect();
    });
    r(this, "onLeftRoom", () => {
      this.debug && console.log("VOIP: Left room"), this.disconnect();
      for (const e of this._incomingStreams.values())
        Ss(e.srcObject);
      this._incomingStreams.clear();
    });
    r(this, "_incomingStreams", /* @__PURE__ */ new Map());
    r(this, "onReceiveStream", (e) => {
      const i = e.target.userId, n = e.stream;
      let o = this._incomingStreams.get(i);
      o || (o = new Audio(), this._incomingStreams.set(i, o)), o.srcObject = n, o.setAttribute("autoplay", "true"), Wn.registerWaitForInteraction(() => {
        o == null || o.play().catch((a) => {
          console.error("VOIP: Failed to play audio", a);
        });
      });
    });
    r(this, "onStreamEnded", (e) => {
      const i = this._incomingStreams.get(e.userId);
      Ss(i == null ? void 0 : i.srcObject), this._incomingStreams.delete(e.userId);
    });
    r(this, "onEnabledChanged", () => {
      for (const e of this._incomingStreams) {
        const i = e[1];
        i.muted = !this.enabled;
      }
    });
    r(this, "onVisibilityChanged", () => {
      if (this.runInBackground)
        return;
      const i = !(document.visibilityState === "visible");
      this.setMuted(i);
      for (const n of this._incomingStreams) {
        const o = n[1];
        o.muted = i;
      }
    });
  }
  /** @internal */
  awake() {
    fR && (this.debug = !0), this.debug && (console.log("VOIP debugging: press 'v' to toggle mute or 'c' to toggle connect/disconnect"), window.addEventListener("keydown", async (e) => {
      switch (e.key.toLowerCase()) {
        case "v":
          console.log("MUTE?", !this.isMuted), this.setMuted(!this.isMuted);
          break;
        case "c":
          this.isSending ? this.disconnect() : this.connect();
          break;
      }
    }), window.addEventListener("blur", () => {
      console.log("VOIP: MUTE ON BLUR"), this.setMuted(!0);
    }), window.addEventListener("focus", () => {
      console.log("VOIP: UNMUTE ON FOCUS"), this.setMuted(!1);
    }));
  }
  /** @internal */
  onEnable() {
    this._net || (this._net = Gu.create(this)), this.debug && (this._net.debug = !0), this._net.addEventListener(xs.StreamReceived, this.onReceiveStream), this._net.addEventListener(xs.StreamEnded, this.onStreamEnded), this._net.enable(), this.autoConnect && this.context.connection.isConnected && this.connect(), this.context.connection.beginListen(ne.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ne.LeftRoom, this.onLeftRoom), this.onEnabledChanged(), this.updateButton(), window.addEventListener("visibilitychange", this.onVisibilityChanged);
  }
  /** @internal */
  onDisable() {
    var e;
    this._net && (this._net.stopSendingStream(this._outputStream), this._net.removeEventListener(xs.StreamReceived, this.onReceiveStream), this._net.removeEventListener(xs.StreamEnded, this.onStreamEnded), (e = this._net) == null || e.disable()), this.context.connection.stopListen(ne.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ne.LeftRoom, this.onLeftRoom), this.onEnabledChanged(), this.updateButton(), window.removeEventListener("visibilitychange", this.onVisibilityChanged);
  }
  /** @internal */
  onDestroy() {
    var e;
    (e = this._menubutton) == null || e.remove(), this._menubutton = void 0;
  }
  /**
   * @returns true if the component is currently sending audio
   */
  get isSending() {
    return this._outputStream != null && this._outputStream.active;
  }
  /** Start sending audio. */
  async connect(e) {
    var i, n;
    if (!this._net)
      return console.error("Cannot connect to voice chat - NetworkedStreams not initialized. Make sure the component is enabled before calling this method."), !1;
    if (this.context.connection.isConnected) {
      if (!await X.microphonePermissionsGranted())
        return console.error("Cannot connect to voice chat - microphone permissions not granted"), this.updateButton(), !1;
    } else
      return console.error("Cannot connect to voice chat - not connected to server"), this.updateButton(), !1;
    return this._allowSending = !0, (i = this._net) == null || i.stopSendingStream(this._outputStream), Ss(this._outputStream), this._outputStream = await this.getAudioStream(e), this._outputStream ? (this.debug && console.log("VOIP: Got audio stream"), (n = this._net) == null || n.startSendingStream(this._outputStream), this.updateButton(), !0) : (this.updateButton(), await X.microphonePermissionsGranted() ? console.error("VOIP: Could not get audio stream - please make sure to connect an audio device and grant microphone permissions") : Iu("Microphone permissions not granted: Please grant microphone permissions to use voice chat"), (this.debug || z()) && console.log("VOIP: Failed to get audio stream"), !1);
  }
  /** Stop sending audio (muting your own microphone) */
  disconnect(e) {
    var i;
    e != null && e.remember && (this._allowSending = !1), (i = this._net) == null || i.stopSendingStream(this._outputStream), Ss(this._outputStream), this._outputStream = null, this.updateButton();
  }
  /**
   * Mute or unmute the audio stream (this will only mute incoming streams and not mute your own microphone. Use disconnect() to mute your own microphone)
   */
  setMuted(e) {
    var n;
    const i = (n = this._outputStream) == null ? void 0 : n.getAudioTracks();
    if (i)
      for (const o of i)
        o.enabled = !e;
  }
  /** Returns true if the audio stream is currently muted */
  get isMuted() {
    var i;
    if (this._outputStream === null)
      return !1;
    const e = (i = this._outputStream) == null ? void 0 : i.getAudioTracks();
    if (e) {
      for (const n of e)
        if (!n.enabled)
          return !0;
    }
    return !1;
  }
  async updateButton() {
    var e;
    if (this.createMenuButton) {
      if (this._menubutton || (this._menubutton = document.createElement("button"), this._menubutton.addEventListener("click", () => {
        this.isSending ? this.disconnect({ remember: !0 }) : this.connect(), X.microphonePermissionsGranted().then((i) => {
          i || ve("<strong>Microphone permissions not granted</strong>. Please allow your browser to use the microphone to be able to talk. Click on the button on the left side of your browser's address bar to allow microphone permissions.");
        });
      })), this._menubutton) {
        this.context.menu.appendChild(this._menubutton), this.activeAndEnabled ? this._menubutton.style.display = "" : this._menubutton.style.display = "none", this._menubutton.title = this.isSending ? "Click to disable your microphone" : "Click to enable your microphone";
        let i = (this.isSending, ""), n = this.isSending ? "mic" : "mic_off";
        await X.microphonePermissionsGranted() || (i = "No Permission", n = "mic_off", this._menubutton.title = "Microphone permissions not granted. Please allow your browser to use the microphone to be able to talk. This can usually be done in the addressbar of the webpage."), this._menubutton.innerText = i, this._menubutton.prepend(Dt(n)), this.context.connection.isConnected == !1 ? this._menubutton.setAttribute("disabled", "") : this._menubutton.removeAttribute("disabled");
      }
    } else
      this.activeAndEnabled || (e = this._menubutton) == null || e.remove();
  }
  // private _analyzer?: AudioAnalyser;
  /** @deprecated */
  getFrequency(e) {
    return this.unsupported_getfrequency || (this.unsupported_getfrequency = !0, z() && ve("VOIP: getFrequency is currently not supported"), console.warn("VOIP: getFrequency is currently not supported")), null;
  }
  async getAudioStream(e) {
    if (!navigator.mediaDevices.getUserMedia)
      return console.error("No getDisplayMedia support"), null;
    const i = async (o) => await navigator.mediaDevices.getUserMedia({ audio: o ?? !0, video: !1 }).catch((a) => (console.warn("VOIP failed getting audio stream", a), null)), n = await i(e);
    if (!n)
      return null;
    if (X.isiOS() && (e == null ? void 0 : e.deviceId) === void 0) {
      const a = (await navigator.mediaDevices.enumerateDevices()).find((l) => (l.kind === "audioinput" || l.kind === "audiooutput") && !l.label.includes("iPhone"));
      if (a) {
        const l = Object.assign({}, e);
        return l.deviceId = a.deviceId, await i(l);
      }
    }
    return n;
  }
}
zg([
  f()
], Lr.prototype, "autoConnect", 2);
zg([
  f()
], Lr.prototype, "runInBackground", 2);
zg([
  f()
], Lr.prototype, "createMenuButton", 2);
var pR = Object.defineProperty, mR = Object.getOwnPropertyDescriptor, zv = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? mR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && pR(t, e, n), n;
};
const gR = x("debugmouth");
class qu extends I {
  constructor() {
    super(...arguments);
    r(this, "idle", []);
    r(this, "talking", []);
    r(this, "marker", null);
    r(this, "voip", null);
    r(this, "lastMouthChangeTime", 0);
    r(this, "mouthChangeLength", 0);
  }
  awake() {
    setTimeout(() => {
      this.voip = S.findObjectOfType(Lr, this.context), this.marker || (this.marker = S.getComponentInParent(this.gameObject, _t));
    }, 3e3);
  }
  update() {
    var n;
    if (!this.voip || this.context.time.frameCount % 10 !== 0)
      return;
    let e = ((n = this.marker) == null ? void 0 : n.connectionId) ?? null;
    if (!e) {
      gR && (e = null);
      return;
    }
    const i = this.voip.getFrequency(e) ?? 0;
    this.updateLips(i);
  }
  updateLips(e) {
    if (this.context.time.time - this.lastMouthChangeTime > this.mouthChangeLength) {
      if (this.mouthChangeLength = 0.05 + Math.random() * 0.1, this.talking && this.talking.length > 0 && e > 30) {
        this.lastMouthChangeTime = this.context.time.time;
        const i = Math.floor(Math.random() * this.talking.length);
        this.setMouthShapeActive(this.talking, i);
      } else if (this.idle.length > 0 && this.context.time.time - this.lastMouthChangeTime > 0.5) {
        this.lastMouthChangeTime = this.context.time.time;
        const i = Math.floor(Math.random() * this.idle.length);
        this.setMouthShapeActive(this.idle, i);
      }
    }
  }
  setMouthShapeActive(e, i) {
    if (e) {
      e != this.idle ? this.idle.map((n) => n.visible = !1) : this.talking.map((n) => n.visible = !1);
      for (let n = 0; n < e.length; n++) {
        const o = e[n];
        o && (o.visible = n === i);
      }
    }
  }
  // private tryFindMouthShapes() {
  //     if (this.mouthShapes) return;
  //     this.mouthShapes = [];
  //     this.head?.traverse(o => {
  //         if (o && o.type === "Mesh") {
  //             if (o.name.lastIndexOf("mouth") > 0) {
  //                 this.mouthShapes.push(o as Mesh);
  //             }
  //         }
  //     });
  // }
}
zv([
  f(L)
], qu.prototype, "idle", 2);
zv([
  f(L)
], qu.prototype, "talking", 2);
class Uv extends I {
  constructor() {
    super(...arguments);
    r(this, "voip", null);
    r(this, "marker", null);
    r(this, "_startPosition", null);
  }
  awake() {
    this.voip = S.findObjectOfType(Lr, this.context), this.marker = S.getComponentInParent(this.gameObject, _t);
  }
  update() {
    if (!this.voip || !this.marker || this.context.time.frameCount % 10 !== 0)
      return;
    const e = this.marker.connectionId, i = this.voip.getFrequency(e);
    if (i == null)
      return;
    this._startPosition || (this._startPosition = this.gameObject.position.clone());
    const n = i / 100;
    this.gameObject.position.y = this._startPosition.y + n * 0.07;
  }
}
var _R = Object.defineProperty, yR = Object.getOwnPropertyDescriptor, bR = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? yR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && _R(t, e, n), n;
};
const aa = x("debugxrflags"), Nv = x("disablexrflags");
Nv && console.warn("XRFlags are disabled");
var ws = /* @__PURE__ */ ((s) => (s[s.Never = 0] = "Never", s[s.Browser = 1] = "Browser", s[s.AR = 2] = "AR", s[s.VR = 4] = "VR", s[s.FirstPerson = 8] = "FirstPerson", s[s.ThirdPerson = 16] = "ThirdPerson", s[s.All = 4294967295] = "All", s))(ws || {});
const M_ = class {
  constructor() {
    r(this, "Mask", 17);
  }
  Has(t) {
    return (this.Mask & t) !== 0;
  }
  Set(t) {
    aa && console.warn("Set XR flag state to", t), this.Mask = t, Xi.Apply();
  }
  Enable(t) {
    this.Mask |= t, Xi.Apply();
  }
  Disable(t) {
    this.Mask &= ~t, Xi.Apply();
  }
  Toggle(t) {
    this.Mask ^= t, Xi.Apply();
  }
  EnableAll() {
    this.Mask = -1, Xi.Apply();
  }
  DisableAll() {
    this.Mask = 0, Xi.Apply();
  }
};
let ei = M_;
r(ei, "Global", new M_());
var $l;
const ls = ($l = class extends I {
  constructor() {
    super(...arguments);
    r(this, "visibleIn");
  }
  static Apply() {
    for (const t of this.registry)
      t.UpdateVisible(ei.Global);
  }
  awake() {
    ls.registry.push(this);
  }
  onEnable() {
    ls.firstApply ? this.UpdateVisible(ei.Global) : (ls.firstApply = !0, ls.Apply());
  }
  onDestroy() {
    const t = ls.registry.indexOf(this);
    t >= 0 && ls.registry.splice(t, 1);
  }
  get isOn() {
    return this.gameObject.visible;
  }
  UpdateVisible(t = null) {
    if (Nv)
      return;
    let e;
    const i = t;
    if (i && typeof i == "number" && (console.assert(typeof i == "number", "XRFlag.UpdateVisible: state must be a number", i), aa && console.log(i), ls.buffer.Mask = i, t = ls.buffer), t instanceof ei ? (aa && console.warn(this.name, "use passed in mask", t.Mask, this.visibleIn), e = t.Has(this.visibleIn)) : (aa && console.log(this.name, "use global mask"), ei.Global.Has(this.visibleIn)), e !== void 0)
      if (e)
        aa && console.log(this.name, "is visible", this.gameObject.uuid), S.setActive(this.gameObject, !0);
      else {
        if (aa && console.log(this.name, "is not visible", this.gameObject.uuid), !this.gameObject.visible)
          return;
        this.gameObject.visible = !1;
      }
  }
}, r($l, "registry", []), r($l, "firstApply"), r($l, "buffer", new ei()), $l);
let Xi = ls;
bR([
  f()
], Xi.prototype, "visibleIn", 2);
var vR = Object.defineProperty, wR = Object.getOwnPropertyDescriptor, Xu = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? wR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && vR(t, e, n), n;
};
class Ja extends I {
  constructor() {
    super(...arguments);
    r(this, "eyes", []);
    r(this, "lastBlinkTime", 0);
    r(this, "blinkLength", 0);
    r(this, "eyesOpen", !0);
    r(this, "state", null);
  }
  awake() {
    this.state = S.getComponentInParent(this.gameObject, Xi);
  }
  update() {
    if (!this.gameObject || !this.gameObject.visible || !this.eyes || !Array.isArray(this.eyes) || this.eyes.length === 0)
      return;
    if (this.context.time.time - this.lastBlinkTime > this.blinkLength) {
      if (this.lastBlinkTime = this.context.time.time, this.state && !this.state.isOn || !this.activeAndEnabled)
        return;
      if (this.eyesOpen = !this.eyesOpen, this.blinkLength = Math.random(), this.eyesOpen ? (this.blinkLength *= 3, this.blinkLength += 0.5, Math.random() < 0.1 && (this.blinkLength = 0.1 + Math.random() * 0.2)) : (this.blinkLength *= Math.random() * 0.2, this.blinkLength += 0.1), Math.random() < 0.1 && (this.blinkLength *= 3), this.blinkLength = Math.max(0.2, this.blinkLength), this.blinkLength = Math.min(3, this.blinkLength), this.eyes)
        for (const i of this.eyes)
          i && (i.visible = this.eyesOpen);
    }
  }
}
Xu([
  f(L)
], Ja.prototype, "eyes", 2);
Xu([
  f()
], Ja.prototype, "lastBlinkTime", 2);
Xu([
  f()
], Ja.prototype, "blinkLength", 2);
Xu([
  f()
], Ja.prototype, "eyesOpen", 2);
var xR = Object.defineProperty, SR = Object.getOwnPropertyDescriptor, Ug = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? SR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && xR(t, e, n), n;
}, Fp;
const $v = (Fp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "head", null);
    r(this, "eyes", null);
    r(this, "target", null);
    r(this, "brain", null);
    r(this, "vec", new v());
    r(this, "currentTargetPoint", new v());
  }
  awake() {
    this.brain || (this.brain = S.getComponentInParent(this.gameObject, Jd)), this.brain || (this.brain = S.addComponent(this.gameObject, Jd)), this.brain && this.target && (this.brain.controlledTarget = this.target);
  }
  update() {
    const t = this.target;
    if (t && this.head) {
      const e = this.eyes;
      if (e) {
        const i = ie(t);
        this.currentTargetPoint.lerp(i, this.context.time.deltaTime / 0.1);
        const n = ie(this.head), o = this.vec.copy(this.currentTargetPoint).sub(n).normalize();
        if (o.length() < 0.1)
          return;
        const a = $v.forward;
        if (a.set(0, 0, 1), a.applyQuaternion(Ce(this.head)), a.dot(o) > 0.45)
          for (let c = 0; c < e.length; c++)
            e[c].lookAt(this.currentTargetPoint);
      }
    }
  }
}, r(Fp, "forward", new v(0, 0, 1)), Fp);
let Jc = $v;
Ug([
  f(L)
], Jc.prototype, "head", 2);
Ug([
  f(L)
], Jc.prototype, "eyes", 2);
Ug([
  f(L)
], Jc.prototype, "target", 2);
var CR = Object.defineProperty, PR = Object.getOwnPropertyDescriptor, Ng = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? PR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && CR(t, e, n), n;
};
class eh extends I {
  constructor() {
    super(...arguments);
    r(this, "length", 1);
    r(this, "depthTest", !0);
    r(this, "isGizmo", !1);
    r(this, "_axes", null);
  }
  /**
   * Creates and adds the axes visualization to the scene when the component is enabled.
   * If marked as a gizmo, it will only be shown when gizmos are enabled in the global parameters.
   */
  onEnable() {
    if (this.isGizmo && !Xc)
      return;
    this._axes || (this._axes = new Oi(this.length)), this._axes.layers.disableAll(), this._axes.layers.set(this.layer), this.gameObject.add(this._axes);
    const e = this._axes.material;
    e && e.depthTest !== void 0 && (e.depthTest = this.depthTest);
  }
  /**
   * Removes the axes visualization from the scene when the component is disabled.
   */
  onDisable() {
    this._axes && this.gameObject.remove(this._axes);
  }
}
Ng([
  f()
], eh.prototype, "length", 2);
Ng([
  f()
], eh.prototype, "depthTest", 2);
Ng([
  f()
], eh.prototype, "isGizmo", 2);
class Wv extends I {
  constructor() {
    super(...arguments);
    r(this, "from");
    r(this, "to");
    r(this, "hint");
    r(this, "desiredDistance", 1);
  }
  onEnable() {
  }
  update() {
    if (!this.from || !this.to || !this.hint)
      return;
    const e = ie(this.to).clone(), i = ie(this.from).clone(), n = e.distanceTo(i), o = e.clone();
    o.sub(i);
    const a = i.clone();
    a.add(e), a.multiplyScalar(0.5);
    const l = ie(this.hint).clone();
    l.sub(a);
    const c = new v();
    c.crossVectors(l, o), c.crossVectors(o, c), c.normalize();
    const h = n * 0.5, d = Math.max(this.desiredDistance, h), u = Math.sqrt(d * d - h * h), p = c.clone();
    p.multiplyScalar(u), p.add(a), yt(this.gameObject, p);
    const m = a.clone();
    m.sub(c), this.gameObject.lookAt(m);
  }
}
const OR = x("gizmos"), MR = x("debugboxhelper"), fn = class extends I {
  constructor() {
    super(...arguments);
    /** The bounding box for this component */
    r(this, "box", null);
    r(this, "_lastMatrixUpdateFrame", -1);
    r(this, "_helper", null);
    r(this, "_color", null);
  }
  /**
   * Tests if an object intersects with this helper's bounding box
   * @param obj The object to test for intersection
   * @returns True if objects intersect, false if not, undefined if the provided object is invalid
   */
  isInBox(e) {
    var n;
    if (!e)
      return;
    if (this.box || (this.box = new Pi()), ki([e], void 0, void 0, fn.testBox), fn.testBox.isEmpty()) {
      const o = ie(e, fn._position);
      fn.testBox.setFromCenterAndSize(o, fn._emptyObjectSize);
    }
    this.updateBox();
    const i = (n = this.box) == null ? void 0 : n.intersectsBox(fn.testBox);
    return i && MR && V.DrawWireBox3(fn.testBox, 16711680, 5), i;
  }
  /**
   * Tests if this helper's bounding box intersects with another box
   * @param box The {@link Box3} to test for intersection
   * @returns True if boxes intersect, false otherwise
   */
  intersects(e) {
    return e ? this.updateBox(!1).intersectsBox(e) : !1;
  }
  /**
   * Updates the helper's bounding box based on the gameObject's position and scale
   * @param force Whether to force an update regardless of frame count
   * @returns The updated {@link Box3}
   */
  updateBox(e = !1) {
    if (this.box || (this.box = new Pi()), e || this.context.time.frameCount != this._lastMatrixUpdateFrame) {
      const i = this._lastMatrixUpdateFrame < 0;
      this._lastMatrixUpdateFrame = this.context.time.frameCount;
      const n = i, o = ie(this.gameObject, fn._position, n), a = Ke(this.gameObject, fn._size);
      this.box.setFromCenterAndSize(o, a);
    }
    return this.box;
  }
  awake() {
    this._helper = null, this._color = null, this.box = null;
  }
  /**
   * Creates and displays a visual wireframe representation of this box helper
   * @param col Optional color for the wireframe. If not provided, uses default color
   * @param force If true, shows the helper even if gizmos are disabled
   */
  showHelper(e = null, i = !1) {
    var n;
    if (!(!OR && !i)) {
      if (this._helper) {
        e && ((n = this._color) == null || n.set(e)), this.gameObject.add(this._helper);
        return;
      }
      this._helper = Sg(e), this.gameObject.add(this._helper);
    }
  }
};
let wi = fn;
r(wi, "testBox", new Pi()), r(wi, "_position", new v()), r(wi, "_size", new v(0.01, 0.01, 0.01)), r(wi, "_emptyObjectSize", new v(0.01, 0.01, 0.01));
var RR = Object.defineProperty, kR = Object.getOwnPropertyDescriptor, fi = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? kR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && RR(t, e, n), n;
};
class Ai extends I {
  constructor() {
    super(...arguments);
    r(this, "attachedRigidbody", null);
    r(this, "isTrigger", !1);
    r(this, "sharedMaterial");
    r(this, "membership", [0]);
    r(this, "filter");
    /**
     * Updates the collider's properties in the physics engine.
     * Use this when you've changed collider properties and need to sync with the physics engine.
     */
    r(this, "updateProperties", () => {
      var e;
      (e = this.context.physics.engine) == null || e.updateProperties(this);
    });
  }
  /**
   * Identifies this component as a collider.
   * @internal
   */
  get isCollider() {
    return !0;
  }
  /** @internal */
  awake() {
    super.awake(), this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(_e));
  }
  /** @internal */
  start() {
    this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(_e));
  }
  /** @internal */
  onEnable() {
    this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(_e));
  }
  /** @internal */
  onDisable() {
    var e;
    (e = this.context.physics.engine) == null || e.removeBody(this);
  }
  /**
   * Returns the underlying physics body from the physics engine.
   * Only available if the component is enabled and active in the scene.
   */
  get body() {
    var e;
    return (e = this.context.physics.engine) == null ? void 0 : e.getBody(this);
  }
  /**
   * Updates the physics material in the physics engine.
   * Call this after changing the sharedMaterial property.
   */
  updatePhysicsMaterial() {
    var e;
    (e = this.context.physics.engine) == null || e.updatePhysicsMaterial(this);
  }
}
fi([
  f(_e)
], Ai.prototype, "attachedRigidbody", 2);
fi([
  f()
], Ai.prototype, "isTrigger", 2);
fi([
  f()
], Ai.prototype, "sharedMaterial", 2);
fi([
  f()
], Ai.prototype, "membership", 2);
fi([
  f()
], Ai.prototype, "filter", 2);
class th extends Ai {
  constructor() {
    super(...arguments);
    r(this, "radius", 0.5);
    r(this, "center", new v(0, 0, 0));
  }
  /**
   * Registers the sphere collider with the physics engine and sets up scale change monitoring.
   */
  onEnable() {
    var e;
    super.onEnable(), (e = this.context.physics.engine) == null || e.addSphereCollider(this), fg(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Removes scale change monitoring when the collider is disabled.
   */
  onDisable() {
    super.onDisable(), b0(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Updates collider properties when validated in the editor or inspector.
   */
  onValidate() {
    this.updateProperties();
  }
}
fi([
  Nt(),
  f()
], th.prototype, "radius", 2);
fi([
  f(v)
], th.prototype, "center", 2);
const Vv = class extends Ai {
  constructor() {
    super(...arguments);
    r(this, "size", new v(1, 1, 1));
    r(this, "center", new v(0, 0, 0));
  }
  /**
   * Creates and adds a BoxCollider to the given object.
   * @param obj The object to add the collider to
   * @param opts Configuration options for the collider and optional rigidbody
   * @returns The newly created BoxCollider
   */
  static add(t, e) {
    const i = en(t, Vv);
    return i.autoFit(), (e == null ? void 0 : e.rigidbody) === !0 && en(t, _e, { isKinematic: !1 }), i;
  }
  /**
   * Registers the box collider with the physics engine and sets up scale change monitoring.
   * @internal
   */
  onEnable() {
    var t;
    super.onEnable(), (t = this.context.physics.engine) == null || t.addBoxCollider(this, this.size), fg(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Removes scale change monitoring when the collider is disabled.
   * @internal
   */
  onDisable() {
    super.onDisable(), b0(this.gameObject.scale, this.updateProperties);
  }
  /**
   * Updates collider properties when validated in the editor or inspector.
   * @internal
   */
  onValidate() {
    this.updateProperties();
  }
  /**
   * Automatically fits the collider to the geometry of the object.
   * Sets the size and center based on the object's bounding box.
   * @param opts Options object with a debug flag to visualize the bounding box
   */
  autoFit(t) {
    const e = this.gameObject, i = e.position.clone(), n = e.quaternion.clone(), o = e.scale.clone(), a = e.parent;
    e.position.set(0, 0, 0), e.quaternion.set(0, 0, 0, 1), e.scale.set(1, 1, 1), e.parent = null, e.updateMatrix();
    const l = ki([e]);
    e.position.copy(i), e.quaternion.copy(n), e.scale.copy(o), e.parent = a, (t == null ? void 0 : t.debug) === !0 && V.DrawWireBox3(l, 16768256, 20), this.size = l.getSize(new v()) || new v(1, 1, 1), this.center = l.getCenter(new v()) || new v(0, 0, 0), this.size.length() <= 0 && this.size.set(0.01, 0.01, 0.01);
  }
};
let ih = Vv;
fi([
  Nt(),
  f(v)
], ih.prototype, "size", 2);
fi([
  f(v)
], ih.prototype, "center", 2);
class jr extends Ai {
  constructor() {
    super(...arguments);
    r(this, "sharedMesh");
    r(this, "convex", !1);
  }
  /**
   * Creates and registers the mesh collider with the physics engine.
   * Handles both individual meshes and mesh groups.
   */
  onEnable() {
    var i, n, o;
    if (super.onEnable(), !this.context.physics.engine)
      return;
    (i = this.sharedMesh) != null && i.isMesh || (this.gameObject instanceof q || this.gameObject instanceof ho) && (this.sharedMesh = this.gameObject);
    const e = 0;
    if ((n = this.sharedMesh) != null && n.isMesh)
      this.context.physics.engine.addMeshCollider(this, this.sharedMesh, this.convex), Ze.assignMeshLOD(this.sharedMesh, e).then((a) => {
        a && this.activeAndEnabled && this.context.physics.engine && this.sharedMesh && (this.context.physics.engine.removeBody(this), this.sharedMesh.geometry = a, this.context.physics.engine.addMeshCollider(this, this.sharedMesh, this.convex));
      });
    else {
      const a = this.sharedMesh;
      if (a != null && a.isGroup) {
        console.warn(`MeshCollider mesh is a group "${((o = this.sharedMesh) == null ? void 0 : o.name) || this.gameObject.name}", adding all children as colliders. This is currently not fully supported (colliders can not be removed from world again)`, this);
        const l = new Array();
        for (const c in a.children) {
          const h = a.children[c];
          h.isMesh && (this.context.physics.engine.addMeshCollider(this, h, this.convex), l.push(Ze.assignMeshLOD(h, e)));
        }
        Promise.all(l).then((c) => {
          var d, u;
          if (c.some((p) => p) == !1)
            return;
          (d = this.context.physics.engine) == null || d.removeBody(this);
          const h = new q();
          for (const p of c)
            p && this.activeAndEnabled && (h.geometry = p, (u = this.context.physics.engine) == null || u.addMeshCollider(this, h, this.convex));
        });
      } else
        (z() || x("showcolliders")) && console.warn(`[MeshCollider] A MeshCollider mesh is assigned to an unknown object on "${this.gameObject.name}", but it's neither a Mesh nor a Group. Please double check that you attached the collider component to the right object and report a bug otherwise!`, this);
    }
  }
}
fi([
  f(q)
], jr.prototype, "sharedMesh", 2);
fi([
  f()
], jr.prototype, "convex", 2);
class So extends Ai {
  constructor() {
    super(...arguments);
    r(this, "center", new v(0, 0, 0));
    r(this, "radius", 0.5);
    r(this, "height", 2);
  }
  /**
   * Registers the capsule collider with the physics engine.
   */
  onEnable() {
    var e;
    super.onEnable(), (e = this.context.physics.engine) == null || e.addCapsuleCollider(this, this.height, this.radius);
  }
}
fi([
  f(v)
], So.prototype, "center", 2);
fi([
  f()
], So.prototype, "radius", 2);
fi([
  f()
], So.prototype, "height", 2);
var TR = Object.defineProperty, AR = Object.getOwnPropertyDescriptor, js = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? AR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && TR(t, e, n), n;
};
const ob = x("debugcharactercontroller");
class el extends I {
  constructor() {
    super(...arguments);
    r(this, "center", new v(0, 0, 0));
    r(this, "radius", 0.5);
    r(this, "height", 2);
    r(this, "_rigidbody", null);
    r(this, "_activeGroundCollisions");
    r(this, "_contactVelocity", new v());
  }
  get rigidbody() {
    return this._rigidbody ? this._rigidbody : (this._rigidbody = this.gameObject.getComponent(_e), this._rigidbody || (this._rigidbody = this.gameObject.addComponent(_e)), this.rigidbody);
  }
  awake() {
    this._activeGroundCollisions = /* @__PURE__ */ new Set();
  }
  onEnable() {
    const e = this.rigidbody;
    let i = this.gameObject.getComponent(So);
    i || (i = this.gameObject.addComponent(So)), i.center.copy(this.center), i.radius = this.radius, i.height = this.height;
    const n = new v(0, 0, 1), o = new v(1, 0, 0), a = new v(0, 1, 0), l = this.gameObject.getWorldDirection(new v());
    l.y = 0;
    const c = o.dot(l) < 0 ? -1 : 1, h = n.angleTo(l) * c;
    this.gameObject.setRotationFromAxisAngle(a, h), e.lockRotationX = !0, e.lockRotationY = !0, e.lockRotationZ = !0;
  }
  move(e) {
    this.gameObject.position.add(e);
  }
  onCollisionEnter(e) {
    (e.contacts.length == 0 || e.contacts.some((i) => i.normal.y > 0.2)) && (this._activeGroundCollisions.add(e), ob && console.log(`Collision(${this._activeGroundCollisions.size}): ${e.contacts.map((i) => i.normal.y.toFixed(2)).join(", ")} - ${this.isGrounded}`));
  }
  onCollisionExit(e) {
    this._activeGroundCollisions.delete(e), ob && console.log(`Collision(${this._activeGroundCollisions.size}) - ${this.isGrounded}`);
  }
  get isGrounded() {
    return this._activeGroundCollisions.size > 0;
  }
  get contactVelocity() {
    var e;
    this._contactVelocity.set(0, 0, 0);
    for (const i of this._activeGroundCollisions) {
      const n = (e = this.context.physics.engine) == null ? void 0 : e.getLinearVelocity(i.collider);
      n && (this._contactVelocity.x += n.x, this._contactVelocity.y += n.y, this._contactVelocity.z += n.z);
    }
    return this._contactVelocity;
  }
}
js([
  f(v)
], el.prototype, "center", 2);
js([
  f()
], el.prototype, "radius", 2);
js([
  f()
], el.prototype, "height", 2);
class Oo extends I {
  constructor() {
    super(...arguments);
    r(this, "controller");
    r(this, "movementSpeed", 2);
    r(this, "rotationSpeed", 2);
    r(this, "jumpForce", 1);
    r(this, "doubleJumpForce", 2);
    r(this, "animator");
    r(this, "lookForward", !0);
    r(this, "lookInput", new oe(0, 0));
    r(this, "moveInput", new oe(0, 0));
    r(this, "jumpInput", !1);
    r(this, "_currentSpeed", new v(0, 0, 0));
    r(this, "_currentAngularSpeed", new v(0, 0, 0));
    r(this, "_temp", new v(0, 0, 0));
    r(this, "_jumpCount", 0);
    r(this, "_currentRotation");
    r(this, "_raycastOptions", new Ts());
  }
  awake() {
    this._currentRotation = new W();
  }
  update() {
    const e = this.context.input;
    e.isKeyPressed("KeyW") ? this.moveInput.y += 1 : e.isKeyPressed("KeyS") && (this.moveInput.y -= 1), e.isKeyPressed("KeyD") ? this.lookInput.x += 1 : e.isKeyPressed("KeyA") && (this.lookInput.x -= 1), this.jumpInput || (this.jumpInput = e.isKeyDown("Space"));
  }
  move(e) {
    this.moveInput.add(e);
  }
  look(e) {
    this.lookInput.add(e);
  }
  jump() {
    this.jumpInput = !0;
  }
  onBeforeRender() {
    this.handleInput(this.moveInput, this.lookInput, this.jumpInput), this.lookInput.set(0, 0), this.moveInput.set(0, 0), this.jumpInput = !1;
  }
  handleInput(e, i, n) {
    var o, a, l, c, h, d, u, p, m, g, _;
    if ((o = this.controller) != null && o.isGrounded && (this._jumpCount = 0, this.doubleJumpForce > 0 && ((a = this.animator) == null || a.setBool("doubleJump", !1))), this._currentSpeed.z += e.y * this.movementSpeed * this.context.time.deltaTime, (l = this.animator) == null || l.setBool("running", e.length() > 0.01), (h = this.animator) == null || h.setBool("jumping", ((c = this.controller) == null ? void 0 : c.isGrounded) === !0 && n), this._temp.copy(this._currentSpeed), this._temp.applyQuaternion(this.gameObject.quaternion), this.controller ? this.controller.move(this._temp) : this.gameObject.position.add(this._temp), this._currentAngularSpeed.y += $.toRadians(-i.x * this.rotationSpeed) * this.context.time.deltaTime, this.lookForward && Math.abs(this._currentAngularSpeed.y) < 0.01) {
      const y = this.context.mainCameraComponent.forward;
      y.y = 0, y.normalize(), this._currentRotation.setFromUnitVectors(new v(0, 0, 1), y), this.gameObject.quaternion.slerp(this._currentRotation, this.context.time.deltaTime * 10);
    }
    if (this.gameObject.rotateY(this._currentAngularSpeed.y), this._currentSpeed.multiplyScalar(1 - this.context.time.deltaTime * 10), this._currentAngularSpeed.y *= 1 - this.context.time.deltaTime * 10, this.controller && n && this.jumpForce > 0) {
      let y = (d = this.controller) == null ? void 0 : d.isGrounded;
      if (this.doubleJumpForce > 0 && !((u = this.controller) != null && u.isGrounded) && this._jumpCount === 1 && (y = !0, (p = this.animator) == null || p.setBool("doubleJump", !0)), y) {
        this._jumpCount += 1;
        const b = this.controller.rigidbody, w = this._jumpCount === 2 ? this.doubleJumpForce : this.jumpForce;
        b.applyImpulse(new v(0, 1, 0).multiplyScalar(w));
      }
    }
    if (this.controller) {
      const y = (m = this.controller) == null ? void 0 : m.rigidbody.getVelocity().y;
      if (y < -1) {
        this._raycastOptions.ray || (this._raycastOptions.ray = new wo()), this._raycastOptions.ray.origin.copy(ie(this.gameObject)), this._raycastOptions.ray.direction.set(0, -1, 0);
        const b = this.layer;
        this.gameObject.layers.disableAll(), this.gameObject.layers.set(2);
        const w = this.context.physics.raycast(this._raycastOptions);
        this.gameObject.layers.set(b), (w.length && w[0].distance > 2 || y < -10) && ((g = this.animator) == null || g.setBool("falling", !0));
      } else
        (_ = this.animator) == null || _.setBool("falling", !1);
    }
  }
}
js([
  f(el)
], Oo.prototype, "controller", 2);
js([
  f()
], Oo.prototype, "movementSpeed", 2);
js([
  f()
], Oo.prototype, "rotationSpeed", 2);
js([
  f()
], Oo.prototype, "jumpForce", 2);
js([
  f()
], Oo.prototype, "doubleJumpForce", 2);
js([
  f(zt)
], Oo.prototype, "animator", 2);
var ER = Object.defineProperty, IR = Object.getOwnPropertyDescriptor, tl = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? IR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && ER(t, e, n), n;
};
const Il = x("debugcontactshadows");
SM((s) => {
  const t = s.domElement.getAttribute("contactshadows") || s.domElement.getAttribute("contact-shadows");
  if (t != null && t != "0" && t != "false") {
    console.debug("Auto-creating ContactShadows because of `contactshadows` attribute");
    const e = Yn.auto(s), i = parseFloat(t);
    isNaN(i) || (e.opacity = i, e.darkness = i);
  }
});
var zp;
const Kl = (zp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "autoFit", !1);
    r(this, "darkness", 0.5);
    r(this, "opacity", 0.5);
    r(this, "blur", 4);
    r(this, "occludeBelowGround", !1);
    r(this, "backfaceShadows", !0);
    /**
     * The minimum size of the shadows box
     */
    r(this, "minSize");
    /** All shadow objects are parented to this object. 
     * The gameObject itself should not be transformed because we want the ContactShadows object e.g. also have a GroundProjectedEnv component
     * in which case ContactShadows scale would affect the projection
     **/
    r(this, "shadowsRoot", new L());
    r(this, "shadowCamera");
    r(this, "shadowGroup", new ho());
    r(this, "renderTarget");
    r(this, "renderTargetBlur");
    r(this, "plane");
    r(this, "occluderMesh");
    r(this, "blurPlane");
    r(this, "depthMaterial");
    r(this, "horizontalBlurMaterial");
    r(this, "verticalBlurMaterial");
    r(this, "textureSize", 512);
  }
  /**
   * Create contact shadows for the scene. Automatically fits the shadows to the scene.  
   * The instance of contact shadows will be created only once.  
   * @param context The context to create the contact shadows in.
   * @returns The instance of the contact shadows.
   */
  static auto(t) {
    if (t || (t = ee.Current), !t)
      throw new Error("No context provided and no current context set.");
    let e = this._instances.get(t);
    if (!e || e.destroyed) {
      const i = new L();
      e = en(i, Kl, {
        autoFit: !1,
        occludeBelowGround: !1
      }), this._instances.set(t, e);
    }
    return t.scene.add(e.gameObject), e.fitShadows(), e;
  }
  /**
   * Call to fit the shadows to the scene.
   */
  fitShadows() {
    Il && console.warn("Fitting shadows to scene"), om(this.shadowsRoot, !1);
    const t = ki(this.context.scene.children, [this.shadowsRoot]), e = Math.max(1, this.blur / 32), i = t.max.x - t.min.x, n = t.max.z - t.min.z;
    t.expandByVector(new v(e * i, 0, e * n)), Il && V.DrawWireBox3(t, 16776960, 60), this.gameObject.parent && t.applyMatrix4(this.gameObject.parent.matrixWorld.clone().invert());
    const o = t.min, a = Math.max(1e-5, (t.max.y - o.y) * 2e-3);
    t.max.y += a, this.shadowsRoot.position.set((o.x + t.max.x) / 2, o.y - a, (o.z + t.max.z) / 2), this.shadowsRoot.scale.set(t.max.x - o.x, t.max.y - o.y, t.max.z - o.z), this.applyMinSize(), this.shadowsRoot.matrixWorldNeedsUpdate = !0, Il && console.log("Fitted shadows to scene", this.shadowsRoot.scale.clone());
  }
  /** @internal */
  awake() {
    Kl._instances.set(this.context, this), this.shadowsRoot.hideFlags = Fg.DontExport, om(this.shadowsRoot, !1);
  }
  /** @internal */
  start() {
    Il && console.log("Create ContactShadows on " + this.gameObject.name, this), this.gameObject.add(this.shadowsRoot), this.shadowsRoot.add(this.shadowGroup), this.renderTarget = new ks(this.textureSize, this.textureSize), this.renderTarget.texture.generateMipmaps = !1, this.renderTargetBlur = new ks(this.textureSize, this.textureSize), this.renderTargetBlur.texture.generateMipmaps = !1;
    const t = new Xn(1, 1).rotateX(Math.PI / 2);
    this.gameObject instanceof q && (console.warn("ContactShadows can not be added to a Mesh. Please add it to a Group or an empty Object"), bs(this.gameObject, !1));
    const e = new Me({
      map: this.renderTarget.texture,
      opacity: this.opacity,
      color: 0,
      transparent: !0,
      depthWrite: !1,
      side: xo
    });
    this.plane = new q(t, e), this.plane.scale.y = -1, this.plane.layers.set(2), this.shadowsRoot.add(this.plane), this.plane && (this.plane.renderOrder = 1), this.occluderMesh = new q(this.plane.geometry, new Me({
      depthWrite: !0,
      stencilWrite: !0,
      colorWrite: !1,
      side: Cu
    })).translateY(-1e-4), this.occluderMesh.renderOrder = -100, this.occluderMesh.layers.set(2), this.shadowsRoot.add(this.occluderMesh), this.blurPlane = new q(t), this.blurPlane.visible = !1, this.shadowGroup.add(this.blurPlane);
    const i = 0, n = 1;
    this.shadowCamera = new rg(-1 / 2, 1 / 2, 1 / 2, -1 / 2, i, n), this.shadowCamera.layers.enableAll(), this.shadowCamera.rotation.x = Math.PI / 2, this.shadowGroup.add(this.shadowCamera), this.depthMaterial = new Yx(), this.depthMaterial.userData.darkness = { value: this.darkness }, this.depthMaterial.blending = Kx, this.depthMaterial.blendEquation = Zx, this.depthMaterial.onBeforeCompile = (o) => {
      this.depthMaterial && (o.uniforms.darkness = this.depthMaterial.userData.darkness, o.fragmentShader = /* glsl */
      `
                uniform float darkness;
                ${o.fragmentShader.replace(
        "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        // we're scaling the shadow value down a bit when it's a backface (looks better)
        "gl_FragColor = vec4( vec3( 1.0 ), ( 1.0 - fragCoordZ ) * darkness * opacity * (gl_FrontFacing ? 1.0 : 0.66) );"
      )}
            `);
    }, this.depthMaterial.depthTest = !1, this.depthMaterial.depthWrite = !1, this.horizontalBlurMaterial = new bn(tS), this.horizontalBlurMaterial.depthTest = !1, this.verticalBlurMaterial = new bn(iS), this.verticalBlurMaterial.depthTest = !1, this.shadowGroup.visible = !1, this.autoFit ? this.fitShadows() : this.applyMinSize();
  }
  /** @internal */
  onDestroy() {
    var e, i, n, o, a, l, c, h;
    Kl._instances.get(this.context) === this && Kl._instances.delete(this.context), (e = this.renderTarget) == null || e.dispose(), (i = this.renderTargetBlur) == null || i.dispose(), (n = this.depthMaterial) == null || n.dispose(), (o = this.horizontalBlurMaterial) == null || o.dispose(), (a = this.verticalBlurMaterial) == null || a.dispose(), (l = this.blurPlane) == null || l.geometry.dispose(), (c = this.plane) == null || c.geometry.dispose(), (h = this.occluderMesh) == null || h.geometry.dispose();
  }
  /** @internal */
  onBeforeRender(t) {
    if (!this.renderTarget || !this.renderTargetBlur || !this.depthMaterial || !this.shadowCamera || !this.blurPlane || !this.shadowGroup || !this.plane || !this.horizontalBlurMaterial || !this.verticalBlurMaterial) {
      Il && console.error("ContactShadows: not initialized yet");
      return;
    }
    const e = this.context.scene, i = this.context.renderer, n = i.getRenderTarget();
    this.shadowGroup.visible = !0, this.occluderMesh && (this.occluderMesh.visible = !1);
    const o = this.plane.visible;
    this.plane.visible = !1, this.gameObject instanceof q && bs(this.gameObject, !1);
    const a = e.background;
    e.background = null, e.overrideMaterial = this.depthMaterial, this.backfaceShadows ? this.depthMaterial.side = Ri : this.depthMaterial.side = xo;
    const l = i.getClearAlpha();
    i.setClearAlpha(0);
    const c = i.xr.enabled;
    i.xr.enabled = !1;
    const h = this.context.scene.matrixWorldAutoUpdate;
    this.context.scene.matrixWorldAutoUpdate = !1;
    const d = i.renderLists.get(e, 0), u = d.transparent;
    rb.length = 0, d.transparent = rb, tp.length = 0;
    for (const m of d.opaque) {
      if (!m.object.visible)
        continue;
      const g = m.material;
      let _ = m.material.colorWrite == !1 || g.wireframe === !0 || pC(m.object) === !1;
      !_ && m.material.isLineMaterial && (_ = !0), !_ && m.material.isPointsMaterial && (_ = !0), _ && (tp.push(m.object), m.object["needle:visible"] = m.object.visible, m.object.visible = !1);
    }
    i.setRenderTarget(this.renderTarget), i.clear(), i.render(e, this.shadowCamera), d.transparent = u;
    for (const m of tp)
      m["needle:visible"] != null && (m.visible = m["needle:visible"]);
    e.overrideMaterial = null;
    const p = Math.max(this.blur, 0.05);
    this.blurShadow(p * 2), this.blurShadow(p * 0.5), this.shadowGroup.visible = !1, this.occluderMesh && (this.occluderMesh.visible = this.occludeBelowGround), this.plane.visible = o, i.setRenderTarget(n), i.setClearAlpha(l), e.background = a, i.xr.enabled = c, this.context.scene.matrixWorldAutoUpdate = h;
  }
  // renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget
  blurShadow(t) {
    if (!this.blurPlane || !this.shadowCamera || !this.renderTarget || !this.renderTargetBlur || !this.horizontalBlurMaterial || !this.verticalBlurMaterial)
      return;
    this.blurPlane.visible = !0;
    const e = this.shadowsRoot.worldScale, i = (e.x + e.z) / 2, n = e.z / i, o = e.x / i;
    this.blurPlane.material = this.horizontalBlurMaterial, this.blurPlane.material.uniforms.tDiffuse.value = this.renderTarget.texture, this.horizontalBlurMaterial.uniforms.h.value = t * 1 / this.textureSize * n;
    const a = this.context.renderer, l = a.getRenderTarget();
    a.setRenderTarget(this.renderTargetBlur), a.render(this.blurPlane, this.shadowCamera), this.blurPlane.material = this.verticalBlurMaterial, this.blurPlane.material.uniforms.tDiffuse.value = this.renderTargetBlur.texture, this.verticalBlurMaterial.uniforms.v.value = t * 1 / this.textureSize * o, a.setRenderTarget(this.renderTarget), a.render(this.blurPlane, this.shadowCamera), this.blurPlane.visible = !1, a.setRenderTarget(l);
  }
  applyMinSize() {
    this.minSize && this.shadowsRoot.scale.set(
      Math.max(this.minSize.x || 0, this.shadowsRoot.scale.x),
      Math.max(this.minSize.y || 0, this.shadowsRoot.scale.y),
      Math.max(this.minSize.z || 0, this.shadowsRoot.scale.z)
    );
  }
}, r(zp, "_instances", /* @__PURE__ */ new Map()), zp);
let Yn = Kl;
tl([
  f()
], Yn.prototype, "autoFit", 2);
tl([
  f()
], Yn.prototype, "darkness", 2);
tl([
  f()
], Yn.prototype, "opacity", 2);
tl([
  f()
], Yn.prototype, "blur", 2);
tl([
  f()
], Yn.prototype, "occludeBelowGround", 2);
tl([
  f()
], Yn.prototype, "backfaceShadows", 2);
const rb = [], tp = new Array(), DR = x("logstats");
class Hv extends I {
  onEnable() {
    console.log(this), DR && this.startCoroutine(this.run(), Re.OnAfterRender);
  }
  *run() {
    for (; this.enabled; ) {
      const t = this.context.renderer.info;
      console.log(t.memory, t.render, t.programs), yield;
    }
  }
}
class Qu extends I {
  constructor() {
    super(...arguments);
    r(this, "isUsed", !0);
    r(this, "usedBy", null);
  }
}
class Gv extends I {
}
const ab = x("debugdeletable"), Mc = class extends wi {
  onEnable() {
    Mc._instances.push(this);
  }
  onDisable() {
    const t = Mc._instances.indexOf(this);
    t >= 0 && Mc._instances.splice(t, 1);
  }
};
let Ra = Mc;
r(Ra, "_instances", []);
class qv extends I {
  update() {
    for (const t of Ra._instances) {
      const e = this.gameObject;
      if (t.isInBox(e) === !0) {
        const n = S.getComponentInParent(this.gameObject, Qu);
        if (n)
          ab && console.warn("DeleteBox: Not deleting object with usage marker", this.guid, n);
        else {
          if (ab)
            try {
              if (t.box) {
                const o = t.box, a = wi.testBox;
                V.DrawWireBox3(o, 16711680, 5), V.DrawWireBox3(a, 255, 5), console.log("DeleteBox: Destroying", this.gameObject, { deleteBoxArea: o, deletedObjectArea: a });
              } else
                console.log("DeleteBox: Destroying", this.gameObject);
            } catch {
            }
          ju(this.gameObject, this.context.connection);
        }
      }
    }
  }
}
var LR = Object.defineProperty, jR = Object.getOwnPropertyDescriptor, BR = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? jR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && LR(t, e, n), n;
};
class $g extends I {
  constructor() {
    super(...arguments);
    r(this, "visibleOn");
  }
  onEnable() {
    this.apply();
  }
  apply() {
    this.test() || S.setActive(this.gameObject, !1);
  }
  test() {
    return this.visibleOn < 0 ? !0 : X.isMobileDevice() ? (this.visibleOn & 2) !== 0 : (this.visibleOn & 1) !== 0;
  }
}
BR([
  f()
], $g.prototype, "visibleOn", 2);
var FR = Object.defineProperty, zR = Object.getOwnPropertyDescriptor, Br = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? zR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && FR(t, e, n), n;
};
const Un = x("debugdrag"), ip = [];
var Xv = /* @__PURE__ */ ((s) => (s[s.XZPlane = 0] = "XZPlane", s[s.Attached = 1] = "Attached", s[s.HitNormal = 2] = "HitNormal", s[s.DynamicViewAngle = 3] = "DynamicViewAngle", s[s.SnapToSurfaces = 4] = "SnapToSurfaces", s[s.None = 5] = "None", s))(Xv || {}), Wl;
const $i = (Wl = class extends I {
  constructor() {
    super(...arguments);
    r(this, "dragMode", 3);
    r(this, "snapGridResolution", 0);
    r(this, "keepRotation", !0);
    r(this, "xrDragMode", 1);
    r(this, "xrKeepRotation", !1);
    r(this, "xrDistanceDragFactor", 1);
    r(this, "showGizmo", !1);
    r(this, "_rigidbody", null);
    // future:
    // constraints?
    /** The object to be dragged – we pass this to handlers when they are created */
    r(this, "_targetObject", null);
    r(this, "_dragHelper", null);
    r(this, "_draggingRigidbodies", []);
    r(this, "_potentialDragStartEvt", null);
    r(this, "_dragHandlers", /* @__PURE__ */ new Map());
    r(this, "_totalMovement", new v());
    /** A marker is attached to components that are currently interacted with, to e.g. prevent them from being deleted. */
    r(this, "_marker", null);
    r(this, "_isDragging", !1);
    r(this, "_didDrag", !1);
  }
  /**
   * Checks if any DragControls component is currently active with selected objects
   * @returns True if any DragControls component is currently active
   */
  static get HasAnySelected() {
    return this._active > 0;
  }
  /** 
   * Retrieves a list of all DragControl components that are currently dragging objects.
   * @returns Array of currently active DragControls components
   */
  static get CurrentlySelected() {
    ip.length = 0;
    for (const t of this._instances)
      t._isDragging && ip.push(t);
    return ip;
  }
  /** 
   * Returns the object currently being dragged by this DragControls component, if any.
   * @returns The object being dragged or null if no object is currently dragged
   */
  get draggedObject() {
    return this._targetObject;
  }
  /**
   * Updates the object that is being dragged by the DragControls.
   * This can be used to change the target during a drag operation.
   * @param obj The new object to drag, or null to stop dragging
   */
  setTargetObject(t) {
    var i, n;
    this._targetObject = t;
    for (const o of this._dragHandlers.values())
      o.setTargetObject(t);
    const e = "_rigidbody-was-kinematic";
    ((i = this._rigidbody) == null ? void 0 : i[e]) === !1 && (this._rigidbody.isKinematic = !1, this._rigidbody[e] = void 0), this._rigidbody = null, t && (this._rigidbody = S.getComponentInChildren(t, _e), ((n = this._rigidbody) == null ? void 0 : n.isKinematic) === !1 && (this._rigidbody.isKinematic = !0, this._rigidbody[e] = !1));
  }
  /** @internal */
  awake() {
    this._potentialDragStartEvt = null, this._dragHandlers = /* @__PURE__ */ new Map(), this._totalMovement = new v(), this._marker = null, this._isDragging = !1, this._didDrag = !1, this._dragHelper = null, this._draggingRigidbodies = [];
  }
  /** @internal */
  start() {
    this.gameObject.getComponentInParent(sn) || this.gameObject.addComponent(sn);
  }
  /** @internal */
  onEnable() {
    $i._instances.push(this);
  }
  /** @internal */
  onDisable() {
    $i._instances = $i._instances.filter((t) => t !== this);
  }
  /**
   * Checks if editing is allowed for the current networking connection.
   * @param _obj Optional object to check edit permissions for
   * @returns True if editing is allowed
   */
  allowEdit(t = null) {
    return this.context.connection.allowEditing;
  }
  /** 
   * Handles pointer enter events. Sets the cursor style and tracks the hovered object.
   * @param evt Pointer event data containing information about the interaction
   * @internal
   */
  onPointerEnter(t) {
    if (!this.allowEdit(this.gameObject) || t.mode !== "screen" || (t.event.mode === "tracked-pointer" || t.event.mode === "transient-pointer" ? this.xrDragMode : this.dragMode) === 5)
      return;
    const n = S.getComponentInParent(t.object, $i);
    !n || n !== this || ($i.lastHovered = t.object, this.context.domElement.style.cursor = "pointer");
  }
  /** 
   * Handles pointer movement events. Marks the event as used if dragging is active.
   * @param args Pointer event data containing information about the movement
   * @internal
   */
  onPointerMove(t) {
    (this._isDragging || this._potentialDragStartEvt !== null) && t.use();
  }
  /** 
   * Handles pointer exit events. Resets the cursor style when the pointer leaves a draggable object.
   * @param evt Pointer event data containing information about the interaction
   * @internal
   */
  onPointerExit(t) {
    this.allowEdit(this.gameObject) && t.mode === "screen" && $i.lastHovered === t.object && (this.context.domElement.style.cursor = "auto");
  }
  /** 
   * Handles pointer down events. Initiates the potential drag operation if conditions are met.
   * @param args Pointer event data containing information about the interaction
   * @internal
   */
  onPointerDown(t) {
    if (!(!this.allowEdit(this.gameObject) || t.used || (t.mode === "tracked-pointer" || t.mode === "transient-pointer" ? this.xrDragMode : this.dragMode) === 5) && ($i.lastHovered = t.object, t.button === 0)) {
      this._dragHandlers.size === 0 && (this._didDrag = !1, this._totalMovement.set(0, 0, 0), this._potentialDragStartEvt = t), this._targetObject || this.setTargetObject(this.gameObject), $i._active += 1;
      const n = new np(this, this._targetObject);
      if (this._dragHandlers.set(t.event.space, n), n.onDragStart(t), this._dragHandlers.size === 2) {
        const o = this._dragHandlers.values(), a = o.next().value, l = o.next().value;
        if (a instanceof np && l instanceof np) {
          const c = new UR(this, this._targetObject, a, l);
          this._dragHandlers.set(this.gameObject, c), c.onDragStart(t);
        } else
          console.error("Attempting to construct a MultiTouchDragHandler with invalid DragPointerHandlers. This is likely a bug.", { a, b: l });
      }
      t.use();
    }
  }
  /** 
   * Handles pointer up events. Finalizes or cancels the drag operation.
   * @param args Pointer event data containing information about the interaction
   * @internal
   */
  onPointerUp(t) {
    if (Un && V.DrawLabel(t.point ?? this.gameObject.worldPosition, "POINTERUP:" + t.pointerId + ", " + t.button, 0.03, 3), !this.allowEdit(this.gameObject) || t.button !== 0)
      return;
    this._potentialDragStartEvt = null;
    const e = this._dragHandlers.get(t.event.space), i = this._dragHandlers.get(this.gameObject);
    i && (i.handlerA === e || i.handlerB === e) && (this._dragHandlers.delete(this.gameObject), i.onDragEnd(t)), e && ($i._active > 0 && ($i._active -= 1), this.setTargetObject(null), e.onDragEnd && e.onDragEnd(t), this._dragHandlers.delete(t.event.space), this._dragHandlers.size === 0 && this.onLastDragEnd(t), t.use());
  }
  /**
   * Updates the drag operation every frame. Processes pointer movement, accumulates drag distance
   * and triggers drag start once there's enough movement.
   * @internal
   */
  update() {
    for (const t of this._dragHandlers.values())
      t.collectMovementInfo && t.collectMovementInfo(), t.getTotalMovement && this._totalMovement.add(t.getTotalMovement());
    if (this._potentialDragStartEvt) {
      if (!this._didDrag)
        if (this._totalMovement.length() > 3e-4)
          this._didDrag = !0;
        else
          return;
      const t = this._potentialDragStartEvt;
      this._potentialDragStartEvt = null, this.onFirstDragStart(t);
    }
    for (const t of this._dragHandlers.values())
      t.onDragUpdate && t.onDragUpdate(this._dragHandlers.size);
    this._dragHelper && this._dragHelper.hasSelected && this.onAnyDragUpdate();
  }
  /** 
   * Called when the first pointer starts dragging on this object. 
   * Sets up network synchronization and marks rigidbodies for dragging.
   * Not called for subsequent pointers on the same object.
   * @param evt Pointer event data that initiated the drag
   */
  onFirstDragStart(t) {
    if (!t || !t.object)
      return;
    const e = S.getComponentInParent(t.object, $i);
    if (!e || e !== this && e._isDragging)
      return;
    const i = this._targetObject || this.gameObject;
    if (!i)
      return;
    this._isDragging = !0;
    const n = S.getComponentInChildren(i, As);
    Un && console.log("DRAG START", n, i), n && (n.fastMode = !0, n == null || n.requestOwnership()), this._marker = S.addComponent(i, Qu), this._draggingRigidbodies.length = 0;
    const o = S.getComponentsInChildren(i, _e);
    o && this._draggingRigidbodies.push(...o);
  }
  /** 
   * Called each frame as long as any pointer is dragging this object.
   * Updates visuals and keeps rigidbodies awake during the drag.
   */
  onAnyDragUpdate() {
    if (!this._dragHelper)
      return;
    this._dragHelper.showGizmo = this.showGizmo, this._dragHelper.onUpdate(this.context);
    for (const e of this._draggingRigidbodies)
      e.wakeUp(), e.resetVelocities(), e.resetForcesAndTorques();
    const t = this._targetObject || this.gameObject;
    _n.markDirty(t);
  }
  /** 
   * Called when the last pointer has been removed from this object.
   * Cleans up drag state and applies final velocities to rigidbodies.
   * @param evt Pointer event data for the last pointer that was lifted
   */
  onLastDragEnd(t) {
    if (!this || !this._isDragging)
      return;
    this._isDragging = !1;
    for (const i of this._draggingRigidbodies)
      i.setVelocity(i.smoothedVelocity);
    if (this._draggingRigidbodies.length = 0, this._targetObject = null, t != null && t.object) {
      const i = S.getComponentInChildren(t.object, As);
      i && (i.fastMode = !1);
    }
    if (this._marker && this._marker.destroy(), !this._dragHelper)
      return;
    const e = this._dragHelper.selected;
    Un && console.log("DRAG END", e, e == null ? void 0 : e.visible), this._dragHelper.setSelected(null, this.context);
  }
}, r(Wl, "_active", 0), /** Registry of currently active and enabled DragControls components */
r(Wl, "_instances", []), r(Wl, "lastHovered"), Wl);
let Si = $i;
Br([
  f()
], Si.prototype, "dragMode", 2);
Br([
  f()
], Si.prototype, "snapGridResolution", 2);
Br([
  f()
], Si.prototype, "keepRotation", 2);
Br([
  f()
], Si.prototype, "xrDragMode", 2);
Br([
  f()
], Si.prototype, "xrKeepRotation", 2);
Br([
  f()
], Si.prototype, "xrDistanceDragFactor", 2);
Br([
  f()
], Si.prototype, "showGizmo", 2);
class UR {
  constructor(t, e, i, n) {
    r(this, "handlerA");
    r(this, "handlerB");
    r(this, "context");
    r(this, "settings");
    r(this, "gameObject");
    r(this, "_handlerAAttachmentPoint", new v());
    r(this, "_handlerBAttachmentPoint", new v());
    r(this, "_followObject");
    r(this, "_manipulatorObject");
    r(this, "_deviceMode");
    r(this, "_followObjectStartWorldQuaternion", new W());
    r(this, "_manipulatorPosOffset", new v());
    r(this, "_manipulatorRotOffset", new W());
    r(this, "_manipulatorScaleOffset", new v());
    r(this, "_tempVec1", new v());
    r(this, "_tempVec2", new v());
    r(this, "_tempVec3", new v());
    r(this, "tempLookMatrix", new se());
    r(this, "_initialScale", new v());
    r(this, "_initialDistance", 0);
    var a, l;
    this.context = t.context, this.settings = t, this.gameObject = e, this.handlerA = i, this.handlerB = n, this._followObject = new L(), this._manipulatorObject = new L(), this.context.scene.add(this._manipulatorObject);
    const o = (l = (a = J.active) == null ? void 0 : a.rig) == null ? void 0 : l.gameObject;
    if (!this.handlerA || !this.handlerB || !this.handlerA.hitPointInLocalSpace || !this.handlerB.hitPointInLocalSpace) {
      console.error("Invalid: MultiTouchDragHandler needs two valid DragPointerHandlers with hitPointInLocalSpace set.");
      return;
    }
    if (this._tempVec1.copy(this.handlerA.hitPointInLocalSpace), this._tempVec2.copy(this.handlerB.hitPointInLocalSpace), this.gameObject.localToWorld(this._tempVec1), this.gameObject.localToWorld(this._tempVec2), o && (o.worldToLocal(this._tempVec1), o.worldToLocal(this._tempVec2)), this._initialDistance = this._tempVec1.distanceTo(this._tempVec2), this._initialDistance < 0.02 ? (Un && console.log("Finding alternative drag attachment points since initial distance is too low: " + this._initialDistance.toFixed(2)), this.handlerA.followObject.parent.getWorldPosition(this._tempVec1), this.handlerB.followObject.parent.getWorldPosition(this._tempVec2), this._handlerAAttachmentPoint.copy(this._tempVec1), this._handlerBAttachmentPoint.copy(this._tempVec2), this.gameObject.worldToLocal(this._handlerAAttachmentPoint), this.gameObject.worldToLocal(this._handlerBAttachmentPoint), this._initialDistance = this._tempVec1.distanceTo(this._tempVec2), this._initialDistance < 1e-3 && (console.warn("Not supported right now – controller drag points for multitouch are too close!"), this._initialDistance = 1)) : (this._handlerAAttachmentPoint.copy(this.handlerA.hitPointInLocalSpace), this._handlerBAttachmentPoint.copy(this.handlerB.hitPointInLocalSpace)), this._tempVec3.lerpVectors(this._tempVec1, this._tempVec2, 0.5), this._initialScale.copy(e.scale), Un) {
      this._followObject.add(new Oi(2)), this._manipulatorObject.add(new Oi(5));
      const c = (h) => `${h.x.toFixed(2)}, ${h.y.toFixed(2)}, ${h.z.toFixed(2)}`;
      V.DrawLine(this._tempVec1, this._tempVec2, 65535, 0, !1), V.DrawLabel(this._tempVec3, "A:B " + this._initialDistance.toFixed(2) + `
` + c(this._tempVec1) + `
` + c(this._tempVec2), 0.03, 5);
    }
  }
  onDragStart(t) {
    this.gameObject.add(this._followObject), this._followObject.matrixAutoUpdate = !1, this._followObject.matrix.identity(), this._deviceMode = t.mode, this._followObjectStartWorldQuaternion.copy(this._followObject.worldQuaternion), this.alignManipulator(), this._manipulatorObject.attach(this._followObject), this._manipulatorPosOffset.copy(this._followObject.position), this._manipulatorRotOffset.copy(this._followObject.quaternion), this._manipulatorScaleOffset.copy(this._followObject.scale);
  }
  onDragEnd(t) {
    if (!this.handlerA || !this.handlerB) {
      console.error("onDragEnd called on MultiTouchDragHandler without valid handlers. This is likely a bug.");
      return;
    }
    this.handlerA.recenter(), this.handlerB.recenter(), this._manipulatorObject.removeFromParent(), this._followObject.removeFromParent(), this._manipulatorObject.destroy(), this._followObject.destroy();
  }
  alignManipulator() {
    if (!this.handlerA || !this.handlerB) {
      console.error("alignManipulator called on MultiTouchDragHandler without valid handlers. This is likely a bug.", this);
      return;
    }
    if (!this.handlerA.followObject || !this.handlerB.followObject) {
      console.error("alignManipulator called on MultiTouchDragHandler without valid follow objects. This is likely a bug.", this.handlerA, this.handlerB);
      return;
    }
    this._tempVec1.copy(this._handlerAAttachmentPoint), this._tempVec2.copy(this._handlerBAttachmentPoint), this.handlerA.followObject.localToWorld(this._tempVec1), this.handlerB.followObject.localToWorld(this._tempVec2), this._tempVec3.lerpVectors(this._tempVec1, this._tempVec2, 0.5), this._manipulatorObject.position.copy(this._tempVec3);
    const t = this.context.mainCamera;
    this.tempLookMatrix.lookAt(this._tempVec3, this._tempVec2, t.worldUp), this._manipulatorObject.quaternion.setFromRotationMatrix(this.tempLookMatrix);
    const e = this._tempVec1.distanceTo(this._tempVec2);
    this._manipulatorObject.scale.copy(this._initialScale).multiplyScalar(e / this._initialDistance), this._manipulatorObject.updateMatrix(), this._manipulatorObject.updateMatrixWorld(!0), Un && (V.DrawLabel(this._tempVec3.clone().add(new v(0, 0.2, 0)), "A:B " + e.toFixed(2), 0.03), V.DrawLine(this._tempVec1, this._tempVec2, 65280, 0, !1));
  }
  onDragUpdate() {
    this.alignManipulator();
    const t = 30, e = 1;
    this._followObject.position.copy(this._manipulatorPosOffset), this._followObject.quaternion.copy(this._manipulatorRotOffset), this._followObject.scale.copy(this._manipulatorScaleOffset);
    const i = this.gameObject, n = this._followObject;
    if (!i) {
      console.error("MultiTouchDragHandler has no dragged object. This is likely a bug.");
      return;
    }
    n.updateMatrix(), n.updateMatrixWorld(!0);
    const a = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer" ? this.settings.xrKeepRotation : this.settings.keepRotation;
    if (this.settings.snapGridResolution > 0) {
      const u = this._followObject.worldPosition, p = this.settings.snapGridResolution;
      u.x = Math.round(u.x / p) * p, u.y = Math.round(u.y / p) * p, u.z = Math.round(u.z / p) * p, this._followObject.worldPosition = u, this._followObject.updateMatrix();
    }
    a && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion, this._followObject.updateMatrix());
    const l = $.clamp01(this.context.time.deltaTime * t * e), c = i.worldPosition;
    c.lerp(n.worldPosition, l), i.worldPosition = c;
    const h = i.worldQuaternion;
    h.slerp(n.worldQuaternion, l), i.worldQuaternion = h;
    const d = i.worldScale;
    d.lerp(n.worldScale, l), i.worldScale = d;
  }
  setTargetObject(t) {
    this.gameObject = t;
  }
}
class np {
  constructor(t, e) {
    r(this, "context");
    r(this, "gameObject");
    r(this, "settings");
    r(this, "_lastRig");
    /** This object is placed at the pivot of the dragged object, and parented to the control space. */
    r(this, "_followObject");
    r(this, "_totalMovement", new v());
    /** Motion along the pointer ray. On screens this doesn't change. In XR it can be used to determine how much
     * effort someone is putting into moving an object closer or further away. */
    r(this, "_totalMovementAlongRayDirection", 0);
    /** Distance between _followObject and its parent at grab start, in local space */
    r(this, "_grabStartDistance", 0);
    r(this, "_deviceMode");
    r(this, "_followObjectStartPosition", new v());
    r(this, "_followObjectStartQuaternion", new W());
    r(this, "_followObjectStartWorldQuaternion", new W());
    r(this, "_lastDragPosRigSpace");
    r(this, "_tempVec", new v());
    r(this, "_tempMat", new se());
    r(this, "_hitPointInLocalSpace", new v());
    r(this, "_hitNormalInLocalSpace", new v());
    r(this, "_bottomCenter", new v());
    r(this, "_backCenter", new v());
    r(this, "_backBottomCenter", new v());
    r(this, "_bounds", new Pi());
    r(this, "_dragPlane", new vr(new v(0, 1, 0)));
    r(this, "_draggedOverObject", null);
    r(this, "_draggedOverObjectLastSetUp", null);
    r(this, "_draggedOverObjectLastNormal", new v());
    r(this, "_draggedOverObjectDuration", 0);
    r(this, "_hasLastSurfaceHitPoint", !1);
    r(this, "_lastSurfaceHitPoint", new v());
    this.settings = t, this.context = t.context, this.gameObject = e, this._followObject = new L();
  }
  /** 
   * Returns the accumulated movement of the pointer in world units.
   * Used for determining if enough motion has occurred to start a drag.
   */
  getTotalMovement() {
    return this._totalMovement;
  }
  /** 
   * Returns the object that follows the pointer during dragging operations.
   */
  get followObject() {
    return this._followObject;
  }
  /**
   * Returns the point where the pointer initially hit the object in local space.
   */
  get hitPointInLocalSpace() {
    return this._hitPointInLocalSpace;
  }
  /** Allows overriding which object is dragged while a drag is already ongoing. Used for example by Duplicatable */
  setTargetObject(t) {
    this.gameObject = t;
  }
  recenter() {
    var o, a;
    if (!this._followObject.parent) {
      console.warn("Error: space follow object doesn't have parent but recenter() is called. This is likely a bug");
      return;
    }
    if (!this.gameObject) {
      console.warn("Error: space follow object doesn't have a gameObject");
      return;
    }
    const t = this._followObject.parent;
    this.gameObject.add(this._followObject), this._followObject.matrixAutoUpdate = !1, this._followObject.position.set(0, 0, 0), this._followObject.quaternion.set(0, 0, 0, 1), this._followObject.scale.set(1, 1, 1), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0), t.attach(this._followObject), this._followObjectStartPosition.copy(this._followObject.position), this._followObjectStartQuaternion.copy(this._followObject.quaternion), this._followObjectStartWorldQuaternion.copy(this._followObject.worldQuaternion), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
    const e = this._hitPointInLocalSpace.clone();
    this.gameObject.localToWorld(e), this._grabStartDistance = e.distanceTo(t.worldPosition);
    const i = (a = (o = J.active) == null ? void 0 : o.rig) == null ? void 0 : a.gameObject, n = (i == null ? void 0 : i.worldScale.x) || 1;
    this._grabStartDistance /= n, this._totalMovementAlongRayDirection = 0, this._lastDragPosRigSpace = void 0, Un && (V.DrawLine(e, t.worldPosition, 65280, 0.5, !1), V.DrawLabel(t.worldPosition.add(new v(0, 0.1, 0)), this._grabStartDistance.toFixed(2), 0.03, 0.5));
  }
  onDragStart(t) {
    if (!this.gameObject) {
      console.warn("Error: space follow object doesn't have a gameObject");
      return;
    }
    if (t.event.space.add(this._followObject), this._lastDragPosRigSpace = void 0, t.point && t.normal)
      this._hitPointInLocalSpace.copy(t.point), this.gameObject.worldToLocal(this._hitPointInLocalSpace), this._hitNormalInLocalSpace.copy(t.normal);
    else if (t) {
      const _ = t.event.space, y = _.worldPosition;
      this.gameObject.worldToLocal(y), this._hitPointInLocalSpace.copy(y);
      const b = _.worldUp;
      this._tempMat.copy(this.gameObject.matrixWorld).invert(), b.transformDirection(this._tempMat), this._hitNormalInLocalSpace.copy(b);
    }
    this.recenter(), this._totalMovement.set(0, 0, 0), this._deviceMode = t.mode;
    const i = this._followObject.parent.worldForward, o = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer" ? this.settings.xrDragMode : this.settings.dragMode, a = this._hitPointInLocalSpace.clone();
    switch (this.gameObject.localToWorld(a), o) {
      case 0:
        const _ = new v(0, 1, 0);
        this.gameObject.parent && _.transformDirection(this.gameObject.parent.matrixWorld.clone().invert()), this._dragPlane.setFromNormalAndCoplanarPoint(_, a);
        break;
      case 2:
        const y = this._hitNormalInLocalSpace.clone();
        y.transformDirection(this.gameObject.matrixWorld), this._dragPlane.setFromNormalAndCoplanarPoint(y, a);
        break;
      case 1:
        this._dragPlane.setFromNormalAndCoplanarPoint(i, a);
        break;
      case 3:
        this.setPlaneViewAligned(a, !0);
        break;
      case 4:
        this.setPlaneViewAligned(a, !1);
        break;
    }
    const l = this.gameObject.parent, c = this.gameObject.position.clone(), h = this.gameObject.quaternion.clone(), d = this.gameObject.scale.clone(), u = this.gameObject.matrixWorld.clone();
    l && l.remove(this.gameObject), this.gameObject.position.set(0, 0, 0), this.gameObject.quaternion.set(0, 0, 0, 1), this.gameObject.scale.set(1, 1, 1);
    const p = ki([this.gameObject]);
    p.expandByPoint(this.gameObject.worldPosition);
    const m = new v();
    p.getCenter(m);
    const g = new v();
    p.getSize(g), this._bottomCenter.copy(m.clone().add(new v(0, -g.y / 2, 0))), this._backCenter.copy(m.clone().add(new v(0, 0, g.z / 2))), this._backBottomCenter.copy(m.clone().add(new v(0, -g.y / 2, g.z / 2))), this._bounds.copy(p), l && l.add(this.gameObject), this.gameObject.position.copy(c), this.gameObject.quaternion.copy(h), this.gameObject.scale.copy(d), this.gameObject.matrixWorld.copy(u), this._draggedOverObject = null, this._draggedOverObjectLastSetUp = null, this._draggedOverObjectLastNormal.set(0, 1, 0), this._draggedOverObjectDuration = 0;
  }
  collectMovementInfo() {
    var o, a;
    if (!this._followObject.parent)
      return;
    const t = this._followObject.parent;
    this._followObject.updateMatrix();
    const e = t.worldPosition, i = (a = (o = J.active) == null ? void 0 : o.rig) == null ? void 0 : a.gameObject;
    i && i.worldToLocal(e), (this._lastDragPosRigSpace === void 0 || i != this._lastRig) && (this._lastDragPosRigSpace = e.clone(), this._lastRig = i), this._tempVec.copy(e).sub(this._lastDragPosRigSpace);
    const n = t.worldForward;
    if (i && (this._tempMat.copy(i.matrixWorld).invert(), n.transformDirection(this._tempMat)), this._totalMovementAlongRayDirection += n.dot(this._tempVec), this._tempVec.x = Math.abs(this._tempVec.x), this._tempVec.y = Math.abs(this._tempVec.y), this._tempVec.z = Math.abs(this._tempVec.z), this._totalMovement.add(this._tempVec), this._lastDragPosRigSpace.copy(e), Un) {
      let l = e;
      i && (l = l.clone(), l.transformDirection(i.matrixWorld)), V.DrawRay(l, n, 255);
    }
  }
  onDragUpdate(t) {
    if (t > 1)
      return;
    const e = this.gameObject;
    if (!e || !this._followObject) {
      console.warn("Warning: DragPointerHandler doesn't have a dragged object. This is likely a bug.");
      return;
    }
    const i = this._followObject.parent;
    if (!i) {
      console.warn("Warning: DragPointerHandler doesn't have a drag source. This is likely a bug.");
      return;
    }
    this._followObject.updateMatrix();
    const n = i.worldPosition, o = i.worldForward, a = this._deviceMode === "tracked-pointer" || this._deviceMode === "transient-pointer", l = a ? this.settings.xrKeepRotation : this.settings.keepRotation, c = a ? this.settings.xrDragMode : this.settings.dragMode;
    if (c === 5)
      return;
    const h = 10;
    l && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion), this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
    let d = 1, u = 2;
    if (a && this._grabStartDistance > 0.5) {
      const w = 1 + this._totalMovementAlongRayDirection * (2 * this.settings.xrDistanceDragFactor);
      d = Math.max(0, w), d = d * d * d;
    } else
      this._grabStartDistance <= 0.5 && (u = 3);
    this._followObject.position.copy(this._followObjectStartPosition), l || this._followObject.quaternion.copy(this._followObjectStartQuaternion), this._followObject.position.multiplyScalar(d), this._followObject.updateMatrix();
    const p = this._hasLastSurfaceHitPoint;
    this._hasLastSurfaceHitPoint = !1;
    const m = new wo(n, o);
    if (c == 4) {
      const w = this.context.physics.raycastFromRay(m, {
        testObject: (P) => P !== this.followObject && P !== i && P !== e
        // && !(o instanceof GroundedSkybox)
      });
      if (w.length > 0) {
        const P = w[0];
        if (this._draggedOverObject === P.object ? this._draggedOverObjectDuration += this.context.time.deltaTime : (this._draggedOverObject = P.object, this._draggedOverObjectDuration = 0), P.face) {
          this._hasLastSurfaceHitPoint = !0, this._lastSurfaceHitPoint.copy(P.point);
          const k = 0.15, O = this._draggedOverObjectDuration >= k, M = 1e-3, E = this._totalMovement.length() >= M, B = G(P.normal || P.face.normal).applyQuaternion(P.object.worldQuaternion);
          if ((O || E) && (this._draggedOverObjectLastSetUp !== this._draggedOverObject || this._draggedOverObjectLastNormal.dot(B) < 0.999999 || this.context.time.frame % 60 === 0)) {
            this._draggedOverObjectLastSetUp = this._draggedOverObject, this._draggedOverObjectLastNormal.copy(P.face.normal);
            const A = G(), F = G();
            this._bounds.getCenter(A), this._bounds.getSize(F), A.sub(F.multiplyScalar(0.5).multiply(B)), this._hitPointInLocalSpace.copy(A), this._hitNormalInLocalSpace.copy(P.face.normal), this._bounds.getCenter(A), this._bounds.getSize(F), A.add(F.multiplyScalar(0.5).multiply(P.face.normal));
            const U = G(this._hitPointInLocalSpace).add(A);
            this._followObject.localToWorld(U);
            const Z = P.point;
            this._dragPlane.setFromNormalAndCoplanarPoint(B, Z);
          } else if (!(O || E))
            return;
        }
      } else
        p && this.gameObject && this.setPlaneViewAligned(this.gameObject.worldPosition, !1);
    }
    if (c !== 1 && m.intersectPlane(this._dragPlane, this._tempVec)) {
      this._followObject.worldPosition = this._tempVec, this._followObject.updateMatrix(), this._followObject.updateMatrixWorld(!0);
      const w = G(this._hitPointInLocalSpace);
      this._followObject.localToWorld(w), Un && V.DrawLine(w, this._tempVec, 65535, 0, !1), this._followObject.worldPosition = this._tempVec.multiplyScalar(2).sub(w), this._followObject.updateMatrix(), this._followObject.updateMatrix();
    }
    if (this.settings.snapGridResolution > 0) {
      const w = this._followObject.worldPosition, P = this.settings.snapGridResolution;
      w.x = Math.round(w.x / P) * P, w.y = Math.round(w.y / P) * P, w.z = Math.round(w.z / P) * P, this._followObject.worldPosition = w, this._followObject.updateMatrix();
    }
    l && (this._followObject.worldQuaternion = this._followObjectStartWorldQuaternion, this._followObject.updateMatrix());
    const g = $.clamp01(this.context.time.deltaTime * h * u), _ = $.clamp01(this.context.time.deltaTime * h * 0.5 * u), y = e.worldPosition;
    y.lerp(this._followObject.worldPosition, g), e.worldPosition = y;
    const b = e.worldQuaternion;
    if (b.slerp(this._followObject.worldQuaternion, _), e.worldQuaternion = b, Un) {
      const w = this._hitPointInLocalSpace.clone();
      e.localToWorld(w), V.DrawSphere(w, 0.02, 16711680);
      const P = this._hitNormalInLocalSpace.clone();
      P.applyQuaternion(b), V.DrawRay(w, P, 16711680), V.DrawLabel(
        y.add(new v(0, 0.25, 0)),
        `Distance: ${this._totalMovement.length().toFixed(2)}

                Along Ray: ${this._totalMovementAlongRayDirection.toFixed(2)}

                Session: ${!!J.active}

                Device: ${this._deviceMode}

                `,
        0.03
      );
      const k = this._bottomCenter.clone(), O = this._backCenter.clone(), M = this._backBottomCenter.clone();
      e.localToWorld(k), e.localToWorld(O), e.localToWorld(M), V.DrawSphere(k, 0.01, 65280, 0, !1), V.DrawSphere(O, 0.01, 255, 0, !1), V.DrawSphere(M, 0.01, 16711935, 0, !1), V.DrawLine(k, M, 65535, 0, !1), V.DrawLine(M, O, 65535, 0, !1);
    }
  }
  onDragEnd(t) {
    console.assert(this._followObject.parent === t.event.space, "Drag end: _followObject is not parented to the space object"), this._followObject.removeFromParent(), this._followObject.destroy(), this._lastDragPosRigSpace = void 0;
  }
  setPlaneViewAligned(t, e) {
    if (!this._followObject.parent)
      return !1;
    const i = this._followObject.parent.worldForward, n = G(0, 1, 0), o = i, a = n.angleTo(o), l = 0.5;
    return e && (a > Math.PI / 2 + l || a < Math.PI / 2 - l) ? this._dragPlane.setFromNormalAndCoplanarPoint(n, t) : this._dragPlane.setFromNormalAndCoplanarPoint(i, t), !0;
  }
}
const R_ = class {
  constructor(t) {
    /** Controls whether visual helpers like lines and markers are displayed */
    r(this, "showGizmo", !0);
    /** When true, drag plane alignment changes based on view angle */
    r(this, "useViewAngle", !0);
    r(this, "_selected", null);
    r(this, "_context", null);
    r(this, "_camera");
    r(this, "_cameraPlane", new vr());
    r(this, "_hasGroundPlane", !1);
    r(this, "_groundPlane", new vr());
    r(this, "_groundOffset", new v());
    r(this, "_groundOffsetFactor", 0);
    r(this, "_groundDistance", 0);
    r(this, "_groundPlanePoint", new v());
    r(this, "_raycaster", new xu());
    r(this, "_cameraPlaneOffset", new v());
    r(this, "_intersection", new v());
    r(this, "_worldPosition", new v());
    r(this, "_inverseMatrix", new se());
    r(this, "_rbs", []);
    r(this, "_groundLine");
    r(this, "_groundMarker");
    r(this, "_groundOffsetVector", new v(0, 1, 0));
    r(this, "_requireUpdateGroundPlane", !0);
    r(this, "_didDragOnGroundPlaneLastFrame", !1);
    this._camera = t;
    const e = new Ac(R_.geometry), i = e.material;
    i.color = new ae(0.4, 0.4, 0.4), e.layers.set(2), e.name = "line", e.scale.y = 1, this._groundLine = e;
    const n = new vu(0.5, 22, 22), o = new Me({ color: i.color }), a = new q(n, o);
    a.visible = !1, a.layers.set(2), this._groundMarker = a;
  }
  /**
   * Checks if there is a currently selected object being visualized
   */
  get hasSelected() {
    return this._selected !== null && this._selected !== void 0;
  }
  /**
   * Returns the currently selected object being visualized, if any
   */
  get selected() {
    return this._selected;
  }
  setSelected(t, e) {
    if (this._selected && e)
      for (const i of this._rbs)
        i.wakeUp(), i.setVelocity(0, 0, 0);
    if (this._selected && go.Remove(e, this._selected), this._selected = t, this._context = e, this._rbs.length = 0, t ? (e.scene.add(this._groundLine), e.scene.add(this._groundMarker)) : (this._groundLine.removeFromParent(), this._groundMarker.removeFromParent()), this._selected) {
      if (!e) {
        console.error("DragHelper: no context");
        return;
      }
      go.Add(e, this._selected, null), this._groundOffsetFactor = 0, this._hasGroundPlane = !0, this._groundOffset.set(0, 0, 0), this._requireUpdateGroundPlane = !0, this.onUpdateScreenSpacePlane();
    }
  }
  onUpdate(t) {
    this._selected;
  }
  onUpdateWorldPosition(t, e, i) {
    if (this._selected) {
      if (i) {
        const n = ie(this._selected);
        n.y = t.y, t = n;
      }
      if (yt(this._selected, t), yt(this._groundLine, t), this._hasGroundPlane ? this._groundLine.scale.y = this._groundDistance : this._groundLine.scale.y = 1e3, this._groundLine.visible = this.showGizmo, this._groundMarker.visible = e !== null && this.showGizmo, e) {
        const n = ie(this._camera).distanceTo(e) * 0.01;
        this._groundMarker.scale.set(n, n, n), yt(this._groundMarker, e);
      }
    }
  }
  onUpdateScreenSpacePlane() {
    if (!this._selected || !this._context)
      return;
    const t = this._context.input.getPointerPositionRC(0);
    t && (this._raycaster.setFromCamera(t, this._camera), this._cameraPlane.setFromNormalAndCoplanarPoint(this._camera.getWorldDirection(this._cameraPlane.normal), this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld)), this._raycaster.ray.intersectPlane(this._cameraPlane, this._intersection) && this._selected.parent && (this._inverseMatrix.copy(this._selected.parent.matrixWorld).invert(), this._cameraPlaneOffset.copy(this._intersection).sub(this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld))));
  }
  onUpdateGroundPlane() {
    if (!this._selected || !this._context)
      return;
    const t = ie(this._selected), e = new wo(G(0, 0.1, 0).add(t), G(0, -1, 0)), i = new Ts();
    i.testObject = (o) => o !== this._selected;
    const n = this._context.physics.raycastFromRay(e, i);
    for (let o = 0; o < n.length; o++) {
      const a = n[o];
      if (!a.face || this.contains(this._selected, a.object))
        continue;
      const l = G(0, 1, 0);
      this._groundPlane.setFromNormalAndCoplanarPoint(l, a.point);
      break;
    }
    this._hasGroundPlane = !0, this._groundPlane.setFromNormalAndCoplanarPoint(e.direction.multiplyScalar(-1), e.origin), this._raycaster.ray.intersectPlane(this._groundPlane, this._intersection), this._groundDistance = this._intersection.distanceTo(t), this._groundOffset.copy(this._intersection).sub(t);
  }
  contains(t, e) {
    if (t === e)
      return !0;
    if (t.children) {
      for (const i of t.children)
        if (this.contains(i, e))
          return !0;
    }
    return !1;
  }
};
let sp = R_;
r(sp, "geometry", new Ps().setFromPoints([new v(0, 0, 0), new v(0, -1, 0)]));
var NR = /* @__PURE__ */ ((s) => (s.File_Spawned = "file-spawned", s))(NR || {});
class YD {
  constructor(t, e, i, n, o, a, l, c, h) {
    r(this, "guid");
    r(this, "file_name");
    r(this, "file_hash");
    r(this, "file_size");
    r(this, "position");
    r(this, "scale");
    r(this, "seed");
    r(this, "sender");
    /** the url to download the file */
    r(this, "downloadUrl");
    r(this, "parentGuid");
    r(this, "boundsSize");
    this.seed = e, this.guid = i, this.file_name = n, this.file_hash = o, this.file_size = a, this.position = l, this.scale = c, this.sender = t, this.downloadUrl = h;
  }
}
var Ko;
((s) => {
  const t = /* @__PURE__ */ new Map();
  function e(n) {
    var u;
    t.has(n.guid) && i(n.guid);
    const o = new L();
    t.set(n.guid, o);
    const a = new L();
    a.position.y = -0.5, o.add(a);
    const l = new q(new Da(1, 1, 1, 1, 1, 1), new Me(
      { color: 14540253, wireframe: !0, transparent: !0, opacity: 0.3 }
    ));
    l.position.y = 0.5, a.add(l);
    const c = new L();
    a.add(c);
    const h = new q(new Da(1, 1, 1, 1, 1, 1), new Me({
      color: 12307660,
      transparent: !0,
      opacity: 0.4
    }));
    h.position.y = 0.5, c.scale.y = 0.01, c.add(h);
    const d = new q(new Xn(1, 1, 1, 1), new Me({
      color: 34,
      transparent: !0,
      opacity: 0.05,
      depthTest: !1
    }));
    return d.rotateX(-Math.PI / 2), d.position.y = 0.51, h.add(d), n.parent.add(o), o.rotateY(Math.PI / 2), n.position && ((u = o.position) == null || u.copy(n.position)), n.size && (o.worldScale = new v().copy(n.size)), o.position.y = o.scale.y / 2, {
      object: o,
      onProgress: (p) => {
        c instanceof L && c.scale.set(1, p, 1);
      }
    };
  }
  s.addPreview = e;
  function i(n) {
    const o = t.get(n);
    o && (t.delete(n), o.removeFromParent());
  }
  s.removePreview = i;
})(Ko || (Ko = {}));
var $R = Object.defineProperty, WR = Object.getOwnPropertyDescriptor, il = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? WR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && $R(t, e, n), n;
};
const mn = x("debugdroplistener");
class VR extends CustomEvent {
  /**
   * Creates a new added event with the provided details
   * @param detail Information about the added object
   */
  constructor(t) {
    super("object-added", { detail: t });
  }
}
const HR = "blob";
class Mo extends I {
  constructor() {
    super(...arguments);
    r(this, "useNetworking", !0);
    r(this, "dropArea");
    r(this, "fitIntoVolume", !1);
    r(this, "fitVolumeSize", new v(1, 1, 1));
    r(this, "placeAtHitPosition", !0);
    r(this, "onDropped", new xe());
    /**
     * Handles network events received from other clients containing information about dropped objects
     * @param evt Network event data containing object information, position, and content URL
     */
    r(this, "onNetworkEvent", (e) => {
      var i;
      if (!this.useNetworking) {
        mn && console.debug("[DropListener] Ignoring networked event because networking is disabled", e);
        return;
      }
      if ((i = e.guid) != null && i.startsWith(this.guid)) {
        const n = e.url;
        if (console.debug("[DropListener] Received networked event", e), n)
          if (Array.isArray(n))
            for (const o of n)
              this.addFromUrl(o, { screenposition: new oe(), point: e.point, size: e.size }, !0);
          else
            this.addFromUrl(n, { screenposition: new oe(), point: e.point, size: e.size }, !0);
      }
    });
    /**
     * Handles clipboard paste events and processes them as potential URL drops
     * Only URLs are processed by this handler, and only when editing is allowed
     * @param evt The paste event
     */
    r(this, "handlePaste", (e) => {
      if (this.context.connection.allowEditing === !1 || e.defaultPrevented)
        return;
      navigator.clipboard.readText().then((n) => {
        if (n && (n.startsWith("http") || n.startsWith("https") || n.startsWith("blob"))) {
          const a = { screenposition: new oe(this.context.input.mousePosition.x, this.context.input.mousePosition.y) };
          this.testIfIsInDropArea(a) && this.addFromUrl(n, a, !1);
        }
      }).catch(console.warn);
    });
    /**
     * Handles drag events over the renderer's canvas
     * Prevents default behavior to enable drop events
     * @param evt The drag event
     */
    r(this, "onDrag", (e) => {
      this.context.connection.allowEditing !== !1 && e.preventDefault();
    });
    /**
     * Processes drop events to add files to the scene
     * Handles both file drops and text/URL drops
     * @param evt The drop event
     */
    r(this, "onDrop", async (e) => {
      if (this.context.connection.allowEditing === !1 || (mn && console.log(e), !(e != null && e.dataTransfer)) || e["droplistener:handled"])
        return;
      e.preventDefault();
      const i = { screenposition: new oe(e.offsetX, e.offsetY) };
      if (this.dropArea && this.testIfIsInDropArea(i) === !1)
        return;
      e["droplistener:handled"] = !0;
      const n = e.dataTransfer.items;
      if (!n)
        return;
      const o = [];
      for (const a in n) {
        const l = n[a];
        if (l.kind === "file") {
          const c = l.getAsFile();
          if (!c)
            continue;
          o.push(c);
        } else
          l.kind === "string" && l.type == "text/plain" && l.getAsString((c) => {
            this.addFromUrl(c, i, !1);
          });
      }
      o.length > 0 && await this.addDroppedFiles(o, i);
    });
    r(this, "_abort", null);
    /** Previously added objects */
    r(this, "_addedObjects", new Array());
    r(this, "_addedModels", new Array());
  }
  /** @internal */
  onEnable() {
    this.context.renderer.domElement.addEventListener("dragover", this.onDrag), this.context.renderer.domElement.addEventListener("drop", this.onDrop), window.addEventListener("paste", this.handlePaste), this.context.connection.beginListen("droplistener", this.onNetworkEvent);
  }
  /** @internal */
  onDisable() {
    this.context.renderer.domElement.removeEventListener("dragover", this.onDrag), this.context.renderer.domElement.removeEventListener("drop", this.onDrop), window.removeEventListener("paste", this.handlePaste), this.context.connection.stopListen("droplistener", this.onNetworkEvent);
  }
  /**
   * Loads a file from the given URL and adds it to the scene.
   */
  loadFromURL(e, i) {
    this.addFromUrl(e, { screenposition: new oe(), point: i == null ? void 0 : i.point, size: i == null ? void 0 : i.size }, !0);
  }
  /**
   * Forgets all previously added objects.     
   * The droplistener will then not be able to remove previously added objects.
   */
  forgetObjects() {
    this.removePreviouslyAddedObjects(!1);
  }
  /**
   * Processes a dropped or pasted URL and tries to load it as a 3D model
   * Handles special cases like GitHub URLs and Polyhaven asset URLs
   * @param url The URL to process
   * @param ctx Context information about where the drop occurred
   * @param isRemote Whether this URL was shared from a remote client
   * @returns The added object or null if loading failed
   */
  async addFromUrl(e, i, n) {
    mn && console.log("dropped url", e);
    try {
      if (e.startsWith("https://github.com/")) {
        const l = e.split("/"), c = l[3], h = l[4], d = l[6], u = l.slice(7).join("/");
        e = `https://raw.githubusercontent.com/${c}/${h}/${d}/${u}`;
      } else
        e.startsWith("https://polyhaven.com/a") && (e = GR(e));
      if (!e)
        return null;
      const o = e.toLowerCase();
      if (o.endsWith(".hdr") || o.endsWith(".hdri") || o.endsWith(".exr") || o.endsWith(".png") || o.endsWith(".jpg") || o.endsWith(".jpeg"))
        return null;
      this.removePreviouslyAddedObjects();
      const a = await eu.loadFileFromURL(new URL(e), {
        guid: this.guid,
        context: this.context,
        parent: this.gameObject,
        point: i.point,
        size: i.size
      });
      if (a && this._addedObjects.length <= 0)
        return i.url = e, this.addObject(a, i, n);
    } catch {
      console.warn("String is not a valid URL", e);
    }
    return null;
  }
  /**
   * Processes dropped files, loads them as 3D models, and handles networking if enabled
   * Creates an abort controller to cancel previous uploads if new files are dropped
   * @param fileList Array of dropped files
   * @param ctx Context information about where the drop occurred
   */
  async addDroppedFiles(e, i) {
    var n, o;
    if (mn && console.log("Add files", e), !!Array.isArray(e) && e.length) {
      this.deleteDropEvent(), this.removePreviouslyAddedObjects(), jd(HR, null), (n = this._abort) == null || n.abort("New files dropped"), this._abort = new AbortController();
      for (const a of e) {
        if (!a)
          continue;
        console.debug("Load file " + a.name);
        const l = await eu.loadFile(a, this.context, { guid: this.guid });
        if (l) {
          this.dispatchEvent(new CustomEvent("file-dropped", { detail: a })), i.file = a;
          const c = this.addObject(l, i, !1);
          c && this.context.connection.isConnected && this.useNetworking && (console.debug("Uploading dropped file to blob storage"), Ga.upload(a, { abort: (o = this._abort) == null ? void 0 : o.signal }).then((h) => {
            h != null && h.download_url && this._addedObjects.includes(c) && this.sendDropEvent(h.download_url, c, l.contentMD5);
          }).catch(console.warn));
          break;
        }
      }
    }
  }
  /**
   * Removes all previously added objects from the scene
   * @param doDestroy When true, destroys the objects; when false, just clears the references
   */
  removePreviouslyAddedObjects(e = !0) {
    if (e)
      for (const i of this._addedObjects)
        i.parent === this.gameObject && nn(i, !0, !0);
    this._addedObjects.length = 0, this._addedModels.length = 0;
  }
  /**
   * Adds a loaded model to the scene with proper positioning and scaling.
   * Handles placement based on component settings and raycasting.
   * If {@link fitIntoVolume} is enabled, the object will be scaled to fit within the volume defined by {@link fitVolumeSize}.
   * @param data The loaded model data and content hash
   * @param ctx Context information about where the drop occurred
   * @param isRemote Whether this object was shared from a remote client
   * @returns The added object or null if adding failed
   */
  addObject(e, i, n) {
    var d, u;
    const { model: o, contentMD5: a } = e;
    if (mn && console.log(`Dropped ${this.gameObject.name}`, o), !(o != null && o.scene))
      return console.warn("No object specified to add to scene", o), null;
    this.removePreviouslyAddedObjects();
    const l = o.scene;
    this.gameObject.attach(l), l.position.set(0, 0, 0), l.quaternion.identity(), this._addedObjects.push(l), this._addedModels.push(o);
    const c = new Pi().setFromCenterAndSize(new v(0, this.fitVolumeSize.y * 0.5, 0).add(this.gameObject.worldPosition), this.fitVolumeSize);
    if (mn && V.DrawWireBox3(c, 255, 5), this.fitIntoVolume && mC(l, c, {
      position: !this.placeAtHitPosition
    }), this.placeAtHitPosition && i && i.screenposition) {
      l.visible = !1;
      const p = this.context.physics.raycast({ screenPoint: this.context.input.convertScreenspaceToRaycastSpace(i.screenposition.clone()) });
      if (l.visible = !0, p && p.length > 0)
        for (const m of p) {
          const g = m.point.clone();
          mn && console.log("Place object at hit", m), gC(l, g);
          break;
        }
    }
    zc.assignAnimationsFromFile(o, {
      createAnimationComponent: (p) => en(p, ti)
    });
    const h = new VR({
      sender: this,
      gltf: o,
      model: o,
      object: l,
      contentMD5: a,
      dropped: i.file || (i.url ? new URL(i.url) : void 0)
    });
    return this.dispatchEvent(h), (d = this.onDropped) == null || d.invoke(h.detail), !n && ((u = i.url) != null && u.startsWith("http")) && this.context.connection.isConnected && l && this.sendDropEvent(i.url, l, a), l;
  }
  /**
   * Sends a network event to other clients about a dropped object
   * Only triggered when networking is enabled and the connection is established
   * @param url The URL to the content that was dropped
   * @param obj The object that was added to the scene
   * @param contentmd5 The content hash for verification
   */
  async sendDropEvent(e, i, n) {
    if (!this.useNetworking) {
      mn && console.debug("[DropListener] Ignoring networked event because networking is disabled", e);
      return;
    }
    if (this.context.connection.isConnected) {
      console.debug('Sending drop event "' + i.name + '"', e);
      const o = ki([i]), a = {
        name: i.name,
        guid: this.guid,
        url: e,
        point: i.worldPosition.clone(),
        size: o.getSize(new v()),
        contentMD5: n
      };
      this.context.connection.send("droplistener", a);
    }
  }
  /**
   * Deletes remote state for this DropListener's objects
   * Called when new files are dropped to clean up previous state
   */
  deleteDropEvent() {
    this.context.connection.sendDeleteRemoteState(this.guid);
  }
  /**
   * Tests if a drop event occurred within the designated drop area if one is specified
   * @param ctx The drop context containing screen position information
   * @returns True if the drop is valid (either no drop area is set or the drop occurred inside it)
   */
  testIfIsInDropArea(e) {
    if (this.dropArea) {
      const i = this.context.input.convertScreenspaceToRaycastSpace(e.screenposition.clone());
      if (!this.context.physics.raycast({
        targets: [this.dropArea],
        screenPoint: i,
        recursive: !0,
        testObject: (o) => !this._addedObjects.includes(o)
      }).length)
        return z() && console.log(`Dropped outside of drop area for DropListener "${this.name}".`), !1;
    }
    return !0;
  }
}
il([
  f()
], Mo.prototype, "useNetworking", 2);
il([
  f(L)
], Mo.prototype, "dropArea", 2);
il([
  f()
], Mo.prototype, "fitIntoVolume", 2);
il([
  f(v)
], Mo.prototype, "fitVolumeSize", 2);
il([
  f()
], Mo.prototype, "placeAtHitPosition", 2);
il([
  f(xe)
], Mo.prototype, "onDropped", 2);
function GR(s) {
  if (!s.startsWith("https://polyhaven.com/"))
    return s;
  const t = "https://dl.polyhaven.org/file/ph-assets/Models/gltf/4k/", n = new URL(s).pathname.split("/").pop(), o = `${t}${n}/${n}_4k.gltf`;
  return console.log("Resolved polyhaven asset url", s, "→", o), o;
}
var eu;
((s) => {
  async function t(i, n, o) {
    const a = i.name.toLowerCase();
    return a.endsWith(".gltf") || a.endsWith(".glb") || a.endsWith(".fbx") || a.endsWith(".obj") || a.endsWith(".usdz") || a.endsWith(".vrm") || i.type === "model/gltf+json" || i.type === "model/gltf-binary" ? new Promise((l, c) => {
      const h = new FileReader();
      h.readAsArrayBuffer(i), h.onloadend = async (d) => {
        const u = h.result, p = o.guid, m = new Bt(p), g = await Hn().parseSync(n, u, i.name, m);
        if (g) {
          const _ = Ga.hashMD5(u);
          l({ model: g, contentMD5: _ });
        }
      };
    }) : (console.warn("Unsupported file type: " + a, i.type), null);
  }
  s.loadFile = t;
  async function e(i, n) {
    return new Promise(async (o, a) => {
      const l = new Bt(n.guid), c = i.toString();
      mn && V.DrawWireSphere(n.point, 0.1, 16711680, 3);
      const h = Ko.addPreview({
        guid: n.guid,
        parent: n.parent,
        position: n == null ? void 0 : n.point,
        size: n == null ? void 0 : n.size
      }), d = await Hn().loadSync(n.context, c, c, l, (u) => {
        h.onProgress(u.loaded / u.total);
      }).catch(console.warn);
      if (d) {
        const u = await fetch(c).then((m) => m.arrayBuffer()), p = Ga.hashMD5(u);
        mn ? setTimeout(() => Ko.removePreview(n.guid), 3e3) : Ko.removePreview(n.guid), o({ model: d, contentMD5: p });
      } else
        mn ? setTimeout(() => Ko.removePreview(n.guid), 3e3) : Ko.removePreview(n.guid), console.warn("Unsupported file type: " + i.toString());
    });
  }
  s.loadFileFromURL = e;
})(eu || (eu = {}));
var qR = Object.defineProperty, XR = Object.getOwnPropertyDescriptor, Wg = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? XR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && qR(t, e, n), n;
};
const Qv = class extends I {
  constructor() {
    super(...arguments);
    r(this, "parent", null);
    r(this, "object", null);
    r(this, "limitCount", 60);
    r(this, "_currentCount", 0);
    r(this, "_startPosition", null);
    r(this, "_startQuaternion", null);
    r(this, "_forwardPointerEvents", /* @__PURE__ */ new Map());
  }
  start() {
    var t, e;
    if (this._currentCount = 0, this._startPosition = null, this._startQuaternion = null, this.object || (this.object = this.gameObject), this.object) {
      if (this.object === this.gameObject) {
        const n = new Bt(this.guid);
        this.object = S.instantiate(this.object, { idProvider: n, keepWorldPosition: !1 });
        const o = S.getComponent(this.object, Qv);
        o == null || o.destroy();
        let a = this.object.getComponentInChildren(Si);
        a || (a = this.object.addComponent(Si, {
          dragMode: Xv.SnapToSurfaces
        }), a.guid = n.generateUUID());
        let l = S.getComponent(a.gameObject, As);
        l || (l = a.gameObject.addComponent(As), l.guid = n.generateUUID());
      }
      this.object.visible = !1;
      const i = this.gameObject.getComponent(Si);
      i && (i.enabled = !1), this._startPosition = ((t = this.object.position) == null ? void 0 : t.clone()) ?? new v(0, 0, 0), this._startQuaternion = ((e = this.object.quaternion) == null ? void 0 : e.clone()) ?? new W(0, 0, 0, 1);
    }
    this.gameObject.getComponentInParent(sn) || this.gameObject.addComponent(sn);
  }
  onEnable() {
    this.startCoroutine(this.cloneLimitIntervalFn());
  }
  onPointerEnter(t) {
    t.used || this.object && this.context.connection.allowEditing && t.button === 0 && this.context.input.setCursor("pointer");
  }
  onPointerExit(t) {
    t.used || this.object && this.context.connection.allowEditing && t.button === 0 && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerDown(t) {
    if (t.used || !this.object || !this.context.connection.allowEditing || t.button !== 0)
      return;
    const e = this.handleDuplication();
    if (e) {
      const i = S.getComponent(e, Si);
      i ? (i.onPointerDown(t), this._forwardPointerEvents.set(t.event.space, i)) : console.warn("Duplicated object does not have DragControls", e);
    } else
      this._currentCount >= this.limitCount ? console.warn(`[Duplicatable] Limit of ${this.limitCount} objects created within a few seconds reached. Please wait a moment before creating more objects.`) : console.warn("[Duplicatable] Could not duplicate object.");
  }
  /** @internal */
  onPointerUp(t) {
    if (t.used)
      return;
    const e = this._forwardPointerEvents.get(t.event.space);
    e && (e.onPointerUp(t), this._forwardPointerEvents.delete(t.event.space));
  }
  *cloneLimitIntervalFn() {
    for (; this.activeAndEnabled && !this.destroyed; )
      this._currentCount > 0 ? this._currentCount -= 1 : this._currentCount < 0 && (this._currentCount = 0), yield Sv(1);
  }
  handleDuplication() {
    var i;
    if (!this.object || this.limitCount > 0 && this._currentCount >= this.limitCount || this.object === this.gameObject)
      return null;
    if (S.isDestroyed(this.object))
      return this.object = null, null;
    this.object.visible = !0, this._startPosition && this.object.position.copy(this._startPosition), this._startQuaternion && this.object.quaternion.copy(this._startQuaternion);
    const t = new Qn();
    this.parent || (this.parent = this.gameObject.parent), this.parent && (t.parent = this.parent.guid ?? ((i = this.parent.userData) == null ? void 0 : i.guid), t.keepWorldPosition = !0), t.position = this.worldPosition, t.rotation = this.worldQuaternion, t.context = this.context, this._currentCount += 1;
    const e = S.instantiateSynced(this.object, t);
    return console.assert(e !== this.object, "Duplicated object is original"), this.object.visible = !1, this._startPosition && this.object.position.clone().copy(this._startPosition), this._startQuaternion && this.object.quaternion.clone().copy(this._startQuaternion), e;
  }
};
let nh = Qv;
Wg([
  f(L)
], nh.prototype, "parent", 2);
Wg([
  f(L)
], nh.prototype, "object", 2);
Wg([
  f()
], nh.prototype, "limitCount", 2);
var cs = /* @__PURE__ */ ((s) => (s[s.PointerEnter = 0] = "PointerEnter", s[s.PointerExit = 1] = "PointerExit", s[s.PointerDown = 2] = "PointerDown", s[s.PointerUp = 3] = "PointerUp", s[s.PointerClick = 4] = "PointerClick", s[s.Drag = 5] = "Drag", s[s.Drop = 6] = "Drop", s[s.Scroll = 7] = "Scroll", s[s.UpdateSelected = 8] = "UpdateSelected", s[s.Select = 9] = "Select", s[s.Deselect = 10] = "Deselect", s[s.Move = 11] = "Move", s[s.InitializePotentialDrag = 12] = "InitializePotentialDrag", s[s.BeginDrag = 13] = "BeginDrag", s[s.EndDrag = 14] = "EndDrag", s[s.Submit = 15] = "Submit", s[s.Cancel = 16] = "Cancel", s))(cs || {}), QR = Object.defineProperty, YR = Object.getOwnPropertyDescriptor, Vg = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? YR(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && QR(t, e, n), n;
};
class Hg {
  constructor() {
    r(this, "eventID");
    r(this, "callback", new xe());
  }
}
Vg([
  f()
], Hg.prototype, "eventID", 2);
Vg([
  f(xe)
], Hg.prototype, "callback", 2);
class Gg extends I {
  constructor() {
    super(...arguments);
    r(this, "triggers", []);
  }
  /** @internal */
  invoke(e) {
    var i;
    if (this.triggers)
      for (const n of this.triggers)
        n.eventID === e && ((i = n.callback) == null || i.invoke());
  }
  hasTrigger(e) {
    var i;
    return ((i = this.triggers) == null ? void 0 : i.some((n) => n.eventID === e)) ?? !1;
  }
  shouldChangeCursor() {
    return this.hasTrigger(cs.PointerClick) || this.hasTrigger(cs.PointerDown) || this.hasTrigger(cs.PointerUp);
  }
  /** @internal */
  onPointerClick(e) {
    this.invoke(cs.PointerClick);
  }
  /** @internal */
  onPointerEnter(e) {
    this.shouldChangeCursor() && this.context.input.setCursor("pointer"), this.invoke(cs.PointerEnter);
  }
  /** @internal */
  onPointerExit(e) {
    this.shouldChangeCursor() && this.context.input.unsetCursor("pointer"), this.invoke(cs.PointerExit);
  }
  /** @internal */
  onPointerDown(e) {
    this.invoke(cs.PointerDown);
  }
  /** @internal */
  onPointerUp(e) {
    this.invoke(cs.PointerUp);
  }
}
Vg([
  f(Hg)
], Gg.prototype, "triggers", 2);
class Yv {
  constructor(t) {
    r(this, "writer");
    this.writer = t;
  }
  writeNode(t) {
  }
}
class KR extends Yv {
  beforeWriteNode(t, e) {
    V.isGizmo(t) && (e.keep = !1);
  }
}
class Kv extends Yv {
  beforeWriteTexture(t, e) {
    t.isRenderTargetTexture && (e.newTexture = Ag(new we(1, 1, 1, 0)));
  }
}
function Am(s) {
  const t = Fg.DontExport;
  return !(s.hideFlags & t);
}
const op = x("debugexr");
class ZR {
  constructor(t) {
    r(this, "parser");
    this.parser = t, op && console.log(t);
  }
  get name() {
    return "EXT_texture_exr";
  }
  loadTexture(t) {
    const e = this.name, i = this.parser, o = i.json.textures[t];
    if (op && console.log("EXT_texture_exr.loadTexture", t, o), !o.extensions || !o.extensions[e])
      return null;
    const a = o.extensions[e], l = new Ld(i.options.manager);
    return op && console.log("EXT_texture_exr.loadTexture", a), i.loadTextureImage(t, a.source, l);
  }
}
typeof window < "u" && window.addEventListener("unhandledrejection", (s) => {
});
const os = gt, Wh = "$___Export_Components", JR = "NEEDLE_components";
var jI;
class ek {
  constructor() {
    r(this, jI);
  }
}
jI = sa;
class tk {
  constructor(t, e, i) {
    r(this, "node");
    r(this, "nodeIndex");
    r(this, "nodeDef");
    this.node = t, this.nodeIndex = e, this.nodeDef = i;
  }
}
class Zv {
  constructor() {
    // import
    r(this, "parser");
    r(this, "nodeToObjectMap", {});
    /** The loaded gltf */
    r(this, "gltf", null);
    // export
    r(this, "exportContext");
    r(this, "objectToNodeMap", {});
    r(this, "context");
    r(this, "writer");
  }
  get name() {
    return JR;
  }
  registerExport(t) {
    t.register((e) => {
      if ("serializeUserData" in e) {
        const i = e.serializeUserData.bind(e);
        this.writer = e, e.serializeUserData = (n, o) => {
          try {
            this.serializeUserData(n, o) && (e.extensionsUsed[this.name] = !0), i(n, o);
          } finally {
            this.afterSerializeUserData(n, o);
          }
        };
      }
      return this;
    });
  }
  beforeParse() {
    this.exportContext = {}, this.objectToNodeMap = {};
  }
  // https://github.com/mrdoob/three.js/blob/efbfc67edc7f65cfcc61a389ffc5fd43ea702bc6/examples/jsm/exporters/GLTFExporter.js#L532
  serializeUserData(t, e) {
    var n;
    const i = (n = t.userData) == null ? void 0 : n.components;
    return !i || i.length <= 0 ? !1 : (delete t.userData.components, t[Wh] = i, !0);
  }
  afterSerializeUserData(t, e) {
    if (t.type === "Scene" && os && console.log("DONE", JSON.stringify(e)), t[Wh] === void 0)
      return;
    const i = t[Wh];
    delete t[Wh], i !== null && (t.userData.components = i);
  }
  writeNode(t, e) {
    const i = this.writer.json.nodes.length;
    os && console.log(t.name, i, t.uuid);
    const n = new tk(t, i, e);
    this.exportContext[i] = n, this.objectToNodeMap[t.uuid] = i;
  }
  afterParse(t) {
    var e;
    os && console.log("AFTER", t);
    for (const i in this.exportContext) {
      const n = this.exportContext[i], o = n.node, a = n.nodeDef, l = n.nodeIndex, c = (e = o.userData) == null ? void 0 : e.components;
      if (!c || c.length <= 0)
        continue;
      const h = new ek();
      a.extensions = a.extensions || {}, a.extensions[this.name] = h, this.context.object = o, this.context.nodeId = l, this.context.objectToNode = this.objectToNodeMap;
      const d = [];
      for (const u of c) {
        this.context.target = u;
        const p = Hn().writeBuiltinComponentData(u, this.context);
        p !== null && d.push(p);
      }
      d.length > 0 && (h[sa] = d, os && console.log("DID WRITE", o, "nodeIndex", l, d));
    }
  }
  // -------------------------------------
  // LOADING 
  // called by GLTFLoader
  beforeRoot() {
    return os && console.log("BEGIN LOAD"), this.nodeToObjectMap = {}, null;
  }
  // called by GLTFLoader
  async afterRoot(t) {
    this.gltf = t;
    const e = t.parser, i = e == null ? void 0 : e.extensions;
    if (!i)
      return;
    const n = i[this.name];
    os && console.log("After root", t, this.parser, i);
    const o = [];
    if (n === !0) {
      const a = e.json.nodes;
      if (a) {
        for (let l = 0; l < a.length; l++) {
          const c = await e.getDependency("node", l);
          this.nodeToObjectMap[l] = c;
        }
        for (let l = 0; l < a.length; l++) {
          const c = a[l], h = l, d = c.extensions;
          if (!d)
            continue;
          const u = d[this.name];
          if (!u)
            continue;
          os && console.log("NODE", c);
          const p = this.nodeToObjectMap[h];
          if (!p) {
            console.error("Could not find object for node index: " + h, c, e);
            continue;
          }
          Rg(p), o.push(this.createComponents(p, u));
        }
      }
    }
    await Promise.all(o);
    for (const a of e.associations.keys()) {
      const l = e.associations.get(a);
      if ((l == null ? void 0 : l.materials) != null) {
        const c = "/materials/" + l.materials;
        HP(a, c);
      }
    }
  }
  async createComponents(t, e) {
    if (!e)
      return;
    const i = e[sa];
    if (i) {
      const n = new Array();
      os && console.log(t.name, i);
      for (const o in i) {
        const a = i[o];
        os && console.log("Serialized data", JSON.parse(JSON.stringify(a))), a && this.parser && n.push(
          Og(this.parser, a).catch((l) => console.error(`Error while resolving references (see console for details)
`, l, t, a))
        ), t.userData = t.userData || {}, t.userData[sa] = t.userData[sa] || [], t.userData[sa].push(a);
      }
      await Promise.all(n).catch((o) => {
        console.error("Error while loading components", o);
      });
    }
  }
  // parse function https://github.com/mrdoob/three.js/blob/efbfc67edc7f65cfcc61a389ffc5fd43ea702bc6/examples/jsm/loaders/GLTFLoader.js#L2290
  // createNodeAttachment(nodeIndex: number): null {
  //     // if(!this.parser){
  //     //     console.error("Parser not set, call registerLoad with on this");
  //     //     return null;
  //     // }
  //     // const node = this.parser.json.nodes[nodeIndex];
  //     // const extenstions = node.extensions;
  //     // const data = extenstions && extenstions[this.name];
  //     // if (!data) return null;
  //     // const components = data[builtinComponentKeyName];
  //     // if (!components) return null;
  //     // console.log(components);
  //     return null;
  // }
}
const lb = "NEEDLE_gameobject_data";
class ik {
  constructor(t) {
    r(this, "parser");
    this.parser = t;
  }
  get name() {
    return lb;
  }
  // private _lastIndex: number = -1;
  // createNodeAttachment(index): null {
  //     if (index === this._lastIndex) return null;
  //     this._lastIndex = index;
  //     const node = this.parser.json.nodes[index];
  //     if (node && node.extensions) {
  //         const ext = node.extensions[EXTENSION_NAME];
  //         if (ext)
  //             this.findAndApplyExtensionData(index, ext);
  //     }
  //     return null;
  // }
  // private lastIndex: number = -1;
  afterRoot(t) {
    var i;
    const e = [];
    for (let n = 0; n < ((i = this.parser.json.nodes) == null ? void 0 : i.length); n++) {
      const o = this.parser.json.nodes[n];
      if (o && o.extensions) {
        const a = o.extensions[lb];
        if (a) {
          const l = this.findAndApplyExtensionData(n, a);
          e.push(l);
        }
      }
    }
    return Promise.all(e).then(() => null);
  }
  async findAndApplyExtensionData(t, e) {
    const i = await this.parser.getDependency("node", t);
    i && this.applyExtensionData(i, e);
  }
  applyExtensionData(t, e) {
    e.layers === void 0 && (e.layers = 0), t.userData.layer = e.layers, t.layers.disableAll(), t.layers.set(e.layers), t.userData.tag = e.tag ?? "none", t.hideFlags = 0, t.userData.static = e.static ?? !1, t.visible = e.activeSelf ?? !0, t.guid = e.guid;
  }
}
const cb = "NEEDLE_lighting_settings", la = x("debugenvlight");
class nk {
  constructor(t, e, i) {
    r(this, "parser");
    r(this, "sourceId");
    r(this, "context");
    this.parser = t, this.sourceId = e, this.context = i;
  }
  get name() {
    return cb;
  }
  afterRoot(t) {
    const e = this.parser.json.extensions;
    if (e) {
      const i = e[cb];
      if (i) {
        la && console.log('Loaded "' + this.name + '", src: "' + this.sourceId + '"', i);
        let n;
        if (t.scene.children.length === 1) {
          const o = t.scene.children[0];
          n = S.addComponent(o, Em, {}, { callAwake: !1 });
        } else {
          const o = new L();
          o.name = "LightSettings " + this.sourceId, t.scene.add(o), n = S.addComponent(o, Em, {}, { callAwake: !1 });
        }
        n.sourceId = this.sourceId, n.ambientIntensity = i.ambientIntensity, n.ambientLight = new ae().fromArray(i.ambientLight), Array.isArray(i.ambientTrilight) && (n.ambientTrilight = i.ambientTrilight.map((o) => new ae().fromArray(o))), n.ambientMode = i.ambientMode, n.environmentReflectionSource = i.environmentReflectionSource;
      }
    }
    return null;
  }
}
fe.registerCallback(pe.ContextCreated, (s) => {
  const t = s.context, e = S.findObjectOfType(Em, t);
  e != null && e.sourceId && (e.enabled = !0);
});
class Em extends I {
  constructor() {
    super(...arguments);
    r(this, "ambientMode", pc.Skybox);
    r(this, "ambientLight");
    r(this, "ambientTrilight");
    r(this, "ambientIntensity", 1);
    r(this, "environmentReflectionSource", Cm.Skybox);
    r(this, "_hasReflection", !1);
    r(this, "_ambientLightObj");
    r(this, "_hemisphereLightObj");
  }
  awake() {
    var i;
    if (this.sourceId) {
      const n = this.environmentReflectionSource === Cm.Skybox ? ao.Skybox : ao.Reflection, o = this.context.lightmaps.tryGet(this.sourceId, n, 0);
      this._hasReflection = o != null, o && this.context.sceneLighting.internalRegisterReflection(this.sourceId, o);
    }
    this.enabled = !1, this.context.sceneLighting.internalRegisterSceneLightSettings(this), la && window.addEventListener("keydown", (n) => {
      if (!this.destroyed)
        switch (n.key) {
          case "l":
            this.enabled = !this.enabled;
            break;
        }
    });
    const e = (i = this.gameObject.userData) == null ? void 0 : i.components;
    if (e) {
      const n = e.indexOf(this);
      e.splice(n, 1), e.push(this);
    }
  }
  onDestroy() {
    this.context.sceneLighting.internalUnregisterSceneLightSettings(this);
  }
  calculateIntensityFactor(e) {
    const i = Math.max(e.r, e.g, e.b);
    return 2.2 * $.lerp(0, 1.33, i);
  }
  onEnable() {
    if (la && console.warn("💡🟡 >>> Enable lighting", this.sourceId, this.enabled, this), this.ambientMode == pc.Flat) {
      if (this.ambientLight && !this._ambientLightObj) {
        const e = this.calculateIntensityFactor(this.ambientLight);
        this._ambientLightObj = new Jx(this.ambientLight, this.ambientIntensity * e), la && console.log("Created ambient light", this.sourceId, this._ambientLightObj, this.ambientIntensity, e);
      }
      this._ambientLightObj && this.gameObject.add(this._ambientLightObj);
    } else if (this.ambientMode === pc.Trilight) {
      if (this.ambientTrilight) {
        const e = this.ambientTrilight[0], i = this.ambientTrilight[this.ambientTrilight.length - 1], n = this.calculateIntensityFactor(i);
        this._hemisphereLightObj = new e1(i, e, this.ambientIntensity * n), this.gameObject.add(this._hemisphereLightObj), la && console.log("Created hemisphere ambient light", this.sourceId, this._hemisphereLightObj, this.ambientIntensity, n);
      }
    } else
      this._ambientLightObj && this._ambientLightObj.removeFromParent(), this._hemisphereLightObj && this._hemisphereLightObj.removeFromParent();
    this.sourceId && this.context.sceneLighting.internalEnableReflection(this.sourceId);
  }
  onDisable() {
    la && console.warn("💡⚫ <<< Disable lighting:", this.sourceId, this), this._ambientLightObj && this._ambientLightObj.removeFromParent(), this._hemisphereLightObj && this._hemisphereLightObj.removeFromParent(), this.sourceId && this.context.sceneLighting.internalDisableReflection(this.sourceId);
  }
}
const rp = x("debugstencil");
function sk(s, t) {
  return (s & 1 << t.layer) != 0;
}
const ok = Symbol("stencils"), er = class {
  constructor(t, e) {
    r(this, "parser");
    r(this, "source");
    this.parser = t, this.source = e;
  }
  get name() {
    return "NEEDLE_render_objects";
  }
  static applyStencil(t) {
    if (!t)
      return;
    const e = t.sourceId;
    if (rp && console.log(e, er.stencils), !e)
      return;
    const i = er.stencils[e];
    if (i)
      for (let n = i.length - 1; n >= 0; n--) {
        const o = i[n];
        if (sk(o.layer, t)) {
          rp && console.log(o), setTimeout(() => {
            ui() && kg(t.gameObject) && (ve("Stencil not supported on instanced objects"), console.warn("Stencil not supported on instanced objects", t));
          }, 500);
          for (let a = 0; a < t.sharedMaterials.length; a++) {
            let l = t.sharedMaterials[a];
            l && (l = l.clone(), l[ok] = !0, l.stencilWrite = !0, l.stencilWriteMask = 255, l.stencilFuncMask = 255, l.stencilRef = o.value, l.stencilFunc = o.compareFunc, l.stencilZPass = o.passOp, l.stencilFail = o.failOp, l.stencilZFail = o.zFailOp, t.sharedMaterials[a] = l);
          }
          t.gameObject.renderOrder = o.event * 1e3 + o.index * 50;
          break;
        }
      }
  }
  afterRoot(t) {
    const e = this.parser.json.extensions;
    if (e) {
      const i = e[ak];
      if (i) {
        rp && console.log(i);
        const n = i.stencil;
        if (n && Array.isArray(n))
          for (const o of n) {
            const a = { ...o };
            a.compareFunc = rk(a.compareFunc), a.passOp = ap(a.passOp), a.failOp = ap(a.failOp), a.zFailOp = ap(a.zFailOp), er.stencils[this.source] || (er.stencils[this.source] = []), er.stencils[this.source].push(a);
          }
      }
    }
    return null;
  }
};
let _c = er;
r(_c, "stencils", {});
function ap(s) {
  switch (s) {
    case 0:
      return l1;
    case 1:
      return a1;
    case 2:
      return r1;
    case 3:
      return o1;
    case 4:
      return s1;
    case 6:
      return n1;
    case 7:
      return i1;
    case 5:
      return t1;
  }
  return 0;
}
function rk(s) {
  switch (s) {
    case 1:
      return D_;
    case 2:
      return m1;
    case 3:
      return p1;
    case 4:
      return f1;
    case 5:
      return u1;
    case 6:
      return d1;
    case 7:
      return h1;
    case 8:
      return c1;
  }
  return D_;
}
const ak = "NEEDLE_render_objects";
var Jv = /* @__PURE__ */ ((s) => (s[s.INT = 5124] = "INT", s[s.FLOAT = 5126] = "FLOAT", s[s.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", s[s.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", s[s.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", s[s.INT_VEC2 = 35667] = "INT_VEC2", s[s.INT_VEC3 = 35668] = "INT_VEC3", s[s.INT_VEC4 = 35669] = "INT_VEC4", s[s.BOOL = 35670] = "BOOL", s[s.BOOL_VEC2 = 35671] = "BOOL_VEC2", s[s.BOOL_VEC3 = 35672] = "BOOL_VEC3", s[s.BOOL_VEC4 = 35673] = "BOOL_VEC4", s[s.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", s[s.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", s[s.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", s[s.SAMPLER_2D = 35678] = "SAMPLER_2D", s[s.SAMPLER_3D = 35680] = "SAMPLER_3D", s[s.SAMPLER_CUBE = 35681] = "SAMPLER_CUBE", s[s.UNKNOWN = 0] = "UNKNOWN", s))(Jv || {});
const An = x("debugcustomshader"), qr = "NEEDLE_techniques_webgl";
class lk {
  constructor() {
    r(this, "objectToWorldMatrix", new se());
    r(this, "worldToObjectMatrix", new se());
    r(this, "objectToWorld", new Array());
    r(this, "worldToObject", new Array());
  }
  updateFrom(t) {
    this.objectToWorldMatrix.copy(t.matrixWorld), Gd(this.objectToWorldMatrix, this.objectToWorld), this.worldToObjectMatrix.copy(t.matrixWorld).invert(), Gd(this.worldToObjectMatrix, this.worldToObject);
  }
}
const Be = class extends s0 {
  constructor(e, ...i) {
    super(...i);
    r(this, "identifier");
    r(this, "onBeforeRenderSceneCallback", this.onBeforeRenderScene.bind(this));
    /* REMOVED, we don't have Lit shader support for now
    async waitForLighting() {
        const context: Context = Context.Current;
        if (!context) {
            console.error("Missing context");
            return;
        }
        const data = await context.sceneLighting.internalGetSceneLightingData(this.identifier);
        if (!data || !data.array) {
            console.warn("Missing lighting data for custom shader, getSceneLightingData did not return anything");
            return;
        }
        if (debug)
            console.log(data);
        const array = data.array;
        const envTexture = data.texture;
        // console.log(envTexture);
        this.uniforms["unity_SpecCube0"] = { value: envTexture };
        SetUnitySphericalHarmonics(this.uniforms, array);
        const hdr = Math.sqrt(Math.PI * .5);
        this.uniforms["unity_SpecCube0_HDR"] = { value: new Vector4(hdr, hdr, hdr, hdr) };
        // this.needsUpdate = true;
        // this.uniformsNeedUpdate = true;
        if (debug) console.log("Set environment lighting", this.uniforms);
    }
    */
    r(this, "_sphericalHarmonicsName", "unity_SpecCube0");
    r(this, "_objToWorldName", "hlslcc_mtx4x4unity_ObjectToWorld");
    r(this, "_worldToObjectName", "hlslcc_mtx4x4unity_WorldToObject");
    r(this, "_viewProjectionName", "hlslcc_mtx4x4unity_MatrixVP");
    r(this, "_viewMatrixName", "hlslcc_mtx4x4unity_MatrixV");
    r(this, "_rendererData", new lk());
    this.identifier = e, An && console.log(this), this.type = "NEEDLE_CUSTOM_SHADER", this.uniforms[this._objToWorldName] || (this.uniforms[this._objToWorldName] = { value: [] }), this.uniforms[this._worldToObjectName] || (this.uniforms[this._worldToObjectName] = { value: [] }), this.uniforms[this._viewProjectionName] || (this.uniforms[this._viewProjectionName] = { value: [] }), this.uniforms[this._sphericalHarmonicsName], (this.depthTextureUniform || this.opaqueTextureUniform) && ee.Current.pre_render_callbacks.push(this.onBeforeRenderSceneCallback);
  }
  clone() {
    const e = super.clone();
    return ew(e), e;
  }
  dispose() {
    super.dispose();
    const e = ee.Current.pre_render_callbacks.indexOf(this.onBeforeRenderSceneCallback);
    e >= 0 && ee.Current.pre_render_callbacks.splice(e, 1);
  }
  get depthTextureUniform() {
    if (this.uniforms)
      return this.uniforms._CameraDepthTexture;
  }
  get opaqueTextureUniform() {
    if (this.uniforms)
      return this.uniforms._CameraOpaqueTexture;
  }
  onBeforeRenderScene() {
    this.opaqueTextureUniform && ee.Current.setRequireColor(!0), this.depthTextureUniform && ee.Current.setRequireDepth(!0);
  }
  onBeforeRender(e, i, n, o, a, l) {
    o.attributes.tangent || o.computeTangents(), this.onUpdateUniforms(n, a);
  }
  onUpdateUniforms(e, i) {
    const n = ee.Current;
    if (e && (Be.viewProjection && this.uniforms[this._viewProjectionName] && (Be.viewProjection.copy(e.projectionMatrix).multiply(e.matrixWorldInverse), Gd(Be.viewProjection, Be._viewProjectionValues)), Be.viewMatrix && this.uniforms[this._viewMatrixName] && (Be.viewMatrix.copy(e.matrixWorldInverse), Gd(Be.viewMatrix, Be._viewMatrixValues)), this.uniforms[Be._worldSpaceCameraPosName] && Be._worldSpaceCameraPos.setFromMatrixPosition(e.matrixWorld)), this.uniforms._TimeParameters && (this.uniforms._TimeParameters.value = n.sceneLighting.timeVec4), this.uniforms._Time) {
      const c = this.uniforms._Time.value;
      c.x = n.sceneLighting.timeVec4.x / 20, c.y = n.sceneLighting.timeVec4.x, c.z = n.sceneLighting.timeVec4.x * 2, c.w = n.sceneLighting.timeVec4.x * 3;
    }
    if (this.uniforms._SinTime) {
      const c = this.uniforms._SinTime.value;
      c.x = Math.sin(n.sceneLighting.timeVec4.x / 8), c.y = Math.sin(n.sceneLighting.timeVec4.x / 4), c.z = Math.sin(n.sceneLighting.timeVec4.x / 2), c.w = Math.sin(n.sceneLighting.timeVec4.x);
    }
    if (this.uniforms._CosTime) {
      const c = this.uniforms._CosTime.value;
      c.x = Math.cos(n.sceneLighting.timeVec4.x / 8), c.y = Math.cos(n.sceneLighting.timeVec4.x / 4), c.z = Math.cos(n.sceneLighting.timeVec4.x / 2), c.w = Math.cos(n.sceneLighting.timeVec4.x);
    }
    if (this.uniforms.unity_DeltaTime) {
      const c = this.uniforms.unity_DeltaTime.value;
      c.x = n.time.deltaTime, c.y = 1 / n.time.deltaTime, c.z = n.time.smoothedDeltaTime, c.w = 1 / n.time.smoothedDeltaTime;
    }
    const o = n.mainLight;
    if (o) {
      const c = ie(o.gameObject, Be._mainLightPosition);
      this.uniforms._MainLightPosition = { value: c.normalize() }, Be._mainLightColor.set(o.color.r, o.color.g, o.color.b, 0), this.uniforms._MainLightColor = { value: Be._mainLightColor };
      const h = o.intensity;
      Be._lightData.z = h, this.uniforms.unity_LightData = { value: Be._lightData };
    }
    if (e && (Be.viewProjection && this.uniforms[this._viewProjectionName] && (this.uniforms[this._viewProjectionName].value = Be._viewProjectionValues), Be.viewMatrix && this.uniforms[this._viewMatrixName] && (this.uniforms[this._viewMatrixName].value = Be._viewMatrixValues), this.uniforms[Be._worldSpaceCameraPosName] && (this.uniforms[Be._worldSpaceCameraPosName] = { value: Be._worldSpaceCameraPos }), n.mainCameraComponent)) {
      if (this.uniforms._ProjectionParams) {
        const c = this.uniforms._ProjectionParams.value;
        c.x = 1, c.y = n.mainCameraComponent.nearClipPlane, c.z = n.mainCameraComponent.farClipPlane, c.w = 1 / c.z, this.uniforms._ProjectionParams.value = c;
      }
      if (this.uniforms._ZBufferParams) {
        const c = this.uniforms._ZBufferParams.value, h = n.mainCameraComponent;
        c.x = 1 - h.farClipPlane / h.nearClipPlane, c.y = h.farClipPlane / h.nearClipPlane, c.z = c.x / h.farClipPlane, c.w = c.y / h.farClipPlane, this.uniforms._ZBufferParams.value = c;
      }
      if (this.uniforms._ScreenParams) {
        const c = this.uniforms._ScreenParams.value;
        c.x = n.domWidth, c.y = n.domHeight, c.z = 1 + 1 / c.x, c.w = 1 + 1 / c.y, this.uniforms._ScreenParams.value = c;
      }
      if (this.uniforms._ScaledScreenParams) {
        const c = this.uniforms._ScaledScreenParams.value;
        c.x = n.domWidth, c.y = n.domHeight, c.z = 1 + 1 / c.x, c.w = 1 + 1 / c.y, this.uniforms._ScaledScreenParams.value = c;
      }
    }
    const a = this.depthTextureUniform;
    a && (a.value = n.depthTexture);
    const l = this.opaqueTextureUniform;
    if (l && (l.value = n.opaqueColorTexture), i) {
      const c = this._rendererData;
      c.updateFrom(i), this.uniforms[this._worldToObjectName].value = c.worldToObject, this.uniforms[this._objToWorldName].value = c.objectToWorld;
    }
    this.uniformsNeedUpdate = !0;
  }
};
let Wi = Be;
r(Wi, "viewProjection", new se()), r(Wi, "_viewProjectionValues", []), r(Wi, "viewMatrix", new se()), r(Wi, "_viewMatrixValues", []), r(Wi, "_worldSpaceCameraPosName", "_WorldSpaceCameraPos"), r(Wi, "_worldSpaceCameraPos", new v()), r(Wi, "_mainLightColor", new me()), r(Wi, "_mainLightPosition", new v()), r(Wi, "_lightData", new me());
class ck {
  constructor(t, e) {
    r(this, "parser");
    r(this, "identifier");
    this.parser = t, this.identifier = e;
  }
  get name() {
    return qr;
  }
  loadMaterial(t) {
    const e = this.parser.json.materials[t];
    if (!e)
      return An && console.log(t, this.parser.json.materials), null;
    if (!e.extensions || !e.extensions[qr])
      return An && console.log(`Material ${t} does not use NEEDLE_techniques_webgl`), null;
    An && console.log(`Material ${t} uses NEEDLE_techniques_webgl`, e);
    const i = e.extensions[qr].technique;
    if (i < 0)
      return console.debug(`Material ${t} does not have a valid technique index`), null;
    const n = this.parser.json.extensions[qr];
    if (!n)
      return An ? console.error("Missing shader data", this.parser.json.extensions) : console.debug("Missing custom shader data in parser.json.extensions"), null;
    An && console.log(n);
    const o = n.techniques[i];
    return o ? new Promise(async (a, l) => {
      var b, w, P;
      const c = await DO(n, o.program), h = c == null ? void 0 : c.fragmentShader, d = c == null ? void 0 : c.vertexShader;
      if (!h || !d)
        return l();
      An && console.log("loadMaterial", e, c);
      const u = {}, p = o.uniforms;
      (d.includes("_Time") || h.includes("_Time")) && (u._Time = { value: new me(0, 0, 0, 0) }), (d.includes("_SinTime") || h.includes("_SinTime")) && (u._SinTime = { value: new me(0, 0, 0, 0) }), (d.includes("_CosTime") || h.includes("_CosTime")) && (u._CosTime = { value: new me(0, 0, 0, 0) }), (d.includes("unity_DeltaTime") || h.includes("unity_DeltaTime")) && (u.unity_DeltaTime = { value: new me(0, 0, 0, 0) });
      for (const k in p) {
        const O = k;
        switch (O) {
          case "_TimeParameters":
            const M = new me();
            u[O] = { value: M };
            break;
          case "hlslcc_mtx4x4unity_MatrixV":
          case "hlslcc_mtx4x4unity_MatrixVP":
            u[O] = { value: [] };
            break;
          case "_MainLightPosition":
          case "_MainLightColor":
          case "_WorldSpaceCameraPos":
            u[O] = { value: [0, 0, 0, 1] };
            break;
          case "unity_OrthoParams":
            break;
          case "unity_SpecCube0":
            u[O] = { value: null };
            break;
          default:
          case "_ScreenParams":
          case "_ZBufferParams":
          case "_ProjectionParams":
            u[O] = { value: [0, 0, 0, 0] };
            break;
          case "_CameraOpaqueTexture":
          case "_CameraDepthTexture":
            u[O] = { value: null };
            break;
        }
      }
      let m = !1;
      if (e.extensions && e.extensions[qr]) {
        const k = e.extensions[qr];
        if (k.technique === i) {
          An && console.log(e.name, "Material Properties", k);
          for (const O in k.values) {
            const M = k.values[O];
            if (typeof M == "string") {
              if (M.startsWith("/textures/")) {
                const E = M.substring(10), B = Number.parseInt(E);
                if (B >= 0) {
                  const A = await this.parser.getDependency("texture", B);
                  A instanceof Fe && (A.colorSpace = wr, A.needsUpdate = !0), u[O] = { value: A };
                  continue;
                }
              }
              switch (O) {
                case "alphaMode":
                  M === "BLEND" && (m = !0);
                  continue;
              }
            }
            if (Array.isArray(M) && M.length === 4) {
              u[O] = { value: new me(M[0], M[1], M[2], M[3]) };
              continue;
            }
            u[O] = { value: M };
          }
        }
      }
      const g = new Wi(
        this.identifier,
        {
          name: e.name ?? "",
          uniforms: u,
          vertexShader: d,
          fragmentShader: h,
          lights: !1
          // defines: {
          //     "USE_SHADOWMAP" : true
          // },
        }
      );
      switch (g.glslVersion = g1, g.vertexShader = g.vertexShader.replace("#version 300 es", ""), g.fragmentShader = g.fragmentShader.replace("#version 300 es", ""), (b = u._Cull) == null ? void 0 : b.value) {
        case 0:
          g.side = Ri;
          break;
        case 1:
          g.side = Cu;
          break;
        case 2:
          g.side = xo;
          break;
        default:
          g.side = xo;
          break;
      }
      switch ((w = u._ZTest) == null ? void 0 : w.value) {
        case 3:
          g.depthTest = !0, g.depthFunc = S1;
          break;
        case 6:
          g.depthTest = !0, g.depthFunc = x1;
          break;
        case 2:
          g.depthTest = !0, g.depthFunc = w1;
          break;
        case 4:
          g.depthTest = !0, g.depthFunc = v1;
          break;
        case 5:
          g.depthTest = !0, g.depthFunc = b1;
          break;
        case 7:
          g.depthTest = !0, g.depthFunc = y1;
          break;
        case 8:
          g.depthTest = !1, g.depthFunc = _1;
          break;
      }
      g.transparent = m, m && (g.depthWrite = !1), EO(u), g.onUpdateUniforms();
      for (const k in p) {
        const O = k, M = p[k].type;
        if (((P = u[O]) == null ? void 0 : P.value) === void 0)
          switch (M) {
            case Jv.SAMPLER_2D:
              u[O] = { value: TO }, console.warn("Missing/unassigned texture, fallback to white: " + O);
              break;
            default:
              O === "unity_OrthoParams" || console.warn("TODO: EXPECTED UNIFORM / fallback NOT SET: " + O, p[k]);
              break;
          }
      }
      An && console.log(g.uuid, u), ew(g), a(g);
    }) : null;
  }
}
function ew(s) {
  if (s.uniforms) {
    An && console.log("Uniforms:", s.uniforms);
    for (const e in s.uniforms)
      switch (t(e, e), e) {
        case "_Color":
          t("color", e);
          break;
      }
  }
  function t(e, i) {
    Object.getOwnPropertyDescriptor(s, e) || Object.defineProperty(s, e, {
      get: () => s.uniforms[i].value,
      set: (n) => {
        s.uniforms[i].value = n, s.needsUpdate = !0;
      }
    });
  }
}
const hk = x("debugextensions");
let tu;
const dk = import("./three-examples.js").then((s) => s.GLTFLoaderAnimationPointer).then(async (s) => (tu = s.GLTFAnimationPointerExtension, tu)).catch((s) => {
  console.warn("Failed to import GLTFLoaderAnimationPointer. Please use @needle-tools/three for full KHR_animation support", s);
}), Sr = new Array();
function KD(s) {
  Sr.includes(s) || Sr.push(s);
}
function ZD(s) {
  const t = Sr.indexOf(s);
  t >= 0 && Sr.splice(t, 1);
}
function qg(s) {
  const t = new Zv();
  return s.register((e) => (t.parser = e, t)), t;
}
class uk {
  resolvePath(t) {
    return t.includes("/extensions/builtin_components/") ? t.replace("/extensions/builtin_components/", "/userData/components/") : t.includes("extensions/builtin_components/") ? t.replace("extensions/builtin_components/", "/userData/components/") : t;
  }
}
async function Im(s, t, e) {
  const i = e.indexOf("?");
  i >= 0 && (e = e.substring(0, i)), s.register((n) => new ik(n)), s.register((n) => new qP(n)), s.register((n) => new CO(n, t.lightmaps, e)), s.register((n) => new nk(n, e, t)), s.register((n) => new ck(n, e)), s.register((n) => new _c(n, e)), s.register((n) => new Ze(n, e)), s.register((n) => new ZR(n)), wP() && s.register((n) => new hc(n)), await dk.catch((n) => {
  }), s.register((n) => {
    if (tu) {
      const o = new tu(n);
      return o.setAnimationPointerResolver.bind(o)(new uk()), o;
    } else
      return (hk || z()) && console.error("Missing KHR_animation_pointer extension..."), {
        name: "KHR_animation_pointer_NOT_AVAILABLE"
      };
  });
  for (const n of Sr)
    n.onImport && n.onImport(s, e, t);
}
function tw(s, t) {
  for (const e of Sr)
    e.onExport && e.onExport(s, t);
}
function iw(s, t, e) {
  for (const i of Sr)
    i.onLoaded && i.onLoaded(s, t, e);
}
class nw {
  constructor(t) {
    this.writer = t, this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(t, e) {
    if (t.constructor.name !== "InstancedMesh")
      return;
    const i = this.writer, n = i.extensionsUsed, o = {};
    e.extensions = e.extensions || {}, e.extensions[this.name] = o;
    let a = new se();
    const l = new Array(), c = new Array(), h = new Array();
    for (let m = 0; m < t.count; m++) {
      t.getMatrixAt(m, a);
      let g = new v(), _ = new W(), y = new v();
      a.decompose(g, _, y), l.push(g.x, g.y, g.z), c.push(_.x, _.y, _.z, _.w), h.push(y.x, y.y, y.z);
    }
    const d = new Float32Array(l), u = new Float32Array(c), p = new Float32Array(h);
    o.attributes = {
      TRANSLATION: i.processAccessor(new mt(d, 3)),
      ROTATION: i.processAccessor(new mt(u, 4)),
      SCALE: i.processAccessor(new mt(p, 3))
    }, n[this.name] = !0;
  }
}
var fk = Object.defineProperty, pk = Object.getOwnPropertyDescriptor, sw = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? pk(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && fk(t, e, n), n;
};
const Vh = x("debugreflectionprobe"), hb = x("noreflectionprobe"), mk = Symbol("reflectionProbeKey"), gk = Symbol("original material");
var rd;
const hs = (rd = class extends I {
  constructor() {
    var t;
    super();
    r(this, "_texture");
    r(this, "center");
    r(this, "size");
    r(this, "_boxHelper");
    hs._probes.has(this.context) || hs._probes.set(this.context, []), (t = hs._probes.get(this.context)) == null || t.push(this);
  }
  static get(t, e, i, n) {
    if (!t || t.isObject3D !== !0 || hb)
      return null;
    const o = hs._probes.get(e);
    if (o) {
      for (const a of o)
        if (a.__didAwake || a.__internalAwake(), a.enabled && n && a.gameObject === n)
          return a;
    }
    return Vh && console.debug("Did not find reflection probe", t.name, i, t), null;
  }
  set texture(t) {
    if (t && !(t instanceof Fe)) {
      console.error("ReflectionProbe.texture must be a Texture", t);
      return;
    }
    this._texture = t, t && (t.mapping = Ms, t.colorSpace = vn, t.needsUpdate = !0);
  }
  get texture() {
    return this._texture;
  }
  isInBox(t) {
    var e;
    return (e = this._boxHelper) == null ? void 0 : e.isInBox(t);
  }
  awake() {
    this._boxHelper = this.gameObject.addComponent(wi), this._boxHelper.updateBox(!0), Vh && this._boxHelper.showHelper(5592320, !0), this.texture && (this.texture.mapping = Ms, this.texture.colorSpace = vn, this.texture.needsUpdate = !0);
  }
  onDestroy() {
    const t = hs._probes.get(this.context);
    if (t) {
      const e = t.indexOf(this);
      e >= 0 && t.splice(e, 1);
    }
  }
  onSet(t) {
    var i;
    if (hb || !this.enabled || ((i = t.sharedMaterials) == null ? void 0 : i.length) <= 0 || !this.texture)
      return;
    let e = hs._rendererMaterialsCache.get(t);
    e || (e = [], hs._rendererMaterialsCache.set(t, e));
    for (let n = 0; n < t.sharedMaterials.length; n++) {
      const o = t.sharedMaterials[n];
      if (!o || o.envMap === void 0 || o instanceof Me)
        continue;
      let a = e[n];
      const l = o === (a == null ? void 0 : a.copy), c = !a || a.material.uuid !== o.uuid || a.copy.version !== o.version;
      if (!l && c) {
        if (Vh) {
          let u = "";
          a ? a.material !== o ? u = "reference changed; cached instance?: " + l : a.copy.version !== o.version && (u = "version changed") : u = "not cached", console.warn("Cloning material", o.name, o.version, "Reason:", u, `
`, o.uuid, `
`, a == null ? void 0 : a.copy.uuid, `
`, t.name);
        }
        const d = o.clone();
        d.version = o.version, a ? (a.copy = d, a.material = o) : (a = {
          material: o,
          copy: d
        }, e.push(a)), d[mk] = this, d[gk] = o, Vh && console.log("Set reflection", t.name, t.guid);
      }
      a && a.copy && (a.copy.onBeforeCompile = o.onBeforeCompile);
      const h = a == null ? void 0 : a.copy;
      h.envMap = this.texture, t.sharedMaterials[n] = h;
    }
  }
  onUnset(t) {
    const e = hs._rendererMaterialsCache.get(t);
    if (e)
      for (let i = 0; i < e.length; i++) {
        const n = e[i];
        t.sharedMaterials[i] = n.material;
      }
  }
}, r(rd, "_probes", /* @__PURE__ */ new Map()), // when objects are rendered and they share material
// and some need reflection probe and some don't
// we need to make sure we don't override the material but use a copy
r(rd, "_rendererMaterialsCache", /* @__PURE__ */ new Map()), rd);
let sh = hs;
sw([
  f(v)
], sh.prototype, "center", 2);
sw([
  f(v)
], sh.prototype, "size", 2);
const ci = x("debuginstancing"), fu = class {
  constructor() {
    r(this, "objs", []);
  }
  setup(t, e, i, n, o, a = 0) {
    t.applySettings(e);
    const l = this.tryCreateOrAddInstance(e, i, o);
    if (l) {
      n === null && (n = []), n.push(l), Ze.assignTextureLOD(l.renderer.material, 0);
      for (let c = 0; c < t.sharedMeshes.length; c++) {
        const h = t.sharedMeshes[c], d = h.geometry;
        Ze.assignMeshLOD(h, 0).then((u) => {
          u && t.activeAndEnabled && d != u && l.setGeometry(u);
        });
      }
    } else if (a <= 0 && e.type !== "Mesh") {
      const c = a + 1;
      for (const h of e.children)
        n = this.setup(t, h, i, n, o, c);
    }
    return a === 0 && o.useMatrixWorldAutoUpdate && n && n.length >= 0 && this.autoUpdateInstanceMatrix(e), n;
  }
  tryCreateOrAddInstance(t, e, i) {
    if (t.type === "Mesh") {
      const n = i.foundMeshes;
      if (i.foundMeshes += 1, !i.rend.enableInstancing)
        return null;
      if (i.rend.enableInstancing !== !0) {
        if (n >= i.rend.enableInstancing.length)
          return ci && console.error("Something is wrong with instance setup", t, i.rend.enableInstancing, n), null;
        if (!i.rend.enableInstancing[n])
          return null;
      }
      const o = t, a = o.material;
      for (const u of this.objs) {
        if (!u.canAdd(o.geometry, a))
          continue;
        return u.addInstance(o);
      }
      let l = fu.getStartInstanceCount(t);
      (!l || l < 0) && (l = 4);
      let c = t.name;
      c != null && c.length || (c = ES());
      const h = new ow(c, o.geometry, a, l, e);
      return this.objs.push(h), h.addInstance(o);
    }
    return null;
  }
  autoUpdateInstanceMatrix(t) {
    const e = t.matrixWorld.multiplyMatrices.bind(t.matrixWorld), i = t.matrixWorld.clone(), n = (o, a) => {
      const l = e(o, a);
      return (t[Fc] || i.equals(l) === !1) && (i.copy(l), t[Fc] = !0), l;
    };
    t.matrixWorld.multiplyMatrices = n;
  }
};
let ir = fu;
r(ir, "instance", new fu()), /** This is the initial instance count when creating a new instancing structure.    
 * Override this and the number of max instances that you expect for a given object.
 * The larger the value the more objects can be added without having to resize but it will also consume more memory.    
 * (The instancing mesh renderer will grow x2 if the max instance count is reached)
 * @default 4
 * @returns The initial instance count
 * */
r(ir, "getStartInstanceCount", (t) => 4);
const Rc = class {
  constructor(t, e) {
    /** The object that is being instanced */
    r(this, "object");
    /** The instancer/BatchedMesh that is rendering this object*/
    r(this, "renderer");
    /** @internal */
    r(this, "__instanceIndex", -1);
    /** @internal */
    r(this, "__reservedVertexRange", 0);
    /** @internal */
    r(this, "__reservedIndexRange", 0);
    r(this, "__geometryIndex", -1);
    /** The mesh information of the object - this tries to also calculate the LOD info */
    r(this, "meshInformation");
    this.__instanceIndex = -1, this.object = t, this.renderer = e, t[nv] = e, this.meshInformation = Zo(t.geometry), Rc.all.push(this);
  }
  /** The name of the object */
  get name() {
    return this.object.name;
  }
  get isActive() {
    return this.__instanceIndex >= 0;
  }
  get vertexCount() {
    return this.object.geometry.attributes.position.count;
  }
  get maxVertexCount() {
    return Math.max(this.meshInformation.vertexCount, this.vertexCount);
  }
  get reservedVertexCount() {
    return this.__reservedVertexRange;
  }
  get indexCount() {
    return this.object.geometry.index ? this.object.geometry.index.count : 0;
  }
  get maxIndexCount() {
    return Math.max(this.meshInformation.indexCount, this.indexCount);
  }
  get reservedIndexCount() {
    return this.__reservedIndexRange;
  }
  /** Calculates the mesh information again
   * @returns true if the vertex count or index count has changed
   */
  updateMeshInformation() {
    const t = Zo(this.object.geometry), e = this.meshInformation.vertexCount, i = this.meshInformation.indexCount;
    return Object.assign(this.meshInformation, t), e !== this.meshInformation.vertexCount || i !== this.meshInformation.indexCount;
  }
  /** Updates the matrix from the rendered object. Will also call updateWorldMatrix internally */
  updateInstanceMatrix(t = !1, e = !0) {
    this.__instanceIndex < 0 || (e && this.object.updateWorldMatrix(!0, t), this.renderer.updateInstance(this.object.matrixWorld, this.__instanceIndex));
  }
  /** Updates the matrix of the instance */
  setMatrix(t) {
    this.__instanceIndex < 0 || this.renderer.updateInstance(t, this.__instanceIndex);
  }
  /** Can be used to change the geometry of this instance */
  setGeometry(t) {
    if (this.__geometryIndex < 0)
      return !1;
    const e = this;
    if (this.vertexCount > this.__reservedVertexRange)
      return i(`Instancing: Can not update geometry (${this.name}), reserved vertex range is too small: ${this.__reservedVertexRange.toLocaleString()} < ${this.vertexCount.toLocaleString()} vertices for ${this.name}`);
    if (this.indexCount > this.__reservedIndexRange)
      return i(`Instancing: Can not update geometry (${this.name}), reserved index range is too small: ${this.__reservedIndexRange.toLocaleString()} < ${this.indexCount.toLocaleString()} indices for ${this.name}`);
    return this.renderer.updateGeometry(t, this.__geometryIndex);
    function i(n) {
      return e.updateMeshInformation() && (e.renderer.remove(e, !0), e.renderer.add(e)) ? !0 : ((z() || ci) && console.error(n), !1);
    }
  }
  /** Adds this object to the instancing renderer (effectively activating instancing) */
  add() {
    this.__instanceIndex >= 0 || (this.renderer.add(this), S.markAsInstancedRendered(this.object, !0));
  }
  /** Removes this object from the instancing renderer 
   * @param delete_ If true, the instance handle will be removed from the global list
  */
  remove(t) {
    if (!(this.__instanceIndex < 0) && (this.renderer.remove(this, t), S.markAsInstancedRendered(this.object, !1), t)) {
      const e = Rc.all.indexOf(this);
      e >= 0 && Rc.all.splice(e, 1);
    }
  }
};
let yc = Rc;
r(yc, "all", []);
class ow {
  constructor(t, e, i, n, o) {
    /** If true, the instancer is allowed to grow when the max instance count is reached */
    r(this, "allowResize", !0);
    /** The name of the instancer */
    r(this, "name", "");
    /** The added geometry */
    r(this, "geometry");
    /** The material used for the instanced mesh */
    r(this, "material");
    r(this, "_context");
    r(this, "_batchedMesh");
    r(this, "_handles", []);
    r(this, "_geometryIds", /* @__PURE__ */ new Map());
    r(this, "_maxInstanceCount");
    r(this, "_currentInstanceCount", 0);
    r(this, "_currentVertexCount", 0);
    r(this, "_currentIndexCount", 0);
    r(this, "_maxVertexCount");
    r(this, "_maxIndexCount");
    r(this, "_needUpdateBounds", !1);
    r(this, "_debugMaterial", null);
    r(this, "onBeforeRender", () => {
      this._batchedMesh.layers.enableAll(), this._needUpdateBounds && this._batchedMesh[ql] === !0 && (ci === "verbose" && console.log("Update instancing bounds", this.name, this._batchedMesh.matrixWorldNeedsUpdate), this.updateBounds());
    });
    r(this, "onAfterRender", () => {
      this._batchedMesh.layers.disableAll();
    });
    this.name = t, this.geometry = e, this.material = i, this._context = o, this._maxInstanceCount = Math.max(2, n), ci && (this._debugMaterial = db());
    const a = this.tryEstimateVertexCountSize(this._maxInstanceCount, [e], n);
    this._maxVertexCount = a.vertexCount, this._maxIndexCount = a.indexCount, this._batchedMesh = new L_(this._maxInstanceCount, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material), this._batchedMesh[ql] = !0, this._batchedMesh.visible = !0, this._context.scene.add(this._batchedMesh), i instanceof s0 && (i.defines.USE_INSTANCING = !0, i.needsUpdate = !0), o.pre_render_callbacks.push(this.onBeforeRender), o.post_render_callbacks.push(this.onAfterRender), ci && console.log(`Instanced renderer created with ${this._maxInstanceCount} instances, ${this._maxVertexCount} max vertices and ${this._maxIndexCount} max indices for "${t}"`);
  }
  /** The three instanced mesh
   * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
   */
  get batchedMesh() {
    return this._batchedMesh;
  }
  get visible() {
    return this._batchedMesh.visible;
  }
  set visible(t) {
    this._batchedMesh.visible = t;
  }
  get castShadow() {
    return this._batchedMesh.castShadow;
  }
  set castShadow(t) {
    this._batchedMesh.castShadow = t;
  }
  set receiveShadow(t) {
    this._batchedMesh.receiveShadow = t;
  }
  /** The current number of instances */
  get count() {
    return this._currentInstanceCount;
  }
  /** Update the bounding box and sphere of the instanced mesh 
   * @param box If true, update the bounding box
   * @param sphere If true, update the bounding sphere
  */
  updateBounds(t = !0, e = !0) {
    if (this._needUpdateBounds = !1, t && this._batchedMesh.computeBoundingBox(), e && this._batchedMesh.computeBoundingSphere(), ci && this._batchedMesh.boundingSphere) {
      const i = this._batchedMesh.boundingSphere;
      V.DrawWireSphere(i.center, i.radius, 65280);
    }
  }
  /** Check if the geometry can be added to this instancer
   * @param geometry The geometry to check
   * @param material The material of the geometry
   * @returns true if the geometry can be added
   */
  canAdd(t, e) {
    return this._maxVertexCount > 1e7 || e !== this.material || !this.validateGeometry(t) ? !1 : !!(!this.mustGrow(t) || this.allowResize);
  }
  dispose() {
    ci && console.warn("Dispose instanced renderer", this.name), this._context.scene.remove(this._batchedMesh), this._batchedMesh.dispose(), this._batchedMesh = null, this._handles = [];
  }
  addInstance(t) {
    const e = new yc(t, this);
    t.castShadow === !0 && this._batchedMesh.castShadow === !1 && (this._batchedMesh.castShadow = !0), t.receiveShadow === !0 && this._batchedMesh.receiveShadow === !1 && (this._batchedMesh.receiveShadow = !0);
    try {
      this.add(e);
    } catch (i) {
      if (console.error(`Failed adding mesh to instancing (object name: "${t.name}", instances: ${this._currentInstanceCount.toLocaleString()}/${this._maxInstanceCount.toLocaleString()}, vertices: ${this._currentVertexCount.toLocaleString()}/${this._maxVertexCount.toLocaleString()}, indices: ${this._currentIndexCount.toLocaleString()}/${this._maxIndexCount.toLocaleString()})
`, i), z()) {
        Iu("Failed instancing mesh. See the browser console for details.");
        debugger;
      }
      return null;
    }
    return e;
  }
  add(t) {
    const e = t.object.geometry;
    if (!e || !e.attributes)
      return console.error("Cannot add object to instancing without geometry", t.name), !1;
    if (this.mustGrow(e))
      if (this.allowResize)
        this.grow(e);
      else
        return console.error("Cannot add instance, max count reached", this.name, this.count, this._maxInstanceCount), !1;
    return t.object.updateWorldMatrix(!0, !0), this.addGeometry(t), this._handles[t.__instanceIndex] = t, this._currentInstanceCount += 1, this.markNeedsUpdate(), this._currentInstanceCount > 0 && (this._batchedMesh.visible = !0), !0;
  }
  remove(t, e) {
    t && (t.__instanceIndex < 0 || this._handles[t.__instanceIndex] != t || this._currentInstanceCount <= 0 || (this.removeGeometry(t, e), this._handles[t.__instanceIndex] = null, t.__instanceIndex = -1, this._currentInstanceCount > 0 && (this._currentInstanceCount -= 1), this._currentInstanceCount <= 0 && (this._batchedMesh.visible = !1), this.markNeedsUpdate()));
  }
  updateInstance(t, e) {
    this._batchedMesh.setMatrixAt(e, t), this.markNeedsUpdate();
  }
  updateGeometry(t, e) {
    return this.validateGeometry(t) ? (this.mustGrow() && this.grow(t), ci && console.debug("[Instancing] UPDATE GEOMETRY at " + e, this._batchedMesh._geometryCount, t.name, Zo(t), t.attributes.position.count, t.index ? t.index.count : 0), this._batchedMesh.setGeometryAt(e, t), this._geometryIds.set(t, e), this.markNeedsUpdate(), !0) : !1;
  }
  validateGeometry(t) {
    const e = this.geometry;
    for (const i in e.attributes)
      if (i !== "batchId" && !t.hasAttribute(i))
        return z() && console.warn(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`), !1;
    return !0;
  }
  markNeedsUpdate() {
    ci === "verbose" && console.warn("Marking instanced mesh dirty", this.name), this._needUpdateBounds = !0;
  }
  /**
   * @param geo The geometry to add (if none is provided it means the geometry is already added and just updated)
   */
  mustGrow(t) {
    if (this.count >= this._maxInstanceCount)
      return !0;
    if (!t || !t.attributes)
      return !1;
    const e = Zo(t), i = e.vertexCount, n = e.indexCount;
    return this._currentVertexCount + i > this._maxVertexCount || this._currentIndexCount + n > this._maxIndexCount;
  }
  grow(t) {
    var h, d;
    const i = Math.ceil(this._maxInstanceCount * 2), n = this.tryEstimateVertexCountSize(i, [t]), o = Math.max(this._maxVertexCount, n.vertexCount), a = Math.max(this._maxIndexCount, n.indexCount, Math.ceil(this._maxVertexCount * 2));
    if (ci) {
      const u = Zo(t);
      console.warn(`[Instancing] Growing Buffer
Mesh: "${this.name}${(h = t.name) != null && h.length ? "/" + t.name : ""}"
${u.vertexCount} vertices, ${u.indexCount} indices
Max count ${this._maxInstanceCount} → ${i}
Max vertex count ${this._maxVertexCount} -> ${o}
Max index count ${this._maxIndexCount} -> ${a}`), this._debugMaterial = db();
    } else
      z() && console.debug(`[Instancing] Growing Buffer
Mesh: "${this.name}${(d = t.name) != null && d.length ? "/" + t.name : ""}"
Max count ${this._maxInstanceCount} → ${i}
Max vertex count ${this._maxVertexCount} -> ${o}
Max index count ${this._maxIndexCount} -> ${a}`);
    this._maxVertexCount = o, this._maxIndexCount = a;
    const l = new L_(i, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material);
    l.layers = this._batchedMesh.layers, l.castShadow = this._batchedMesh.castShadow, l.receiveShadow = this._batchedMesh.receiveShadow, l.visible = this._batchedMesh.visible, l[ql] = this._batchedMesh[ql], l.matrixAutoUpdate = this._batchedMesh.matrixAutoUpdate, l.matrixWorldNeedsUpdate = this._batchedMesh.matrixWorldNeedsUpdate, l.matrixAutoUpdate = this._batchedMesh.matrixAutoUpdate, l.matrixWorld.copy(this._batchedMesh.matrixWorld), l.matrix.copy(this._batchedMesh.matrix), this._batchedMesh.dispose(), this._batchedMesh.removeFromParent(), this._geometryIds.clear(), this._batchedMesh = l, this._maxInstanceCount = i;
    const c = [...this._handles];
    this._handles = [];
    for (const u of c)
      u && u.__instanceIndex >= 0 && (this.addGeometry(u), this._handles[u.__instanceIndex] = u);
    this._context.scene.add(l);
  }
  tryEstimateVertexCountSize(t, e, i = 1) {
    const n = /* @__PURE__ */ new Map();
    for (const u of this._handles)
      if (u && u.__instanceIndex >= 0 && u.object.geometry)
        if (n.has(u.object.geometry)) {
          const p = n.get(u.object.geometry);
          p.count += 1;
        } else {
          const m = { count: 1, ...Zo(u.object.geometry) };
          n.set(u.object.geometry, m);
        }
    let o = 0, a = 0;
    for (const [u, p] of n)
      o += p.vertexCount * p.count, a += p.indexCount * p.count;
    let c = Math.ceil(o / Math.max(1, this._currentInstanceCount)) * t, d = Math.ceil(a / Math.max(1, this._currentInstanceCount)) * t * 2;
    if (e)
      for (const u of e) {
        const p = Zo(u);
        p != null && (c += p.vertexCount * i, d += p.indexCount * i);
      }
    return { vertexCount: c, indexCount: d };
  }
  addGeometry(t) {
    const i = t.object.geometry;
    if (!i)
      return;
    let n = this._geometryIds.get(i);
    n == null ? (ci && console.debug(`[Instancing] > ADD NEW GEOMETRY "${t.name} (${i.name}; ${i.uuid})"
${this._currentInstanceCount} instances, ${t.maxVertexCount} max vertices, ${t.maxIndexCount} max indices`), n = this._batchedMesh.addGeometry(i, t.maxVertexCount, t.maxIndexCount), this._geometryIds.set(i, n)) : ci === "verbose" && console.log(`[Instancing] > ADD INSTANCE "${t.name}"
GEOMETRY_ID=${n}
${this._currentInstanceCount} instances`), this._currentVertexCount += t.maxVertexCount, this._currentIndexCount += t.maxIndexCount;
    const o = this._batchedMesh.addInstance(n);
    t.__geometryIndex = n, t.__instanceIndex = o, t.__reservedVertexRange = t.maxVertexCount, t.__reservedIndexRange = t.maxIndexCount, this._batchedMesh.setMatrixAt(o, t.object.matrixWorld), ci && console.debug(`[Instancing] > ADDED INSTANCE "${t.name}"
GEOMETRY_ID=${n}
${this._currentInstanceCount} instances
Index: ${t.__instanceIndex}`);
  }
  removeGeometry(t, e) {
    if (t.__instanceIndex < 0) {
      console.warn("Cannot remove geometry, instance index is invalid", t.name);
      return;
    }
    ci && console.debug(`[Instancing] < REMOVE INSTANCE "${t.name}" at [${t.__instanceIndex}]
GEOMETRY_ID=${t.__geometryIndex}
${this._currentInstanceCount} instances
Index: ${t.__instanceIndex}`), this._batchedMesh.deleteInstance(t.__instanceIndex);
  }
}
r(ow, "nullMatrix", new se());
function Zo(s) {
  var n, o;
  if (!s)
    return z() && console.error("Cannot get mesh information from null geometry"), { vertexCount: 0, indexCount: 0 };
  let t = ((o = (n = s.attributes) == null ? void 0 : n.position) == null ? void 0 : o.count) || 0, e = s.index ? s.index.count : 0;
  const i = Ze.getMeshLODInformation(s);
  if (i) {
    const a = i.lods[0];
    let l = a.vertexCount, c = a.indexCount;
    const h = Math.min(200, Math.ceil(l * 0.05));
    l += h, c += 20, t = Math.max(t, l), e = Math.max(e, c);
  }
  return t = Math.ceil(t), e = Math.ceil(e), { vertexCount: t, indexCount: e };
}
function db() {
  const s = new It({ color: new ae(Math.random(), Math.random(), Math.random()) });
  return s.emissive = s.color, s.emissiveIntensity = 0.3, x("wireframe") && (s.wireframe = !0), s;
}
const Xr = x("debuglightmaps");
class Dm {
  constructor(t, e) {
    r(this, "lightmapIndex", -1);
    r(this, "lightmapScaleOffset", new me(1, 1, 0, 0));
    r(this, "context");
    r(this, "gameObject");
    r(this, "lightmapTexture", null);
    r(this, "lightmapScaleOffsetUniform", { value: new me(1, 1, 0, 0) });
    r(this, "lightmapUniform", { value: null });
    r(this, "onBeforeCompile", (t, e) => {
      Xr && console.log(`Lightmaps, before compile
`, t), this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset, this.lightmapUniform.value = this.lightmapTexture, t.uniforms.lightmapScaleOffset = this.lightmapScaleOffsetUniform;
    });
    this.gameObject = t, this.context = e;
  }
  get lightmap() {
    return this.lightmapTexture;
  }
  set lightmap(t) {
    t !== this.lightmapTexture && (this.lightmapTexture = t, this.applyLightmap(), this.lightmapTexture && Ze.assignTextureLOD(this.lightmapTexture, 0).then((e) => {
      e != null && e.isTexture && (this.lightmapTexture = e);
    }));
  }
  init(t, e, i) {
    console.assert(this.gameObject !== void 0 && this.gameObject !== null, "Missing gameobject", this), this.lightmapIndex = t, !(this.lightmapIndex < 0) && (this.lightmapScaleOffset = e, this.lightmapTexture = i, Ze.assignTextureLOD(i, 0).then((n) => {
      n != null && n.isTexture && (this.lightmapTexture = n);
    }), Xr == "show" ? (console.log("Lightmap:", this.gameObject.name, t, `
ScaleOffset:`, e, `
Texture:`, i), this.setLightmapDebugMaterial()) : Xr && console.log("Use debuglightmaps=show to render lightmaps only in the scene."), this.applyLightmap());
  }
  updateLightmapUniforms(t) {
    const e = t.uniforms;
    e && e.lightmap && (this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset, e.lightmapScaleOffset = this.lightmapScaleOffsetUniform);
  }
  /**
   * Apply the lightmap to the object. This will clone the material and set the lightmap texture and scale/offset
   */
  applyLightmap() {
    if (this.gameObject.type === "Object3D") {
      Xr && console.warn("Can not add lightmap. Is this object missing a renderer?", this.gameObject.name);
      return;
    }
    if (this.gameObject.type === "Group") {
      this.gameObject["Needle:Multimaterial-LightmapWarning"] === void 0 && (this.gameObject["Needle:Multimaterial-LightmapWarning"] = !0, console.warn("Lightmap on multimaterial object is not supported yet... please open a feature request on https://github.com/needle-tools/needle-engine-support if your project requires it"));
      return;
    }
    console.assert(this.gameObject.type === "Mesh", "Lightmap only works on meshes", this);
    const t = this.gameObject;
    if (t.geometry.getAttribute("uv1") || t.geometry.setAttribute("uv1", t.geometry.getAttribute("uv")), Array.isArray(this.gameObject.material)) {
      const e = this.gameObject.material;
      for (let i = 0; i < e.length; i++)
        e[i] = this.ensureLightmapMaterial(e[i]);
    } else
      this.gameObject.material = this.ensureLightmapMaterial(this.gameObject.material);
    if (this.lightmapIndex >= 0 && this.lightmapTexture) {
      this.lightmapTexture.channel = 1;
      const e = this.gameObject.material;
      if (Array.isArray(e))
        for (const i of e)
          this.assignLightmapTexture(i);
      else
        e && this.assignLightmapTexture(e);
    }
  }
  ensureLightmapMaterial(t) {
    return t.userData || (t.userData = {}), t["NEEDLE:lightmap-material-version"] != t.version && t["NEEDLE:lightmap-material-version"] == null && (Xr && console.warn("Cloning material for lightmap " + t.name), t = t.clone(), t.onBeforeCompile = this.onBeforeCompile), t;
  }
  assignLightmapTexture(t) {
    !t || t instanceof Jp && t.transmission > 0 || !(t.lightMap !== this.lightmapTexture || t["NEEDLE:lightmap-material-version"] !== t.version) || (Xr && console.log("Assigning lightmap", t.name, t.version), t.lightMap = this.lightmapTexture, t["NEEDLE:lightmap-material-version"] = t.version);
  }
  setLightmapDebugMaterial() {
    this.gameObject.material = new bn({
      vertexShader: `
                varying vec2 vUv1;
                void main()
                {
                    vUv1 = uv1;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
                `,
      fragmentShader: `
                uniform sampler2D lightMap;
                uniform float lightMapIntensity;
                uniform vec4 lightmapScaleOffset;
                varying vec2 vUv1;

                // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
                vec4 conv_sRGBToLinear( in vec4 value ) {
                    return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
                }

                void main() {
                    vec2 lUv = vUv1.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
                    
                    vec4 lightMapTexel = texture2D( lightMap, lUv);
                    gl_FragColor = lightMapTexel;
                    gl_FragColor.a = 1.;
                }
                `,
      defines: { USE_LIGHTMAP: "" }
    });
  }
}
var _k = Object.defineProperty, yk = Object.getOwnPropertyDescriptor, Bs = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? yk(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && _k(t, e, n), n;
};
const Zl = x("debugrenderer"), ub = x("debugskinnedmesh"), fb = x("noinstancing"), bk = x("wireframe");
class vk {
  constructor() {
    r(this, "path", null);
    r(this, "asset", null);
    r(this, "default");
  }
}
class wk {
  constructor(t, e) {
    r(this, "_renderer");
    r(this, "_targets", []);
    r(this, "_indexMapMaxIndex");
    r(this, "_indexMap");
    r(this, "_changed", !1);
    this._renderer = t;
    const i = this.setMaterial.bind(this), n = this.getMaterial.bind(this), o = t.gameObject;
    if (this._targets = [], o)
      switch (o.type) {
        case "Group":
          this._targets = [...o.children];
          break;
        case "SkinnedMesh":
        case "Mesh":
          this._targets.push(o);
          break;
      }
    let a = !1, l, c = 0;
    for (let h = 0; h < this._targets.length; h++) {
      const d = this._targets[h];
      if (!d)
        continue;
      const u = d.material;
      if (u) {
        u.shadowSide = u.side;
        for (let p = 0; p < e.length; p++) {
          const m = e[p];
          if (!m) {
            a = !0;
            continue;
          }
          if (u.name === m.name) {
            l === void 0 && (l = /* @__PURE__ */ new Map()), l.set(p, h), c = Math.max(c, p);
            break;
          }
        }
      }
    }
    if (a) {
      this._indexMapMaxIndex = c, this._indexMap = l;
      const h = `Renderer ${t.name} was initialized with missing materials - this may lead to unexpected behaviour when trying to access sharedMaterials by index.`;
      console.warn(h), ui() && ve("Found renderer with missing materials: please check the console for details.");
    }
    return new Proxy(this, {
      get(h, d) {
        if (typeof d == "string") {
          const u = parseInt(d);
          if (!isNaN(u))
            return n(u);
        }
        return h[d];
      },
      set(h, d, u) {
        return typeof d == "string" && i(u, Number.parseInt(d)), Reflect.set(h, d, u) ? (u instanceof Se && (h.changed = !0), !0) : !1;
      }
    });
  }
  get changed() {
    return this._changed;
  }
  set changed(t) {
    t === !0 && Zl && console.warn("SharedMaterials have changed: " + this._renderer.name, this), this._changed = t;
  }
  is(t) {
    return this._renderer === t;
  }
  get length() {
    return this._indexMapMaxIndex !== void 0 ? this._indexMapMaxIndex + 1 : this._targets.length;
  }
  // iterator to support: for(const mat of sharedMaterials)
  *[Symbol.iterator]() {
    for (let t = 0; t < this.length; t++)
      yield this.getMaterial(t);
  }
  resolveIndex(t) {
    const e = this._indexMap;
    return e && e.has(t) ? e.get(t) : t;
  }
  setMaterial(t, e) {
    if (e = this.resolveIndex(e), e < 0 || e >= this._targets.length)
      return;
    const i = this._targets[e];
    !i || i.material === void 0 || (i.material = t, this.changed = !0);
  }
  getMaterial(t) {
    if (t = this.resolveIndex(t), t < 0)
      return null;
    const e = this._targets;
    if (t >= e.length)
      return null;
    const i = e[t];
    return i ? i.material : null;
  }
}
const Pd = class extends I {
  constructor() {
    super(...arguments);
    r(this, "receiveShadows", !1);
    r(this, "shadowCastingMode", 0);
    r(this, "lightmapIndex", -1);
    r(this, "lightmapScaleOffset", new me(1, 1, 0, 0));
    r(this, "enableInstancing");
    r(this, "renderOrder");
    r(this, "allowOcclusionWhenDynamic", !0);
    r(this, "probeAnchor");
    r(this, "reflectionProbeUsage", 0);
    // custom shader
    // get materialProperties(): Array<MaterialProperties> | undefined {
    //     return this._materialProperties;
    // }
    // set materialProperties(value: Array<MaterialProperties> | undefined) {
    //     this._materialProperties = value;
    // }
    // private customShaderHandler: RendererCustomShader | undefined = undefined;
    // private _materialProperties: Array<MaterialProperties> | undefined = undefined;
    r(this, "_lightmaps");
    r(this, "_sharedMeshes", []);
    r(this, "_sharedMaterials");
    r(this, "_originalMaterials");
    r(this, "_probeAnchorLastFrame");
    r(this, "_lightmapTextureOverride");
    r(this, "allowProgressiveLoading", !0);
    r(this, "_firstFrame", -1);
    r(this, "_isInstancingEnabled", !1);
    r(this, "_handles");
    r(this, "_handlesTempArray", []);
    r(this, "onBeforeRenderThree", (t, e, i, n, o, a) => {
      var l;
      if (o.envMapIntensity !== void 0) {
        const c = this.hasLightmap ? Math.PI : 1, h = ((l = this.context.mainCameraComponent) == null ? void 0 : l.environmentIntensity) ?? 1;
        o.envMapIntensity = Math.max(0, h * this.context.sceneLighting.environmentIntensity / c), o.envMap || (o.envMap = this.context.scene.environment);
      }
      if (this._lightmaps)
        for (const c of this._lightmaps)
          c.updateLightmapUniforms(o), c.applyLightmap();
    });
    r(this, "_reflectionProbe", null);
  }
  /** Enable or disable instancing for an object. This will create a Renderer component if it does not exist yet.
   * @returns the Renderer component that was created or already existed on the object
   */
  static setInstanced(t, e) {
    const i = Bu(t, Pd);
    return i.setInstancingEnabled(e), i;
  }
  /** Check if an object is currently rendered using instancing
   * @returns true if the object is rendered using instancing
   */
  static isInstanced(t) {
    const e = Ya(t, Pd);
    return e ? e.isInstancingActive : _n.isUsingInstancing(t);
  }
  /** Set the rendering state only of an object (makes it visible or invisible) without affecting component state or child hierarchy visibility! You can also just enable/disable the Renderer component on that object for the same effect!
   * 
   * If you want to activate or deactivate a complete object you can use obj.visible as usual (it acts the same as setActive in Unity) */
  static setVisible(t, e) {
    bs(t, e);
  }
  /** Get the mesh Object3D for this renderer  
   * Warn: if this is a multimaterial object it will return the first mesh only 
   * @returns a mesh object3D.
   * */
  get sharedMesh() {
    if (this.gameObject.type === "Mesh")
      return this.gameObject;
    if (this.gameObject.type === "SkinnesMesh")
      return this.gameObject;
    if (this.gameObject.type === "Group")
      return this.gameObject.children[0];
  }
  /** Get all the mesh Object3D for this renderer 
   * @returns an array of mesh object3D.
   */
  get sharedMeshes() {
    if (this.destroyed || !this.gameObject)
      return this._sharedMeshes;
    if (this._sharedMeshes.length = 0, this.gameObject.type === "Group")
      for (const t of this.gameObject.children)
        (t.type === "Mesh" || t.type === "SkinnedMesh") && this._sharedMeshes.push(t);
    else
      (this.gameObject.type === "Mesh" || this.gameObject.type === "SkinnedMesh") && this._sharedMeshes.push(this.gameObject);
    return this._sharedMeshes;
  }
  get sharedMaterial() {
    return this.sharedMaterials[0];
  }
  set sharedMaterial(t) {
    this.sharedMaterials[0] !== t && (this.sharedMaterials[0] = t, this.applyLightmapping());
  }
  /**@deprecated please use sharedMaterial */
  get material() {
    return this.sharedMaterials[0];
  }
  /**@deprecated please use sharedMaterial */
  set material(t) {
    this.sharedMaterial = t;
  }
  // this is just available during deserialization
  set sharedMaterials(t) {
    if (!this._originalMaterials)
      this._originalMaterials = t;
    else if (t) {
      let e = !1;
      for (let i = 0; i < this._sharedMaterials.length; i++) {
        const n = i < t.length ? t[i] : null;
        n && n instanceof Se ? this.sharedMaterials[i] = n : e || (e = !0, console.warn("Can not assign null as material: " + this.name, n));
      }
    }
  }
  //@ts-ignore
  get sharedMaterials() {
    return (!this._sharedMaterials || !this._sharedMaterials.is(this)) && (this._originalMaterials || (this._originalMaterials = []), this._sharedMaterials = new wk(this, this._originalMaterials)), this._sharedMaterials;
  }
  static get shouldSuppressInstancing() {
    return fb;
  }
  get lightmap() {
    var t;
    return (t = this._lightmaps) != null && t.length ? this._lightmaps[0].lightmap : null;
  }
  /** set undefined to return to default lightmap */
  set lightmap(t) {
    var e;
    if (this._lightmapTextureOverride = t, t === void 0 && (t = this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex)), (e = this._lightmaps) != null && e.length)
      for (const i of this._lightmaps)
        i.lightmap = t;
  }
  get hasLightmap() {
    const t = this.lightmap;
    return t != null;
  }
  registering() {
    this.enabled || this.setVisibility(!1);
  }
  awake() {
    if (this._firstFrame = this.context.time.frame, Zl && console.log("Renderer ", this.name, this), this.clearInstancingState(), this.probeAnchor && Zl && this.probeAnchor.add(new Oi(0.2)), this._reflectionProbe = null, this.isMultiMaterialObject(this.gameObject)) {
      for (const t of this.gameObject.children)
        this.context.addBeforeRenderListener(t, this.onBeforeRenderThree), t.layers.mask = this.gameObject.layers.mask;
      if (this.renderOrder !== void 0) {
        let t = 0;
        for (let e = 0; e < this.gameObject.children.length; e++) {
          const i = this.gameObject.children[e];
          if (!(!this.isMeshOrSkinnedMesh(i) || S.getComponent(i, Pd))) {
            if (this.renderOrder.length <= t) {
              console.warn("Incorrect renderOrder element count", this, this.renderOrder.length + " but expected " + this.gameObject.children.length, "Index: " + t, "ChildElement:", i);
              continue;
            }
            i.renderOrder = this.renderOrder[t], t += 1;
          }
        }
      }
    } else
      this.isMeshOrSkinnedMesh(this.gameObject) ? (this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree), this.renderOrder !== void 0 && this.renderOrder.length > 0 && (this.gameObject.renderOrder = this.renderOrder[0])) : this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
    if (this.applyLightmapping(), bk)
      for (let t = 0; t < this.sharedMaterials.length; t++) {
        const e = this.sharedMaterials[t];
        e && (e.wireframe = !0);
      }
  }
  applyLightmapping() {
    var t;
    if (this.lightmapIndex >= 0) {
      const e = this.gameObject.type, i = this._lightmapTextureOverride !== void 0 ? this._lightmapTextureOverride : this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex);
      if (i) {
        if (this._lightmaps || (this._lightmaps = []), e === "Mesh") {
          const n = this.gameObject.material;
          if (n != null && n.isMeshBasicMaterial)
            n && console.warn("Lightmapping is not supported on MeshBasicMaterial", n.name);
          else {
            if (this._lightmaps.length <= 0) {
              const a = new Dm(this.gameObject, this.context);
              this._lightmaps.push(a);
            }
            this._lightmaps[0].init(this.lightmapIndex, this.lightmapScaleOffset, i);
          }
        } else if (this.isMultiMaterialObject(this.gameObject) && this.sharedMaterials.length > 0)
          for (let n = 0; n < this.gameObject.children.length; n++) {
            const o = this.gameObject.children[n];
            if (!((t = o.material) != null && t.isMeshBasicMaterial)) {
              let a;
              n >= this._lightmaps.length ? (a = new Dm(o, this.context), this._lightmaps.push(a)) : a = this._lightmaps[n], a.init(this.lightmapIndex, this.lightmapScaleOffset, i);
            }
          }
      } else
        Zl && console.warn("Lightmap not found", this.sourceId, this.lightmapIndex);
    }
  }
  /** 
   * @returns true if this renderer has instanced objects
   */
  get isInstancingActive() {
    return this._handles != null && this._handles.length > 0 && this._isInstancingEnabled;
  }
  /** @returns the instancing handles */
  get instances() {
    if (!this._handles || this._handles.length <= 0)
      return null;
    if (this._handlesTempArray.length = 0, this._handles)
      for (const t of this._handles)
        this._handlesTempArray.push(t);
    return this._handlesTempArray;
  }
  /** Enable or disable instancing for this renderer.
   * @param enabled true to enable instancing, false to disable it
   */
  setInstancingEnabled(t) {
    if (this._isInstancingEnabled === t)
      return t && (this._handles === void 0 || this._handles != null && this._handles.length > 0);
    if (this._isInstancingEnabled = t, t) {
      if (this.enableInstancing === void 0 && (this.enableInstancing = !0), this._handles === void 0) {
        if (this._handles = ir.instance.setup(this, this.gameObject, this.context, null, { rend: this, foundMeshes: 0, useMatrixWorldAutoUpdate: this.useInstanceMatrixWorldAutoUpdate() }), this._handles)
          return S.markAsInstancedRendered(this.gameObject, !0), !0;
      } else if (this._handles !== null) {
        for (const e of this._handles)
          e.updateInstanceMatrix(!0), e.add();
        return S.markAsInstancedRendered(this.gameObject, !0), !0;
      }
    } else {
      if (this._handles)
        for (const e of this._handles)
          e.remove(this.destroyed);
      return !0;
    }
    return !1;
  }
  clearInstancingState() {
    this._isInstancingEnabled = !1, this._handles = void 0;
  }
  /** Return true to wrap matrix update events for instanced rendering to update instance matrices automatically when matrixWorld changes
   * This is a separate method to be overrideable from user code
   */
  useInstanceMatrixWorldAutoUpdate() {
    return !0;
  }
  start() {
    if (this.enableInstancing && !fb && (this.setInstancingEnabled(!0), _n.markDirty(this.gameObject)), this.gameObject.frustumCulled = this.allowOcclusionWhenDynamic, this.isMultiMaterialObject(this.gameObject))
      for (let t = 0; t < this.gameObject.children.length; t++) {
        const e = this.gameObject.children[t];
        e.frustumCulled = this.allowOcclusionWhenDynamic;
      }
  }
  onEnable() {
    this.sharedMeshes, this.setVisibility(!0), this._isInstancingEnabled || this.enableInstancing == !0 || Array.isArray(this.enableInstancing) && this.enableInstancing.some((e) => e) ? this.__internalDidAwakeAndStart && this.setInstancingEnabled(!0) : this.enabled && this.applyStencil(), this.updateReflectionProbe();
  }
  onDisable() {
    this.setVisibility(!1), this._handles && this._handles.length > 0 && this.setInstancingEnabled(!1);
  }
  onDestroy() {
    if (this._handles = null, this.isMultiMaterialObject(this.gameObject))
      for (const t of this.gameObject.children)
        this.context.removeBeforeRenderListener(t, this.onBeforeRenderThree);
    else
      this.context.removeBeforeRenderListener(this.gameObject, this.onBeforeRenderThree);
  }
  onBeforeRender() {
    var t, e, i;
    if (this.gameObject) {
      if (this._probeAnchorLastFrame !== this.probeAnchor && ((t = this._reflectionProbe) == null || t.onUnset(this), this.updateReflectionProbe()), Zl == this.name && this.gameObject instanceof q) {
        this.gameObject.geometry.computeBoundingSphere();
        const n = G(this.gameObject.geometry.boundingSphere.center).applyMatrix4(this.gameObject.matrixWorld);
        V.DrawWireSphere(n, this.gameObject.geometry.boundingSphere.radius, 56831);
      }
      if (this.isMultiMaterialObject(this.gameObject) && ((e = this.gameObject.children) == null ? void 0 : e.length) > 0)
        for (const n of this.gameObject.children)
          this.applySettings(n);
      else
        this.applySettings(this.gameObject);
      if (this.sharedMaterials.changed && (this.sharedMaterials.changed = !1, this.applyLightmapping()), (i = this._handles) != null && i.length && this.gameObject[Fc] === !0) {
        this.gameObject[Fc] = !1;
        for (let o = this._handles.length - 1; o >= 0; o--)
          this._handles[o].updateInstanceMatrix();
        this.gameObject.matrixWorldNeedsUpdate = !1;
      }
      if (this._handles && this._handles.length <= 0 && S.markAsInstancedRendered(this.gameObject, !1), this._isInstancingEnabled && this._handles)
        for (let n = 0; n < this._handles.length; n++) {
          const o = this._handles[n];
          bs(o.object, !1);
        }
      this.reflectionProbeUsage !== 0 && this._reflectionProbe && this._reflectionProbe.onSet(this);
    }
  }
  onAfterRender() {
    if (this._isInstancingEnabled && this._handles)
      for (let t = 0; t < this._handles.length; t++) {
        const e = this._handles[t];
        bs(e.object, !0);
      }
    this.reflectionProbeUsage !== 0 && this._reflectionProbe && this._reflectionProbe.onUnset(this), this.static && this.gameObject.matrixAutoUpdate && (this.gameObject.matrixAutoUpdate = !1);
  }
  /** Applies stencil settings for this renderer's objects (if stencil settings are available) */
  applyStencil() {
    _c.applyStencil(this);
  }
  /** Apply the settings of this renderer to the given object
   * Settings include shadow casting and receiving (e.g. this.receiveShadows, this.shadowCastingMode)
   */
  applySettings(t) {
    t.receiveShadow = this.receiveShadows, this.shadowCastingMode == 1 ? t.castShadow = !0 : t.castShadow = !1;
  }
  updateReflectionProbe() {
    this._reflectionProbe = null, this.reflectionProbeUsage !== 0 && (this.startCoroutine(this._updateReflectionProbe(), Re.LateUpdate), this._probeAnchorLastFrame = this.probeAnchor);
  }
  *_updateReflectionProbe() {
    const t = this.probeAnchor || this.gameObject, e = !!this.probeAnchor;
    this._reflectionProbe = sh.get(t, this.context, e, this.probeAnchor);
  }
  setVisibility(t) {
    if (!this.isMultiMaterialObject(this.gameObject))
      bs(this.gameObject, t);
    else
      for (const e of this.gameObject.children)
        this.isMeshOrSkinnedMesh(e) && bs(e, t);
  }
  isMultiMaterialObject(t) {
    return t.type === "Group";
  }
  isMeshOrSkinnedMesh(t) {
    return t.type === "Mesh" || t.type === "SkinnedMesh";
  }
};
let Je = Pd;
Bs([
  f()
], Je.prototype, "receiveShadows", 2);
Bs([
  f()
], Je.prototype, "shadowCastingMode", 2);
Bs([
  f()
], Je.prototype, "lightmapIndex", 2);
Bs([
  f(me)
], Je.prototype, "lightmapScaleOffset", 2);
Bs([
  f()
], Je.prototype, "enableInstancing", 2);
Bs([
  f()
], Je.prototype, "renderOrder", 2);
Bs([
  f()
], Je.prototype, "allowOcclusionWhenDynamic", 2);
Bs([
  f(L)
], Je.prototype, "probeAnchor", 2);
Bs([
  f()
], Je.prototype, "reflectionProbeUsage", 2);
class Yu extends Je {
}
class rw extends Yu {
  constructor() {
    super(...arguments);
    r(this, "_needUpdateBoundingSphere", !1);
  }
  // private _lastWorldPosition = new Vector3();
  awake() {
    var e;
    super.awake(), ub && console.log('SkinnedMeshRenderer for "' + this.name + '"', this), this.allowOcclusionWhenDynamic = !1;
    for (const i of this.sharedMeshes)
      (e = i.parent) == null || e.updateWorldMatrix(!1, !0), this.markBoundsDirty();
  }
  onAfterRender() {
    if (super.onAfterRender(), this._needUpdateBoundingSphere) {
      for (const e of this.sharedMeshes)
        if (e instanceof Os) {
          this._needUpdateBoundingSphere = !1;
          try {
            const i = e.geometry, n = a0(e);
            n && (e.geometry = n), e.computeBoundingSphere(), e.geometry = i;
          } catch (i) {
            console.error(`Error updating bounding sphere for ${e.name}`, i);
          }
        }
    }
    if (ub) {
      for (const e of this.sharedMeshes)
        if (e instanceof Os && e.boundingSphere) {
          const i = G(e.boundingSphere.center).applyMatrix4(e.matrixWorld);
          V.DrawWireSphere(i, e.boundingSphere.radius, "red");
        }
    }
  }
  markBoundsDirty() {
    this._needUpdateBoundingSphere = !0;
  }
}
var xk = Object.defineProperty, Sk = Object.getOwnPropertyDescriptor, aw = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Sk(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && xk(t, e, n), n;
};
const Hh = x("debuggltfexport");
class lw extends wi {
  constructor() {
    super(...arguments);
    r(this, "sceneRoot");
  }
}
const ca = class extends I {
  constructor() {
    super(...arguments);
    r(this, "binary", !0);
    r(this, "objects", []);
    r(this, "ext");
  }
  async exportNow(t, e) {
    Hh && console.log("Exporting objects as glTF", this.objects), t || (t = "scene"), (!this.objects || this.objects.length <= 0) && (this.objects = [this.context.scene]);
    const i = {
      binary: this.binary,
      pivot: ca.calculateCenter(this.objects),
      ...e
    }, n = await this.export(this.objects, i).catch((o) => (console.error(o), !1));
    return n === !1 ? !1 : (this.binary ? t.endsWith(".glb") || (t += ".glb") : t.endsWith(".gltf") || (t += ".gltf"), this.binary ? ca.saveArrayBuffer(n, t) : ca.saveJson(n, t), !0);
  }
  async export(t, e) {
    if (!t || t.length <= 0) {
      console.warn("No objects set to export");
      return;
    }
    const i = new h0();
    i.register((h) => new nw(h)), i.register((h) => new Kv(h)), tw(i, this.context), ca.filterTopmostParent(t);
    const n = {
      trs: !1,
      onlyVisible: !0,
      truncateDrawRange: !1,
      binary: !0,
      maxTextureSize: 1 / 0,
      // To prevent NaN value,
      embedImages: !0,
      includeCustomExtensions: !0,
      animations: (e == null ? void 0 : e.animations) || ca.collectAnimations(t),
      ...e
    }, o = new Array(), a = new L();
    e != null && e.pivot && a.position.sub(e.pivot), Hh && console.log("EXPORT", t), t.forEach((h) => {
      h && Am(h) && (a.children.push(h), h.matrixAutoUpdate = !1, h.matrix.copy(h.matrixWorld), S.getComponentsInChildren(h, Je).forEach((d) => {
        S.isActiveInHierarchy(d.gameObject) && d.setInstancingEnabled(!1);
      }), h.traverse((d) => {
        if (!Am(d)) {
          const u = d.parent;
          d.removeFromParent(), o.push(() => {
            u && u.add(d);
          });
        }
      }));
    });
    const l = new uv(a);
    return e != null && e.needleComponents && (this.ext = new Zv()), this.ext && (this.ext.registerExport(i), this.ext.context = l), new Promise((h, d) => {
      Hh && console.log("Starting glTF export.");
      try {
        i == null || i.parse(
          a,
          // called when the gltf has been generated
          (u) => {
            c(), h(u);
          },
          // called when there is an error in the generation
          (u) => {
            c(), d(u);
          },
          n
        );
      } catch (u) {
        console.error(u), d(u);
      } finally {
        o.forEach((u) => u()), Hh && console.log("Finished glTF export.");
      }
    });
    function c() {
      t.forEach((h) => {
        h && (h.matrixAutoUpdate = !0, S.getComponentsInChildren(h, Je).forEach((d) => {
          S.isActiveInHierarchy(d.gameObject) && d.setInstancingEnabled(!1);
        }));
      });
    }
  }
  static saveArrayBuffer(t, e) {
    this.save(new Blob([t], { type: "application/octet-stream" }), e);
  }
  static saveJson(t, e) {
    this.save("data: text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(t)), e);
  }
  static save(t, e) {
    const i = document.createElement("a");
    i.style.display = "none", document.body.appendChild(i), typeof t == "string" ? i.href = t : i.href = URL.createObjectURL(t), i.download = e, i.click(), i.remove();
  }
  static collectAnimations(t, e) {
    e = e || [];
    for (const i of t)
      i && i.traverseVisible((n) => {
        n.animations && n.animations.length > 0 && e.push(...n.animations);
      });
    return e;
  }
  static calculateCenter(t, e) {
    const i = e || new v();
    return i.set(0, 0, 0), t.forEach((n) => {
      i.add(ie(n));
    }), i.divideScalar(t.length), i;
  }
  static filterTopmostParent(t) {
    if (!(t.length <= 0))
      for (let e = 0; e < t.length; e++) {
        let i = t[e];
        if (!i) {
          t.splice(e, 1), e--;
          continue;
        }
        for (; i.parent; ) {
          if (t.includes(i.parent)) {
            t.splice(e, 1), e--;
            break;
          }
          i = i.parent;
        }
      }
  }
};
let Ku = ca;
aw([
  f()
], Ku.prototype, "binary", 2);
aw([
  f(L)
], Ku.prototype, "objects", 2);
typeof globalThis !== void 0 && !("OffscreenCanvas" in globalThis) && (globalThis.OffscreenCanvas = class {
  constructor(t, e) {
    r(this, "canvas");
    return this.canvas = document.createElement("canvas"), this.canvas.width = t, this.canvas.height = e, this.canvas.convertToBlob = (i, n) => new Promise((o) => {
      this.canvas.toBlob(o, i, n);
    }), this.canvas;
  }
});
const Ck = x("debugprogress");
function Pk(s) {
  s = s || /* @__PURE__ */ new Date();
  const t = s.getMonth() + 1, e = s.getDate(), i = s.getHours(), n = s.getMinutes(), o = s.getSeconds(), a = (t < 10 ? "0" : "") + t, l = (e < 10 ? "0" : "") + e, c = (i < 10 ? "0" : "") + i, h = (n < 10 ? "0" : "") + n, d = (o < 10 ? "0" : "") + o;
  return s.getFullYear() + a + l + "-" + c + h + d;
}
class he {
  /** Start a new progress reporting scope. Make sure to close it with Progress.end.
   * @param scope The scope to start progress reporting for.
   * @param options Parent scope, onProgress callback and logging. If only a string is provided, it's used as parentScope.
   * @example
   * // Manual usage:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting object 1", currentStep: 1, totalSteps: 3 });
   * Progress.report("export-usdz", { message: "Exporting object 2", currentStep: 2, totalSteps: 3 });
   * Progress.report("export-usdz", { message: "Exporting object 3", currentStep: 3, totalSteps: 3 });
   * 
   * // Auto step usage:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting objects", autoStep: true, totalSteps: 3 });
   * Progress.report("export-usdz", "Exporting object 1");
   * Progress.report("export-usdz", "Exporting object 2");
   * Progress.report("export-usdz", "Exporting object 3");
   * Progress.end("export-usdz");
   * 
   * // Auto step with weights:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Exporting objects", autoStep: true, totalSteps: 10 });
   * Progress.report("export-usdz", { message: "Exporting object 1", autoStep: 8 }); // will advance to 80% progress
   * Progress.report("export-usdz", "Exporting object 2"); // 90%
   * Progress.report("export-usdz", "Exporting object 3"); // 100%
   * 
   * // Child scopes:
   * Progress.start("export-usdz", undefined, (progress) => console.log("Progress: " + progress));
   * Progress.report("export-usdz", { message: "Overall export", autoStep: true, totalSteps: 2 });
   * Progress.start("export-usdz-objects", "export-usdz");
   * Progress.report("export-usdz-objects", { message: "Exporting objects", autoStep: true, totalSteps: 3 });
   * Progress.report("export-usdz-objects", "Exporting object 1");
   * Progress.report("export-usdz-objects", "Exporting object 2");
   * Progress.report("export-usdz-objects", "Exporting object 3");
   * Progress.end("export-usdz-objects");
   * Progress.report("export-usdz", "Exporting materials");
   * Progress.end("export-usdz");
   * 
   * // Enable console logging:
   * Progress.start("export-usdz", { logTimings: true });
   */
  static start(t, e) {
    typeof e == "string" && (e = { parentScope: e });
    const i = new Ok(t, e);
    Jl.set(t, i);
  }
  /** Report progress for a formerly started scope.
   * @param scope The scope to report progress for.
   * @param options Options for the progress report. If a string is passed, it will be used as the message.
   * @example
   * // auto step and show a message
   * Progress.report("export-usdz", "Exporting object 1");
   * // same as above
   * Progress.report("export-usdz", { message: "Exporting object 1", autoStep: true });
   * // show the current step and total steps and implicitly calculate progress as 10%
   * Progress.report("export-usdz", { currentStep: 1, totalSteps: 10 });
   * // enable auto step mode, following calls that have autoStep true will increase currentStep automatically.
   * Progress.report("export-usdz", { totalSteps: 20, autoStep: true });
   * // show the progress as 50%
   * Progress.report("export-usdz", { progress: 0.5 });
   * // give this step a weight of 20, which changes how progress is calculated. Useful for steps that take longer and/or have child scopes.
   * Progress.report("export-usdz", { message. "Long process", autoStep: 20 });
   * // show the current step and total steps and implicitly calculate progress as 10%
   * Progress.report("export-usdz", { currentStep: 1, totalSteps: 10 });
   */
  static report(t, e) {
    const i = Jl.get(t);
    if (!i) {
      console.warn("Reporting progress for non-existing scope", t);
      return;
    }
    typeof e == "string" && (e = { message: e, autoStep: !0 }), i.report(e);
  }
  /** End a formerly started scope. This will also report the progress as 100%.
   * @remarks Will warn if any child scope is still running (progress < 1).
  */
  static end(t) {
    const e = Jl.get(t);
    e && (e.end(), Jl.delete(t));
  }
}
const Jl = /* @__PURE__ */ new Map();
class Ok {
  constructor(t, e) {
    r(this, "scopeLabel");
    r(this, "parentScope");
    r(this, "childScopes", []);
    r(this, "parentDepth", 0);
    r(this, "lastStep", 0);
    r(this, "lastAutoStepWeight", 1);
    r(this, "lastTotalSteps", 0);
    r(this, "onProgress");
    r(this, "showLogs", !1);
    r(this, "selfProgress", 0);
    r(this, "totalProgress", 0);
    r(this, "selfReports", 0);
    r(this, "totalReports", 0);
    this.parentScope = e != null && e.parentScope ? Jl.get(e.parentScope) : void 0, this.parentScope && (this.parentScope.childScopes.push(this), this.parentDepth = this.parentScope.parentDepth + 1), this.scopeLabel = " ".repeat(this.parentDepth * 2) + t, this.showLogs = (e == null ? void 0 : e.logTimings) ?? !!Ck, this.showLogs && console.time(this.scopeLabel), this.onProgress = e == null ? void 0 : e.onProgress;
  }
  report(t, e = !1) {
    if (t) {
      if (t.totalSteps !== void 0 && (this.lastTotalSteps = t.totalSteps), t.currentStep !== void 0 && (this.lastStep = t.currentStep), t.autoStep !== void 0) {
        if (t.currentStep === void 0) {
          this.lastStep === void 0 && (this.lastStep = 0);
          const n = typeof t.autoStep == "number" ? t.autoStep : 1;
          this.lastStep += this.lastAutoStepWeight, this.lastAutoStepWeight = n, t.currentStep = this.lastStep;
        }
        t.totalSteps = this.lastTotalSteps;
      }
      t.progress !== void 0 ? this.selfProgress = t.progress : t.currentStep !== void 0 && t.totalSteps !== void 0 && (this.selfProgress = t.currentStep / t.totalSteps);
    }
    if (this.childScopes.length > 0) {
      let n = 0, o = 0;
      for (const l of this.childScopes)
        n += l.selfProgress, o += 1;
      o > 0 && (n /= o);
      const a = this.lastAutoStepWeight / (this.lastTotalSteps ?? 1);
      this.totalProgress = this.selfProgress + n * a;
    } else
      this.totalProgress = this.selfProgress;
    this.selfProgress = Math.min(1, this.selfProgress), this.totalProgress = Math.min(1, this.totalProgress);
    let i = (this.totalProgress * 100).toFixed(3) + "%";
    this.childScopes.length > 0 && (i += " (" + (this.selfProgress * 100).toFixed(3) + "% self)"), t != null && t.message && (i = t.message + " – " + i), this.lastStep !== void 0 && this.lastTotalSteps !== void 0 && (i = "Step " + (this.lastStep + (this.lastAutoStepWeight != 1 ? "–" + (this.lastStep + this.lastAutoStepWeight) : "") + "/" + this.lastTotalSteps) + " " + i), e ? this.totalReports++ : (this.selfReports++, this.totalReports++), this.showLogs && console.timeLog(this.scopeLabel, i), this.onProgress && this.onProgress(this.totalProgress), this.parentScope && this.parentScope.report(void 0, !0);
  }
  end() {
    this.report({ progress: 1, autoStep: !0 }, !0), this.showLogs && (console.timeLog(this.scopeLabel, "Total reports: " + this.totalReports, "Self reports: " + this.selfReports), console.timeEnd(this.scopeLabel));
    let t = !1;
    for (const e of this.childScopes)
      if (!(e.selfProgress >= 1)) {
        t = !0;
        break;
      }
    t && console.warn("Progress end with child scopes that are still running", this), this.onProgress = void 0;
  }
}
function qn(s) {
  return s = s.replace(/[^a-zA-Z0-9_]/g, ""), s.match(/^[a-zA-Z_]/) || (s = "_" + s), s;
}
function cw(s) {
  return s = s.replace('"', '\\"'), s;
}
function hw(s) {
  if (s.length === 0)
    return null;
  const t = s.map((i) => {
    const n = new Array();
    for (; i.parent; )
      n.unshift(i.parent), i = i.parent;
    return n;
  });
  return t[0].findLast((i) => t.every((n) => n.includes(i))) || null;
}
function dw(s) {
  const t = hw(s), e = /* @__PURE__ */ new Set();
  for (const i of s) {
    let n = i.parent;
    for (; n && n !== t; )
      s.includes(n) || e.add(n), n = n.parent;
  }
  return e;
}
const Mk = new v(), Rk = new W(), kk = new v(1, 1, 1), tr = class {
  constructor(t, e, i = null, n = null, o = null, a = null, l = null, c = null) {
    r(this, "uuid");
    r(this, "name");
    /** If no type is provided, type is chosen automatically (Xform or Mesh) */
    r(this, "type");
    /** MaterialBindingAPI and SkelBindingAPI are handled automatically, extra schemas can be added here */
    r(this, "extraSchemas", []);
    r(this, "displayName");
    r(this, "visibility");
    r(this, "transform", null);
    r(this, "_isDynamic");
    r(this, "geometry");
    r(this, "material");
    r(this, "camera");
    r(this, "parent");
    r(this, "skinnedMesh");
    r(this, "children", []);
    r(this, "animations");
    r(this, "_eventListeners");
    // these are for tracking which xformops are needed
    r(this, "needsTranslate", !1);
    r(this, "needsOrient", !1);
    r(this, "needsScale", !1);
    var h, d, u;
    this.uuid = t, this.name = qn(e), this.displayName = e, i ? this.transform = {
      position: ((h = i.position) == null ? void 0 : h.clone()) || null,
      quaternion: ((d = i.quaternion) == null ? void 0 : d.clone()) || null,
      scale: ((u = i.scale) == null ? void 0 : u.clone()) || null
    } : this.transform = null, this.geometry = n, this.material = o, this.camera = a, this.parent = null, this.children = [], this._eventListeners = {}, this._isDynamic = !1, this.skinnedMesh = l, this.animations = c;
  }
  // defaults to "inherited" in USD
  getMatrix() {
    if (!this.transform)
      return new se();
    const { position: t, quaternion: e, scale: i } = this.transform, n = new se();
    return n.compose(t || Mk, e || Rk, i || kk), n;
  }
  setMatrix(t) {
    if (!t || !(t instanceof se)) {
      this.transform = null;
      return;
    }
    const e = new v(), i = new W(), n = new v();
    t.decompose(e, i, n), this.transform = { position: e, quaternion: i, scale: n };
  }
  /** @deprecated Use `transform`, or `getMatrix()` if you really need the matrix */
  get matrix() {
    return this.getMatrix();
  }
  /** @deprecated Use `transform`, or `setMatrix()` if you really need the matrix */
  set matrix(t) {
    this.setMatrix(t);
  }
  get isDynamic() {
    return this._isDynamic;
  }
  set isDynamic(t) {
    this._isDynamic = t;
  }
  static createEmptyParent(t) {
    const e = new tr(Cs.generateUUID(), t.name + "_empty_" + tr.USDObject_export_id++, t.transform), i = t.parent;
    return i && i.add(e), e.add(t), e.isDynamic = !0, t.transform = null, e;
  }
  static createEmpty() {
    const t = new tr(Cs.generateUUID(), "Empty_" + tr.USDObject_export_id++);
    return t.isDynamic = !0, t;
  }
  is(t) {
    return t ? this.uuid === t.uuid : !1;
  }
  isEmpty() {
    return !this.geometry;
  }
  clone() {
    const t = new tr(Cs.generateUUID(), this.name, this.transform, this.geometry, this.material);
    return t.isDynamic = this.isDynamic, t;
  }
  deepClone() {
    const t = this.clone();
    for (const e of this.children)
      e && t.add(e.deepClone());
    return t;
  }
  getPath() {
    let t = this.parent, e = this.name;
    for (; t; )
      e = (t.parent ? t.name : t.name + "/Scenes/Scene") + "/" + e, t = t.parent;
    return "</" + e + ">";
  }
  add(t) {
    t.parent && t.parent.remove(t), t.parent = this, this.children.push(t);
  }
  remove(t) {
    const e = this.children.indexOf(t);
    e >= 0 && (t.parent === this && (t.parent = null), this.children.splice(e, 1));
  }
  addEventListener(t, e) {
    this._eventListeners[t] || (this._eventListeners[t] = []), this._eventListeners[t].push(e);
  }
  removeEventListener(t, e) {
    if (!this._eventListeners[t])
      return;
    const i = this._eventListeners[t].indexOf(e);
    i >= 0 && this._eventListeners[t].splice(i, 1);
  }
  onSerialize(t, e) {
    const i = this._eventListeners.serialize;
    i && i.forEach((n) => n(t, e));
  }
};
let Lt = tr;
r(Lt, "USDObject_export_id", 0);
class uw extends Lt {
  constructor() {
    super(void 0, "StageRoot", null, null, null, null);
    r(this, "stageLength");
    this.children = [], this.stageLength = 200;
  }
  get isDocumentRoot() {
    return !0;
  }
  get isDynamic() {
    return !1;
  }
  add(e) {
    e.parent = this, this.children.push(e);
  }
  remove(e) {
    const i = this.children.indexOf(e);
    i >= 0 && (e.parent === this && (e.parent = null), this.children.splice(i, 1));
  }
  traverse(e, i = null) {
    if (i !== null ? e(i) : i = this, i.children)
      for (const n of i.children)
        this.traverse(e, n);
  }
  findById(e) {
    let i = !1;
    function n(o) {
      if (!i) {
        if (o.uuid === e)
          return i = !0, o;
        if (o.children)
          for (const a of o.children) {
            if (!a)
              continue;
            const l = n(a);
            if (l)
              return l;
          }
      }
    }
    return n(this);
  }
  buildHeader(e) {
    var u, p, m;
    const i = (u = e.extensions) == null ? void 0 : u.find((g) => (g == null ? void 0 : g.extensionName) === "animation"), n = (p = e.extensions) == null ? void 0 : p.find((g) => (g == null ? void 0 : g.extensionName) === "Behaviour"), o = (m = e.extensions) == null ? void 0 : m.find((g) => (g == null ? void 0 : g.extensionName) === "Physics"), a = (i == null ? void 0 : i.getStartTimeCode()) ?? 0, l = (i == null ? void 0 : i.getEndTimeCode()) ?? 0;
    let c = "";
    const h = i == null ? void 0 : i.registeredClips;
    if (h)
      for (const g of h)
        c += `	# Animation: ${g.name}, start=${i.getStartTimeByClip(g) * 60}, length=${g.duration * 60}
`;
    const d = c;
    return `#usda 1.0
(
	customLayerData = {
		string creator = "Needle Engine ${$n}"
		dictionary Needle = {
			bool animations = ${i ? 1 : 0}
			bool interactive = ${n ? 1 : 0}
			bool physics = ${o ? 1 : 0}
			bool quickLookCompatible = ${e.quickLookCompatible ? 1 : 0}
		}
	}
	defaultPrim = "${qn(this.name)}"
	metersPerUnit = 1
	upAxis = "Y"
	startTimeCode = ${a}
	endTimeCode = ${l}
	timeCodesPerSecond = 60
	framesPerSecond = 60
	doc = """Generated by Needle Engine USDZ Exporter ${$n}"""
${d}
)
`;
  }
}
const Qr = `
`, Vt = "</StageRoot/Materials";
class Tk {
  constructor() {
    r(this, "str");
    r(this, "indent");
    this.str = "", this.indent = 0;
  }
  clear() {
    this.str = "", this.indent = 0;
  }
  beginBlock(t = void 0, e = "{", i = !0) {
    t !== void 0 ? (t = this.applyIndent(t), this.str += t, i ? (this.str += Qr, this.str += this.applyIndent(e)) : this.str += " " + e) : this.str += this.applyIndent(e), this.str += Qr, this.indent += 1;
  }
  closeBlock(t = "}") {
    this.indent -= 1, this.str += this.applyIndent(t) + Qr;
  }
  beginArray(t) {
    t = this.applyIndent(t + " = ["), this.str += t, this.str += Qr, this.indent += 1;
  }
  closeArray() {
    this.indent -= 1, this.str += this.applyIndent("]") + Qr;
  }
  appendLine(t = "") {
    t = this.applyIndent(t), this.str += t, this.str += Qr;
  }
  toString() {
    return this.str;
  }
  applyIndent(t) {
    let e = "";
    for (let i = 0; i < this.indent; i++)
      e += "	";
    return e + t;
  }
}
class Ak {
  constructor(t, e, i) {
    r(this, "root");
    r(this, "exporter");
    r(this, "extensions", []);
    r(this, "quickLookCompatible");
    r(this, "exportInvisible");
    r(this, "materials");
    r(this, "textures");
    r(this, "files");
    r(this, "document");
    r(this, "output");
    r(this, "animations");
    this.root = t, this.exporter = e, this.quickLookCompatible = i.quickLookCompatible, this.exportInvisible = i.exportInvisible, i.extensions && (this.extensions = i.extensions), this.materials = /* @__PURE__ */ new Map(), this.textures = {}, this.files = {}, this.document = new uw(), this.output = "", this.animations = [];
  }
}
class lp {
  constructor() {
    r(this, "ar", {
      anchoring: { type: "plane" },
      planeAnchoring: { alignment: "horizontal" }
    });
    r(this, "quickLookCompatible", !1);
    r(this, "extensions", []);
    r(this, "maxTextureSize", 4096);
    r(this, "exportInvisible", !1);
  }
}
let Ek = class {
  constructor() {
    r(this, "debug");
    r(this, "pruneUnusedNodes");
    r(this, "sceneAnchoringOptions", new lp());
    r(this, "extensions", []);
    r(this, "keepObject");
    r(this, "beforeWritingDocument");
    this.debug = !1, this.pruneUnusedNodes = !0;
  }
  async parse(t, e = new lp()) {
    var w, P;
    e = Object.assign(new lp(), e), this.sceneAnchoringOptions = e;
    const i = new Ak(t, this, e);
    this.extensions = i.extensions;
    const n = i.files, o = "model.usda";
    n[o] = null;
    const a = i.materials, l = i.textures;
    he.report("export-usdz", "Invoking onBeforeBuildDocument"), await Od(i, "onBeforeBuildDocument"), he.report("export-usdz", "Done onBeforeBuildDocument"), he.report("export-usdz", "Reparent bones to common ancestor");
    const c = [], h = /* @__PURE__ */ new Set();
    t == null || t.traverse((k) => {
      if (!(!e.exportInvisible && !k.visible) && k instanceof Os) {
        const O = k.skeleton.bones, M = hw(O);
        if (M) {
          const E = { object: k, originalParent: k.parent, newParent: M };
          c.push(E), h.add(E.object.uuid), E.newParent && h.add(E.newParent.uuid), E.originalParent && h.add(E.originalParent.uuid);
        }
      }
    });
    for (const k of c) {
      const { object: O, originalParent: M, newParent: E } = k;
      E.add(O);
    }
    he.report("export-usdz", "Traversing hierarchy"), t && fw(t, i.document, i, this.keepObject), he.report("export-usdz", "Invoking onAfterBuildDocument"), await Od(i, "onAfterBuildDocument");
    const d = i.extensions.find((k) => k.extensionName === "Behaviour"), u = (d == null ? void 0 : d.getAllTargetUuids()) ?? /* @__PURE__ */ new Set();
    if (this.pruneUnusedNodes) {
      const k = {
        allBehaviorTargets: u,
        debug: !1,
        boneReparentings: h,
        quickLookCompatible: i.quickLookCompatible
      };
      this.debug && pb(i.document, "Hierarchy BEFORE pruning", k), pw(i.document, k), this.debug && pb(i.document, "Hierarchy AFTER pruning");
    } else
      this.debug && console.log("Pruning of empty nodes is disabled. This may result in a larger USDZ file.");
    he.report("export-usdz", { message: "Parsing document", autoStep: 10 }), await Ik(i, () => (he.report("export-usdz", "Building materials"), Wk(a, l, e.quickLookCompatible))), he.report("export-usdz", "Invoking onAfterSerialize"), await Od(i, "onAfterSerialize");
    for (const k of c) {
      const { object: O, originalParent: M, newParent: E } = k;
      M && M.add(O);
    }
    (P = (w = i.exporter) == null ? void 0 : w.beforeWritingDocument) == null || P.call(w);
    const m = i.document.buildHeader(i) + `
` + i.output;
    this.debug && console.log(m), n[o] = d0(m), i.output = "", he.report("export-usdz", { message: "Exporting textures", autoStep: 10 }), he.start("export-usdz-textures", { parentScope: "export-usdz", logTimings: !1 });
    const g = new kr({
      antialias: !1,
      alpha: !0,
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0
    }), _ = Object.keys(l).length;
    he.report("export-usdz-textures", { totalSteps: _ * 3, currentStep: 0 });
    const y = async (k) => {
      const O = l[k], M = O.texture, E = yw.includes(M.format);
      let B = {
        imageData: M.image
      };
      he.report("export-usdz-textures", { message: "read back texture", autoStep: !0 });
      const A = O.scale !== void 0 && O.scale.x !== 1 && O.scale.y !== 1 && O.scale.z !== 1 && O.scale.w !== 1;
      (M.isCompressedTexture || M.isRenderTargetTexture || A) && (B = await Dk(M, e.maxTextureSize, g, O.scale)), he.report("export-usdz-textures", { message: "convert texture to canvas", autoStep: !0 });
      const F = await jk(B.imageBitmap || B.imageData, e.maxTextureSize).catch((U) => {
        console.error("Error converting texture to canvas", M, U);
      });
      if (F) {
        he.report("export-usdz-textures", { message: "convert canvas to blob", autoStep: !0 });
        const U = await F.convertToBlob({ type: E ? "image/png" : "image/jpeg", quality: 0.95 });
        n[`textures/${k}.${E ? "png" : "jpg"}`] = new Uint8Array(await U.arrayBuffer());
      } else
        console.warn("Can`t export texture: ", M);
    };
    for (const k in l)
      await y(k);
    g.dispose(), he.end("export-usdz-textures");
    let b = 0;
    for (const k in n) {
      const O = n[k], M = 34 + k.length;
      b += M;
      const E = b & 63;
      if (E !== 4) {
        const B = 64 - E, A = new Uint8Array(B);
        n[k] = [O, { extra: { 12345: A } }];
      }
      b = O.length;
    }
    return he.report("export-usdz", "zip archive"), nS(n, { level: 0 });
  }
};
function fw(s, t, e, i) {
  var c;
  if (!e.exportInvisible && !s.visible)
    return;
  let n, o, a;
  const l = { position: s.position, quaternion: s.quaternion, scale: s.scale };
  if (s.position.x === 0 && s.position.y === 0 && s.position.z === 0 && (l.position = null), s.quaternion.x === 0 && s.quaternion.y === 0 && s.quaternion.z === 0 && s.quaternion.w === 1 && (l.quaternion = null), s.scale.x === 1 && s.scale.y === 1 && s.scale.z === 1 && (l.scale = null), (s instanceof q || s instanceof Os) && (o = s.geometry, a = s.material), i && !i(s) && (o = void 0, a = void 0), (s instanceof q || s instanceof Os) && a && (a instanceof It || a instanceof Me || a instanceof Se && a.type === "MeshLineMaterial")) {
    const h = Xh(s), d = s instanceof Os ? s : null;
    n = new Lt(s.uuid, h, l, o, a, void 0, d, s.animations);
  } else if (s instanceof ye || s instanceof rg) {
    const h = Xh(s);
    n = new Lt(s.uuid, h, l, void 0, void 0, s);
  } else {
    const h = Xh(s);
    n = new Lt(s.uuid, h, l, void 0, void 0, void 0, void 0, s.animations);
  }
  if (n) {
    if (n.displayName = ((c = s.userData) == null ? void 0 : c.name) || s.name, n.visibility = s.visible ? void 0 : "invisible", t && t.add(n), t = n, e.extensions)
      for (const h of e.extensions)
        h.onExportObject && h.onExportObject.call(h, s, n, e);
  } else {
    const h = Xh(s), d = new Lt(s.uuid, h, { position: s.position, quaternion: s.quaternion, scale: s.scale });
    t && t.add(d), t = d;
  }
  for (const h of s.children)
    fw(h, t, e, i);
}
function pb(s, t, ...e) {
  const i = {};
  let n = 0;
  function o(a, l) {
    n++;
    let c = a.displayName || a.name;
    c += " (" + a.uuid + ")", (a.geometry || a.material || a.camera || a.skinnedMesh) && (c += " (" + (a.geometry ? "geo, " : "") + (a.material ? "mat, " : "") + (a.camera ? "cam, " : "") + (a.skinnedMesh ? "skin, " : "") + ")"), l[c] = {};
    const d = { object: a };
    a.material && (d.mat = !0), a.geometry && (d.geo = !0), a.camera && (d.cam = !0), a.skinnedMesh && (d.skin = !0), l[c]._self = d;
    for (const u of a.children)
      u && o(u, l[c]);
  }
  o(s, i), console.log(t + " (" + n + " nodes)", i, ...e);
}
function pw(s, t) {
  var h;
  let e = !0;
  const i = new Array(), n = new Array();
  if (s.children.length === 0)
    e = !0;
  else {
    const d = [...s.children];
    for (const u of d)
      if (u) {
        const p = pw(u, t);
        t.debug && (p ? i.push(u) : n.push(u)), e = e && p;
      }
  }
  const o = t.allBehaviorTargets.has(s.uuid), a = s.geometry || s.material || s.camera && !t.quickLookCompatible || s.skinnedMesh || !1, l = t.boneReparentings.has(s.uuid), c = e && !o && !a && !l;
  return c ? (t.debug && console.log("Pruned object:", (s.displayName || s.name) + " (" + s.uuid + ")", {
    isVisible: a,
    isBehaviorSourceOrTarget: o,
    allChildsWerePruned: e,
    isBoneReparenting: l,
    object: s,
    prunedChilds: i,
    keptChilds: n
  }), (h = s.parent) == null || h.remove(s)) : t.debug && console.log("Kept object:", (s.displayName || s.name) + " (" + s.uuid + ")", {
    isVisible: a,
    isBehaviorSourceOrTarget: o,
    allChildsWerePruned: e,
    isBoneReparenting: l,
    object: s,
    prunedChilds: i,
    keptChilds: n
  }), c;
}
async function Ik(s, t) {
  he.start("export-usdz-resources", "export-usdz");
  const e = [];
  for (const c of s.document.children)
    mw(c, s, e);
  const i = e.length;
  for (let c = 0; c < i; c++)
    he.report("export-usdz-resources", { totalSteps: i, currentStep: c }), await new Promise((h, d) => {
      e[c](), h();
    });
  he.end("export-usdz-resources");
  const n = new Tk(), o = s.exporter.sceneAnchoringOptions.ar;
  n.beginBlock(`def Xform "${s.document.name}"`), n.beginBlock(`def Scope "Scenes" (
		kind = "sceneLibrary"
	)`), n.beginBlock('def Xform "Scene"', "(", !1), n.appendLine('apiSchemas = ["Preliminary_AnchoringAPI"]'), n.appendLine("customData = {"), n.appendLine("	bool preliminary_collidesWithEnvironment = 0"), n.appendLine('	string sceneName = "Scene"'), n.appendLine("}"), n.appendLine('sceneName = "Scene"'), n.closeBlock(")"), n.beginBlock(), n.appendLine(`token preliminary:anchoring:type = "${o.anchoring.type}"`), o.anchoring.type === "plane" && n.appendLine(`token preliminary:planeAnchoring:alignment = "${o.planeAnchoring.alignment}"`), o.anchoring.type === "image" && n.appendLine(`rel preliminary:imageAnchoring:referenceImage = </${s.document.name}/Scenes/Scene/AnchoringReferenceImage>`), n.appendLine();
  const a = (c) => {
    if (!c)
      return 0;
    let h = 1;
    for (const d of c.children)
      h += a(d);
    return h;
  }, l = a(s.document);
  he.start("export-usdz-xforms", "export-usdz"), he.report("export-usdz-xforms", { totalSteps: l, currentStep: 1 });
  for (const c of s.document.children)
    gw(c, n, s);
  he.end("export-usdz-xforms"), he.report("export-usdz", "invoke onAfterHierarchy"), Od(s, "onAfterHierarchy", n), n.closeBlock(), n.closeBlock(), n.appendLine(t()), n.closeBlock(), he.report("export-usdz", "write to string"), s.output += n.toString();
}
function mw(s, t, e) {
  if (!s)
    return;
  const i = s.geometry, n = s.material;
  if (i)
    if (n && ("isMeshStandardMaterial" in n && n.isMeshStandardMaterial || "isMeshBasicMaterial" in n && n.isMeshBasicMaterial || n.type === "MeshLineMaterial")) {
      const o = "geometries/" + Lm(i, s.name) + ".usda";
      if (!(o in t.files)) {
        const a = () => {
          var c, h;
          const l = Uk(i, (h = (c = s.skinnedMesh) == null ? void 0 : c.skeleton) == null ? void 0 : h.bones, t.quickLookCompatible);
          t.files[o] = zk(l);
        };
        e.push(a);
      }
    } else
      console.warn("NeedleUSDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", n == null ? void 0 : n.name);
  n && (n.uuid in t.materials || (t.materials[n.uuid] = n));
  for (const o of s.children)
    mw(o, t, e);
}
async function Od(s, t, e = null) {
  if (s.extensions) {
    for (const i of s.extensions)
      if (i && typeof i[t] == "function") {
        const o = i[t].call(i, s, e);
        o instanceof Promise && await o;
      }
  }
}
let Gh = null, Ht = null, cp, Yr, qh;
async function Dk(s, t = 1 / 0, e = null, i = void 0) {
  cp || (cp = new Xn(2, 2, 1, 1)), Yr || (Yr = new bn({
    uniforms: {
      blitTexture: new co(s),
      flipY: new co(!1),
      scale: new co(new me(1, 1, 1, 1))
    },
    vertexShader: `
            varying vec2 vUv;
			uniform bool flipY;
            void main(){
                vUv = uv;
				if (flipY)
					vUv.y = 1. - vUv.y;
                gl_Position = vec4(position.xy * 1.0,0.,.999999);
            }`,
    fragmentShader: `
            uniform sampler2D blitTexture;
			uniform vec4 scale; 
            varying vec2 vUv;

            void main(){ 
                gl_FragColor = vec4(vUv.xy, 0, 1);
                
                #ifdef IS_SRGB
                gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );
                #else
                gl_FragColor = texture2D( blitTexture, vUv);
                #endif
				
				gl_FragColor.rgba *= scale.rgba;
            }`
  }));
  const n = Yr.uniforms;
  n.blitTexture.value = s, n.flipY.value = !1, n.scale.value = new me(1, 1, 1, 1), i !== void 0 && n.scale.value.copy(i), Yr.defines.IS_SRGB = s.colorSpace == vn, Yr.needsUpdate = !0, qh || (qh = new q(cp, Yr), qh.frustumCulled = !1);
  const o = new ye(), a = new Mi();
  a.add(qh), e || (e = Gh = new kr({ antialias: !1, alpha: !0, premultipliedAlpha: !1, preserveDrawingBuffer: !0 }));
  const l = Math.min(s.image.width, t), c = Math.min(s.image.height, t);
  Ht && (Ht.width !== l || Ht.height !== c) && (Ht.dispose(), Ht = null), Ht || (Ht = new ks(l, c, { format: Su, type: C1, minFilter: j_, magFilter: j_ })), e.setRenderTarget(Ht), e.setSize(l, c), e.clear(), e.render(a, o), Gh && (Gh.dispose(), Gh = null);
  const h = new Uint8ClampedArray(Ht.width * Ht.height * 4);
  e.readRenderTargetPixels(Ht, 0, 0, Ht.width, Ht.height, h);
  const d = new ImageData(h, Ht.width, Ht.height, void 0), u = await createImageBitmap(d, { premultiplyAlpha: "none" });
  return {
    imageData: d,
    imageBitmap: u
  };
}
function Lk(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas || typeof ImageBitmap < "u" && s instanceof ImageBitmap;
}
async function jk(s, t = 4096) {
  const e = t / Math.max(s.width, s.height), i = s.width * Math.min(1, e), n = s.height * Math.min(1, e), o = new OffscreenCanvas(i, n), a = { premultiplyAlpha: "none" };
  s.width !== i && (a.resizeWidth = i), s.height !== n && (a.resizeHeight = n);
  const l = await createImageBitmap(s, a), c = o.getContext("bitmaprenderer");
  return c && c.transferFromImageBitmap(l), o;
}
async function Bk(s, t = void 0, e = !1, i = 4096) {
  if (Lk(s)) {
    const n = i / Math.max(s.width, s.height), o = new OffscreenCanvas(s.width * Math.min(1, n), s.height * Math.min(1, n)), a = o.getContext("2d", { alpha: !0, premultipliedAlpha: !1 });
    if (!a)
      throw new Error("Could not get canvas 2D context");
    if (e === !0 && (a.translate(0, o.height), a.scale(1, -1)), a.drawImage(s, 0, 0, o.width, o.height), t !== void 0) {
      const l = t.x, c = t.y, h = t.z, d = t.w, u = a.getImageData(0, 0, o.width, o.height), p = u.data;
      for (let m = 0; m < p.length; m += 4)
        p[m + 0] = p[m + 0] * l, p[m + 1] = p[m + 1] * c, p[m + 2] = p[m + 2] * h, p[m + 3] = p[m + 3] * d;
      a.putImageData(u, 0, 0);
    }
    return o;
  } else
    throw new Error("NeedleUSDZExporter: No valid image data found. Unable to process texture.");
}
const Ie = 7;
function Fk() {
  return `#usda 1.0
(
    customLayerData = {
        string creator = "Needle Engine USDZExporter"
    }
    metersPerUnit = 1
    upAxis = "Y"
)
`;
}
function zk(s, t) {
  let e = Fk();
  return e += s, d0(e);
}
function Xh(s) {
  return s.name.replace(/[-<>\(\)\[\]§$%&\/\\\=\?\,\;]/g, "") + "_" + s.id;
}
function mb(s) {
  return qn(s.name || "bone_" + s.uuid);
}
function Lm(s, t) {
  return qn(s.name || "Geometry") + "_" + s.id;
}
function Xg(s) {
  return qn(s.name || "Material") + "_" + s.id;
}
function ka(s, t) {
  let e = mb(s), i = s.parent;
  for (; i && i !== t; )
    e = mb(i) + "/" + e, i = i.parent;
  return e;
}
function gw(s, t, e) {
  var m;
  if (s == null)
    return;
  he.report("export-usdz-xforms", { message: "buildXform " + s.displayName || s.name, autoStep: !0 });
  const i = s.transform, n = s.geometry, o = s.material, a = s.camera, l = s.name;
  if (s.animations)
    for (const g of s.animations)
      e.animations.push(g);
  const c = n && n.isBufferGeometry && n.attributes.skinIndex !== void 0 && n.attributes.skinIndex.count > 0, h = c ? "SkelRoot" : "Xform", d = new Array(), u = o && o instanceof Me && o.color && o.color.r === 1 && o.color.g === 1 && o.color.b === 1 && !o.map && o.opacity === 1 && (n == null ? void 0 : n.attributes.color);
  if (n != null && n.attributes.color && !u && console.warn("NeedleUSDZExporter: Geometry has vertex colors. Vertex colors will only be shown in QuickLook for unlit materials with white color and no texture. Otherwise, they will be ignored.", s.displayName), t.appendLine(), n ? (t.beginBlock(`def ${h} "${l}"`, "(", !1), e.quickLookCompatible && o && o.side === Ri && !c ? t.appendLine(`prepend references = @./geometries/${Lm(n)}.usda@</Geometry_doubleSided>`) : t.appendLine(`prepend references = @./geometries/${Lm(n)}.usda@</Geometry>`), u || d.push("MaterialBindingAPI"), c && d.push("SkelBindingAPI")) : a && !e.quickLookCompatible ? t.beginBlock(`def Camera "${l}"`, "(", !1) : s.type !== void 0 ? t.beginBlock(`def ${s.type} "${l}"`) : t.beginBlock(`def Xform "${l}"`, "(", !1), s.type === void 0 && ((m = s.extraSchemas) != null && m.length && d.push(...s.extraSchemas), d.length && t.appendLine(`prepend apiSchemas = [${d.map((g) => `"${g}"`).join(", ")}]`)), s.displayName && t.appendLine(`displayName = "${cw(s.displayName)}"`), (a || s.type === void 0) && (t.closeBlock(")"), t.beginBlock()), n && o) {
    if (!u) {
      const g = Xg(o);
      t.appendLine(`rel material:binding = </StageRoot/Materials/${g}>`);
    }
    !e.quickLookCompatible && o.side === Ri && (t.beginBlock('over "Geometry" '), t.appendLine("uniform bool doubleSided = 1"), t.closeBlock());
  }
  let p = !1;
  if (c ? (t.appendLine("rel skel:skeleton = <Rig>"), t.appendLine("rel skel:animationSource = <Rig/_anim>"), p = !1) : s.type === void 0 && i && (p = p || i.position !== null || i.quaternion !== null || i.scale !== null, i.position && (s.needsTranslate = !0, t.appendLine(`double3 xformOp:translate = (${ce(i.position.x)}, ${ce(i.position.y)}, ${ce(i.position.z)})`)), i.quaternion && (s.needsOrient = !0, t.appendLine(`quatf xformOp:orient = (${ce(i.quaternion.w)}, ${ce(i.quaternion.x)}, ${ce(i.quaternion.y)}, ${ce(i.quaternion.z)})`)), i.scale && (s.needsScale = !0, t.appendLine(`double3 xformOp:scale = (${ce(i.scale.x)}, ${ce(i.scale.y)}, ${ce(i.scale.z)})`))), s.visibility !== void 0 && t.appendLine(`token visibility = "${s.visibility}"`), a && !e.quickLookCompatible && ("isOrthographicCamera" in a && a.isOrthographicCamera ? (t.appendLine(`float2 clippingRange = (${a.near}, ${a.far})`), t.appendLine(`float horizontalAperture = ${((Math.abs(a.left) + Math.abs(a.right)) * 10).toPrecision(Ie)}`), t.appendLine(`float verticalAperture = ${((Math.abs(a.top) + Math.abs(a.bottom)) * 10).toPrecision(Ie)}`), t.appendLine('token projection = "orthographic"')) : "isPerspectiveCamera" in a && a.isPerspectiveCamera && (t.appendLine(`float2 clippingRange = (${a.near.toPrecision(Ie)}, ${a.far.toPrecision(Ie)})`), t.appendLine(`float focalLength = ${a.getFocalLength().toPrecision(Ie)}`), t.appendLine(`float focusDistance = ${a.focus.toPrecision(Ie)}`), t.appendLine(`float horizontalAperture = ${a.getFilmWidth().toPrecision(Ie)}`), t.appendLine('token projection = "perspective"'), t.appendLine(`float verticalAperture = ${a.getFilmHeight().toPrecision(Ie)}`))), s.onSerialize && s.onSerialize(t, e), s.type === void 0) {
    const g = new Array();
    s.needsTranslate && g.push('"xformOp:translate"'), s.needsOrient && g.push('"xformOp:orient"'), s.needsScale && g.push('"xformOp:scale"'), g.length && t.appendLine(`uniform token[] xformOpOrder = [${g.join(", ")}]`);
  }
  if (s.children) {
    t.appendLine();
    for (const g of s.children)
      gw(g, t, e);
  }
  t.closeBlock();
}
function ce(s) {
  return Number.isInteger(s) ? s.toString() : s.toFixed(10);
}
function gb(s) {
  const t = s.elements;
  return `( ${Qh(t, 0)}, ${Qh(t, 4)}, ${Qh(t, 8)}, ${Qh(t, 12)} )`;
}
function Qh(s, t) {
  return `(${ce(s[t + 0])}, ${ce(s[t + 1])}, ${ce(s[t + 2])}, ${ce(s[t + 3])})`;
}
function Uk(s, t = [], e = !0) {
  return `
def "Geometry"
${Nk(s, t, e)}
`;
}
function Nk(s, t = [], e = !0) {
  const i = "Geometry", n = s.attributes, o = n.position.count, a = t && t.length > 0, l = [], c = [];
  let h = new Array(), d = n.skinIndex;
  if (a) {
    const p = [];
    for (const y of t)
      l.push({ bone: y, index: t.indexOf(y) }), p.push(y.uuid);
    let m = 1e4;
    for (; p.length < t.length && m-- > 0; )
      for (const y of l) {
        const b = y.bone.children;
        for (const w of b)
          p.indexOf(w.uuid) === -1 && t.indexOf(w) !== -1 && (l.push({ bone: w, index: t.indexOf(w) }), p.push(w.uuid));
      }
    m <= 0 && console.error("Failed to sort bones in skinned mesh", l, t, p);
    for (const y of dw(t))
      l.push({ bone: y, index: l.length });
    const g = l[0].bone.parent;
    l.sort((y, b) => ka(y.bone, g) > ka(b.bone, g) ? 1 : -1), l.map((y) => '"' + ka(y.bone, g) + '"').join(", ");
    for (const y in l)
      c[l[y].index] = parseInt(y);
    const _ = n.skinIndex;
    h = new Array();
    for (let y = 0; y < _.count; y++) {
      const b = _.getX(y), w = _.getY(y), P = _.getZ(y), k = _.getW(y);
      h.push(c[b], c[w], c[P], c[k]);
    }
    d = new mt(new Uint16Array(h), 4);
  }
  const u = n.skinWeight && n.skinIndex;
  return `
{	
    def Mesh "${i}" ${u ? `(
        prepend apiSchemas = ["SkelBindingAPI"]
    )` : ""}
    {
        int[] faceVertexCounts = [${hp(s)}]
        int[] faceVertexIndices = [${dp(s)}]
		${n.normal || e ? (
    // in QuickLook, normals are required, otherwise double-sided rendering doesn't work.
    `normal3f[] normals = [${Md(n.normal, o)}] (
            interpolation = "vertex"
        )`
  ) : ""}
        point3f[] points = [${Md(n.position, o)}]
        ${n.uv ? `texCoord2f[] primvars:st = [${_w(n.uv, o, !0)}] (
            interpolation = "vertex"
        )` : ""}
		${n.uv1 ? up("st1", n.uv1) : ""}
		${n.uv2 ? up("st2", n.uv2) : ""}
		${n.uv3 ? up("st3", n.uv3) : ""}
		${u ? `matrix4d primvars:skel:geomBindTransform = ( (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1) ) (
				elementSize = 1
				interpolation = "constant"
			)` : ""}
		${n.skinIndex ? `int[] primvars:skel:jointIndices = [${_b(d, !0)}] (
			elementSize = 4
			interpolation = "vertex"
		)` : ""}
		${n.skinWeight ? `float[] primvars:skel:jointWeights = [${_b(n.skinWeight)}] (
			elementSize = 4
			interpolation = "vertex"
		)` : ""}
		${n.color ? `color3f[] primvars:displayColor = [${Md(n.color, o)}] (
			interpolation = "vertex"
		)` : ""}
        uniform token subdivisionScheme = "none"
    }
}
${e ? `
# This is a workaround for QuickLook/RealityKit not supporting the doubleSided attribute. We're adding a second
# geometry definition here, that uses the same mesh data but appends extra faces with reversed winding order.
def "${i}_doubleSided" (
	prepend references = </Geometry>
)
{
	over "Geometry"
	{
		int[] faceVertexCounts = [${hp(s) + ", " + hp(s)}]
		int[] faceVertexIndices = [${dp(s) + ", " + dp(s, !0)}]
	}
}
` : ""}
`;
}
function hp(s) {
  const t = s.index !== null ? s.index.count : s.attributes.position.count;
  return Array(Math.floor(t / 3)).fill(3).join(", ");
}
function dp(s, t = !1) {
  const e = s.index, i = [];
  if (e !== null)
    for (let n = 0; n < e.count; n++) {
      let o = n;
      t && (o = n % 3 === 0 ? n + 2 : n % 3 === 2 ? n - 2 : n), i.push(e.getX(o));
    }
  else {
    const n = s.attributes.position.count;
    for (let o = 0; o < n; o++) {
      let a = o;
      t && (a = o % 3 === 0 ? o + 2 : o % 3 === 2 ? o - 2 : o), i.push(a);
    }
  }
  return i.join(", ");
}
function up(s, t) {
  const e = t.itemSize;
  switch (e) {
    case 2:
      return `texCoord2f[] primvars:${s} = [${_w(t, e, !0)}] (
				interpolation = "vertex"
			)`;
    case 3:
      return `texCoord3f[] primvars:${s} = [${Md(t, e)}] (
				interpolation = "vertex"
			)`;
    case 4:
      return `double4[] primvars:${s} = [${$k(t, e)}] (
				interpolation = "vertex"
			)`;
    default:
      return console.warn("USDZExporter: Attribute with " + e + " components are currently not supported. Results may be undefined for " + s + "."), "";
  }
}
function Md(s, t) {
  if (s === void 0)
    return console.warn("USDZExporter: A mesh attribute is missing and will be set with placeholder data. The result may look incorrect."), Array(t).fill("(0, 0, 1)").join(", ");
  const e = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), a = s.getZ(i);
    e.push(`(${n.toPrecision(Ie)}, ${o.toPrecision(Ie)}, ${a.toPrecision(Ie)})`);
  }
  return e.join(", ");
}
function $k(s, t) {
  if (s === void 0)
    return console.warn("USDZExporter: Attribute is missing. Results may be undefined."), Array(t).fill("(0, 0, 0, 0)").join(", ");
  const e = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), a = s.getZ(i) || 0, l = s.getW(i) || 0;
    e.push(`(${n.toPrecision(Ie)}, ${o.toPrecision(Ie)}, ${a.toPrecision(Ie)}, ${l.toPrecision(Ie)})`);
  }
  return e.join(", ");
}
function _b(s, t = !1) {
  const e = [];
  for (let i = 0; i < s.count; i++) {
    const n = s.getX(i), o = s.getY(i), a = s.getZ(i), l = s.getW(i);
    e.push(`${t ? n : n.toPrecision(Ie)}`), e.push(`${t ? o : o.toPrecision(Ie)}`), e.push(`${t ? a : a.toPrecision(Ie)}`), e.push(`${t ? l : l.toPrecision(Ie)}`);
  }
  return e.join(", ");
}
function _w(s, t, e = !1) {
  if (s === void 0)
    return console.warn("USDZExporter: UVs missing."), Array(t).fill("(0, 0)").join(", ");
  const i = [];
  for (let n = 0; n < s.count; n++) {
    const o = s.getX(n);
    let a = s.getY(n);
    e && (a = 1 - a), i.push(`(${o.toPrecision(Ie)}, ${a.toPrecision(Ie)})`);
  }
  return i.join(", ");
}
function Wk(s, t, e = !1) {
  const i = [];
  for (const n in s) {
    const o = s[n];
    i.push(Vk(o, t, e));
  }
  return `
	def "Materials"
    {
${i.join("")}
    }`;
}
function Vk(s, t, e = !1) {
  var g, _, y;
  const i = Xg(s);
  if (s.colorWrite === !1 || ((g = s.userData) == null ? void 0 : g.isShadowCatcherMaterial) || ((_ = s.userData) == null ? void 0 : _.isLightBlendMaterial)) {
    const b = s.userData.isLightBlendMaterial || s.userData.isShadowCatcherMaterial ? "ND_realitykit_shadowreceiver_surfaceshader" : "ND_realitykit_occlusion_surfaceshader";
    return `

		def Material "${i}" ${s.name ? `(
			displayName = "${s.name}"
		)` : ""}
		{
			token outputs:mtlx:surface.connect = ${Vt}/${i}/Occlusion.outputs:out>

			def Shader "Occlusion"
			{
				uniform token info:id = "${b}"
				token outputs:out
			}
		}`;
  }
  const o = "                ", a = [], l = [], c = /* @__PURE__ */ new Set();
  function h(b) {
    var w;
    return qn(b.name) + "_" + (((w = b.source) == null ? void 0 : w.id) ?? b.id);
  }
  function d(b, w, P = void 0, k = void 0) {
    const O = h(b), M = O + (k !== void 0 && k !== 1 ? "_" + k : ""), E = e && k !== void 0 && k !== 1, B = E ? new me(1, 1, 1, k) : void 0;
    k === void 0 && (k = 1), E && (k = 1), B && B.w <= 0.05 && (B.w = 0.05), t[M] = { texture: b, scale: B };
    const A = b.channel > 0 ? "st" + b.channel : "st";
    c.add(b.channel);
    const F = yw.includes(b.format), U = {
      1e3: "repeat",
      // RepeatWrapping
      1001: "clamp",
      // ClampToEdgeWrapping
      1002: "mirror"
      // MirroredRepeatWrapping
    }, Z = b.repeat.clone(), T = b.offset.clone(), j = b.rotation, H = Math.sin(j), Y = Math.cos(j);
    T.y = 1 - T.y - Z.y, e ? (Z.x === 0 && (Z.x = 1e-4), Z.y === 0 && (Z.y = 1e-4), T.x = T.x / Z.x, T.y = T.y / Z.y, T.x += H / Z.x, T.y += Y - 1) : (T.x += H * Z.x, T.y += (1 - Y) * Z.y);
    const te = Z.x != 1 || Z.y != 1 || T.x != 0 || T.y != 0 || j != 0, le = `${Vt}/${i}/${"uvReader_" + A}.outputs:result>`, de = `${Vt}/${i}/Transform2d_${w}.outputs:result>`, De = w !== "normal" && P && (P.r !== 1 || P.g !== 1 || P.b !== 1 || k !== 1) || !1, Ct = w === "normal", ai = s instanceof It && s.normalScale ? s.normalScale.x * 2 : 2, $t = ai.toFixed(Ie), Vr = (-1 * (ai / 2)).toFixed(Ie), Ns = (1 - ai).toFixed(Ie);
    return `
			${te ? `def Shader "Transform2d_${w}" (
				sdrMetadata = {
					string role = "math"
				}
			)
			{
				uniform token info:id = "UsdTransform2d"
				float2 inputs:in.connect = ${le}
				float2 inputs:scale = ${bb(Z)}
				float2 inputs:translation = ${bb(T)}
				float inputs:rotation = ${(j / Math.PI * 180).toFixed(Ie)}
				float2 outputs:result
			}
			` : ""}
			def Shader "${O}_${w}"
			{
				uniform token info:id = "UsdUVTexture"
				asset inputs:file = @textures/${M}.${F ? "png" : "jpg"}@
				token inputs:sourceColorSpace = "${b.colorSpace === "srgb" ? "sRGB" : "raw"}"
				float2 inputs:st.connect = ${te ? de : le}
				${De ? `
				float4 inputs:scale = (${P ? P.r + ", " + P.g + ", " + P.b : "1, 1, 1"}, ${k})
				` : ""}
				${Ct ? `
				float4 inputs:scale = (${$t}, ${$t}, ${$t}, 1)
				float4 inputs:bias = (${Vr}, ${Vr}, ${Ns}, 0)
				` : ""}
				token inputs:wrapS = "${U[b.wrapS]}"
				token inputs:wrapT = "${U[b.wrapT]}"
				float outputs:r
				float outputs:g
				float outputs:b
				float3 outputs:rgb
				${s.transparent || s.alphaTest > 0 ? "float outputs:a" : ""}
			}`;
  }
  let u = s.transparent || s.alphaTest ? s.opacity : 1, p = !1, m = !1;
  if (s instanceof Jp && s.transmission !== void 0 && (u *= 1 - s.transmission * (1 - s.roughness * 0.5)), s.map ? (a.push(`${o}color3f inputs:diffuseColor.connect = ${Vt}/${i}/${h(s.map)}_diffuse.outputs:rgb>`), s instanceof Me && s.transparent && s.alphaTest == 0 && e ? (a.push(`${o}float inputs:opacity.connect = ${Vt}/${i}/${h(s.map)}_diffuse.outputs:a>`), p = !0, a.push(`${o}float inputs:opacityThreshold = ${1e-10}`), m = !0) : s.transparent ? (a.push(`${o}float inputs:opacity.connect = ${Vt}/${i}/${h(s.map)}_diffuse.outputs:a>`), p = !0) : s.alphaTest > 0 && (a.push(`${o}float inputs:opacity.connect = ${Vt}/${i}/${h(s.map)}_diffuse.outputs:a>`), p = !0, a.push(`${o}float inputs:opacityThreshold = ${s.alphaTest}`), m = !0), l.push(d(s.map, "diffuse", s.color, u))) : a.push(`${o}color3f inputs:diffuseColor = ${yb(s.color)}`), s.alphaHash && e && (m ? console.warn("Opacity threshold for " + s.name + " was already connected. Skipping alphaHash opacity threshold.") : (a.push(`${o}float inputs:opacityThreshold = 0.0000000001`), m = !0)), s.aoMap && (a.push(`${o}float inputs:occlusion.connect = ${Vt}/${i}/${h(s.aoMap)}_occlusion.outputs:r>`), l.push(d(s.aoMap, "occlusion"))), s.alphaMap ? (a.push(`${o}float inputs:opacity.connect = ${Vt}/${i}/${h(s.alphaMap)}_opacity.outputs:r>`), a.push(`${o}float inputs:opacityThreshold = 0.0000000001`), p = !0, m = !0, l.push(d(s.alphaMap, "opacity", new ae(1, 1, 1), u))) : (p ? console.warn("Opacity for " + s.name + " was already connected. Skipping default opacity.") : (a.push(`${o}float inputs:opacity = ${u}`), p = !0), s.alphaTest > 0 && (m ? console.warn("Opacity threshold for " + s.name + " was already connected. Skipping default opacity threshold.") : (a.push(`${o}float inputs:opacityThreshold = ${s.alphaTest}`), m = !0))), s instanceof It) {
    if (s.emissiveMap) {
      a.push(`${o}color3f inputs:emissiveColor.connect = ${Vt}/${i}/${h(s.emissiveMap)}_emissive.outputs:rgb>`);
      const b = s.emissive.clone();
      b.multiplyScalar(s.emissiveIntensity), l.push(d(s.emissiveMap, "emissive", b));
    } else if (((y = s.emissive) == null ? void 0 : y.getHex()) > 0) {
      const b = s.emissive.clone();
      b.multiplyScalar(s.emissiveIntensity), a.push(`${o}color3f inputs:emissiveColor = ${yb(b)}`);
    }
    s.normalMap && (a.push(`${o}normal3f inputs:normal.connect = ${Vt}/${i}/${h(s.normalMap)}_normal.outputs:rgb>`), l.push(d(s.normalMap, "normal"))), s.roughnessMap && s.roughness === 1 ? (a.push(`${o}float inputs:roughness.connect = ${Vt}/${i}/${h(s.roughnessMap)}_roughness.outputs:g>`), l.push(d(s.roughnessMap, "roughness"))) : a.push(`${o}float inputs:roughness = ${s.roughness !== void 0 ? s.roughness : 1}`), s.metalnessMap && s.metalness === 1 ? (a.push(`${o}float inputs:metallic.connect = ${Vt}/${i}/${h(s.metalnessMap)}_metallic.outputs:b>`), l.push(d(s.metalnessMap, "metallic"))) : a.push(`${o}float inputs:metallic = ${s.metalness !== void 0 ? s.metalness : 0}`);
  }
  return s instanceof Jp && (a.push(`${o}float inputs:clearcoat = ${s.clearcoat}`), a.push(`${o}float inputs:clearcoatRoughness = ${s.clearcoatRoughness}`), a.push(`${o}float inputs:ior = ${s.ior}`), !s.transparent && !(s.alphaTest > 0) && s.transmissionMap && (a.push(`${o}float inputs:opacity.connect = ${Vt}/${i}/${h(s.transmissionMap)}_transmission.outputs:r>`), l.push(d(s.transmissionMap, "transmission")))), c.size > 2 ? console.warn("USDZExporter: Material " + s.name + " uses more than 2 UV channels. Currently, only UV0 and UV1 are supported.") : c.size === 2 && (!c.has(0) || !c.has(1)) && console.warn("USDZExporter: Material " + s.name + " uses UV channels other than 0 and 1. Currently, only UV0 and UV1 are supported."), `

		def Material "${i}" ${s.name ? `(
			displayName = "${cw(s.name)}"
		)` : ""}
		{
			token outputs:surface.connect = ${Vt}/${i}/PreviewSurface.outputs:surface>

			def Shader "PreviewSurface"
			{
				uniform token info:id = "UsdPreviewSurface"
${a.join(`
`)}
				int inputs:useSpecularWorkflow = ${s instanceof Me ? "1" : "0"}
				token outputs:surface
			}
${l.length > 0 ? `
${c.has(0) ? `
			def Shader "uvReader_st"
			{
				uniform token info:id = "UsdPrimvarReader_float2"
				token inputs:varname = "st"
				float2 inputs:fallback = (0.0, 0.0)
				float2 outputs:result
			}
` : ""}
${c.has(1) ? `
			def Shader "uvReader_st1"
			{
				uniform token info:id = "UsdPrimvarReader_float2"
				token inputs:varname = "st1"
				float2 inputs:fallback = (0.0, 0.0)
				float2 outputs:result
			}
` : ""}
${l.join(`
`)}` : ""}
		}`;
}
function yb(s) {
  return `(${s.r}, ${s.g}, ${s.b})`;
}
function bb(s) {
  return `(${s.x}, ${s.y})`;
}
const yw = [
  // uncompressed formats with alpha channel
  1023,
  // RGBAFormat
  // compressed formats with alpha channel
  33777,
  // RGBA_S3TC_DXT1_Format
  33778,
  // RGBA_S3TC_DXT3_Format
  33779,
  // RGBA_S3TC_DXT5_Format
  35842,
  // RGBA_PVRTC_4BPPV1_Format
  35843,
  // RGBA_PVRTC_2BPPV1_Format
  37496,
  // RGBA_ETC2_EAC_Format
  37808,
  // RGBA_ASTC_4x4_Format
  37809,
  // RGBA_ASTC_5x4_Format
  37810,
  // RGBA_ASTC_5x5_Format
  37811,
  // RGBA_ASTC_6x5_Format
  37812,
  // RGBA_ASTC_6x6_Format
  37813,
  // RGBA_ASTC_8x5_Format
  37814,
  // RGBA_ASTC_8x6_Format
  37815,
  // RGBA_ASTC_8x8_Format
  37816,
  // RGBA_ASTC_10x5_Format
  37817,
  // RGBA_ASTC_10x6_Format
  37818,
  // RGBA_ASTC_10x8_Format
  37819,
  // RGBA_ASTC_10x10_Format
  37820,
  // RGBA_ASTC_12x10_Format
  37821,
  // RGBA_ASTC_12x12_Format
  36492
  // RGBA_BPTC_Format
];
x("debugusdz");
const k_ = class {
  constructor(t, e, i) {
    r(this, "id");
    r(this, "trigger");
    r(this, "action");
    r(this, "exclusive", !1);
    this.id = "Behavior_" + qn(t) + "_" + k_.global_id++, this.trigger = e, this.action = i;
  }
  makeExclusive(t) {
    return this.exclusive = t, this;
  }
  writeTo(t, e, i) {
    if (!this.trigger || !this.action)
      return;
    i.beginBlock(`def Preliminary_Behavior "${this.id}"`);
    let n = "";
    if (Array.isArray(this.trigger)) {
      n = "[";
      for (let o = 0; o < this.trigger.length; o++) {
        const a = this.trigger[o];
        n += "<" + a.id + ">", o + 1 < this.trigger.length && (n += ", ");
      }
      n += "]";
    } else
      n = `<${this.trigger.id}>`;
    if (i.appendLine(`rel triggers = ${n}`), i.appendLine(`rel actions = <${this.action.id}>`), i.appendLine(`uniform bool exclusive = ${this.exclusive ? 1 : 0}`), i.appendLine(), Array.isArray(this.trigger))
      for (const o of this.trigger)
        o.writeTo(e, i), i.appendLine();
    else
      this.trigger.writeTo(e, i);
    i.appendLine(), this.action.writeTo(e, i), i.closeBlock();
  }
};
let kt = k_;
r(kt, "global_id", 0);
const Kr = /* @__PURE__ */ new Set();
function jm(s, t) {
  var i, n;
  let e = "";
  if (Array.isArray(s)) {
    Kr.clear();
    let o = "[ ";
    for (let a = 0; a < s.length; a++) {
      let l = s[a];
      if (!l) {
        console.warn("Invalid target object in behavior", s + ". Is the object exported?");
        continue;
      }
      if (typeof l == "string") {
        if (Kr.has(l))
          continue;
        o += l, Kr.add(l);
      } else if (typeof l == "object") {
        if (l.isObject3D && (l = t.findById(l.uuid), !l)) {
          console.warn("Invalid target object in behavior", s + ". Is the object exported?");
          continue;
        }
        const c = (i = l.getPath) == null ? void 0 : i.call(l);
        if (Kr.has(c))
          continue;
        o += c, Kr.add(c);
      }
      a + 1 < s.length && (o += ", ");
    }
    o += " ]", e = o, Kr.clear();
  } else if (typeof s == "object") {
    const o = s;
    if (o.isObject3D && (s = t.findById(o.uuid)), !s)
      throw console.error("Invalid target object in behavior, the target object is likely missing from USDZ export. Is the object exported?", o), new Error(`Invalid target object in behavior, the target object is likely missing from USDZ export. Please report a bug. uuid: ${o.uuid}.`);
    e = (n = s.getPath) == null ? void 0 : n.call(s);
  }
  return e;
}
const T_ = class {
  constructor(t, e) {
    r(this, "id");
    r(this, "targetId");
    r(this, "tokenId");
    r(this, "type");
    r(this, "distance");
    t && (this.targetId = t), e ? this.id = e : this.id = "Trigger_" + T_.global_id++;
  }
  writeTo(t, e) {
    e.beginBlock(`def Preliminary_Trigger "${this.id}"`), this.targetId && (typeof this.targetId != "string" && (this.targetId = jm(this.targetId, t)), e.appendLine("rel affectedObjects = " + this.targetId)), this.tokenId && e.appendLine(`token info:id = "${this.tokenId}"`), this.type && e.appendLine(`token type = "${this.type}"`), typeof this.distance == "number" && e.appendLine(`double distance = ${this.distance}`), e.closeBlock();
  }
};
let _o = T_;
r(_o, "global_id", 0);
function vb(s, t = { direct: !0, indirect: !0 }) {
  const e = Lt.createEmpty();
  e.name = "InputTarget_" + e.name, e.displayName = void 0, e.type = "RealityKitComponent", e.onSerialize = (i) => {
    i.appendLine("bool allowsDirectInput = " + (t.direct ? 1 : 0)), i.appendLine("bool allowsIndirectInput = " + (t.indirect ? 1 : 0)), i.appendLine('uniform token info:id = "RealityKit.InputTarget"');
  }, s.add(e);
}
class Ft {
  static sceneStartTrigger() {
    if (this.__sceneStartTrigger !== void 0)
      return this.__sceneStartTrigger;
    const t = new _o(void 0, "SceneStart");
    return t.tokenId = "SceneTransition", t.type = "enter", this.__sceneStartTrigger = t, t;
  }
  /** Trigger that fires when an object has been tapped/clicked.
   * @param targetObject The object or list of objects that can be interacted with.
   * @param inputMode Input Mode (direct and/or indirect). Only available for USDObject targets. Only supported on Vision OS at the moment. */
  static tapTrigger(t, e = { direct: !0, indirect: !0 }) {
    const i = new _o(t);
    if (Array.isArray(t) && t.length > 1)
      for (const n of t)
        n instanceof Lt && vb(n, e);
    else
      t instanceof Lt && vb(t, e);
    return i.tokenId = "TapGesture", i;
  }
  static isTapTrigger(t) {
    return (t == null ? void 0 : t.tokenId) === "TapGesture";
  }
  static proximityToCameraTrigger(t, e) {
    const i = new _o(t);
    return i.tokenId = "ProximityToCamera", i.distance = e, i;
  }
}
r(Ft, "__sceneStartTrigger");
class nr {
  constructor(t, e) {
    r(this, "id");
    r(this, "actions");
    r(this, "loops", 0);
    r(this, "performCount", 1);
    r(this, "type", "serial");
    r(this, "multiplePerformOperation");
    this.id = t, this.actions = e;
  }
  static getId() {
    return this.global_id++;
  }
  addAction(t) {
    return this.actions.push(t), this;
  }
  makeParallel() {
    return this.type = "parallel", this;
  }
  makeSequence() {
    return this.type = "serial", this;
  }
  makeLooping() {
    return this.loops = 1, this.performCount = 0, this;
  }
  makeRepeat(t) {
    return this.performCount = t, this;
  }
  writeTo(t, e) {
    e.beginBlock(`def Preliminary_Action "${this.id}"`), e.beginArray("rel actions");
    for (const i of this.actions) {
      if (!i)
        continue;
      const n = i === this.actions[this.actions.length - 1];
      e.appendLine("<" + i.id + ">" + (n ? "" : ", "));
    }
    e.closeArray(), e.appendLine(), e.appendLine('token info:id = "Group"'), e.appendLine(`bool loops = ${this.loops}`), e.appendLine(`int performCount = ${this.loops > 0 ? 0 : Math.max(0, this.performCount)}`), e.appendLine(`token type = "${this.type}"`), typeof this.multiplePerformOperation == "string" && e.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`), e.appendLine();
    for (const i of this.actions)
      i && (i.writeTo(t, e), e.appendLine());
    e.closeBlock();
  }
}
r(nr, "global_id", 0);
const pu = class {
  constructor(t, e) {
    r(this, "id");
    r(this, "tokenId");
    r(this, "affectedObjects");
    r(this, "easeType");
    r(this, "motionType");
    r(this, "duration");
    r(this, "moveDistance");
    r(this, "style");
    r(this, "type");
    // combined types of different actions
    r(this, "front");
    r(this, "up");
    r(this, "start");
    r(this, "animationSpeed");
    r(this, "reversed");
    r(this, "pingPong");
    r(this, "xFormTarget");
    r(this, "audio");
    r(this, "gain");
    r(this, "auralMode");
    r(this, "multiplePerformOperation");
    r(this, "velocity");
    // extra info written as comment at the beginning of the action
    r(this, "comment");
    r(this, "animationName");
    t && (this.affectedObjects = t), e ? this.id = e : this.id = "Action", this.id += "_" + pu.global_id++;
  }
  clone() {
    const t = new pu(), e = t.id;
    return Object.assign(t, this), t.id = e, t;
  }
  writeTo(t, e) {
    e.beginBlock(`def Preliminary_Action "${this.id}"`), this.comment && e.appendLine(`# ${this.comment}`), this.affectedObjects && (typeof this.affectedObjects != "string" && (this.affectedObjects = jm(this.affectedObjects, t)), e.appendLine("rel affectedObjects = " + this.affectedObjects)), typeof this.duration == "number" && (typeof this.animationSpeed == "number" && this.animationSpeed !== 1 ? e.appendLine(`double duration = ${this.duration / this.animationSpeed} `) : e.appendLine(`double duration = ${this.duration} `)), this.easeType && e.appendLine(`token easeType = "${this.easeType}"`), this.tokenId && e.appendLine(`token info:id = "${this.tokenId}"`), this.tokenId === "ChangeScene" && e.appendLine("rel scene = </StageRoot/Scenes/Scene>"), this.motionType !== void 0 && e.appendLine(`token motionType = "${this.motionType}"`), typeof this.moveDistance == "number" && e.appendLine(`double moveDistance = ${this.moveDistance} `), this.style && e.appendLine(`token style = "${this.style}"`), this.type && e.appendLine(`token type = "${this.type}"`), this.front && e.appendLine(`vector3d front = (${this.front.x}, ${this.front.y}, ${this.front.z})`), this.up && e.appendLine(`vector3d upVector = (${this.up.x}, ${this.up.y}, ${this.up.z})`), typeof this.start == "number" && e.appendLine(`double start = ${this.start} `), typeof this.animationSpeed == "number" && e.appendLine(`double animationSpeed = ${this.animationSpeed.toFixed(2)} `), typeof this.reversed == "boolean" && e.appendLine(`bool reversed = ${this.reversed}`), typeof this.pingPong == "boolean" && e.appendLine(`bool reverses = ${this.pingPong}`), this.xFormTarget && (typeof this.xFormTarget != "string" && (this.xFormTarget = jm(this.xFormTarget, t)), e.appendLine(`rel xformTarget = ${this.xFormTarget}`)), typeof this.audio == "string" && e.appendLine(`asset audio = @${this.audio}@`), typeof this.gain == "number" && e.appendLine(`double gain = ${this.gain}`), typeof this.auralMode == "string" && e.appendLine(`token auralMode = "${this.auralMode}"`), typeof this.multiplePerformOperation == "string" && e.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`), typeof this.velocity == "object" && e.appendLine(`vector3d velocity = (${this.velocity.x}, ${this.velocity.y}, ${this.velocity.z})`), e.closeBlock();
  }
};
let bi = pu;
r(bi, "global_id", 0);
class Ki {
  constructor(t, e, i) {
    r(this, "x", 0);
    r(this, "y", 0);
    r(this, "z", 0);
    this.x = t, this.y = e, this.z = i;
  }
  static get up() {
    return new Ki(0, 1, 0);
  }
  static get right() {
    return new Ki(1, 0, 0);
  }
  static get forward() {
    return new Ki(0, 0, 1);
  }
  static get back() {
    return new Ki(0, 0, -1);
  }
  static get zero() {
    return new Ki(0, 0, 0);
  }
}
class ge {
  static sequence(...t) {
    return new nr("Group_" + nr.getId(), t).makeSequence();
  }
  static parallel(...t) {
    return new nr("Group_" + nr.getId(), t).makeParallel();
  }
  static fadeAction(t, e, i) {
    const n = new bi(t);
    return n.tokenId = "Visibility", n.type = i ? "show" : "hide", n.duration = e, n.style = "basic", n.motionType = "none", n.moveDistance = 0, n.easeType = "none", n;
  }
  /**
   * creates an action that plays an animation
   * @param start offset in seconds!
   * @param duration in seconds! 0 means play to end
   */
  static startAnimationAction(t, e, i = !1, n = !1) {
    const o = new bi(t);
    o.tokenId = "StartAnimation";
    const a = e.start, l = e.duration, c = e.speed, h = e.clipName;
    if (o.comment = `Animation: ${h}, start=${a * 60}, length=${l * 60}, end=${(a + l) * 60}`, o.animationName = h, o.start = a, o.duration = l, o.animationSpeed = c, o.reversed = i, o.pingPong = n, o.multiplePerformOperation = "allow", i && (o.start -= l), n) {
      o.pingPong = !1;
      const d = o.clone();
      return d.reversed = !i, d.start = o.start, d.reversed && (d.start -= l), ge.sequence(o, d);
    }
    return o;
  }
  static waitAction(t) {
    const e = new bi();
    return e.tokenId = "Wait", e.duration = t, e.motionType = void 0, e;
  }
  static lookAtCameraAction(t, e, i, n) {
    const o = new bi(t);
    return o.tokenId = "LookAtCamera", o.duration = e === void 0 ? 9999999999999 : e, o.front = i ?? Ki.forward, o.up = n ?? Ki.up, o;
  }
  static emphasize(t, e, i = "bounce", n = 1, o = "basic") {
    const a = new bi(t);
    return a.tokenId = "Emphasize", a.duration = e, a.style = o ?? "basic", a.motionType = i, a.moveDistance = n, a;
  }
  static transformAction(t, e, i, n, o = "inout") {
    const a = new bi(t);
    return a.tokenId = "Transform", a.duration = i, a.duration = Math.max(1e-6, i), a.type = n, a.easeType = i > 0 ? o : "none", Array.isArray(e) && console.error("Transform target must not be an array", e), a.xFormTarget = e, a;
  }
  static playAudioAction(t, e, i = "play", n = 1, o = "spatial") {
    const a = new bi(t);
    return a.tokenId = "Audio", a.type = i, a.audio = e, a.gain = n, a.auralMode = o, a.multiplePerformOperation = "allow", a;
  }
  // Supported only on VisionOS, Preliminary Behaviours can affect RealityKit physics as well
  static impulseAction(t, e) {
    const i = new bi(t);
    return i.tokenId = "Impulse", i.velocity = e, i;
  }
  // Currently doesn't work on VisionOS, see FB13761990
  /*
  static reloadSceneAction() {
      const act = new ActionModel();
      act.tokenId = "ChangeScene";
      // rel scene = ... is implicit since we only allow one scene right now
      return act;
  }
  */
}
class Hk {
  constructor(t) {
    r(this, "object");
    r(this, "model");
    this.object = t;
  }
  get id() {
    return this.object.uuid;
  }
  apply(t) {
    if (!this.model && (this.model = t.findById(this.object.uuid), !this.model)) {
      console.error("could not find model with id " + this.object.uuid);
      return;
    }
    this.onApply(t);
  }
}
class bw extends Hk {
  constructor(e, i, n, o) {
    super(e);
    r(this, "matrix");
    r(this, "material");
    r(this, "geometry");
    r(this, "_enableAction");
    r(this, "_disableAction");
    this.matrix = i, this.material = n, this.geometry = o;
  }
  onApply(e) {
    var o, a;
    const i = this.model;
    if (!i)
      return;
    (o = i.parent) != null && o.isDynamic || Lt.createEmptyParent(i);
    const n = i.clone();
    this.matrix && n.setMatrix(this.matrix), this.material && (n.material = this.material), this.geometry && (n.geometry = this.geometry), (a = i.parent) == null || a.add(n);
  }
  enable() {
    return this._enableAction ? this._enableAction : (this._enableAction = ge.fadeAction(this.object, 0, !0), this._enableAction);
  }
  disable() {
    return this._disableAction ? this._disableAction : (this._disableAction = ge.fadeAction(this.object, 0, !1), this._disableAction);
  }
}
class Gk {
  constructor(t) {
    r(this, "actions");
    r(this, "sortedActions");
    this.actions = [...t];
  }
  // organize is called once when getting an action for the first time
  // the sorted actions are baked then and adding new actions will not be added anymore
  organize() {
    this.sortedActions = {};
    for (const t of this.actions) {
      const e = t.id;
      this.sortedActions[e] || (this.sortedActions[e] = []), this.sortedActions[e].push(t);
    }
  }
  /** returns all document actions affecting the object passed in */
  getActions(t) {
    return this.sortedActions || this.organize(), this.sortedActions[t.uuid];
  }
}
const Ln = x("debugusdzanimation"), Bm = x("debugusdzanimationserialization");
class sr {
  constructor(t, e, i) {
    r(this, "_start");
    r(this, "ext");
    r(this, "root");
    r(this, "_nearestAnimatedRoot");
    r(this, "clip");
    // Playback speed. Does not affect how the animation is written, just how fast actions play it back.
    r(this, "speed");
    this.ext = t, this.root = e, this.clip = i, this._nearestAnimatedRoot = this.getNearestAnimatedRoot();
  }
  get start() {
    return this._start === void 0 && (this._start = this.ext.getStartTimeByClip(this.clip)), this._start;
  }
  get duration() {
    var t;
    return ((t = this.clip) == null ? void 0 : t.duration) ?? $e.restPoseClipDuration;
  }
  get nearestAnimatedRoot() {
    return this._nearestAnimatedRoot;
  }
  get clipName() {
    var t;
    return ((t = this.clip) == null ? void 0 : t.name) ?? "rest";
  }
  static isDescendantOf(t, e) {
    let i = e;
    if (!i || !t)
      return !1;
    for (; i; ) {
      if (!i)
        return !1;
      if (i === t)
        return !0;
      i = i.parent;
    }
    return !1;
  }
  /** Finds the nearest actually animated object under root based on the tracks in the AnimationClip. */
  getNearestAnimatedRoot() {
    var e;
    let t;
    try {
      for (const i of ((e = this.clip) == null ? void 0 : e.tracks) ?? []) {
        const n = La.parseTrackName(i.name);
        let o = La.findNode(this.root, n.nodeName);
        if (o)
          if (!t)
            t = o;
          else {
            if (o === t || sr.isDescendantOf(t, o))
              continue;
            if (!sr.isDescendantOf(o, t)) {
              for (; !sr.isDescendantOf(o, t) && o.parent; )
                o = o.parent;
              sr.isDescendantOf(o, t) || console.error("USDZExporter: Animation clip targets multiple roots that are not parent/child. Please report a bug", this.root, this.clip, t, o);
            }
            t = o;
          }
      }
    } catch (i) {
      console.error("USDZExporter: Exception when trying to find nearest animated root. Please report a bug", i), t = void 0;
    }
    return t;
  }
}
const kc = class {
  constructor(t, e, i) {
    r(this, "clip");
    r(this, "pos");
    r(this, "rot");
    r(this, "scale");
    r(this, "root");
    r(this, "target");
    r(this, "duration", 0);
    r(this, "useRootMotion", !1);
    if (this.root = t, this.target = e, this.clip = i, i ? this.duration = i.duration : this.duration = kc.restPoseClipDuration, i && i.tracks) {
      const o = Math.max(...i.tracks.map((a) => a.times[a.times.length - 1]));
      o !== this.duration && (console.warn("USDZExporter: Animation clip duration does not match the maximum time value in the tracks.", i, o, this.duration), this.duration = o);
    }
    const n = S.getComponent(t, zt);
    n && (this.useRootMotion = n.applyRootMotion);
  }
  addTrack(t) {
    var e, i;
    if (!this.clip) {
      console.error("This is a rest clip but you're trying to add tracks to it – this is likely a bug");
      return;
    }
    t.name.endsWith("position") ? this.pos = t : t.name.endsWith("quaternion") ? this.rot = t : t.name.endsWith("scale") ? this.scale = t : (t.name.endsWith("activeSelf") ? console.warn("[USDZ] Animation of enabled/disabled state is not supported for USDZ export and will NOT be exported: " + t.name + " on " + (((e = this.root) == null ? void 0 : e.name) ?? this.target.name) + ". Animate scale 0/1 instead.") : console.warn("[USDZ] Animation track type not supported for USDZ export and will NOT be exported: " + t.name + " on " + (((i = this.root) == null ? void 0 : i.name) ?? this.target.name) + ". Only .position, .rotation, .scale are supported."), z() && ve("[USDZ] Some animations can't be exported. See console for details."));
  }
  getFrames() {
    var t, e, i, n, o, a;
    return this.clip ? Math.max(((e = (t = this.pos) == null ? void 0 : t.times) == null ? void 0 : e.length) ?? 0, ((n = (i = this.rot) == null ? void 0 : i.times) == null ? void 0 : n.length) ?? 0, ((a = (o = this.scale) == null ? void 0 : o.times) == null ? void 0 : a.length) ?? 0) : 2;
  }
  getDuration() {
    return this.duration;
  }
  getSortedTimesArray(t = !0, e = !0, i = !0) {
    var c, h, d;
    if (!this.clip)
      return [0, this.duration];
    const n = (c = this.pos) == null ? void 0 : c.times, o = (h = this.rot) == null ? void 0 : h.times, a = (d = this.scale) == null ? void 0 : d.times, l = [];
    if (t && n)
      for (const u of n)
        l.push(u);
    if (e && o)
      for (const u of o)
        l.push(u);
    if (i && a)
      for (const u of a)
        l.push(u);
    return l.includes(0) || l.push(0), l.sort((u, p) => u - p), [...new Set(l)];
  }
  /**
   * Returns an iterator that yields the values for each time sample. 
   * Values are reused objects - if you want to append them to some array 
   * instead of processing them right away, clone() them.
   * @param timesArray 
   * @param generatePos 
   * @param generateRot 
   * @param generateScale 
   */
  *getValues(t, e = !0, i = !0, n = !0) {
    var m, g, _;
    const o = new v(), a = new W(), l = new v(1, 1, 1), c = this.target, h = e ? (m = this.pos) == null ? void 0 : m.createInterpolant() : void 0, d = i ? (g = this.rot) == null ? void 0 : g.createInterpolant() : void 0, u = n ? (_ = this.scale) == null ? void 0 : _.createInterpolant() : void 0;
    h || o.set(c.position.x, c.position.y, c.position.z), d || a.set(c.quaternion.x, c.quaternion.y, c.quaternion.z, c.quaternion.w), u || l.set(c.scale.x, c.scale.y, c.scale.z), h && h.valueSize !== 3 && (h.valueSize = 3), d && d.valueSize !== 4 && (d.valueSize = 4), u && u.valueSize !== 3 && (u.valueSize = 3);
    const p = 0;
    for (let y = 0 - p; y < t.length + p; y++) {
      let b = 0, w = 0;
      if (y < 0 ? (b = t[0], w = b - kc.animationDurationPadding / 2 + 1 / 60) : y >= t.length ? (b = t[t.length - 1], w = b + kc.animationDurationPadding / 2 - 1 / 60) : (b = t[y], w = b), h) {
        const P = h.evaluate(b);
        o.set(P[0], P[1], P[2]);
      }
      if (d) {
        const P = d.evaluate(b);
        a.set(P[0], P[1], P[2], P[3]);
      }
      if (u) {
        const P = u.evaluate(b);
        l.set(P[0], P[1], P[2]);
      }
      if (this.useRootMotion && c === this.root) {
        const P = new se();
        P.compose(o, a, l), P.multiply(c.matrix), P.decompose(o, a, l);
      }
      yield { time: w, translation: o, rotation: a, scale: l, index: y };
    }
  }
};
let $e = kc;
/** This value can theoretically be anything – a value of 1 is good to clearly see animation gaps.
 * For production, a value of 1/60 is enough, since the files can then still properly play back at 60fps.
 */
r($e, "frameRate", 60), r($e, "animationDurationPadding", 6 / 60), r($e, "restPoseClipDuration", 6 / 60);
class Qg {
  constructor(t) {
    /** For each animated object, contains time/pos/rot/scale samples in the format that USD needs,
     *  ready to be written to the .usda file.
     */
    r(this, "dict", /* @__PURE__ */ new Map());
    /** Map of all roots (Animation/Animator or scene) and all targets that they animate.
     *  We need that info so that we can ensure that each target has the same number of TransformData entries
     *  so that switching between animations doesn't result in data "leaking" to another clip.
     */
    r(this, "rootTargetMap", /* @__PURE__ */ new Map());
    r(this, "rootAndClipToRegisteredAnimationMap", /* @__PURE__ */ new Map());
    /** Clips registered for each root */
    r(this, "rootToRegisteredClip", /* @__PURE__ */ new Map());
    r(this, "lastClipEndTime", 0);
    r(this, "clipToStartTime", /* @__PURE__ */ new Map());
    r(this, "clipToHoldClip", /* @__PURE__ */ new Map());
    r(this, "serializers", []);
    /** Determines if we inject a rest pose clip for each root - only makes sense for QuickLook */
    r(this, "injectRestPoses", !1);
    /** Determines if we inject a PlayAnimationOnClick component with "scenestart" trigger - only makes sense for QuickLook */
    r(this, "injectImplicitBehaviours", !1);
    this.injectRestPoses = t, this.injectImplicitBehaviours = t;
  }
  get extensionName() {
    return "animation";
  }
  get animationData() {
    return this.dict;
  }
  get registeredClips() {
    return this.clipToStartTime.keys();
  }
  get animatedRoots() {
    return this.rootTargetMap.keys();
  }
  get holdClipMap() {
    return this.clipToHoldClip;
  }
  getStartTimeCode() {
    return !this.injectRestPoses || this.rootAndClipToRegisteredAnimationMap.size === 0 ? 0 : ($e.restPoseClipDuration + $e.animationDurationPadding) * 60;
  }
  /** Returns the end time code, based on 60 frames per second, for all registered animations.
   * This matches the highest time value in the USDZ file. */
  getEndTimeCode() {
    let t = 0;
    for (const [e, i] of this.rootAndClipToRegisteredAnimationMap) {
      const n = i.start + i.duration;
      n > t && (t = n);
    }
    return t * 60;
  }
  getClipCount(t) {
    var i;
    return ((i = this.rootToRegisteredClip.get(t)) == null ? void 0 : i.length) ?? 0 ?? 0;
  }
  /*
      // TODO why do we have this here and on TransformData? Can RegisteredAnimationInfo not cache this value?
      // TODO we probably want to assert here that this is the same value on all nodes
      getStartTime01(root: Object3D, clip: AnimationClip | null) {
          // This is a rest pose clip, it always starts at 0
          if (!clip) return 0;
  
          const targets = this.rootTargetMap.get(root);
          if (!targets) return 0;
          const transformDatas = this.dict.get(targets[0]);
          if (!transformDatas) {
              console.error("Trying to get start time for root that has no animation data", root, clip, ...this.dict);
              return 0;
          }
  
          let currentStartTime = 0;
          for (let i = 0; i < transformDatas.length; i++) {
              if (transformDatas[i].clip === clip) break;
              currentStartTime += transformDatas[i].getDuration() + TransformData.animationDurationPadding;
          }
  
          return currentStartTime;
      }
      */
  getStartTimeByClip(t) {
    return t ? this.clipToStartTime.has(t) ? this.clipToStartTime.get(t) : (console.error("USDZExporter: Missing start time for clip – please report a bug.", t), 0) : 0;
  }
  // The same clip could be registered for different roots. All of them need written animation data then.
  // The same root could have multiple clips registered to it. If it does, the clips need to write
  // independent time data, so that playing back an animation on that root doesn't result in data "leaking"/"overlapping".
  // The structure we need is:
  // - MyRoot
  //   Animator
  //     - Clip1: CubeScale (only animates MyCube), duration: 3s
  //     - Clip2: SphereRotation (only animates MySphere), duration: 2s
  //   - MyCube
  //   - MySphere
  // Results in:
  // - MyRoot
  //   - MyCube
  //     - # rest clip (0..0.1)
  //     - # CubeScale (0.2..3.2)
  //     - # rest clip for SphereRotation (3.3..5.3)
  //   - MySphere
  //     - # rest clip (0..0.1)
  //     - # rest clip for CubeScale (0.2..3.2)
  //     - # SphereRotation (3.3..5.3)
  /** Register an AnimationClip for a specific root object.
   * @param root The root object that the animation clip is targeting.
   * @param clip The animation clip to register. If null, a rest pose is registered.
   * @returns The registered animation info, which contains the start time and duration of the clip.
   */
  registerAnimation(t, e) {
    var h;
    if (!t)
      return null;
    this.rootTargetMap.has(t) || this.rootTargetMap.set(t, []);
    const i = t.uuid + ((e == null ? void 0 : e.uuid) ?? "-rest");
    if (this.rootAndClipToRegisteredAnimationMap.has(i))
      return this.rootAndClipToRegisteredAnimationMap.get(i);
    Ln && console.log("registerAnimation", t, e);
    const n = this.injectRestPoses ? 1 : 0, o = (((h = this.rootToRegisteredClip.get(t)) == null ? void 0 : h.length) ?? 0) + n, a = this.rootTargetMap.get(t), l = new Set(a);
    if (e && e.tracks)
      for (const d of e.tracks) {
        const u = La.parseTrackName(d.name), p = La.findNode(t, u.nodeName);
        if (!p) {
          console.warn("no object found for track", d.name, "using " + t.name + " instead");
          continue;
        }
        this.dict.has(p) || this.dict.set(p, []);
        const m = this.dict.get(p);
        if (!m) {
          console.warn("no transform data found for target ", p, "at slot " + o + ", this is likely a bug");
          continue;
        }
        l.delete(p), this.injectRestPoses && !m[0] && (console.log("Injecting rest pose", p, e, "at slot", o), m[0] = new $e(null, p, null));
        let g = m[o];
        g || (g = new $e(t, p, e), m[o] = g), g.addTrack(d), a != null && a.includes(p) || a == null || a.push(p);
      }
    Ln && console.log("Unregistered nodes for this clip", l, "clip", e, "at slot", o, "for root", t, "targets", a);
    for (const d of l) {
      const u = this.dict.get(d);
      if (!u)
        continue;
      if (this.injectRestPoses && !u[0]) {
        console.warn("Adding rest pose for ", d, e, "at slot", o, "This is likely a bug, should have been added earlier.");
        const m = new $e(null, d, null);
        u[0] = m;
      }
      let p = u[o];
      p || (Ln && console.log("Adding padding clip for ", d, e, "at slot", o), p = new $e(t, d, e), u[o] = p);
    }
    const c = new sr(this, t, e);
    if (this.rootAndClipToRegisteredAnimationMap.set(i, c), Ln && console.log({ root: t, clip: e, info: c }), e) {
      const d = this.rootToRegisteredClip.get(t);
      if (d ? d.push(e) : this.rootToRegisteredClip.set(t, [e]), !this.clipToStartTime.get(e)) {
        this.lastClipEndTime == null && (this.lastClipEndTime = $e.restPoseClipDuration);
        let p = this.lastClipEndTime + $e.animationDurationPadding, m = p + e.duration;
        const g = Math.round(p * 60) / 60, _ = Math.round(m * 60) / 60;
        Math.abs(g - p) < 0.01 && (p = g), Math.abs(_ - m) < 0.01 && (m = _), p = Math.ceil(p), m = p + e.duration, this.clipToStartTime.set(e, p), this.lastClipEndTime = m;
      }
    }
    return c;
  }
  onAfterHierarchy(t) {
    Ln && console.log("Animation clips per animation target node", this.dict);
  }
  onAfterBuildDocument(t) {
    var e, i;
    Ln && console.log("Animation data", { dict: this.dict, rootTargetMap: this.rootTargetMap, rootToRegisteredClip: this.rootToRegisteredClip });
    for (const n of this.rootTargetMap.keys()) {
      const o = this.rootTargetMap.get(n);
      if (!o)
        continue;
      let a;
      const l = [];
      for (const c of o) {
        const h = this.dict.get(c);
        if (!h) {
          console.error("No data found for target on USDZ export – please report a bug!", c);
          continue;
        }
        a === void 0 && (a = h == null ? void 0 : h.length), a !== (h == null ? void 0 : h.length) && console.error("Different array lengths for targets – please report a bug!", h);
        for (let d = 0; d < h.length; d++) {
          let u = h[d];
          if (!u) {
            const m = d - (this.injectRestPoses ? 1 : 0);
            h[d] = new $e(null, c, this.rootToRegisteredClip.get(n)[m]), u = h[d];
          }
          const p = u.getDuration();
          if (l[d] === void 0)
            l[d] = p;
          else if (l[d] !== p) {
            console.error("Error during UDSZ export: Encountered different animation durations for animated targets. Please report a bug!", { datas: h, target: c }), l[d] = p;
            continue;
          }
        }
      }
    }
    for (const n of this.serializers) {
      const o = (e = n.model) == null ? void 0 : e.parent, a = (o == null ? void 0 : o.isDynamic) === !0;
      Bm && console.log(a, (i = n.model) == null ? void 0 : i.parent), a && n.registerCallback(o);
    }
  }
  onExportObject(t, e, i) {
    S.foreachComponent(t, (o) => {
      const a = o;
      typeof a.createAnimation == "function" && a.createAnimation(this, e, i);
    }, !1);
    const n = new qk(t, this);
    this.serializers.push(n), n.registerCallback(e);
  }
}
class qk {
  constructor(t, e) {
    r(this, "model");
    r(this, "object");
    r(this, "animationData");
    r(this, "ext");
    r(this, "callback");
    this.object = t, this.animationData = e.animationData, this.ext = e;
  }
  registerCallback(t) {
    this.model && this.callback && this.model.removeEventListener("serialize", this.callback), this.callback || (this.callback = this.onSerialize.bind(this)), Bm && console.log("REPARENT", t), this.model = t, this.callback && this.model.addEventListener("serialize", this.callback);
  }
  skinnedMeshExport(t, e, i) {
    var a;
    const n = this.model, o = this.animationData;
    if (n && n.skinnedMesh) {
      let l = function(T) {
        const j = [];
        for (const [H, Y] of T) {
          let te = `${H} : [`;
          const le = [];
          for (const de of Y)
            le.push(`(${ce(de.x)}, ${ce(de.y)}, ${ce(de.z)})`);
          te = te.concat(le.join(", ")), te = te.concat("],"), j.push(te);
        }
        return j;
      }, c = function(T) {
        const j = [];
        for (const [H, Y] of T) {
          let te = `${H} : [`;
          const le = [];
          for (const de of Y)
            le.push(`(${ce(de.w)}, ${ce(de.x)}, ${ce(de.y)}, ${ce(de.z)})`);
          te = te.concat(le.join(", ")), te = te.concat("],"), j.push(te);
        }
        return j;
      }, h = function(T) {
        let j, H = !0;
        const Y = /* @__PURE__ */ new Map();
        for (const [le, de] of T) {
          j === void 0 && (j = de.length), j !== de.length && (H = !1);
          let De = 0;
          for (const Ct of de)
            De++, Ct || (Y.has(le) || Y.set(le, []), Y.get(le).push(De));
        }
        Ln && console.log("Bone count: ", T.size, "TransformData entries per bone: ", j, "Undefined bone entries: ", Y), console.assert(H, "All bones should have the same number of TransformData entries", T), console.assert(Y.size === 0, "All TransformData entries should be set", Y);
        const te = [];
        for (const [le, de] of T)
          for (let De = 0; De < de.length; De++) {
            const Ct = de[De], ai = i.getStartTimeByClip(Ct.clip);
            te.length <= De && te.push({ pos: [], rot: [], scale: [], timeOffset: ai });
            const $t = te[De];
            $t.pos.push(...Ct.getSortedTimesArray(!0, !1, !1)), $t.rot.push(...Ct.getSortedTimesArray(!1, !0, !1)), $t.scale.push(...Ct.getSortedTimesArray(!1, !1, !0));
          }
        for (const le of te)
          le.pos.sort((de, De) => de - De), le.rot.sort((de, De) => de - De), le.scale.sort((de, De) => de - De), le.pos = [...new Set(le.pos)], le.rot = [...new Set(le.rot)], le.scale = [...new Set(le.scale)];
        return te;
      }, d = function(T, j, H) {
        const Y = /* @__PURE__ */ new Map(), te = /* @__PURE__ */ new Map(), le = /* @__PURE__ */ new Map(), de = j.length;
        for (const De of H) {
          const Ct = T.get(De);
          let ai;
          Ct ? console.assert(Ct.length === de, "We should have the same number of TransformData entries for each bone", Ct, j) : ai = new $e(null, De, null);
          for (let $t = 0; $t < de; $t++) {
            const Vr = Ct ? Ct[$t] : ai, Ns = j[$t];
            for (const { time: Sl, translation: Cl } of Vr.getValues(Ns.pos, !0, !1, !1)) {
              const an = (Sl + Ns.timeOffset) * 60;
              Y.has(an) || Y.set(an, new Array()), Y.get(an).push(Cl.clone());
            }
            for (const { time: Sl, rotation: Cl } of Vr.getValues(Ns.rot, !1, !0, !1)) {
              const an = (Sl + Ns.timeOffset) * 60;
              te.has(an) || te.set(an, new Array()), te.get(an).push(Cl.clone());
            }
            for (const { time: Sl, scale: Cl } of Vr.getValues(Ns.scale, !1, !1, !0)) {
              const an = (Sl + Ns.timeOffset) * 60;
              le.has(an) || le.set(an, new Array()), le.get(an).push(Cl.clone());
            }
          }
        }
        return {
          position: Y.size == 0 ? void 0 : Y,
          quaternion: te.size == 0 ? void 0 : te,
          scale: le.size == 0 ? void 0 : le
        };
      }, u = function(T) {
        const j = [];
        for (const H of T)
          j.push(`(${ce(H.x)}, ${ce(H.y)}, ${ce(H.z)})`);
        return j.join(", ");
      }, p = function(T) {
        const j = [];
        for (const H of T)
          j.push(`(${ce(H.w)}, ${ce(H.x)}, ${ce(H.y)}, ${ce(H.z)})`);
        return j.join(", ");
      }, m = function(T) {
        const j = /* @__PURE__ */ new Map();
        if (Ln) {
          const H = new Array();
          for (const [Y, te] of o)
            H.push(Y.uuid + ": " + te.length + " " + te.map((le) => {
              var de;
              return (de = le.clip) == null ? void 0 : de.uuid.substring(0, 6);
            }).join(" "));
          console.log(`getPerBoneTransformData
` + H.join(`
`));
        }
        for (const H of T) {
          const Y = o.get(H);
          Y && j.set(H, Y);
        }
        return j;
      }, g = function(T) {
        const j = m(T), H = h(j);
        return d(j, H, T);
      };
      const _ = n.skinnedMesh.skeleton, y = new Array(), b = [], w = [];
      for (const T of _.bones) {
        b.push(T), w.push(T.uuid);
        const j = _.boneInverses[_.bones.indexOf(T)];
        y.push({ bone: T, inverse: j });
      }
      let P = 1e4;
      for (; w.length < _.bones.length && P-- > 0; )
        for (const T of b) {
          const j = T.children;
          for (const H of j)
            if (w.indexOf(H.uuid) === -1 && _.bones.indexOf(H) !== -1) {
              b.push(H), w.push(H.uuid);
              const Y = _.boneInverses[_.bones.indexOf(H)];
              y.push({ bone: H, inverse: Y });
            }
        }
      P <= 0 && console.error("Failed to sort bones in skinned mesh", n.skinnedMesh, _.bones, w);
      for (const T of dw(_.bones))
        y.push({ bone: T, inverse: T.matrixWorld.clone().invert() });
      const k = y[0].bone.parent;
      k || console.error("No bone parent found for skinned mesh during USDZ export", n.skinnedMesh), y.sort((T, j) => ka(T.bone, k) > ka(j.bone, k) ? 1 : -1);
      const O = e.quickLookCompatible, M = [], E = [], B = [], A = [];
      for (const { bone: T } of y) {
        if (O) {
          const j = T.scale;
          j.x == 0 && (j.x = 1e-5), j.y == 0 && (j.y = 1e-5), j.z == 0 && (j.z = 1e-5), M.push(new se().compose(T.position, T.quaternion, T.scale));
        } else
          M.push(T.matrix.clone());
        E.push(T.position), B.push(T.quaternion), A.push(T.scale);
      }
      const F = y.map((T) => '"' + ka(T.bone, k) + '"').join(", "), U = y.map((T) => gb(T.inverse.clone().invert())).join(", ");
      t.beginBlock('def Skeleton "Rig"'), t.appendLine(`uniform matrix4d[] bindTransforms = [${U}]`), t.appendLine(`uniform token[] joints = [${F}]`), t.appendLine('uniform token purpose = "guide"'), t.appendLine(`uniform matrix4d[] restTransforms = [${M.map((T) => gb(T)).join(", ")}]`);
      const Z = g(y.map((T) => T.bone));
      if (Ln) {
        let T = 1e7, j = 0;
        for (const H of ((a = Z.position) == null ? void 0 : a.keys()) ?? [])
          T = Math.min(T, H), j = Math.max(j, H);
        console.log("Time samples", T, j, Z);
      }
      if (t.beginBlock('def SkelAnimation "_anim"'), t.appendLine(`uniform token[] joints = [${F}]`), t.appendLine(`quatf[] rotations = [${p(B)}]`), Z && Z.quaternion) {
        t.beginBlock("quatf[] rotations.timeSamples = {", "");
        const T = c(Z.quaternion);
        for (const j of T)
          t.appendLine(j);
        t.closeBlock();
      }
      if (t.appendLine(`half3[] scales = [${u(A)}]`), Z && Z.scale) {
        t.beginBlock("half3[] scales.timeSamples = {", "");
        const T = l(Z.scale);
        for (const j of T)
          t.appendLine(j);
        t.closeBlock();
      }
      if (t.appendLine(`float3[] translations = [${u(E)}]`), Z && Z.position) {
        t.beginBlock("float3[] translations.timeSamples = {", "");
        const T = l(Z.position);
        for (const j of T)
          t.appendLine(j);
        t.closeBlock();
      }
      t.closeBlock(), t.closeBlock();
    }
  }
  onSerialize(t, e) {
    if (!this.model)
      return;
    const i = this.animationData.get(this.object);
    if (i)
      for (let d = 0; d < i.length; d++)
        i[d] === void 0 && (i[d] = new $e(null, this.object, null));
    const n = this.ext;
    this.skinnedMeshExport(t, e, n);
    const o = this.object, a = this.model, l = this.animationData.get(o);
    if (!l || o.isSkinnedMesh)
      return;
    Bm && console.log("SERIALIZE", this.model.name, this.object.type, l);
    const c = Intl.NumberFormat("en-US", {
      maximumFractionDigits: 3,
      minimumFractionDigits: 0,
      useGrouping: !1
    });
    function h(d, u) {
      var m;
      if (d.some((g) => g && {
        position: g.pos,
        rotation: g.rot,
        scale: g.scale
      }[u])) {
        switch (u) {
          case "position":
            a.needsTranslate = !0, t.beginBlock("double3 xformOp:translate.timeSamples = {", "");
            break;
          case "rotation":
            a.needsOrient = !0, t.beginBlock("quatf xformOp:orient.timeSamples = {", "");
            break;
          case "scale":
            a.needsScale = !0, t.beginBlock("double3 xformOp:scale.timeSamples = {", "");
            break;
        }
        for (let g = 0; g < d.length; g++) {
          const _ = d[g];
          if (!_)
            continue;
          const y = n.getStartTimeByClip(_.clip), b = _.getSortedTimesArray(u === "position", u === "rotation", u === "scale");
          if (!b || b.length === 0) {
            console.error("got an animated object but no time values?", o, _);
            continue;
          }
          const w = !_.clip, P = u === "position" && (_.pos || w), k = u === "rotation" && (_.rot || w), O = u === "scale" && (_.scale || w);
          if (P || k || O) {
            const M = ((m = _.clip) == null ? void 0 : m.name) ?? "rest", E = _.getDuration();
            Ln && console.log("Write .timeSamples:", M, y, E, d), t.appendLine("# " + M + ": start=" + c.format(y * $e.frameRate) + ", length=" + c.format(E * $e.frameRate) + ", frames=" + _.getFrames());
          }
          if (P)
            for (const { time: M, translation: E } of _.getValues(b, !0, !1, !1)) {
              const A = `${c.format((y + M) * $e.frameRate)}: (${ce(E.x)}, ${ce(E.y)}, ${ce(E.z)}),`;
              t.appendLine(A);
            }
          if (k)
            for (const { time: M, rotation: E } of _.getValues(b, !1, !0, !1)) {
              const A = `${c.format((y + M) * $e.frameRate)}: (${ce(E.w)}, ${ce(E.x)}, ${ce(E.y)}, ${ce(E.z)}),`;
              t.appendLine(A);
            }
          if (O)
            for (const { time: M, scale: E } of _.getValues(b, !1, !1, !0)) {
              const A = `${c.format((y + M) * $e.frameRate)}: (${ce(E.x)}, ${ce(E.y)}, ${ce(E.z)}),`;
              t.appendLine(A);
            }
        }
        t.closeBlock();
      }
    }
    h(l, "position"), h(l, "rotation"), h(l, "scale");
  }
}
const Xk = x("debugusdz");
class nl {
  constructor() {
    r(this, "files", new Array());
  }
  static getName(t) {
    var o;
    const e = t.split(".").pop();
    let n = (o = t.split(".").slice(0, -1).join(".").split("/").pop()) == null ? void 0 : o.replace(".", "_");
    return n || (n = "Audio_" + Math.random().toString(36).substring(2, 15)), qn(n) + "." + e;
  }
  get extensionName() {
    return "Audio";
  }
  onExportObject(t, e, i) {
    const n = S.getComponents(t, qe);
    if (n.length)
      for (const o of n) {
        if (!o.clip || typeof o.clip != "string" || !o.playOnAwake)
          continue;
        const a = o.clip.split("/").pop() || "Audio", l = nl.getName(o.clip), c = qn(l);
        if (!this.files.some((h) => h.path === o.clip)) {
          this.files.push({ path: o.clip, name: l });
          const h = l.toLowerCase();
          i.quickLookCompatible && !h.endsWith(".mp3") && !h.endsWith(".wav") && !h.endsWith(".m4a") && console.error("Audio file " + o.clip + " from " + o.name + " is not an MP3 or WAV file. QuickLook may not support playing it.");
        }
        i.quickLookCompatible || e.addEventListener("serialize", (h, d) => {
          h.appendLine(), h.beginBlock(`def SpatialAudio "${c}"`, "(", !1), h.appendLine(`displayName = "${a}"`), h.closeBlock(")"), h.beginBlock(), h.appendLine(`uniform asset filePath = @audio/${l}@`), h.appendLine(`uniform token auralMode = "${o.spatialBlend > 0 ? "spatial" : "nonSpatial"}"`), h.appendLine(`uniform token playbackMode = "${o.loop ? "loopFromStage" : "onceFromStart"}"`), h.appendLine(`uniform float gain = ${o.volume}`), h.closeBlock();
        });
      }
  }
  async onAfterSerialize(t) {
    for (const e of this.files) {
      const i = "audio/" + e.name;
      if (t.files[i]) {
        Xk && console.warn("Audio file with name " + i + " already exists in the context. Skipping.");
        continue;
      }
      const a = await (await (await fetch(e.path)).blob()).arrayBuffer(), l = new Uint8Array(a);
      t.files[i] = l;
    }
  }
}
var Qk = Object.defineProperty, Yk = Object.getOwnPropertyDescriptor, Ve = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Yk(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && Qk(t, e, n), n;
};
const wb = x("debugusdzbehaviours");
function oh(s) {
  s && (s.getComponentInParent(qa) || (z() && console.debug('Raycaster on "' + s.name + '" was automatically added, because no raycaster was found in the parent hierarchy.'), s.addComponent(sn)));
}
class sl extends I {
  constructor() {
    super(...arguments);
    r(this, "object");
    r(this, "target");
    r(this, "duration", 1);
    r(this, "relativeMotion", !1);
    r(this, "coroutine", null);
    r(this, "targetPos", new v());
    r(this, "targetRot", new W());
    r(this, "targetScale", new v());
  }
  start() {
    oh(this.gameObject);
  }
  onPointerClick(e) {
    e.use(), this.coroutine && this.stopCoroutine(this.coroutine), this.relativeMotion ? this.coroutine = this.startCoroutine(this.moveRelative()) : this.coroutine = this.startCoroutine(this.moveToTarget());
  }
  *moveToTarget() {
    if (!this.target || !this.object)
      return;
    const e = ie(this.object).clone(), i = ie(this.target).clone(), n = Ce(this.object).clone(), o = Ce(this.target).clone(), a = Ke(this.object).clone(), l = Ke(this.target).clone(), c = e.distanceTo(i), h = n.angleTo(o), d = a.distanceTo(l);
    if (c < 0.01 && h < 0.01 && d < 0.01) {
      yt(this.object, i), wn(this.object, o), Lc(this.object, l), this.coroutine = null;
      return;
    }
    let u = 0, p = 0;
    for (; u < 1; )
      u += this.context.time.deltaTime / this.duration, u > 1 && (u = 1), p = u < 0.5 ? 4 * u * u * u : 1 - Math.pow(-2 * u + 2, 3) / 2, this.targetPos.lerpVectors(e, i, p), this.targetRot.slerpQuaternions(n, o, p), this.targetScale.lerpVectors(a, l, p), yt(this.object, this.targetPos), wn(this.object, this.targetRot), Lc(this.object, this.targetScale), yield;
    this.coroutine = null;
  }
  *moveRelative() {
    if (!this.target || !this.object)
      return;
    const e = this.object.position.clone(), i = this.object.quaternion.clone(), n = this.object.scale.clone(), o = this.target.position.clone(), a = this.target.quaternion.clone(), l = this.target.scale.clone();
    o.applyQuaternion(this.object.quaternion), this.targetPos.copy(this.object.position).add(o), this.targetRot.copy(this.object.quaternion).multiply(a), this.targetScale.copy(this.object.scale).multiply(l);
    let c = 0, h = 0;
    for (; c < 1; )
      c += this.context.time.deltaTime / this.duration, c > 1 && (c = 1), h = c < 0.5 ? 4 * c * c * c : 1 - Math.pow(-2 * c + 2, 3) / 2, this.object.position.lerpVectors(e, this.targetPos, h), this.object.quaternion.slerpQuaternions(i, this.targetRot, h), this.object.scale.lerpVectors(n, this.targetScale, h), yield;
    this.coroutine = null;
  }
  beforeCreateDocument(e) {
    var i;
    if (this.target && this.object && this.gameObject) {
      const n = new kt(
        "Move to " + ((i = this.target) == null ? void 0 : i.name),
        Ft.tapTrigger(this.gameObject),
        ge.transformAction(this.object, this.target, this.duration, this.relativeMotion ? "relative" : "absolute")
      );
      e.addBehavior(n);
    }
  }
}
Ve([
  f(L)
], sl.prototype, "object", 2);
Ve([
  f(L)
], sl.prototype, "target", 2);
Ve([
  f()
], sl.prototype, "duration", 2);
Ve([
  f()
], sl.prototype, "relativeMotion", 2);
var ea;
const qt = (ea = class extends I {
  constructor() {
    super(...arguments);
    r(this, "materialToSwitch");
    r(this, "variantMaterial");
    r(this, "fadeDuration", 0);
    r(this, "_objectsWithThisMaterial", null);
    r(this, "selfModel");
    r(this, "targetModels");
  }
  start() {
    var t;
    this._objectsWithThisMaterial = this.objectsWithThisMaterial, oh(this.gameObject), z() && this._objectsWithThisMaterial.length <= 0 && console.warn('ChangeMaterialOnClick: No objects found with material "' + ((t = this.materialToSwitch) == null ? void 0 : t.name) + '"');
  }
  onPointerEnter(t) {
    this.context.input.setCursor("pointer");
  }
  onPointerExit(t) {
    this.context.input.unsetCursor("pointer");
  }
  onPointerClick(t) {
    if (t.use(), !!this.variantMaterial)
      for (let e = 0; e < this.objectsWithThisMaterial.length; e++) {
        const i = this.objectsWithThisMaterial[e];
        i.material = this.variantMaterial;
      }
  }
  /** Get all objects in the scene that have the assigned materialToSwitch */
  get objectsWithThisMaterial() {
    return this._objectsWithThisMaterial != null ? this._objectsWithThisMaterial : (this._objectsWithThisMaterial = [], this.variantMaterial && this.materialToSwitch && this.context.scene.traverse((t) => {
      if (t instanceof q)
        if (Array.isArray(t.material)) {
          for (const e of t.material)
            if (e === this.materialToSwitch) {
              this.objectsWithThisMaterial.push(t);
              break;
            }
        } else
          t.material === this.materialToSwitch ? this.objectsWithThisMaterial.push(t) : VP(t.material, this.materialToSwitch) && this.objectsWithThisMaterial.push(t);
    }), this._objectsWithThisMaterial);
  }
  async beforeCreateDocument(t, e) {
    this.targetModels = [], qt._materialTriggersPerId = {}, qt.variantSwitchIndex = 0, this.materialToSwitch && await Ze.assignTextureLOD(this.materialToSwitch, 0), this.variantMaterial && await Ze.assignTextureLOD(this.variantMaterial, 0);
  }
  createBehaviours(t, e, i) {
    this.objectsWithThisMaterial.find((o) => o.uuid === e.uuid) && this.targetModels.push(e), this.gameObject.uuid === e.uuid && (this.selfModel = e, this.materialToSwitch && (qt._materialTriggersPerId[this.materialToSwitch.uuid] || (qt._materialTriggersPerId[this.materialToSwitch.uuid] = []), qt._materialTriggersPerId[this.materialToSwitch.uuid].push(this)));
  }
  afterCreateDocument(t, e) {
    if (!this.materialToSwitch)
      return;
    const i = qt._materialTriggersPerId[this.materialToSwitch.uuid];
    if (i) {
      const n = {};
      for (const o of i) {
        const a = o.createVariants();
        a && a.length > 0 && (n[o.selfModel.uuid] = a);
      }
      for (const o of i) {
        const a = [];
        for (const l in n)
          l !== o.selfModel.uuid && a.push(...n[l]);
        o.createAndAttachBehaviors(t, n[o.selfModel.uuid], a);
      }
    }
    delete qt._materialTriggersPerId[this.materialToSwitch.uuid];
  }
  createAndAttachBehaviors(t, e, i) {
    const n = [], o = Math.max(0, this.fadeDuration);
    n.push(ge.fadeAction([...this.targetModels, ...i], o, !1)), n.push(ge.fadeAction(e, o, !0)), t.addBehavior(
      new kt(
        "Select_" + this.selfModel.name,
        Ft.tapTrigger(this.selfModel),
        ge.parallel(...n)
      )
    ), qt._parallelStartHiddenActions.push(...e), qt._startHiddenBehaviour || (qt._startHiddenBehaviour = new kt(
      "StartHidden_" + this.selfModel.name,
      Ft.sceneStartTrigger(),
      ge.fadeAction(qt._parallelStartHiddenActions, o, !1)
    ), t.addBehavior(qt._startHiddenBehaviour));
  }
  static getMaterialName(t) {
    return qn(t.name || "Material") + "_" + t.id;
  }
  createVariants() {
    if (!this.variantMaterial)
      return null;
    const t = [];
    for (const e of this.targetModels) {
      const i = e.clone();
      i.name += "_Variant_" + qt.variantSwitchIndex++ + "_" + qt.getMaterialName(this.variantMaterial), i.displayName = i.displayName + ": Variant with material " + this.variantMaterial.name, i.material = this.variantMaterial, i.geometry = e.geometry, i.transform = e.transform, (!e.parent || !e.parent.isEmpty()) && Lt.createEmptyParent(e), e.parent && e.parent.add(i), t.push(i);
    }
    return t;
  }
}, r(ea, "_materialTriggersPerId", {}), r(ea, "_startHiddenBehaviour", null), r(ea, "_parallelStartHiddenActions", []), r(ea, "variantSwitchIndex", 0), ea);
let rh = qt;
Ve([
  f(Se)
], rh.prototype, "materialToSwitch", 2);
Ve([
  f(Se)
], rh.prototype, "variantMaterial", 2);
Ve([
  f()
], rh.prototype, "fadeDuration", 2);
var ta;
const Ue = (ta = class extends I {
  constructor() {
    super(...arguments);
    r(this, "target");
    r(this, "toggleOnClick", !1);
    r(this, "targetState", !0);
    r(this, "hideSelf", !0);
    r(this, "selfModel");
    r(this, "selfModelClone");
    r(this, "targetModel");
    r(this, "toggleModel");
    r(this, "stateBeforeCreatingDocument", !1);
    r(this, "targetStateBeforeCreatingDocument", !1);
  }
  start() {
    oh(this.gameObject);
  }
  onPointerClick(t) {
    t.use(), !this.toggleOnClick && this.hideSelf && (this.gameObject.visible = !1), this.target && (this.target.visible = this.toggleOnClick ? !this.target.visible : this.targetState);
  }
  createBehaviours(t, e, i) {
    e.uuid === this.gameObject.uuid && (this.selfModel = e, this.selfModelClone = e.clone());
  }
  beforeCreateDocument() {
    this.target && (this.gameObject[Ue.wasVisible] === void 0 && (this.gameObject[Ue.wasVisible] = this.gameObject.activeSelf), this.target[Ue.wasVisible] === void 0 && (this.target[Ue.wasVisible] = this.target.activeSelf), this.stateBeforeCreatingDocument = this.gameObject[Ue.wasVisible], this.targetStateBeforeCreatingDocument = this.target[Ue.wasVisible], this.gameObject.visible = !0, this.target.visible = !0);
  }
  afterCreateDocument(t, e) {
    if (!this.target)
      return;
    this.targetModel = e.document.findById(this.target.uuid);
    const i = this.selfModel;
    if (this.selfModel && this.targetModel) {
      let n = this.selfModel, o = this.targetState;
      if (this.toggleOnClick)
        if (o = !this.targetStateBeforeCreatingDocument, !this.selfModelClone.geometry)
          (!this.selfModel.parent || this.selfModel.parent.isEmpty()) && uw.createEmptyParent(this.selfModel), this.toggleModel = this.selfModel.deepClone(), this.toggleModel.name += "_toggle", this.selfModel.parent.add(this.toggleModel);
        else {
          if (!this.gameObject[Ue.toggleClone]) {
            const c = this.selfModelClone.clone();
            c.setMatrix(new se()), c.name += "_toggle" + Ue.clonedToggleIndex++, i.add(c), this.gameObject[Ue.toggleClone] = c, console.warn("USDZExport: Toggle " + this.gameObject.name + " doesn't have geometry. It will be deep cloned and nested behaviours will likely not work.");
          }
          const l = this.gameObject[Ue.toggleClone];
          if (!this.gameObject[Ue.reverseToggleClone]) {
            const c = this.selfModelClone.clone();
            c.setMatrix(new se()), c.name += "_toggleReverse" + Ue.clonedToggleIndex++, i.add(c), this.gameObject[Ue.reverseToggleClone] = c;
          }
          this.toggleModel = this.gameObject[Ue.reverseToggleClone], (!this.toggleModel.geometry || !l.geometry) && console.error("triggers without childs and without geometry won't work!", this, i.geometry), n = l, i.geometry = null, i.material = null;
        }
      if (this.toggleModel) {
        if (this.toggleOnClick) {
          const l = [];
          l.push(ge.fadeAction(n, 0, !1)), l.push(ge.fadeAction(this.toggleModel, 0, !0)), l.push(ge.fadeAction(this.targetModel, 0, o)), t.addBehavior(new kt(
            "Toggle_" + n.name + "_ToggleTo" + (o ? "On" : "Off"),
            Ft.tapTrigger(n),
            ge.parallel(...l)
          ));
          const c = [];
          c.push(ge.fadeAction(this.toggleModel, 0, !1)), c.push(ge.fadeAction(n, 0, !0)), c.push(ge.fadeAction(this.targetModel, 0, !o)), t.addBehavior(new kt(
            "Toggle_" + n.name + "_ToggleTo" + (o ? "Off" : "On"),
            Ft.tapTrigger(this.toggleModel),
            ge.parallel(...c)
          ));
        }
      } else {
        const l = [];
        this.hideSelf && l.push(ge.fadeAction(n, 0, !1)), l.push(ge.fadeAction(this.targetModel, 0, o)), t.addBehavior(new kt(
          "Toggle_" + n.name + "_ToggleTo" + (o ? "On" : "Off"),
          Ft.tapTrigger(n),
          l.length > 1 ? ge.parallel(...l) : l[0]
        ));
      }
      const a = new Array();
      this.targetStateBeforeCreatingDocument || a.push(this.targetModel), this.stateBeforeCreatingDocument || a.push(i), this.toggleModel && a.push(this.toggleModel), or.add(a, t);
    }
  }
  afterSerialize(t, e) {
    this.gameObject[Ue.wasVisible] !== void 0 && (this.gameObject.visible = this.gameObject[Ue.wasVisible], delete this.gameObject[Ue.wasVisible]), this.target && this.target[Ue.wasVisible] !== void 0 && (this.target.visible = this.target[Ue.wasVisible], delete this.target[Ue.wasVisible]), delete this.gameObject[Ue.toggleClone], delete this.gameObject[Ue.reverseToggleClone];
  }
}, r(ta, "clonedToggleIndex", 0), r(ta, "wasVisible", Symbol("usdz_SetActiveOnClick_wasVisible")), r(ta, "toggleClone", Symbol("clone for toggling")), r(ta, "reverseToggleClone", Symbol("clone for reverse toggling")), ta);
let ol = Ue;
Ve([
  f(L)
], ol.prototype, "target", 2);
Ve([
  f()
], ol.prototype, "toggleOnClick", 2);
Ve([
  f()
], ol.prototype, "targetState", 2);
Ve([
  f()
], ol.prototype, "hideSelf", 2);
const ms = class extends I {
  constructor() {
    super(...arguments);
    r(this, "wasVisible", !1);
  }
  static add(e, i) {
    const n = Array.isArray(e) ? e : [e];
    for (const o of n)
      ms._fadeObjects.includes(o) || (console.log("adding hide on start", o), ms._fadeObjects.push(o));
    ms._fadeBehaviour === void 0 && (ms._fadeBehaviour = new kt(
      "HideOnStart",
      Ft.sceneStartTrigger(),
      //@ts-ignore
      ge.fadeAction(ms._fadeObjects, 0, !1)
    ), i.addBehavior(ms._fadeBehaviour));
  }
  start() {
    S.setActive(this.gameObject, !1);
  }
  createBehaviours(e, i, n) {
    i.uuid === this.gameObject.uuid && (this.wasVisible || ms.add(i, e));
  }
  beforeCreateDocument() {
    this.wasVisible = S.isActiveSelf(this.gameObject);
  }
};
let or = ms;
r(or, "_fadeBehaviour"), r(or, "_fadeObjects", []);
class ah extends I {
  constructor() {
    super(...arguments);
    r(this, "target");
    r(this, "duration", 0.5);
    r(this, "motionType", "bounce");
  }
  beforeCreateDocument() {
  }
  createBehaviours(e, i, n) {
    if (this.target && i.uuid === this.gameObject.uuid) {
      const o = new kt(
        "emphasize " + this.name,
        Ft.tapTrigger(this.gameObject),
        ge.emphasize(this.target, this.duration, this.motionType, void 0, "basic")
      );
      e.addBehavior(o);
    }
  }
  afterCreateDocument(e, i) {
  }
}
Ve([
  f()
], ah.prototype, "target", 2);
Ve([
  f()
], ah.prototype, "duration", 2);
Ve([
  f()
], ah.prototype, "motionType", 2);
class Cr extends I {
  constructor() {
    super(...arguments);
    r(this, "target");
    r(this, "clip", "");
    r(this, "toggleOnClick", !1);
    // Not exposed, but used for implicit playback of PlayOnAwake audio sources
    r(this, "trigger", "tap");
  }
  start() {
    oh(this.gameObject);
  }
  ensureAudioSource() {
    if (!this.target) {
      const e = this.gameObject.addComponent(qe);
      e && (this.target = e, e.spatialBlend = 1, e.volume = 1, e.loop = !1, e.preload = !0);
    }
  }
  onPointerClick(e) {
    var i;
    e.use(), !(!((i = this.target) != null && i.clip) && !this.clip) && (this.ensureAudioSource(), this.target && (this.target.isPlaying && this.toggleOnClick ? this.target.stop() : (!this.toggleOnClick && this.target.isPlaying && this.target.stop(), this.clip ? this.target.play(this.clip) : this.target.play())));
  }
  createBehaviours(e, i, n) {
    if (!(!this.target && !this.clip) && i.uuid === this.gameObject.uuid) {
      const o = this.clip ? this.clip : this.target ? this.target.clip : void 0;
      if (!o || typeof o != "string")
        return;
      const a = this.target ? this.target.gameObject : this.gameObject;
      nl.getName(o);
      const l = this.target ? this.target.volume : 1, c = this.target && this.target.spatialBlend == 0 ? "nonSpatial" : "spatial";
      let h = !1;
      this.gameObject.traverse((m) => {
        m instanceof q && m.visible && (h = !0);
      }), h = !0;
      const d = e.addAudioClip(o);
      let u = ge.playAudioAction(a, d, "play", l, c);
      this.target && this.target.loop && (u = ge.sequence(u).makeLooping());
      const p = this.name ? "_" + this.name : "";
      if (h && this.trigger === "tap") {
        this.toggleOnClick && (u.multiplePerformOperation = "stop");
        const m = new kt(
          "playAudio" + p,
          Ft.tapTrigger(i),
          u
        );
        e.addBehavior(m);
      }
      if (this.target && this.target.playOnAwake && this.target.enabled)
        if (h && this.trigger === "tap")
          console.warn("USDZExport: Audio sources that are played on tap can't also auto-play at scene start due to a QuickLook bug.");
        else {
          const m = new kt(
            "playAudioOnStart" + p,
            Ft.sceneStartTrigger(),
            u
          );
          e.addBehavior(m);
        }
    }
  }
}
Ve([
  f(qe)
], Cr.prototype, "target", 2);
Ve([
  f(URL)
], Cr.prototype, "clip", 2);
Ve([
  f()
], Cr.prototype, "toggleOnClick", 2);
var ad;
const Tn = (ad = class extends I {
  constructor() {
    super(...arguments);
    r(this, "animator");
    r(this, "stateName");
    // Not editable from the outside yet, but from code
    // we want to expose this once we have a nice drawer for "Triggers" (e.g. shows proximity distance)
    // and once we rename the component to "PlayAnimation" or "PlayAnimationOnTrigger"
    r(this, "trigger", "tap");
    // "proximity"
    r(this, "animation");
    r(this, "selfModel");
    r(this, "stateAnimationModel");
    r(this, "animationSequence", new Array());
    r(this, "animationLoopAfterSequence", new Array());
    r(this, "randomOffsetNormalized", 0);
  }
  get target() {
    var t, e;
    return ((t = this.animator) == null ? void 0 : t.gameObject) || ((e = this.animation) == null ? void 0 : e.gameObject);
  }
  start() {
    oh(this.gameObject);
  }
  onPointerClick(t) {
    var e;
    t.use(), this.target && this.stateName && ((e = this.animator) == null || e.play(this.stateName, 0, 0, 0.1));
  }
  createBehaviours(t, e, i) {
    e.uuid === this.gameObject.uuid && (this.selfModel = e);
  }
  // Cleanup. TODO This is not the best way as it's called multiple times (once for each component).
  afterSerialize() {
    if (Tn.rootsWithExclusivePlayback.size > 1) {
      const t = 'Multiple root objects targeted by more than one animation. To work around QuickLook bug FB13410767, animations will be set as "exclusive" and activating them will stop other animations being marked as exclusive.';
      z() && ve(t), console.warn(t, ...Tn.rootsWithExclusivePlayback);
    }
    Tn.animationActions = [], Tn.rootsWithExclusivePlayback = /* @__PURE__ */ new Set();
  }
  afterCreateDocument(t, e) {
    if (this.animationSequence === void 0 && this.animationLoopAfterSequence === void 0 || !this.stateAnimationModel || !this.target)
      return;
    const i = e.document, n = e.extensions.find((l) => l instanceof Qg);
    if (!n)
      return;
    const o = n.getClipCount(this.target) > 1;
    o && (z() && console.warn("Setting exclusive playback for " + this.target.name + "@" + this.stateName + " because it has " + n.getClipCount(this.target) + " animations. This works around QuickLook bug FB13410767."), Tn.rootsWithExclusivePlayback.add(this.target));
    const a = this.name ? this.name : "";
    i.traverse((l) => {
      var c, h;
      if (l.uuid === ((c = this.target) == null ? void 0 : c.uuid)) {
        const d = Tn.getActionForSequences(
          i,
          l,
          this.animationSequence,
          this.animationLoopAfterSequence,
          this.randomOffsetNormalized
        ), u = new kt(
          this.trigger + "_" + a + "_toPlayAnimation_" + this.stateName + "_on_" + ((h = this.target) == null ? void 0 : h.name),
          this.trigger == "tap" ? Ft.tapTrigger(this.selfModel) : Ft.sceneStartTrigger(),
          d
        );
        o && u.makeExclusive(!0), t.addBehavior(u);
      }
    });
  }
  static getActionForSequences(t, e, i, n, o) {
    const a = (c, h) => {
      let d = Tn.animationActions.find((u) => u.affectedObjects == c && u.start == h.start && u.duration == h.duration && u.animationSpeed == h.speed);
      return d || (d = ge.startAnimationAction(c, h), Tn.animationActions.push(d)), d;
    }, l = ge.sequence();
    if (i && i.length > 0)
      for (const c of i)
        l.addAction(a(e, c));
    if (n && n.length > 0) {
      const c = l.actions.length == 0 ? l : ge.sequence();
      for (const h of n)
        c.addAction(a(e, h));
      c.makeLooping(), l !== c && l.addAction(c);
    }
    return o && o > 0 && l.actions.unshift(ge.waitAction(o)), l;
  }
  static getAndRegisterAnimationSequences(t, e, i) {
    var g, _, y, b, w, P, k, O;
    if (!e)
      return;
    const n = e.getComponent(zt), o = e.getComponent(ti);
    if (!n && !o)
      return;
    if (n && !i)
      throw new Error("PlayAnimationOnClick: No stateName specified for animator " + n.name + " on " + e.name);
    let a = [], l = [];
    if (o) {
      const M = t.registerAnimation(e, o.clip);
      M && (o.loop ? l.push(M) : a.push(M));
      let E = 0;
      if (o.minMaxOffsetNormalized) {
        const B = o.minMaxOffsetNormalized.x, A = o.minMaxOffsetNormalized.y;
        E = (((g = o.clip) == null ? void 0 : g.duration) || 1) * (B + Math.random() * (A - B));
      }
      return {
        animationSequence: a,
        animationLoopAfterSequence: l,
        randomTimeOffset: E
      };
    }
    const c = n == null ? void 0 : n.runtimeAnimatorController;
    let h = c == null ? void 0 : c.findState(i), d = [], u = [];
    if (c && h) {
      const M = new Array();
      M.push(h);
      let E = !1;
      for (; M.length < 100; ) {
        if (!h || h === null || !h.transitions || h.transitions.length === 0) {
          (_ = h.motion) != null && _.isLooping && (E = !0);
          break;
        }
        const B = h.transitions.find((F) => F.conditions.length === 0), A = B ? c.getState(B.destinationState, 0) : null;
        if (A && M.includes(A)) {
          h = A, E = !0;
          break;
        } else if (B) {
          if (h = A, !h)
            break;
          M.push(h);
        } else {
          E = ((y = h.motion) == null ? void 0 : y.isLooping) ?? !1;
          break;
        }
      }
      if (E && h) {
        const B = M.indexOf(h);
        d = M.slice(0, B), u = M.slice(B), wb && console.log("found loop from " + i, "states until loop", d, "states looping", u);
      } else
        d = M, u = [], wb && console.log("found no loop from " + i, "states", d);
      if (!u.length) {
        const B = d[d.length - 1], A = (b = B.motion) == null ? void 0 : b.clip;
        if (A) {
          let F;
          if (t.holdClipMap.has(A))
            F = t.holdClipMap.get(A);
          else {
            const U = B.name + "_hold";
            F = A.clone(), F.duration = 1, F.name = U;
            const Z = A.duration;
            F.tracks = A.tracks.map((T) => {
              const j = T.clone();
              j.times = new Float32Array([0, Z]);
              const H = T.values.length, Y = T.getValueSize(), te = T.values.slice(H - Y, H);
              return j.values = new Float32Array(2 * Y), j.values.set(te, 0), j.values.set(te, Y), j;
            }), F.name = U, t.holdClipMap.set(A, F);
          }
          if (F) {
            const U = {
              name: F.name,
              motion: { clip: F, isLooping: !1, name: F.name },
              speed: 1,
              transitions: [],
              behaviours: [],
              hash: B.hash + 1
            };
            u.push(U);
          }
        }
      }
    }
    if (d.length === 1 && (!((w = d[0].motion) != null && w.clip) || ((k = (P = d[0].motion) == null ? void 0 : P.clip.tracks) == null ? void 0 : k.length) === 0)) {
      a = new Array();
      const M = t.registerAnimation(e, null);
      M && a.push(M);
      return;
    }
    if (d = d.filter((M) => {
      var E, B, A;
      return ((E = M.motion) == null ? void 0 : E.clip) && ((A = (B = M.motion) == null ? void 0 : B.clip.tracks) == null ? void 0 : A.length) > 0;
    }), u = u.filter((M) => {
      var E, B, A;
      return ((E = M.motion) == null ? void 0 : E.clip) && ((A = (B = M.motion) == null ? void 0 : B.clip.tracks) == null ? void 0 : A.length) > 0;
    }), d.length === 0 && u.length === 0) {
      console.warn("No clips found for state " + i + " on " + (n == null ? void 0 : n.name) + ", can't export animation data");
      return;
    }
    const p = (M, E) => {
      if (!e)
        return;
      const B = t.registerAnimation(e, M.motion.clip ?? null);
      B ? (B.speed = M.speed, E.push(B)) : console.warn("Couldn't register animation for state " + M.name + " on " + (n == null ? void 0 : n.name));
    };
    if (d.length > 0) {
      a = new Array();
      for (const M of d)
        p(M, a);
    }
    if (u.length > 0) {
      l = new Array();
      for (const M of u)
        p(M, l);
    }
    let m = 0;
    if (n && c && n.minMaxOffsetNormalized) {
      const M = n.minMaxOffsetNormalized.x, E = n.minMaxOffsetNormalized.y, B = d.length ? d[0] : u.length ? u[0] : null;
      m = (((O = B == null ? void 0 : B.motion.clip) == null ? void 0 : O.duration) || 1) * (M + Math.random() * (E - M));
    }
    return {
      animationSequence: a,
      animationLoopAfterSequence: l,
      randomTimeOffset: m
    };
  }
  createAnimation(t, e, i) {
    if (!this.target || !this.animator && !this.animation)
      return;
    const n = Tn.getAndRegisterAnimationSequences(t, this.target, this.stateName);
    n && (this.animationSequence = n.animationSequence, this.animationLoopAfterSequence = n.animationLoopAfterSequence, this.randomOffsetNormalized = n.randomTimeOffset, this.stateAnimationModel = e);
  }
}, r(ad, "animationActions", []), r(ad, "rootsWithExclusivePlayback", /* @__PURE__ */ new Set()), ad);
let Xa = Tn;
Ve([
  f(zt)
], Xa.prototype, "animator", 2);
Ve([
  f()
], Xa.prototype, "stateName", 2);
class lh extends I {
  constructor() {
    super(...arguments);
    r(this, "target");
  }
  getType() {
  }
  getDuration() {
  }
}
Ve([
  f(L)
], lh.prototype, "target", 2);
class Zu extends I {
  constructor() {
    super(...arguments);
    r(this, "target");
  }
}
Ve([
  f(lh)
], Zu.prototype, "target", 2);
class Ju extends lh {
  constructor() {
    super(...arguments);
    r(this, "type", 1);
    r(this, "duration", 1);
  }
  getType() {
    switch (this.type) {
      case 1:
        return "hide";
      case 0:
        return "show";
    }
  }
  getDuration() {
    return this.duration;
  }
}
Ve([
  f()
], Ju.prototype, "type", 2);
Ve([
  f()
], Ju.prototype, "duration", 2);
class vw extends Zu {
}
const A_ = class {
  constructor() {
    r(this, "_quicklookButton");
    r(this, "_arButton");
    r(this, "_vrButton");
    r(this, "_sendToQuestButton");
  }
  static create() {
    return new A_();
  }
  static getOrCreate() {
    return this._instance || (this._instance = this.create()), this._instance;
  }
  get isSecureConnection() {
    return window.location.protocol === "https:";
  }
  get quicklookButton() {
    return this._quicklookButton;
  }
  get arButton() {
    return this._arButton;
  }
  get vrButton() {
    return this._vrButton;
  }
  get sendToQuestButton() {
    return this._sendToQuestButton;
  }
  get qrButton() {
    return zn.getOrCreate().createQRCode();
  }
  /** get or create the quicklook button 
   * Behaviour of the button:
   * - if the button is clicked a USDZExporter component will be searched for in the scene and if found, it will be used to export the scene to USDZ / Quicklook
  */
  createQuicklookButton() {
    if (this._quicklookButton)
      return this._quicklookButton;
    const t = document.createElement("button");
    this._quicklookButton = t, t.dataset.needle = "quicklook-button";
    const e = X.supportsQuickLookAR();
    t.innerText = "View in AR", t.prepend(Dt("view_in_ar"));
    let i = !1, n = null;
    return t.addEventListener("click", () => {
      n = Uu(Ge), n || (i = !0, n = new Ge()), i && (n.objectToExport = ee.Current.scene), n ? (t.classList.add("this-mode-is-requested"), n.exportAndOpen().then(() => {
        t.classList.remove("this-mode-is-requested");
      }).catch((o) => {
        t.classList.remove("this-mode-is-requested"), console.error(o);
      })) : console.warn("No USDZExporter component found in the scene");
    }), this.hideElementDuringXRSession(t), t;
  }
  /** get or create the WebXR AR button  
   * @param init optional session init options
   * Behaviour of the button:
   * - if the device supports AR, the button will be visible and clickable
   * - if the device does not support AR, the button will be hidden
   * - if the device changes and now supports AR, the button will be visible
   */
  createARButton(t) {
    var n;
    if (this._arButton)
      return this._arButton;
    const e = "immersive-ar", i = document.createElement("button");
    return this._arButton = i, i.classList.add("webxr-button"), i.dataset.needle = "webxr-ar-button", i.innerText = "Enter AR", i.prepend(Dt("view_in_ar")), i.title = "Click to start an AR session", i.addEventListener("click", () => J.start(e, t)), this.updateSessionSupported(i, e), this.listenToXRSessionState(i, e), this.hideElementDuringXRSession(i), this.isSecureConnection || (i.disabled = !0, i.title = "WebXR requires a secure connection (HTTPS)"), X.isMozillaXR() || (n = navigator.xr) == null || n.addEventListener("devicechange", () => this.updateSessionSupported(i, e)), i;
  }
  /** get or create the WebXR VR button 
   * @param init optional session init options
   * Behaviour of the button:
   * - if the device supports VR, the button will be visible and clickable
   * - if the device does not support VR, the button will be hidden
   * - if the device changes and now supports VR, the button will be visible
  */
  createVRButton(t) {
    var n;
    if (this._vrButton)
      return this._vrButton;
    const e = "immersive-vr", i = document.createElement("button");
    return this._vrButton = i, i.classList.add("webxr-button"), i.dataset.needle = "webxr-vr-button", i.innerText = "Enter VR", i.prepend(Dt("panorama_photosphere")), i.title = "Click to start a VR session", i.addEventListener("click", () => J.start(e, t)), this.updateSessionSupported(i, e), this.listenToXRSessionState(i, e), this.hideElementDuringXRSession(i), this.isSecureConnection || (i.disabled = !0, i.title = "WebXR requires a secure connection (HTTPS)"), X.isMozillaXR() || (n = navigator.xr) == null || n.addEventListener("devicechange", () => this.updateSessionSupported(i, e)), i;
  }
  /** get or create the Send To Quest button 
   * Behaviour of the button:
   * - if the button is clicked, the current URL will be sent to the Oculus Browser on the Quest
  */
  createSendToQuestButton() {
    var i;
    if (this._sendToQuestButton)
      return this._sendToQuestButton;
    const t = "https://oculus.com/open_url/?url=", e = document.createElement("button");
    return this._sendToQuestButton = e, e.dataset.needle = "webxr-sendtoquest-button", e.innerText = "Open on Quest", e.prepend(Dt("share_windows")), e.title = "Click to send this page to the Oculus Browser on your Quest", e.addEventListener("click", () => {
      const n = encodeURIComponent(window.location.href), o = t + n;
      window.open(o) == null && We("This page doesn't allow popups. Please paste " + o + " into your browser.");
    }), this.listenToXRSessionState(e), this.hideElementDuringXRSession(e), X.isMozillaXR() || (i = navigator.xr) == null || i.addEventListener("devicechange", () => {
      var n;
      (n = navigator.xr) != null && n.isSessionSupported("immersive-vr") ? e.style.display = "none" : e.style.display = "";
    }), e;
  }
  /**
   * @deprecated please use ButtonsFactory.getOrCreate().createQRCode(). This method will be removed in a future update
   */
  createQRCode() {
    return zn.getOrCreate().createQRCode();
  }
  updateSessionSupported(t, e) {
    if (!("xr" in navigator)) {
      t.style.display = "none";
      return;
    }
    J.isSessionSupported(e).then((i) => {
      t.style.display = i ? "" : "none", z() && !i && console.log('[WebXR] "' + e + '" is not supported on this device – make sure your server runs using HTTPS and you have a device connected that supports ' + e);
    });
  }
  hideElementDuringXRSession(t) {
    bg((e) => {
      t["previous-display"] = t.style.display, t.style.display = "none";
    }), W0((e) => {
      t["previous-display"] != null && (t.style.display = t["previous-display"]);
    });
  }
  listenToXRSessionState(t, e) {
    e && (J.onSessionRequestStart((i) => {
      i.mode === e ? t.classList.add("this-mode-is-requested") : (t["was-disabled"] = t.disabled, t.disabled = !0, t.classList.add("other-mode-is-requested"));
    }), J.onSessionRequestEnd((i) => {
      t.classList.remove("this-mode-is-requested"), t.classList.remove("other-mode-is-requested"), t.disabled = t["was-disabled"];
    }));
  }
};
let yo = A_;
r(yo, "_instance");
var Kk = Object.defineProperty, Zk = Object.getOwnPropertyDescriptor, vt = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Zk(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && Kk(t, e, n), n;
};
const iu = x("debugspriterenderer"), Jk = x("wireframe"), mu = class {
  static getOrCreateGeometry(t) {
    if (t.__cached_geometry)
      return t.__cached_geometry;
    if (t.guid && mu.cache[t.guid])
      return iu && console.log("Take cached geometry for sprite", t.guid), mu.cache[t.guid];
    const e = new Ps();
    t.__cached_geometry = e;
    const i = new Float32Array(t.triangles.length * 3), n = new Float32Array(t.triangles.length * 2);
    for (let o = 0; o < t.triangles.length; o += 1) {
      const a = t.triangles[o];
      i[o * 3] = -t.vertices[a].x, i[o * 3 + 1] = t.vertices[a].y, i[o * 3 + 2] = 0;
      const l = t.uv[a];
      n[o * 2] = l.x, n[o * 2 + 1] = 1 - l.y;
    }
    return e.setAttribute("position", new mt(i, 3)), e.setAttribute("uv", new mt(n, 2)), t.guid && (this.cache[t.guid] = e), iu && console.log("Built sprite geometry", t, e), e;
  }
};
let yr = mu;
r(yr, "cache", {});
class e2 {
  constructor() {
    r(this, "x");
    r(this, "y");
  }
}
function ww(s) {
  s && (s.colorSpace != vn && (s.colorSpace = vn, s.needsUpdate = !0), s.minFilter == Id && s.magFilter == Id && (s.anisotropy = 1, s.needsUpdate = !0));
}
let Ro = class {
  constructor(t) {
    r(this, "guid");
    r(this, "texture");
    r(this, "triangles");
    r(this, "uv");
    r(this, "vertices");
    /** @internal */
    r(this, "__cached_geometry");
    r(this, "_mesh");
    r(this, "_material");
    t && (this.texture = t, this.triangles = [0, 1, 2, 0, 2, 3], this.uv = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }], this.vertices = [{ x: -0.5, y: -0.5 }, { x: 0.5, y: -0.5 }, { x: 0.5, y: 0.5 }, { x: -0.5, y: 0.5 }]);
  }
  /**
   * The mesh that represents the sprite
   */
  get mesh() {
    return this._mesh || (this._mesh = new q(yr.getOrCreateGeometry(this), this.material)), this._mesh;
  }
  /**
   * The material used to render the sprite
   */
  get material() {
    return this._material || (this.texture && ww(this.texture), this._material = new Me({
      map: this.texture,
      color: 16777215,
      side: Ri,
      transparent: !0
    })), this._material;
  }
  /**
   * The geometry of the sprite that can be used to create a mesh
   */
  getGeometry() {
    return yr.getOrCreateGeometry(this);
  }
};
vt([
  f()
], Ro.prototype, "guid", 2);
vt([
  f(Fe)
], Ro.prototype, "texture", 2);
vt([
  Ka()
], Ro.prototype, "triangles", 2);
vt([
  Ka()
], Ro.prototype, "uv", 2);
vt([
  Ka()
], Ro.prototype, "vertices", 2);
const fp = Symbol("spriteOwner");
class Nc {
  constructor() {
    r(this, "sprites");
    this.sprites = [];
  }
}
vt([
  f(Ro)
], Nc.prototype, "sprites", 2);
const Fm = class {
  // we don't assign anything here because it's used by the serialization system.
  // there's currently a limitation in the serializer when e.g. spriteSheet is already assigned it will not be overriden by the serializer
  // hence the spriteSheet field is undefined by default
  constructor() {
    r(this, "spriteSheet");
    r(this, "index", 0);
  }
  static create() {
    const s = new Fm();
    return s.spriteSheet = new Nc(), s;
  }
  clone() {
    const s = new Fm();
    return s.index = this.index, s.spriteSheet = this.spriteSheet, s;
  }
  /**
   * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link index}
   */
  set sprite(s) {
    s && (this.spriteSheet ? ((this.index === null || this.index === void 0) && (this.index = 0), this.spriteSheet.sprites[this.index] = s) : (this.spriteSheet = new Nc(), this.spriteSheet.sprites = [s], this.index = 0));
  }
  /** The currently active sprite */
  get sprite() {
    if (this.spriteSheet)
      return this.spriteSheet.sprites[this.index];
  }
  update(s) {
    if (!this.spriteSheet)
      return;
    const t = this.index;
    if (t < 0 || t >= this.spriteSheet.sprites.length)
      return;
    const e = this.spriteSheet.sprites[t], i = e == null ? void 0 : e.texture;
    if (i && (ww(i), !e.__hasLoadedProgressive)) {
      e.__hasLoadedProgressive = !0;
      const n = i;
      Ze.assignTextureLOD(i, 0).then((o) => {
        o instanceof Fe && (e.texture = o, (s == null ? void 0 : s.map) === n && (s.map = o, s.needsUpdate = !0));
      });
    }
  }
};
let br = Fm;
vt([
  f(Nc)
], br.prototype, "spriteSheet", 2);
vt([
  f()
], br.prototype, "index", 2);
class Ei extends I {
  constructor() {
    super(...arguments);
    r(this, "drawMode", 0);
    r(this, "size", { x: 1, y: 1 });
    r(this, "color");
    r(this, "sharedMaterial");
    r(this, "transparent", !0);
    r(this, "cutoutThreshold", 0);
    r(this, "castShadows", !1);
    r(this, "renderOrder", 0);
    r(this, "toneMapped", !0);
    r(this, "_spriteSheet");
    r(this, "_currentSprite");
  }
  /**
   * Assign a new texture to the currently active sprite
   */
  set texture(e) {
    var n;
    if (!this._spriteSheet)
      return;
    const i = (n = this._spriteSheet.spriteSheet) == null ? void 0 : n.sprites[this.spriteIndex];
    i && (i.texture = e, this.updateSprite());
  }
  /**
   * Add a new sprite to the currently assigned sprite sheet. The sprite will be added to the end of the sprite sheet.
   * Note that the sprite will not be rendered by default - set the `spriteIndex` to the index of the sprite to be rendered.
   * @param sprite The sprite to be added
   * @returns The index of the sprite in the sprite sheet
   * @example
   * ```typescript
   * const spriteRenderer = gameObject.addComponent(SpriteRenderer);
   * const index = spriteRenderer.addSprite(mySprite);
   * if(index >= 0)
   *   spriteRenderer.spriteIndex = index;
   * ```
   */
  addSprite(e, i = !1) {
    var o, a;
    if (this._spriteSheet || (this._spriteSheet = br.create()), !this._spriteSheet.spriteSheet)
      return -1;
    (o = this._spriteSheet.spriteSheet) == null || o.sprites.push(e);
    const n = ((a = this._spriteSheet.spriteSheet) == null ? void 0 : a.sprites.length) - 1;
    return i && (this.spriteIndex = n), n;
  }
  get sprite() {
    return this._spriteSheet;
  }
  /**
   * Set the sprite to be rendered in the currently assigned sprite sheet at the currently active index {@link spriteIndex}
   */
  set sprite(e) {
    if (e !== this._spriteSheet)
      if (typeof e == "number") {
        const i = Math.floor(e);
        this.spriteIndex = i;
      } else
        e instanceof Ro ? (this._spriteSheet || (this._spriteSheet = br.create()), this._spriteSheet.sprite != e && (this._spriteSheet.sprite = e), this.updateSprite()) : e != this._spriteSheet && (this._spriteSheet = e, this.updateSprite());
  }
  /**
   * Set the index of the sprite to be rendered in the currently assigned sprite sheet
   */
  set spriteIndex(e) {
    this._spriteSheet && (this._spriteSheet.index = e, this.updateSprite());
  }
  get spriteIndex() {
    var e;
    return ((e = this._spriteSheet) == null ? void 0 : e.index) ?? 0;
  }
  /**
   * Get the number of sprites in the currently assigned sprite sheet
   */
  get spriteFrames() {
    var e, i;
    return ((i = (e = this._spriteSheet) == null ? void 0 : e.spriteSheet) == null ? void 0 : i.sprites.length) ?? 0;
  }
  /** @internal */
  awake() {
    this._currentSprite = void 0, this._spriteSheet ? this._spriteSheet = this._spriteSheet.clone() : this._spriteSheet = br.create(), iu && console.log("Awake", this.name, this, this.sprite);
  }
  /** @internal */
  start() {
    this._currentSprite ? this.gameObject && this.gameObject.add(this._currentSprite) : this.updateSprite();
  }
  /**
   * Update the sprite. Modified properties will be applied to the sprite mesh. This method is called automatically when the sprite is changed.
   * @param force If true, the sprite will be forced to update.
   * @returns True if the sprite was updated successfully
   */
  updateSprite(e = !1) {
    var o;
    if (!this.__didAwake && !e)
      return !1;
    const i = this._spriteSheet;
    if (!((o = i == null ? void 0 : i.spriteSheet) != null && o.sprites))
      return console.warn("SpriteRenderer has no data or spritesheet assigned..."), !1;
    const n = i.spriteSheet.sprites[this.spriteIndex];
    if (!n)
      return iu && console.warn("Sprite not found", this.spriteIndex, i.spriteSheet.sprites), !1;
    if (this._currentSprite)
      this._currentSprite.geometry = yr.getOrCreateGeometry(n), this._currentSprite.material.map = n.texture;
    else {
      const a = new Me({ color: 16777215, side: Ri });
      if (Jk && (a.wireframe = !0), this.color && (a.color || (a.color = new ae()), a.color.copy(this.color), a.opacity = this.color.alpha), a.transparent = !0, a.toneMapped = this.toneMapped, a.depthWrite = !1, n.texture && !a.wireframe) {
        let l = n.texture;
        l[fp] !== void 0 && l[fp] !== this && this.spriteFrames > 1 && (l = n.texture = l.clone()), l[fp] = this, a.map = l;
      }
      this.sharedMaterial = a, this._currentSprite = new q(yr.getOrCreateGeometry(n), a), this._currentSprite.renderOrder = Math.round(this.renderOrder), Ze.assignTextureLOD(a, 0);
    }
    return this._currentSprite.parent !== this.gameObject && (this.drawMode === 2 && this._currentSprite.scale.set(this.size.x, this.size.y, 1), this.gameObject && this.gameObject.add(this._currentSprite)), this._currentSprite && this._currentSprite.layers.set(this.layer), this.sharedMaterial && (this.sharedMaterial.alphaTest = this.cutoutThreshold, this.sharedMaterial.transparent = this.transparent), this._currentSprite.castShadow = this.castShadows, i == null || i.update(this.sharedMaterial), !0;
  }
}
vt([
  f()
], Ei.prototype, "drawMode", 2);
vt([
  f(e2)
], Ei.prototype, "size", 2);
vt([
  f(we)
], Ei.prototype, "color", 2);
vt([
  f(Se)
], Ei.prototype, "sharedMaterial", 2);
vt([
  f()
], Ei.prototype, "transparent", 2);
vt([
  f()
], Ei.prototype, "cutoutThreshold", 2);
vt([
  f()
], Ei.prototype, "castShadows", 2);
vt([
  f()
], Ei.prototype, "renderOrder", 2);
vt([
  f()
], Ei.prototype, "toneMapped", 2);
vt([
  f(br)
], Ei.prototype, "sprite", 1);
const xb = x("debugwebxr"), t2 = new se().makeRotationY(Math.PI), ba = class extends I {
  constructor() {
    super(...arguments);
    r(this, "_arScale", 1);
    /** When enabled the placed scene forward direction will towards the XRRig 
     * @deprecated
     * @default false
    */
    r(this, "invertForward", !1);
    /** When assigned this asset will be loaded and visualize the placement while in AR
     * @default null
     */
    r(this, "customReticle");
    /** Enable touch transform to translate, rotate and scale the scene in AR with multitouch
     * @default true
     */
    r(this, "arTouchTransform", !0);
    /** When enabled the scene will be placed automatically when a point in the real world is found
     * @default false
     */
    r(this, "autoPlace", !1);
    /** When enabled the scene center will be automatically calculated from the content in the scene */
    r(this, "autoCenter", !1);
    /** Experimental: When enabled we will create a XR anchor for the scene placement    
     * and make sure the scene is at that anchored point during a XR session 
     * @default false
     **/
    r(this, "useXRAnchor", !1);
    /** true if we're currently placing the scene */
    r(this, "_isPlacing", !0);
    /** This is the world matrix of the ar session root when entering webxr
     * it is applied when the scene has been placed (e.g. if the session root is x:10, z:10 we want this position to be the center of the scene)
     */
    r(this, "_startOffset", new se());
    r(this, "_createdPlacementObject", null);
    r(this, "_reparentedComponents", []);
    // move objects into a temporary scene while placing (which is not rendered) so that the components won't be disabled during this process
    // e.g. we want the avatar to still be updated while placing
    // another possibly solution would be to ensure from this component that the Rig is *also* not disabled while placing
    r(this, "_placementScene", new Mi());
    /** the reticles used for placement */
    r(this, "_reticle", []);
    /** needs to be in sync with the reticles */
    r(this, "_hits", []);
    r(this, "_placementStartTime", -1);
    r(this, "_rigPlacementMatrix");
    /** if useAnchor is enabled this is the anchor we have created on placing the scene using the placement hit */
    r(this, "_anchor", null);
    /** user input is used for ar touch transform */
    r(this, "userInput");
    r(this, "onPlaceScene", (e) => {
      var o;
      if (this._isPlacing == !1 || e != null && e.used)
        return;
      let i = this._reticle[0];
      if (!i) {
        console.warn("No reticle to place...");
        return;
      }
      if (!i.visible && !this.autoPlace) {
        console.warn("Reticle is not visible (can not place)");
        return;
      }
      if ((o = J.active) != null && o.isTrackingImages) {
        console.warn("Scene Placement is disabled while images are being tracked");
        return;
      }
      let n = this._hits[0];
      if (e && e.origin instanceof V0) {
        const a = this._reticle[e.origin.index];
        a && (i = a, n = this._hits[e.origin.index]);
      }
      if (e && (e.stopImmediatePropagation(), e.stopPropagation(), e.use()), this._isPlacing = !1, this.context.input.removeEventListener("pointerup", this.onPlaceScene), this.onRevertSceneChanges(), i.position.copy(i.lastPos), i.quaternion.copy(i.lastQuat), this.onApplyPose(i), ba._hasPlaced = !0, this.useXRAnchor && this.onCreateAnchor(J.active, n), this.context.xr)
        for (const a of this.context.xr.controllers)
          a.cancelHitTestSource();
    });
    r(this, "upVec", new v(0, 1, 0));
    r(this, "lookPoint", new v());
    r(this, "worldUpVec", new v(0, 1, 0));
  }
  /**
   * Event that is called when the scene has been placed in AR.
   * @param cb the callback that is called when the scene has been placed
   * @returns a function to remove the event listener
   */
  static onPlaced(e) {
    const i = "placed";
    return this._eventListeners[i] || (this._eventListeners[i] = []), this._eventListeners[i].push(e), () => {
      const n = this._eventListeners[i].indexOf(e);
      n >= 0 && this._eventListeners[i].splice(n, 1);
    };
  }
  /**
   * @returns true if the scene has been placed in AR by the user or automatic placement
   */
  static get hasPlaced() {
    return this._hasPlaced;
  }
  /** The scale of the user in AR.  
   * **NOTE**: a large value makes the scene appear smaller  
   * @default 1
   */
  get arScale() {
    return this._arScale;
  }
  set arScale(e) {
    this._arScale = Math.max(1e-6, e), this.onSetScale();
  }
  onEnable() {
    var e;
    (e = this.customReticle) == null || e.preload();
  }
  supportsXR(e) {
    return e === "immersive-ar";
  }
  onEnterXR(e) {
    xb && console.log("ENTER WEBXR: SessionRoot start..."), this._anchor = null, ba._hasPlaced = !1, this.gameObject.updateMatrixWorld(), this._startOffset.copy(this.gameObject.matrixWorld);
    const i = new L();
    this._createdPlacementObject = i, i.name = "AR Session Root", this._placementScene.name = "AR Placement Scene", this._placementScene.children.length = 0;
    for (let n = this.context.scene.children.length - 1; n >= 0; n--) {
      const o = this.context.scene.children[n];
      this._placementScene.add(o);
    }
    if (this.context.scene.add(i), this.autoCenter) {
      const n = ki(this._placementScene.children), o = n.getCenter(new v()), a = n.getSize(new v()), l = new se();
      l.makeTranslation(o.x, o.y - a.y * 0.5, o.z), this._startOffset.multiply(l);
    }
    this._reparentedComponents.length = 0, this._reparentedComponents.push({ comp: this, originalObject: this.gameObject }), S.addComponent(i, this);
    for (const n of this._reticle)
      nn(n);
    this._reticle.length = 0, this._isPlacing = !0, this.context.input.addEventListener("pointerup", this.onPlaceScene, { queue: vi.Early });
  }
  onLeaveXR() {
    this.context.input.removeEventListener("pointerup", this.onPlaceScene, { queue: vi.Early }), this.onRevertSceneChanges(), this._anchor = null, ba._hasPlaced = !1, this._rigPlacementMatrix = void 0;
  }
  onUpdateXR(e) {
    var i, n, o, a;
    if (e.xr.isTrackingImages) {
      for (const l of this._reticle)
        l.visible = !1;
      return;
    }
    if (this._isPlacing) {
      const l = (i = e.xr.rig) == null ? void 0 : i.gameObject;
      l && l.parent !== this.context.scene && this.context.scene.add(l);
      let c = !1;
      if (e.xr.isPassThrough && e.xr.controllers.length > 0 && !this.autoPlace)
        for (const h of e.xr.controllers) {
          const d = h.getHitTest();
          d && (c = !0, this.updateReticleAndHits(e.xr, h.index, d, e.xr.rigScale));
        }
      if (!c) {
        const h = e.xr.getHitTest();
        h && this.updateReticleAndHits(e.xr, 0, h, e.xr.rigScale);
      }
    } else {
      if (this._anchor && e.xr.referenceSpace) {
        const l = e.xr.frame.getPose(this._anchor.anchorSpace, e.xr.referenceSpace);
        if (l && this.context.time.frame % 20 === 0) {
          const c = e.xr.convertSpace(l.transform), h = this._reticle[0];
          h && (h.position.copy(c.position), h.quaternion.copy(c.quaternion), this.onApplyPose(h));
        }
      }
      if (this.arTouchTransform ? (this.userInput || (this.userInput = new ha(this.context)), (n = this.userInput) == null || n.enable()) : (o = this.userInput) == null || o.disable(), this.arTouchTransform && ((a = this.userInput) != null && a.hasChanged)) {
        if (e.xr.rig) {
          const l = e.xr.rig.gameObject;
          this.userInput.applyMatrixTo(l.matrix, !0), l.matrix.decompose(l.position, l.quaternion, l.scale), this.userInput.factor = l.scale.x;
        }
        this.userInput.reset();
      }
    }
  }
  updateReticleAndHits(e, i, n, o) {
    this._hits[i] = n.hit;
    let a = this._reticle[i];
    if (!a) {
      if (this.customReticle)
        if (this.customReticle.asset)
          a = Ha(this.customReticle.asset);
        else {
          this.customReticle.loadAssetAsync();
          return;
        }
      else
        a = new q(
          new P1(0.07, 0.09, 32).rotateX(-Math.PI / 2),
          new Me({ side: Ri, depthTest: !1, depthWrite: !1, transparent: !0, opacity: 1, color: 15658734 })
        ), a.name = "AR Placement Reticle";
      if (xb) {
        const l = new Oi(1);
        l.position.y += 0.01, a.add(l);
      }
      this._reticle[i] = a, a.matrixAutoUpdate = !1, a.visible = !1;
    }
    if (a.lastPos = a.lastPos || n.position.clone(), a.lastQuat = a.lastQuat || n.quaternion.clone(), a.position.copy(a.lastPos.lerp(n.position, this.context.time.deltaTime / 0.1)), a.lastPos.copy(a.position), a.quaternion.copy(a.lastQuat.slerp(n.quaternion, this.context.time.deltaTime / 0.05)), a.lastQuat.copy(a.quaternion), a.scale.set(o, o, o), this.customReticle && this.applyViewBasedTransform(a), a.updateMatrix(), a.visible = !0, a.parent !== this.context.scene && this.context.scene.add(a), this._placementStartTime < 0 && (this._placementStartTime = this.context.time.realtimeSinceStartup), this.autoPlace)
      if (this.upVec.set(0, 1, 0).applyQuaternion(a.quaternion), this.upVec.dot(G(0, 1, 0)) > 0.9) {
        let c = a["autoplace:timer"] || 0;
        c >= 1 ? (a.visible = !1, this.onPlaceScene(null)) : (c += this.context.time.deltaTime, a["autoplace:timer"] = c);
      } else
        a["autoplace:timer"] = 0;
  }
  onSetScale() {
    var i, n, o;
    if (!ba._hasPlaced)
      return;
    const e = (n = (i = J.active) == null ? void 0 : i.rig) == null ? void 0 : n.gameObject;
    if (e) {
      const a = ((o = J.active) == null ? void 0 : o.rigScale) || 1, l = 1 / this._arScale * a, c = new se().makeScale(l, l, l).invert();
      e.matrix.premultiply(c), e.matrix.decompose(e.position, e.quaternion, e.scale);
    }
  }
  onRevertSceneChanges() {
    var e;
    for (const i of this._reticle)
      i && (i.visible = !1, i == null || i.removeFromParent());
    this._reticle.length = 0;
    for (let i = this._placementScene.children.length - 1; i >= 0; i--) {
      const n = this._placementScene.children[i];
      this.context.scene.add(n);
    }
    (e = this._createdPlacementObject) == null || e.removeFromParent();
    for (const i of this._reparentedComponents)
      S.addComponent(i.originalObject, i.comp);
  }
  async onCreateAnchor(e, i) {
    if (i.createAnchor === void 0) {
      console.warn("Hit does not support creating an anchor", i), z() && ve("Hit does not support creating an anchor");
      return;
    } else {
      const n = await i.createAnchor(e.viewerPose.transform);
      e.running && n && (this._anchor = n);
    }
  }
  applyViewBasedTransform(e) {
    const i = this.context.mainCamera, n = e, o = i.worldPosition, a = n.worldPosition;
    this.upVec.set(0, 1, 0).applyQuaternion(e.quaternion);
    const l = i.worldPosition;
    l && e.position.clone().sub(l).angleTo(this.upVec) < Math.PI / 2 && this.upVec.negate();
    const c = this.upVec.angleTo(this.worldUpVec) * 180 / Math.PI, h = 30;
    c > h && c < 180 - h || c < -h && c > -180 + h ? (this.lookPoint.copy(e.position).add(this.upVec), this.lookPoint.y = e.position.y, e.lookAt(this.lookPoint)) : (o.y = a.y, e.lookAt(o));
  }
  onApplyPose(e) {
    var o, a, l;
    const i = (a = (o = J.active) == null ? void 0 : o.rig) == null ? void 0 : a.gameObject;
    if (!i) {
      console.warn("No rig object to place");
      return;
    }
    const n = i.parent || this.context.scene;
    this._rigPlacementMatrix ? (l = this._rigPlacementMatrix) == null || l.decompose(i.position, i.quaternion, i.scale) : this._rigPlacementMatrix = i.matrix.clone(), this.applyViewBasedTransform(e), e.updateMatrix(), this.context.scene.add(e), e.attach(i), e.removeFromParent(), i.scale.set(this.arScale, this.arScale, this.arScale), i.position.multiplyScalar(this.arScale), i.updateMatrix(), this.invertForward && i.matrix.premultiply(t2), i.matrix.premultiply(this._startOffset), i.matrix.decompose(i.position, i.quaternion, i.scale), n.add(i);
  }
};
let gn = ba;
r(gn, "_eventListeners", {}), r(gn, "_hasPlaced", !1);
const gu = class {
  // readonly translate: Vector3 = new Vector3();
  // readonly rotation: Quaternion = new Quaternion();
  // readonly scale: Vector3 = new Vector3(1, 1, 1);
  constructor(t) {
    r(this, "oneFingerDrag", !0);
    r(this, "twoFingerRotate", !0);
    r(this, "twoFingerScale", !0);
    r(this, "factor", 1);
    r(this, "context");
    r(this, "offset");
    r(this, "plane");
    r(this, "_scale", 1);
    r(this, "_hasChanged", !1);
    r(this, "_enabled", !1);
    r(this, "currentlyUsedPointerIds", /* @__PURE__ */ new Set());
    r(this, "currentlyUnusedPointerIds", /* @__PURE__ */ new Set());
    r(this, "onPointerDownEarly", (t) => {
      this.isActive && t.stopPropagation();
    });
    r(this, "onPointerDownLate", (t) => {
      t.used ? this.currentlyUsedPointerIds.add(t.pointerId) : this.currentlyUsedPointerIds.size <= 0 && this.currentlyUnusedPointerIds.add(t.pointerId);
    });
    r(this, "onPointerUpEarly", (t) => {
      this.currentlyUsedPointerIds.delete(t.pointerId), this.currentlyUnusedPointerIds.delete(t.pointerId);
    });
    // private _needsUpdate: boolean = true;
    // private _rotationMatrix: Matrix4 = new Matrix4();
    // private updateMatrix() {
    //     this._needsUpdate = false;
    //     this._rotationMatrix.makeRotationFromQuaternion(this.rotation);
    //     this.offset.compose(this.translate, new Quaternion(), this.scale);
    //     // const rot = this._tempMatrix.makeRotationY(this.angle);
    //     // this.translate.applyMatrix4(rot);
    //     // this.offset.elements[12] = this.translate.x;
    //     // this.offset.elements[13] = this.translate.y;
    //     // this.offset.elements[14] = this.translate.z;
    //     // this.offset.premultiply(rot);
    //     // const s = this.scale;
    //     // this.offset.premultiply(this._tempMatrix.makeScale(s, s, s));
    // }
    r(this, "prev", /* @__PURE__ */ new Map());
    r(this, "_didMultitouch", !1);
    r(this, "touchStart", (t) => {
      if (!t.defaultPrevented)
        for (let e = 0; e < t.changedTouches.length; e++) {
          const i = t.changedTouches[e], n = X.isAndroidDevice() && i.clientY < window.innerHeight * 0.1;
          this.prev.has(i.identifier) || this.prev.set(i.identifier, {
            ignore: n,
            x: 0,
            z: 0,
            screenx: 0,
            screeny: 0
          });
          const o = this.prev.get(i.identifier);
          if (o) {
            const a = this.getPositionOnPlane(i.clientX, i.clientY);
            o.x = a.x, o.z = a.z, o.screenx = i.clientX, o.screeny = i.clientY;
          }
        }
    });
    r(this, "touchEnd", (t) => {
      t.touches.length <= 0 && (this._didMultitouch = !1);
      for (let e = 0; e < t.changedTouches.length; e++) {
        const i = t.changedTouches[e];
        this.prev.delete(i.identifier);
      }
    });
    r(this, "touchMove", (t) => {
      if (!t.defaultPrevented && this.isActive) {
        if (t.touches.length === 1) {
          if (this._didMultitouch)
            return;
          const e = t.touches[0], i = this.prev.get(e.identifier);
          if (!i || i.ignore)
            return;
          const n = this.getPositionOnPlane(e.clientX, e.clientY), o = n.x - i.x, a = n.z - i.z;
          if (o === 0 && a === 0)
            return;
          this.oneFingerDrag && this.addMovement(o, a), i.x = n.x, i.z = n.z, i.screenx = e.clientX, i.screeny = e.clientY;
          return;
        } else if (t.touches.length === 2) {
          this._didMultitouch = !0;
          const e = t.touches[0], i = t.touches[1], n = this.prev.get(e.identifier), o = this.prev.get(i.identifier);
          if (!n || !o)
            return;
          if (this.twoFingerRotate) {
            const a = Math.atan2(e.clientY - i.clientY, e.clientX - i.clientX), l = Math.atan2(n.screeny - o.screeny, n.screenx - o.screenx), c = a - l;
            Math.abs(c) > 1e-3 && this.addRotation(c);
          }
          if (this.twoFingerScale) {
            const a = e.clientX - i.clientX, l = e.clientY - i.clientY, c = Math.sqrt(a * a + l * l), h = n.screenx - o.screenx, d = n.screeny - o.screeny, u = Math.sqrt(h * h + d * d), p = c - u;
            Math.abs(p) > 2 && this.addScale(p);
          }
          n.screenx = e.clientX, n.screeny = e.clientY, o.screenx = i.clientX, o.screeny = i.clientY;
        }
      }
    });
    r(this, "_raycaster", new xu());
    r(this, "_intersection", new v());
    r(this, "_screenPos", new v());
    r(this, "_tempMatrix", new se());
    this.context = t, this.offset = new se(), this.plane = new vr(), this.plane.setFromNormalAndCoplanarPoint(gu.up, gu.zero);
  }
  get scale() {
    return this._scale;
  }
  reset() {
    this._scale = 1, this.offset.identity(), this._hasChanged = !0;
  }
  get hasChanged() {
    return this._hasChanged;
  }
  /**
   * Applies the matrix to the offset matrix
   * @param matrix the matrix to apply the drag offset to
   * @param invert if true the offset matrix will be inverted before applying it to the matrix and premultiplied 
   */
  applyMatrixTo(t, e) {
    this._hasChanged = !1, e ? (this.offset.invert(), t.premultiply(this.offset)) : t.multiply(this.offset);
  }
  get isActive() {
    return this.currentlyUsedPointerIds.size <= 0 && this.currentlyUnusedPointerIds.size > 0;
  }
  enable() {
    this._enabled || (this._enabled = !0, this.context.input.addEventListener("pointerdown", this.onPointerDownEarly, { queue: vi.Early }), this.context.input.addEventListener("pointerdown", this.onPointerDownLate, { queue: vi.Late }), this.context.input.addEventListener("pointerup", this.onPointerUpEarly, { queue: vi.Early }), window.addEventListener("touchstart", this.touchStart, { passive: !1 }), window.addEventListener("touchmove", this.touchMove, { passive: !1 }), window.addEventListener("touchend", this.touchEnd, { passive: !1 }));
  }
  disable() {
    this._enabled && (this._enabled = !1, this.context.input.removeEventListener("pointerdown", this.onPointerDownEarly, { queue: vi.Early }), this.context.input.removeEventListener("pointerdown", this.onPointerDownLate, { queue: vi.Late }), this.context.input.removeEventListener("pointerup", this.onPointerUpEarly, { queue: vi.Early }), window.removeEventListener("touchstart", this.touchStart), window.removeEventListener("touchmove", this.touchMove), window.removeEventListener("touchend", this.touchEnd));
  }
  getPositionOnPlane(t, e) {
    const i = this.context.mainCamera;
    return this._screenPos.x = t / window.innerWidth * 2 - 1, this._screenPos.y = -(e / window.innerHeight) * 2 + 1, this._screenPos.z = 1, this._screenPos.unproject(i), this._raycaster.set(i.position, this._screenPos.sub(i.position)), this._raycaster.ray.intersectPlane(this.plane, this._intersection), this._intersection;
  }
  addMovement(t, e) {
    t /= this._scale, e /= this._scale, t *= this.factor, e *= this.factor, this.offset.elements[12] += t, this.offset.elements[14] += e, (t !== 0 || e !== 0) && (this._hasChanged = !0);
  }
  addScale(t) {
    t /= window.innerWidth, t *= -1, this._scale *= 1 + t, this._tempMatrix.makeScale(1 - t, 1 - t, 1 - t), this.offset.premultiply(this._tempMatrix), t !== 0 && (this._hasChanged = !0);
  }
  addRotation(t) {
    t *= -1, this._tempMatrix.makeRotationY(t), this.offset.premultiply(this._tempMatrix), t !== 0 && (this._hasChanged = !0);
  }
};
let ha = gu;
r(ha, "up", new v(0, 1, 0)), r(ha, "zero", new v(0, 0, 0)), r(ha, "one", new v(1, 1, 1));
const so = x("debugautosync"), pp = Symbol("syncerId");
class i2 {
  constructor() {
    r(this, "_syncers", {});
  }
  getOrCreateSyncer(t) {
    if (!t.guid)
      return null;
    if (this._syncers[t.guid])
      return this._syncers[t.guid];
    const e = new n2(t);
    return e[pp] = t.guid, this._syncers[e[pp]] = e, e;
  }
  removeSyncer(t) {
    delete this._syncers[t[pp]];
  }
}
const Yg = new i2();
class n2 {
  constructor(t) {
    r(this, "comp");
    // private getters: { [key: string]: Function } = {};
    r(this, "hasChanges", !1);
    r(this, "changedProperties", {});
    /** is set to true in on receive call to avoid circular sending */
    r(this, "_isReceiving", !1);
    r(this, "_isInit", !1);
    r(this, "onHandleSending", () => {
      if (!this.hasChanges)
        return;
      this.hasChanges = !1;
      const t = this.comp.context.connection;
      if (!t || !t.isConnected || !t.isInRoom) {
        for (const e in this.changedProperties)
          delete this.changedProperties[e];
        return;
      }
      for (const e in this.changedProperties) {
        const i = this.changedProperties[e];
        so && console.log("SEND", this.comp.guid, this.networkingKey), t.send(this.networkingKey, { guid: this.comp.guid, property: e, data: i }, In.Queued), delete this.changedProperties[e];
      }
    });
    r(this, "onHandleReceiving", (t) => {
      if (so && console.log("SYNCFIELD RECEIVE", this.comp.name, this.comp.guid, t), !!this._isInit && this.comp && t.guid === this.comp.guid)
        try {
          this._isReceiving = !0, this.comp[t.property] = t.data;
        } catch (e) {
          console.error(e);
        } finally {
          this._isReceiving = !1;
        }
    });
    this.comp = t;
  }
  get networkingKey() {
    return this.comp.guid;
  }
  init(t) {
    if (this._isInit)
      return;
    this._isInit = !0, this.comp = t, this.comp.context.post_render_callbacks.push(this.onHandleSending), this.comp.context.connection.beginListen(this.networkingKey, this.onHandleReceiving);
    const e = this.comp.context.connection.tryGetState(this.comp.guid);
    e && this.onHandleReceiving(e);
  }
  destroy() {
    this._isInit && (this.comp.context.post_render_callbacks.splice(this.comp.context.post_render_callbacks.indexOf(this.onHandleSending), 1), this.comp.context.connection.stopListen(this.networkingKey, this.onHandleReceiving), this.comp = null, this._isInit = !1);
  }
  notifyChanged(t, e) {
    this._isReceiving || (so && console.log("Property changed: " + t, e), this.hasChanges = !0, this.changedProperties[t] = e);
  }
}
function s2(s, t) {
  let e = t !== s;
  return !e && s && t && (Array.isArray(s) && Array.isArray(t) || typeof s == "object" && typeof t == "object") && (e = !0), e;
}
const bc = Symbol("AutoSyncHandler");
function o2(s) {
  if (s[bc])
    return s[bc];
  const t = Yg.getOrCreateSyncer(s);
  return t == null || t.init(s), s[bc] = t, t;
}
function r2(s) {
  const t = s[bc];
  t && (Yg.removeSyncer(t), t.destroy(), delete s[bc]);
}
const xw = function(s = null) {
  return function(t, e) {
    var d;
    let i = "";
    typeof e == "string" ? i = e : i = e.name;
    let n = null, o;
    typeof s == "string" ? o = t[s] : typeof s == "function" && (o = s), o == null && (z() || so) && s != null && console.warn('syncField: no callback function found for property "' + i + '"', '"' + s + '"');
    const a = t, l = a.__internalAwake;
    if (typeof l != "function") {
      (so || z()) && console.error('@syncField can currently only used on Needle Engine Components, custom object of type "' + ((d = t == null ? void 0 : t.constructor) == null ? void 0 : d.name) + '" is not supported', t);
      return;
    }
    so && console.log(i);
    const c = Symbol(i);
    a.__internalAwake = function() {
      if (this[c] !== void 0)
        return;
      this[c] = this[i], n = Yg.getOrCreateSyncer(this);
      const u = Object.getOwnPropertyDescriptor(this, i);
      if ((u == null ? void 0 : u.set) === void 0) {
        let p = !1;
        Object.defineProperty(this, i, {
          set: function(m) {
            var _;
            const g = this[c];
            if (this[c] = m, p) {
              (z() || so) && console.warn("Recursive call detected", i);
              return;
            }
            p = !0;
            try {
              const y = s2(m, g);
              so && console.log("SyncField assignment", i, "changed?", y, m, o), y && (o == null ? void 0 : o.call(this, m, g)) !== !1 && ((_ = o2(this)) == null || _.notifyChanged(i, m));
            } finally {
              p = !1;
            }
          },
          get: function() {
            return this[c];
          },
          configurable: !0,
          enumerable: !0
        });
      }
      n == null || n.init(this), l.call(this);
    };
    const h = a.__internalDestroy;
    a.__internalDestroy = function() {
      r2(this), h.call(this);
    };
  };
};
var a2 = Object.defineProperty, l2 = Object.getOwnPropertyDescriptor, ef = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? l2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && a2(t, e, n), n;
};
const Qt = x("debugplayersync"), Sw = class extends I {
  constructor() {
    super(...arguments);
    r(this, "autoSync", !0);
    r(this, "asset");
    r(this, "onPlayerSpawned");
    r(this, "_localInstance");
    r(this, "onJoinedRoom", () => {
      Qt && console.log("PlayerSync.joinedRoom. autoSync is set to " + this.autoSync), this.autoSync && this.getInstance();
    });
    /**
     * Destroys the current player instance and cleans up networking state
     */
    r(this, "destroyInstance", () => {
      var t;
      (t = this._localInstance) == null || t.then((e) => {
        Qt && console.log("PlayerSync.destroyInstance", e), ju(e, this.context.connection, !0, { saveInRoom: !1 });
      }), this._localInstance = void 0;
    });
  }
  /**
   * This API is experimental and may change or be removed in the future.
   * Creates a PlayerSync instance at runtime from a given URL and sets it up for networking
   * @param url Path to the asset that should be instantiated for each player
   * @param init Optional initialization parameters for the PlayerSync component
   * @returns Promise resolving to a PlayerSync instance with a guaranteed asset property
   * @example
   * ```typescript
   * const res = await PlayerSync.setupFrom("/assets/demo.glb");
   * addComponent(res.asset?.asset, DragControls);
   * addComponent(res.asset?.asset, SyncedTransform);
   * scene.add(res.gameObject);
   * ```
   */
  static async setupFrom(t, e) {
    const i = re.getOrCreateFromUrl(t);
    if (!i.asset) {
      const a = await i.loadAssetAsync();
      a && S.getOrAddComponent(a, Ji);
    }
    const n = new Sw();
    n._internalInit(e), n.asset = i;
    const o = new L();
    return o.guid = t, S.addComponent(o, n), n;
  }
  awake() {
    this.watchTabVisible(), this.onPlayerSpawned || (this.onPlayerSpawned = new xe());
  }
  onEnable() {
    this.context.connection.beginListen(ne.RoomStateSent, this.onJoinedRoom), this.context.connection.beginListen(ne.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(ne.LeftRoom, this.destroyInstance), this.context.connection.isInRoom && this.onJoinedRoom();
  }
  onDisable() {
    this.context.connection.stopListen(ne.RoomStateSent, this.onJoinedRoom), this.context.connection.stopListen(ne.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(ne.LeftRoom, this.destroyInstance);
  }
  /**
   * Gets or creates an instance of the assigned asset for the local player
   * @returns Promise resolving to the instantiated player object or null if creation failed
   */
  async getInstance() {
    var e, i, n, o, a, l;
    if (this._localInstance)
      return this._localInstance;
    if (Qt && console.log("PlayerSync.createInstance", (e = this.asset) == null ? void 0 : e.url), !((i = this.asset) != null && i.asset) && !((n = this.asset) != null && n.url))
      return console.error('PlayerSync: can not create an instance because "asset" is not set and or has no URL!'), null;
    this.gameObject.guid || console.warn("PlayerSync: gameObject has no guid! This might cause issues with syncing the player state."), this._localInstance = (o = this.asset) == null ? void 0 : o.instantiateSynced({ parent: this.gameObject, deleteOnDisconnect: !0 }, !0);
    const t = await this._localInstance;
    if (t) {
      const c = S.getComponentsInChildren(t, Ji);
      if (Qt && console.log(`PlayerSync.createInstance: found ${c == null ? void 0 : c.length} PlayerState components. Owner: ${this.context.connection.connectionId}`), c != null && c.length) {
        for (const h of c)
          h.owner = this.context.connection.connectionId;
        (a = this.onPlayerSpawned) == null || a.invoke(t);
      } else
        this._localInstance = void 0, console.error("<strong>Failed finding PlayerState on " + ((l = this.asset) == null ? void 0 : l.url) + "</strong>: please make sure the asset has a PlayerState component!"), S.destroySynced(t);
    } else
      this._localInstance = void 0, console.warn("PlayerSync: failed instantiating asset!");
    return this._localInstance;
  }
  /**
   * Sets up visibility change listeners to handle player cleanup when browser tab visibility changes
   */
  watchTabVisible() {
    window.addEventListener("visibilitychange", (t) => {
      if (document.visibilityState === "visible")
        for (let e = Ji.all.length - 1; e >= 0; e--) {
          const i = Ji.all[e];
          (!i.owner || !this.context.connection.userIsInRoom(i.owner)) && i.doDestroy();
        }
    });
  }
};
let ch = Sw;
ef([
  f()
], ch.prototype, "autoSync", 2);
ef([
  f(re)
], ch.prototype, "asset", 2);
ef([
  f(xe)
], ch.prototype, "onPlayerSpawned", 2);
var c2 = /* @__PURE__ */ ((s) => (s.OwnerChanged = "ownerChanged", s))(c2 || {}), Vl;
const Mt = (Vl = class extends I {
  constructor() {
    super(...arguments);
    /** Event triggered when the owner of this PlayerState changes */
    r(this, "onOwnerChangeEvent", new xe());
    /** Event triggered the first time an owner is assigned to this PlayerState */
    r(this, "onFirstOwnerChangeEvent", new xe());
    /** Indicates if this PlayerState has an owner assigned */
    r(this, "hasOwner", !1);
    r(this, "owner");
    /** 
     * When enabled, PlayerState will not destroy itself when the owner is not connected anymore 
     */
    r(this, "dontDestroy", !1);
    /**
     * Handler for when a user leaves the networked room
     * @param model Object containing the ID of the user who left
     */
    r(this, "onUserLeftRoom", (t) => {
      if (t.userId === this.owner) {
        Qt && console.log("PLAYERSYNC LEFT", this.owner), this.doDestroy();
        return;
      }
    });
  }
  /** All PlayerState instances for all players in the scene */
  static get all() {
    return Mt._all;
  }
  /** All PlayerState instances that belong to the local player */
  static get local() {
    return Mt._local;
  }
  /**
   * Gets the PlayerState component for a given object or component
   * @param obj Object3D or Component to find the PlayerState for
   * @returns The PlayerState component if found, undefined otherwise
   */
  static getFor(t) {
    if (t instanceof L)
      return S.getComponentInParent(t, Mt);
    if (t instanceof I)
      return S.getComponentInParent(t.gameObject, Mt);
  }
  /**
   * Checks if a given object or component belongs to the local player
   * @param obj Object3D or Component to check
   * @returns True if the object belongs to the local player, false otherwise
   */
  static isLocalPlayer(t) {
    const e = Mt.getFor(t);
    return (e == null ? void 0 : e.isLocalPlayer) ?? !1;
  }
  /**
   * Registers a callback for a specific PlayerState event
   * @param event The event to listen for
   * @param cb Callback function that will be invoked when the event occurs
   * @returns The provided callback function for chaining
   */
  static addEventListener(t, e) {
    return this._callbacks[t] || (this._callbacks[t] = []), this._callbacks[t].push(e), e;
  }
  /**
   * Removes a previously registered event callback
   * @param event The event type to remove the callback from
   * @param cb The callback function to remove
   */
  static removeEventListener(t, e) {
    if (!this._callbacks[t])
      return;
    const i = this._callbacks[t].indexOf(e);
    i >= 0 && this._callbacks[t].splice(i, 1);
  }
  static dispatchEvent(t, e) {
    if (this._callbacks[t])
      for (const i of this._callbacks[t])
        i(e);
  }
  /**
   * Indicates if this PlayerState belongs to the local player
   */
  get isLocalPlayer() {
    return this.owner === this.context.connection.connectionId;
  }
  /**
   * Handles owner change events and updates relevant state
   * @param newOwner The new owner's connection ID
   * @param oldOwner The previous owner's connection ID
   */
  onOwnerChange(t, e) {
    var a, l;
    Qt && console.log(`PlayerSync.onOwnerChange: ${e} → ${t} (me: ${this.context.connection.connectionId})`);
    const i = Mt._local.indexOf(this);
    i >= 0 && Mt._local.splice(i, 1);
    const n = {
      playerState: this,
      oldValue: e,
      newValue: t
    };
    if (this.hasOwner || (this.hasOwner = !0, (a = this.onFirstOwnerChangeEvent) == null || a.invoke(n)), (l = this.onOwnerChangeEvent) == null || l.invoke(n), this.owner === this.context.connection.connectionId) {
      Mt._local.push(this);
      const c = new CustomEvent("local-owner-changed", { detail: n });
      this.dispatchEvent(c);
    }
    const o = new CustomEvent("owner-changed", { detail: n });
    this.dispatchEvent(o), Mt.dispatchEvent("ownerChanged", o);
  }
  /** @internal */
  awake() {
    Mt.all.push(this), Qt && console.log("Registered new PlayerState", this.guid, Mt.all.length - 1, Mt.all), this.context.connection.beginListen(ne.UserLeftRoom, this.onUserLeftRoom);
  }
  /** @internal */
  async start() {
    Qt && console.log("PLAYERSTATE.START, owner: " + this.owner, this.context.connection.usersInRoom([])), this.owner ? (this.context.connection.isInRoom || await Gn(300), this.context.connection.userIsInRoom(this.owner) == !1 && (Qt && console.log(`PlayerSync.start → doDestroy "${this.name}" because user "${this.owner}" is not in room anymore...`, "Currently in room:", ...this.context.connection.usersInRoom()), this.doDestroy())) : this.owner || (Qt && console.warn("PlayerState.start → owner is undefined!", this.name), setTimeout(() => {
      !this.destroyed && !this.owner ? this.dontDestroy ? Qt && console.warn("PlayerState.start → owner is still undefined but dontDestroy is set to true", this.name) : (Qt && console.warn(`PlayerState.start → owner is still undefined: destroying "${this.name}" instance now`), this.doDestroy()) : Qt && console.log("PlayerState.start → owner is assigned", this.owner);
    }, 2e3));
  }
  /** Tells the server that this client has been destroyed, and the networking message for the instantiate will be removed      */
  doDestroy() {
    Qt && console.log("PlayerSync.doDestroy → syncDestroy", this.name), ju(this.gameObject, this.context.connection, !0, { saveInRoom: !1 });
  }
  /** @internal */
  onDestroy() {
    if (Qt && console.warn("PlayerState.onDestroy", this.owner), this.context.connection.stopListen(ne.UserLeftRoom, this.onUserLeftRoom), Mt.all.splice(Mt.all.indexOf(this), 1), this.isLocalPlayer) {
      const t = Mt._local.indexOf(this);
      t >= 0 && Mt._local.splice(t, 1);
    }
  }
}, r(Vl, "_all", []), r(Vl, "_local", []), r(Vl, "_callbacks", {}), Vl);
let Ji = Mt;
ef([
  xw(Ji.prototype.onOwnerChange)
], Ji.prototype, "owner", 2);
var h2 = Object.defineProperty, d2 = Object.getOwnPropertyDescriptor, rl = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? d2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && h2(t, e, n), n;
};
class Fs extends I {
  constructor() {
    super(...arguments);
    r(this, "position", "bottom");
    r(this, "showNeedleLogo", !0);
    r(this, "showSpatialMenu");
    r(this, "createFullscreenButton");
    r(this, "createMuteButton");
    r(this, "createQRCodeButton");
  }
  /** 
   * Applies the configured menu options when the component is enabled
   * @hidden
   */
  onEnable() {
    this.applyOptions();
  }
  /** 
   * Applies all configured options to the active {@link Context.menu}.
   */
  applyOptions() {
    this.context.menu.setPosition(this.position), this.context.menu.showNeedleLogo(this.showNeedleLogo), this.createFullscreenButton === !0 && this.context.menu.showFullscreenOption(!0), this.createMuteButton === !0 && this.context.menu.showAudioPlaybackOption(!0), this.showSpatialMenu === !0 && this.context.menu.showSpatialMenu(this.showSpatialMenu), this.createQRCodeButton === !0 && (X.isMobileDevice() || this.context.menu.showQRCodeButton(!0));
  }
}
rl([
  f()
], Fs.prototype, "position", 2);
rl([
  f()
], Fs.prototype, "showNeedleLogo", 2);
rl([
  f()
], Fs.prototype, "showSpatialMenu", 2);
rl([
  f()
], Fs.prototype, "createFullscreenButton", 2);
rl([
  f()
], Fs.prototype, "createMuteButton", 2);
rl([
  f()
], Fs.prototype, "createQRCodeButton", 2);
var u2 = Object.defineProperty, f2 = Object.getOwnPropertyDescriptor, Kg = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? f2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && u2(t, e, n), n;
};
const Dl = x("debugwebxr"), Sb = new W().setFromAxisAngle(new v(0, 1, 0), Math.PI);
class Pr extends I {
  constructor() {
    super(...arguments);
    r(this, "head");
    r(this, "leftHand");
    r(this, "rightHand");
    r(this, "_leftHandMeshes");
    r(this, "_rightHandMeshes");
    r(this, "_syncTransforms");
  }
  async onEnterXR(e) {
    if (!this.activeAndEnabled)
      return;
    Dl && console.warn("AVATAR ENTER XR", this.guid, this.sourceId, this, this.activeAndEnabled), this._syncTransforms && (this._syncTransforms.length = 0), await this.prepareAvatar();
    const i = Ji.getFor(this);
    if (i != null && i.owner) {
      const n = this.gameObject.addComponent(_t);
      n.avatar = this.gameObject, n.connectionId = i.owner;
    } else
      this.context.connection.isConnected ? console.error("No player state found for avatar", this) : i && !this.context.connection.isConnected && (i.dontDestroy = !0);
  }
  onLeaveXR(e) {
    const i = this.gameObject.getComponent(_t);
    i && i.destroy();
  }
  onUpdateXR(e) {
    var h, d;
    if (!this.activeAndEnabled)
      return;
    const i = Ji.isLocalPlayer(this);
    if (!i)
      return;
    const n = e.xr;
    if (n.rig && n.rig.gameObject !== this.gameObject.parent && (this.gameObject.position.set(0, 0, 0), this.gameObject.rotation.set(0, 0, 0), this.gameObject.scale.set(1, 1, 1), n.rig.gameObject.add(this.gameObject)), this._syncTransforms && i)
      for (const u of this._syncTransforms)
        u.fastMode = !0, u.isOwned() || u.requestOwnership();
    if (this.head && this.context.mainCamera) {
      const u = this.head.asset;
      if (u.position.copy(this.context.mainCamera.position), u.position.x *= -1, u.position.z *= -1, u.quaternion.copy(this.context.mainCamera.quaternion), u.quaternion.x *= -1, this.context.time.frameCount % 10 === 0 && this.head.asset) {
        const p = S.getComponentsInChildren(this.head.asset, Xi);
        for (const m of p)
          m.enabled = !1, m.gameObject.visible = !1;
      }
    }
    const o = e.xr.leftController, a = (h = this.leftHand) == null ? void 0 : h.asset;
    o && a ? (a.position.copy(o.gripPosition), a.quaternion.copy(o.gripQuaternion), a.quaternion.multiply(Sb), a.visible = o.isTracking, this.updateHandVisibility(o, a, this._leftHandMeshes)) : a && a.visible && (a.visible = !1);
    const l = e.xr.rightController, c = (d = this.rightHand) == null ? void 0 : d.asset;
    l && c ? (c.position.copy(l.gripPosition), c.quaternion.copy(l.gripQuaternion), c.quaternion.multiply(Sb), c.visible = l.isTracking, this.updateHandVisibility(l, c, this._rightHandMeshes)) : c && c.visible && (c.visible = !1);
  }
  onBeforeRender() {
    this.context.xr && this.context.time.frame % 10 === 0 && this.updateRemoteAvatarVisibility();
  }
  updateHandVisibility(e, i, n) {
    if (n) {
      const o = e.model && e.model.visible && e.model !== i;
      n.forEach((a) => {
        bs(a, !o);
      });
    }
  }
  updateRemoteAvatarVisibility() {
    var e, i, n;
    if (this.context.connection.isConnected) {
      const o = Ji.getFor(this);
      if (o && o.isLocalPlayer == !1) {
        const a = J.getXRSync(this.context);
        if (a && a.hasState(o.owner)) {
          this.tryFindAvatarObjectsIfMissing();
          const l = (e = this.leftHand) == null ? void 0 : e.asset;
          l && (l.visible = (a == null ? void 0 : a.isTracking(o.owner, "left")) ?? !1);
          const c = (i = this.rightHand) == null ? void 0 : i.asset;
          c && (c.visible = (a == null ? void 0 : a.isTracking(o.owner, "right")) ?? !1);
        }
        if ((n = this.head) != null && n.asset) {
          const l = S.getComponentsInChildren(this.head.asset, Xi);
          for (const c of l)
            c.enabled = !1, c.gameObject.visible = !0;
        }
      }
    }
  }
  tryFindAvatarObjectsIfMissing() {
    if (!this.head || !this.leftHand || !this.rightHand) {
      const e = { head: this.head, leftHand: this.leftHand, rightHand: this.rightHand };
      pP.tryFindAvatarObjects(this.gameObject, this.sourceId || "", e), e.head && (this.head = e.head), e.leftHand && (this.leftHand = e.leftHand), e.rightHand && (this.rightHand = e.rightHand);
    }
  }
  async prepareAvatar() {
    var e, i;
    if (this.tryFindAvatarObjectsIfMissing(), this.head)
      this.head instanceof L && (this.head = new re("", this.sourceId, this.head));
    else {
      const n = new L();
      n.name = "Head";
      const o = Ar.createPrimitive(Na.Cube);
      n.add(o), this.gameObject.add(n), this.head = new re("", this.sourceId, n), Dl && console.log("Create head", n);
    }
    if (this.rightHand)
      this.rightHand instanceof L && (this.rightHand = new re("", this.sourceId, this.rightHand));
    else {
      const n = new L();
      n.name = "Right Hand", this.gameObject.add(n), this.rightHand = new re("", this.sourceId, n), Dl && console.log("Create right hand", n);
    }
    if (this.leftHand)
      this.leftHand instanceof L && (this.leftHand = new re("", this.sourceId, this.leftHand));
    else {
      const n = new L();
      n.name = "Left Hand", this.gameObject.add(n), this.leftHand = new re("", this.sourceId, n), Dl && console.log("Create left hand", n);
    }
    await this.loadAvatarObjects(this.head, this.leftHand, this.rightHand), this._leftHandMeshes = [], (e = this.leftHand.asset) == null || e.traverse((n) => {
      n != null && n.isMesh && this._leftHandMeshes.push(n);
    }), this._rightHandMeshes = [], (i = this.rightHand.asset) == null || i.traverse((n) => {
      n != null && n.isMesh && this._rightHandMeshes.push(n);
    }), Ji.isLocalPlayer(this.gameObject) && (this._syncTransforms = S.getComponentsInChildren(this.gameObject, As));
  }
  async loadAvatarObjects(e, i, n) {
    const o = e.loadAssetAsync(), a = i.loadAssetAsync(), l = n.loadAssetAsync(), c = new Array();
    o && c.push(o), a && c.push(a), l && c.push(l);
    const h = await v0(c);
    Dl && console.log("Avatar loaded results:", h);
  }
}
Kg([
  f(re)
], Pr.prototype, "head", 2);
Kg([
  f(re)
], Pr.prototype, "leftHand", 2);
Kg([
  f(re)
], Pr.prototype, "rightHand", 2);
var p2 = Object.defineProperty, m2 = Object.getOwnPropertyDescriptor, tf = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? m2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && p2(t, e, n), n;
};
const rs = x("debugwebxr"), Hs = new Array();
class Es extends I {
  constructor() {
    super(...arguments);
    r(this, "createControllerModel", !0);
    r(this, "createHandModel", !0);
    r(this, "customLeftHand");
    r(this, "customRightHand");
    r(this, "_models", new Array());
  }
  supportsXR(e) {
    return e === "immersive-vr" || e === "immersive-ar";
  }
  async onXRControllerAdded(e) {
    var o;
    if (!(e.xr.isVR || e.xr.isPassThrough))
      return;
    const { controller: n } = e;
    if (rs && console.warn("Add Controller Model for", n.side, n.index), this.createControllerModel || this.createHandModel) {
      if (n.hand) {
        if (this.createHandModel) {
          const a = await this.loadHandModel(this, n);
          if (!a || !n.connected || !n.isHand) {
            a != null && a.handObject && Rl(a.handObject, !1), (o = a == null ? void 0 : a.handObject) == null || o.destroy();
            return;
          }
          this._models.push({ controller: n, model: a.handObject, handmesh: a.handmesh }), this._models.sort((l, c) => l.controller.index - c.controller.index), this.scene.add(a.handObject), n.model = a.handObject;
        }
      } else if (this.createControllerModel) {
        const a = await n.getModelUrl();
        if (a) {
          const l = await this.loadModel(n, a);
          if (!l || !n.connected || n.isHand)
            return;
          this._models.push({ controller: n, model: l }), this._models.sort((c, h) => c.controller.index - h.controller.index), this.scene.add(l), l.traverse((c) => {
            c.layers.set(2), c.matrixAutoUpdate = !1, c.updateMatrix();
          }), n.model = l;
        } else
          n.targetRayMode !== "transient-pointer" && console.warn("XRControllerModel: no model found for " + n.side);
      }
    }
  }
  onXRControllerRemoved(e) {
    console.debug("XR Controller Removed", e.controller.side, e.controller.index);
    const i = this._models.findIndex((o) => o.controller === e.controller), n = this._models[i];
    n && (this._models.splice(i, 1), n.model && (Rl(n.model, !1), n.model.destroy(), n.model = void 0));
  }
  onBeforeXR(e, i) {
    this.createHandModel && (this.customLeftHand || this.customRightHand) && (i.optionalFeatures = i.optionalFeatures || [], i.optionalFeatures.includes("hand-tracking") || i.optionalFeatures.push("hand-tracking"));
  }
  onLeaveXR(e) {
    for (const i of this._models)
      i && (i.model && (Rl(i.model, !1), i.model.destroy(), i.model = void 0), i.controller.model === i.model && (i.controller.model = null));
    this._models.length = 0;
  }
  onBeforeRender() {
    if (J.active && (rs && (Hs[0] = Date.now()), this.updateRendering(J.active), rs)) {
      const e = Date.now() - Hs[0];
      Hs.push(e), Hs.length >= 30 && (Hs[0] = 0, Hs.reduce((i, n) => i + n, 0) / Hs.length, Hs.length = 0);
    }
  }
  updateRendering(e) {
    var i, n, o, a, l;
    for (let c = 0; c < this._models.length; c++) {
      const h = this._models[c];
      if (!h)
        continue;
      const d = h.controller;
      if (!d.connected) {
        rs && console.warn("XRControllerModel.onUpdateXR: controller is not connected anymore", d.side, d.hand);
        continue;
      }
      if (h.model && !h.handmesh)
        h.model.matrixAutoUpdate = !1, h.model.matrix.copy(d.gripMatrix), h.model.visible = d.isTracking, (i = e.rig) == null || i.gameObject.add(h.model);
      else if (d.inputSource.hand && h.handmesh) {
        const u = e.referenceSpace, p = this.context.renderer.xr.getHand(d.index);
        if (u && e.frame.getJointPose) {
          for (const m of d.inputSource.hand.values()) {
            const g = p.joints[m.jointName];
            if (g) {
              const _ = d.getHandJointPose(m);
              if (_) {
                const y = _.transform.position, b = _.transform.orientation;
                g.position.copy(y), g.quaternion.copy(b), g.matrixAutoUpdate = !1;
              }
              g.visible = _ != null;
            }
          }
          h.model && (h.model.visible = d.isTracking, h.model.visible && h.model.parent !== ((n = e.rig) == null ? void 0 : n.gameObject) && ((o = e.rig) == null || o.gameObject.add(h.model))), (a = h.model) != null && a.visible && ((l = h.handmesh) == null || l.updateMesh(), h.model.matrixAutoUpdate = !1, h.model.matrix.identity(), h.model.applyMatrix4(Sa));
        }
      }
    }
  }
  async loadModel(e, i) {
    var a;
    if (!e.connected)
      return console.warn("XRControllerModel.onXRControllerAdded: controller is not connected anymore", e.side), null;
    const o = await re.getOrCreate("", i).instantiate();
    return Rl(o), (a = J.active) != null && a.isPassThrough && o.traverseVisible((l) => {
      this.makeOccluder(l);
    }), o;
  }
  async loadHandModel(e, i) {
    const n = this.context, o = n.renderer.xr.getHand(i.index);
    o || (rs ? V.DrawLabel(i.rayWorldPosition, "No hand found for index " + i.index, 0.05, 5) : console.warn("No hand found for index " + i.index));
    const a = new xr();
    Nu(a, n), await Im(a, n, this.sourceId ?? "");
    const l = qg(a);
    let c = "";
    const h = i.side === "left" ? this.customLeftHand : this.customRightHand;
    h ? (c = h.url.split(".").slice(0, -1).join("."), a.setPath("")) : (c = i.inputSource.handedness === "left" ? "left" : "right", a.setPath("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/"));
    const d = new L();
    Rl(d);
    const u = new oS(d, o, a.path, c, a, (p) => {
      var g;
      const m = l.gltf;
      ((g = m == null ? void 0 : m.scene.children) == null ? void 0 : g.length) === 0 && (m.scene.children[0] = p), Hn().createBuiltinComponents(e.context, e.sourceId || c, l.gltf, null, l), p.traverse((_) => {
        var y;
        _.layers.set(2), (y = J.active) != null && y.isPassThrough && !h && this.makeOccluder(_), _ instanceof q && Ze.assignMeshLOD(_, 0);
      }), i.connected || (rs && V.DrawLabel(i.rayWorldPosition, "Hand is loaded but not connected anymore", 0.05, 5), p.removeFromParent());
    });
    if (rs && d.add(new Oi(0.5)), i.inputSource.hand) {
      rs && console.log(i.inputSource.hand);
      for (const p of i.inputSource.hand.values())
        if (o.joints[p.jointName] === void 0) {
          const m = new ho();
          m.matrixAutoUpdate = !1, m.visible = !0, o.joints[p.jointName] = m, o.add(m);
        }
    } else
      rs && V.DrawLabel(i.rayWorldPosition, "No inputSource.hand found for index " + i.index, 0.05, 5);
    return { handObject: d, handmesh: u };
  }
  makeOccluder(e) {
    if (e instanceof q) {
      let i = e.material;
      i instanceof Se && (i = e.material = i.clone(), i.depthWrite = !0, i.depthTest = !0, i.colorWrite = !1, e.receiveShadow = !1, e.renderOrder = -100);
    }
  }
}
r(Es, "factory", new sS());
tf([
  f()
], Es.prototype, "createControllerModel", 2);
tf([
  f()
], Es.prototype, "createHandModel", 2);
tf([
  f(re)
], Es.prototype, "customLeftHand", 2);
tf([
  f(re)
], Es.prototype, "customRightHand", 2);
class Zg extends I {
}
var g2 = Object.defineProperty, _2 = Object.getOwnPropertyDescriptor, ko = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? _2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && g2(t, e, n), n;
};
const mp = x("debugwebxr");
class on extends I {
  constructor() {
    super(...arguments);
    r(this, "movementSpeed", 1.5);
    r(this, "rotationStep", 30);
    r(this, "useTeleport", !0);
    r(this, "usePinchToTeleport", !0);
    r(this, "useTeleportTarget", !1);
    r(this, "useTeleportFade", !1);
    r(this, "showRays", !0);
    r(this, "showHits", !0);
    r(this, "isXRMovementHandler", !0);
    r(this, "xrSessionMode", "immersive-vr");
    r(this, "_didApplyRotation", !1);
    r(this, "_didTeleport", !1);
    r(this, "_teleportBuffer", new Array());
    r(this, "_plane", null);
    r(this, "_lines", []);
    r(this, "_hitDiscs", []);
    r(this, "_hitDistances", []);
    r(this, "_lastHitDistances", []);
    r(this, "hitPointRaycastFilter", (e) => e.type === "SkinnedMesh" ? "continue in children" : !0);
  }
  onUpdateXR(e) {
    const i = e.xr.rig;
    if (!(i != null && i.gameObject) || e.xr.isPassThrough)
      return;
    const n = e.xr.leftController, o = e.xr.rightController;
    n && this.onHandleMovement(n, i.gameObject), o && (this.onHandleRotation(o, i.gameObject), this.useTeleport && this.onHandleTeleport(o, i.gameObject));
  }
  onLeaveXR(e) {
    for (const i of this._lines)
      i.removeFromParent();
    for (const i of this._hitDiscs)
      i == null || i.removeFromParent();
  }
  onBeforeRender() {
    var e;
    (e = this.context.xr) != null && e.running && (this.showRays && this.renderRays(this.context.xr), this.showHits && this.renderHits(this.context.xr));
  }
  onHandleMovement(e, i) {
    const n = e.getStick("xr-standard-thumbstick");
    if (n.x != 0 || n.y != 0) {
      const o = G(n.x, 0, n.y);
      o.multiplyScalar(this.context.time.deltaTimeUnscaled * this.movementSpeed);
      const a = Ke(i);
      o.multiplyScalar(a.x), o.applyQuaternion(e.xr.poseOrientation), o.y = 0, o.applyQuaternion(i.worldQuaternion), i.position.add(o), i.updateWorldMatrix(!1, !1);
      for (const l of i.children)
        l.updateWorldMatrix(!1, !1);
    }
  }
  onHandleRotation(e, i) {
    if (e._isMxInk)
      return;
    const o = e.getStick("xr-standard-thumbstick").x;
    if (this._didApplyRotation)
      Math.abs(o) < 0.3 && (this._didApplyRotation = !1);
    else if (Math.abs(o) > 0.5) {
      this._didApplyRotation = !0;
      const a = o > 0 ? 1 : -1, l = ie(this.context.mainCamera).clone();
      i.rotateY(a * $.toRadians(this.rotationStep));
      const h = ie(this.context.mainCamera).clone().sub(l);
      h.y = 0, i.position.sub(h);
    }
  }
  onHandleTeleport(e, i) {
    var o, a, l, c, h;
    let n = 0;
    if (e.hand && this.usePinchToTeleport && e.isTeleportGesture) {
      const d = e.getPointerId("primary");
      if (d != null && this.context.input.getIsPointerIdInUse(d))
        return;
      const u = e.getGesture("pinch");
      u && (n = u.value);
    } else
      n = (o = e.getStick("xr-standard-thumbstick")) == null ? void 0 : o.y;
    if (this._didTeleport)
      n >= 0 && n < 0.4 ? this._didTeleport = !1 : n < 0 && n > -0.4 && (this._didTeleport = !1);
    else if (n > 0.8) {
      this._didTeleport = !0;
      const d = this.context.physics.raycastFromRay(e.ray)[0];
      if (d && d.object instanceof Ba) {
        const p = (a = d.normal) == null ? void 0 : a.dot(G(0, 1, 0));
        if (p !== void 0 && p < 0.4)
          return;
      }
      let u = d == null ? void 0 : d.point;
      if (!u && !this.useTeleportTarget) {
        this._plane || (this._plane = new vr(new v(0, 1, 0), 0));
        const p = i.worldPosition;
        this._plane.setFromNormalAndCoplanarPoint(new v(0, 1, 0), p);
        const m = e.ray;
        u = p.clone(), this._plane.intersectLine(new O1(m.origin, G(m.direction).multiplyScalar(1e4).add(m.origin)), u), u.distanceTo(p) > i.scale.x * 10 && (u = null);
      }
      if (u) {
        if (this.useTeleportTarget && !S.getComponentInParent(d.object, Zg))
          return;
        const p = u.clone();
        if (mp && V.DrawSphere(u, 0.025, 16711680, 5), (l = this.context.mainCamera) == null ? void 0 : l.position) {
          const g = (c = this.context.xr) == null ? void 0 : c.getUserOffsetInRig();
          g && (g.y = 0, p.sub(g), mp && V.DrawWireSphere(g.add(p), 0.025, 65280, 5));
        }
        this._teleportBuffer.push(i.matrix.clone()), this._teleportBuffer.length > 10 && this._teleportBuffer.shift(), this.useTeleportFade ? (h = e.xr.fadeTransition()) == null || h.then(() => {
          i.worldPosition = p;
        }) : i.worldPosition = p;
      }
    } else if (n < -0.8 && (this._didTeleport = !0, this._teleportBuffer.length > 0)) {
      const d = this._teleportBuffer.pop();
      d && d.decompose(i.position, i.quaternion, i.scale);
    }
  }
  renderRays(e) {
    var i;
    for (let n = 0; n < this._lines.length; n++) {
      const o = this._lines[n];
      o && (o.visible = !1);
    }
    for (let n = 0; n < e.controllers.length; n++) {
      const o = e.controllers[n];
      let a = this._lines[n];
      if (!o.connected || !o.isTracking || !o.ray || o.targetRayMode === "transient-pointer" || !o.hasSelectEvent) {
        a && (a.visible = !1);
        continue;
      }
      a || (a = this.createRayLineObject(), a.scale.z = 0.5, this._lines[n] = a), o.updateRayWorldPosition(), o.updateRayWorldQuaternion();
      const l = o.rayWorldPosition, c = o.rayWorldQuaternion;
      a.position.copy(l), a.quaternion.copy(c);
      const h = e.rigScale, d = this.usePinchToTeleport && o.isTeleportGesture, u = this._lastHitDistances[n], p = this._hitDistances[n] != null, m = u ?? h;
      a.scale.set(h, h, m), a.visible = !0, a.layers.disableAll(), a.layers.enable(2);
      let g = a.material.opacity;
      d ? g = 1 : this.showHits && m < e.rigScale * 0.5 ? g = 0 : (i = o.getButton("primary")) != null && i.pressed ? g = 0.5 : g = p ? 0.2 : 0.1, a.material.opacity = $.lerp(a.material.opacity, g, this.context.time.deltaTimeUnscaled / 0.1), a.parent !== this.context.scene && this.context.scene.add(a);
    }
  }
  renderHits(e) {
    var i;
    for (const n of this._hitDiscs) {
      if (!n)
        continue;
      const o = n.controller;
      if (!o || !o.connected || !o.isTracking) {
        n.visible = !1;
        continue;
      }
    }
    for (let n = 0; n < e.controllers.length; n++) {
      const o = e.controllers[n];
      if (!o.connected || !o.isTracking || !o.ray || !o.hasSelectEvent)
        continue;
      let a = this._hitDiscs[n], l = !0;
      const c = o.getPointerId("primary");
      c != null && this.context.input.getIsPointerIdInUse(c) && (a && (a.visible = !1), this._hitDistances[n] = null, this._lastHitDistances[n] = 0, l = !1);
      const h = this.context.time.smoothedFps >= 59 ? 1 : 10;
      if ((this.context.time.frame + o.index) % h !== 0 && (l = !1), !l) {
        const p = this._hitDiscs[n];
        p && p.visible && p.hit && this.updateHitPointerPosition(o, p, p.hit.distance);
        continue;
      }
      const d = this.context.physics.raycastFromRay(o.ray, { testObject: this.hitPointRaycastFilter, precise: !1 });
      let u = d.find((p) => this.usePinchToTeleport && o.isTeleportGesture ? !0 : this.isObjectWithInteractiveComponent(p.object));
      if (u || (u = d[0]), a && (a.controller = o, a.hit = u), this._hitDistances[n] = (u == null ? void 0 : u.distance) || null, u) {
        this._lastHitDistances[n] = u.distance;
        const p = e.rigScale ?? 1;
        mp && (V.DrawWireSphere(u.point, 0.025 * p, 16711680), V.DrawLabel(G(0, 0.2, 0).add(u.point), u.object.name, 0.02, 0)), a || (a = this.createHitPointObject(), this._hitDiscs[n] = a), a.hit = u, a.visible = u.distance > p * 0.05;
        let m = 0.01 * (p + u.distance);
        const g = (i = o.getButton("primary")) == null ? void 0 : i.pressed;
        g && (m *= 1.1), a.scale.set(m, m, m), a.layers.set(2);
        let _ = a.material.opacity;
        if (g ? _ = 1 : _ = u.distance < 0.15 * p ? 0.2 : 0.6, a.material.opacity = $.lerp(a.material.opacity, _, this.context.time.deltaTimeUnscaled / 0.1), a.visible) {
          if (u.normal) {
            this.updateHitPointerPosition(o, a, u.distance);
            const y = u.normal.applyQuaternion(Ce(u.object));
            a.quaternion.setFromUnitVectors(y2, y);
          } else
            this.updateHitPointerPosition(o, a, u.distance);
          a.parent !== this.context.scene && this.context.scene.add(a);
        }
      } else
        this._hitDiscs[n] && (this._hitDiscs[n].visible = !1);
    }
  }
  isObjectWithInteractiveComponent(e, i = 0) {
    return km(e) || e.isUI === !0 ? !0 : e.isScene ? !1 : e.parent ? this.isObjectWithInteractiveComponent(e.parent, i + 1) : !1;
  }
  updateHitPointerPosition(e, i, n) {
    const o = G(e.rayWorldPosition);
    o.add(G(0, 0, n - 0.01).applyQuaternion(e.rayWorldQuaternion)), i.position.lerp(o, this.context.time.deltaTimeUnscaled / 0.05);
  }
  /** create an object to visualize hit points in the scene */
  createHitPointObject() {
    const e = new q(
      new vu(0.3, 6, 6),
      // new RingGeometry(.3, 0.5, 32).rotateX(- Math.PI / 2),
      new Me({
        color: 15658734,
        opacity: 0.7,
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
        side: Ri
      })
    );
    return e.layers.disableAll(), e.layers.enable(2), e;
  }
  /** create an object to visualize controller rays */
  createRayLineObject() {
    const e = new rS();
    e.layers.disableAll(), e.layers.enable(2);
    const i = new aS();
    e.geometry = i;
    const n = new Float32Array(9);
    n.set([0, 0, 0.02, 0, 0, 0.4, 0, 0, 1]), i.setPositions(n);
    const o = new Float32Array(9);
    o.set([1, 1, 1, 0.1, 0.1, 0.1, 0, 0, 0]), i.setColors(o);
    const a = new lS({
      color: 16777215,
      vertexColors: !0,
      worldUnits: !0,
      linewidth: 4e-3,
      transparent: !0,
      depthWrite: !1,
      // TODO: this doesnt work with passthrough
      blending: o0,
      dashed: !1
      // alphaToCoverage: true,
    });
    return e.material = a, e;
  }
}
ko([
  f()
], on.prototype, "movementSpeed", 2);
ko([
  f()
], on.prototype, "rotationStep", 2);
ko([
  f()
], on.prototype, "useTeleport", 2);
ko([
  f()
], on.prototype, "usePinchToTeleport", 2);
ko([
  f()
], on.prototype, "useTeleportTarget", 2);
ko([
  f()
], on.prototype, "useTeleportFade", 2);
ko([
  f()
], on.prototype, "showRays", 2);
ko([
  f()
], on.prototype, "showHits", 2);
const y2 = new v(0, 1, 0);
var b2 = Object.defineProperty, v2 = Object.getOwnPropertyDescriptor, wt = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? v2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && b2(t, e, n), n;
};
const Ll = x("debugwebxr"), w2 = x("debugusdz");
var Up;
const da = (Up = class extends I {
  constructor() {
    super(...arguments);
    r(this, "createVRButton", !0);
    r(this, "createARButton", !0);
    r(this, "createSendToQuestButton", !0);
    r(this, "createQRCode", !0);
    r(this, "useDefaultControls", !0);
    r(this, "showControllerModels", !0);
    r(this, "showHandModels", !0);
    r(this, "usePlacementReticle", !0);
    r(this, "customARPlacementReticle");
    r(this, "usePlacementAdjustment", !0);
    r(this, "arScale", 1);
    r(this, "useXRAnchor", !1);
    r(this, "autoPlace", !1);
    r(this, "autoCenter", !1);
    r(this, "useQuicklookExport", !1);
    r(this, "useDepthSensing", !1);
    r(this, "useSpatialGrab", !0);
    r(this, "defaultAvatar");
    r(this, "_playerSync");
    /** these components were created by the WebXR component on session start and will be cleaned up again in session end */
    r(this, "_createdComponentsInSession", []);
    r(this, "_usdzExporter");
    r(this, "_exitXRMenuButton");
    r(this, "_previousXRState", 0);
    r(this, "_spatialGrabRaycaster");
    r(this, "_activeWebARSessionRoot", null);
    /**
     * Event handler called when a player avatar is spawned.
     * Ensures the avatar has the necessary Avatar component.
     * @param instance The spawned avatar 3D object
     */
    r(this, "onAvatarSpawned", (t) => {
      Ll && console.log("WebXR.onAvatarSpawned", t), S.getComponentInChildren(t, Pr) ?? (e = S.addComponent(t, Pr));
    });
    /**
     * Reference to the WebXR button factory used by this component.
     */
    r(this, "_buttonFactory");
    /**
     * Storage for UI buttons created by this component.
     */
    r(this, "_buttons", []);
  }
  /**
   * Initializes the WebXR component by obtaining the XR sync object for this context.
   * @internal
   */
  awake() {
    J.getXRSync(this.context);
  }
  /**
   * Sets up the WebXR component when it's enabled. Checks for HTTPS connection,
   * sets up USDZ export if enabled, creates UI buttons, and configures avatar settings.
   * @internal
   */
  onEnable() {
    var t, e;
    window.location.protocol !== "https:" && ve('<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API" target="_blank">WebXR</a> only works on secure connections (https).'), this.useQuicklookExport && (S.findObjectOfType(Ge) || (Ll && console.log("WebXR: Adding USDZExporter"), this._usdzExporter = S.addComponent(this.gameObject, Ge), this._usdzExporter.objectToExport = this.context.scene, this._usdzExporter.autoExportAnimations = !0, this._usdzExporter.autoExportAudioSources = !0)), this.handleCreatingHTML(), this.handleOfferSession(), this.defaultAvatar === !0 && (Ll && console.warn("WebXR: No default avatar set, using static default avatar"), this.defaultAvatar = new re("https://cdn.needle.tools/static/avatars/DefaultAvatar.glb")), this.defaultAvatar && (this._playerSync = this.gameObject.getOrAddComponent(ch), this._playerSync.autoSync = !1), this._playerSync && typeof this.defaultAvatar != "boolean" && (this._playerSync.asset = this.defaultAvatar, (t = this._playerSync.onPlayerSpawned) == null || t.removeEventListener(this.onAvatarSpawned), (e = this._playerSync.onPlayerSpawned) == null || e.addEventListener(this.onAvatarSpawned));
  }
  /**
   * Cleans up resources when the component is disabled.
   * Destroys the USDZ exporter if one was created and removes UI buttons.
   * @internal
   */
  onDisable() {
    var t;
    (t = this._usdzExporter) == null || t.destroy(), this.removeButtons();
  }
  /**
   * Checks if WebXR is supported and offers an appropriate session.
   * This is used to show the WebXR session joining prompt in browsers that support it.
   * @returns A Promise that resolves to true if a session was offered, false otherwise
   */
  async handleOfferSession() {
    return this.createVRButton && await J.isVRSupported() && this.createVRButton ? J.offerSession("immersive-vr", "default", this.context) : this.createARButton && await J.isARSupported() && this.createARButton ? J.offerSession("immersive-ar", "default", this.context) : !1;
  }
  /** the currently active webxr input session */
  get session() {
    return J.active ?? null;
  }
  /** immersive-vr or immersive-ar */
  get sessionMode() {
    return J.activeMode ?? null;
  }
  /** While AR: this will return the currently active WebARSessionRoot component.   
   * You can also query this component in your scene with `findObjectOfType(WebARSessionRoot)` 
   */
  get arSessionRoot() {
    return this._activeWebARSessionRoot;
  }
  /** Call to start an WebVR session.     
   * 
   * This is a shorthand for `NeedleXRSession.start("immersive-vr", init, this.context)`
  */
  async enterVR(t) {
    return J.start("immersive-vr", t, this.context);
  }
  /** Call to start an WebAR session   
   * 
   * This is a shorthand for `NeedleXRSession.start("immersive-ar", init, this.context)`
  */
  async enterAR(t) {
    return J.start("immersive-ar", t, this.context);
  }
  /** Call to end a WebXR (AR or VR) session.   
   * 
   * This is a shorthand for `NeedleXRSession.stop()`
   */
  exitXR() {
    J.stop();
  }
  get isActiveWebXR() {
    return !da.activeWebXRComponent || da.activeWebXRComponent === this;
  }
  /**
   * Called before entering a WebXR session. Sets up optional features like depth sensing, if needed.
   * @param _mode The XR session mode being requested (immersive-ar or immersive-vr)
   * @param args The XRSessionInit object that will be passed to the WebXR API
   * @internal
   */
  onBeforeXR(t, e) {
    var i;
    if (!this.isActiveWebXR) {
      console.warn(`WebXR: another WebXR component is already active (${(i = da.activeWebXRComponent) == null ? void 0 : i.name}). This is ignored: ${this.name}`);
      return;
    }
    da.activeWebXRComponent = this, t == "immersive-ar" && this.useDepthSensing && (e.optionalFeatures = e.optionalFeatures || [], e.optionalFeatures.push("depth-sensing"));
  }
  /**
   * Called when a WebXR session begins. Sets up the scene for XR by configuring controllers,
   * AR placement, and other features based on component settings.
   * @param args Event arguments containing information about the started XR session
   * @internal
   */
  async onEnterXR(t) {
    if (!this.isActiveWebXR)
      return;
    Ll && console.log("WebXR onEnterXR"), this._previousXRState = ei.Global.Mask;
    const e = t.xr.isVR;
    if (ei.Global.Set(e ? ws.VR : ws.AR), t.xr.isAR) {
      let i = S.findObjectOfType(gn);
      if (!i)
        if (this.usePlacementReticle) {
          const n = new L();
          for (const o of this.context.scene.children)
            n.add(o);
          this.context.scene.add(n), i = S.addComponent(n, gn), this._createdComponentsInSession.push(i);
        } else
          (Ll || z()) && console.warn("WebXR: No WebARSessionRoot found in scene and usePlacementReticle is disabled in WebXR component.");
      this._activeWebARSessionRoot = i, i && (i.customReticle = this.customARPlacementReticle, i.arScale = this.arScale, i.arTouchTransform = this.usePlacementAdjustment, i.autoPlace = this.autoPlace, i.autoCenter = this.autoCenter, i.useXRAnchor = this.useXRAnchor);
    }
    this.useDefaultControls && this.setDefaultMovementEnabled(!0), (this.showControllerModels || this.showHandModels) && this.setDefaultControllerRenderingEnabled(!0), this.useSpatialGrab && (this._spatialGrabRaycaster = S.findObjectOfType(gr) ?? void 0, this._spatialGrabRaycaster || (this._spatialGrabRaycaster = this.gameObject.addComponent(gr))), this.createLocalAvatar(t.xr), t.xr.isScreenBasedAR || (this._exitXRMenuButton = this.context.menu.appendChild({
      label: "Quit XR",
      onClick: () => this.exitXR(),
      icon: "exit_to_app",
      priority: 2e4
    }));
  }
  /**
   * Called every frame during an active WebXR session.
   * Updates components that depend on the current XR state.
   * @param _args Event arguments containing information about the current XR session frame
   * @internal
   */
  onUpdateXR(t) {
    this.isActiveWebXR && this._spatialGrabRaycaster && (this._spatialGrabRaycaster.enabled = this.useSpatialGrab);
  }
  /**
   * Called when a WebXR session ends. Restores pre-session state,
   * removes temporary components, and cleans up resources.
   * @param _ Event arguments containing information about the ended XR session
   * @internal
   */
  onLeaveXR(t) {
    var e, i;
    if ((e = this._exitXRMenuButton) == null || e.remove(), !!this.isActiveWebXR) {
      ei.Global.Set(this._previousXRState), (i = this._playerSync) == null || i.destroyInstance();
      for (const n of this._createdComponentsInSession)
        n.destroy();
      this._createdComponentsInSession.length = 0, this._activeWebARSessionRoot = null, this.handleOfferSession(), ku(1).then(() => da.activeWebXRComponent = null);
    }
  }
  /** Call to enable or disable default controller behaviour */
  setDefaultMovementEnabled(t) {
    let e = this.gameObject.getComponent(on);
    return !e && t && (e = this.gameObject.addComponent(on), this._createdComponentsInSession.push(e)), e && (e.enabled = t), e;
  }
  /** Call to enable or disable default controller rendering */
  setDefaultControllerRenderingEnabled(t) {
    let e = this.gameObject.getComponent(Es);
    return !e && t && (e = this.gameObject.addComponent(Es), this._createdComponentsInSession.push(e), e.createControllerModel = this.showControllerModels, e.createHandModel == this.showHandModels), e && (e.enabled = t), e;
  }
  /**
   * Creates and instantiates the user's avatar representation in the WebXR session.
   * @param xr The active session
   */
  async createLocalAvatar(t) {
    this._playerSync && t.running && typeof this.defaultAvatar != "boolean" && (this._playerSync.asset = this.defaultAvatar, await this._playerSync.getInstance());
  }
  // HTML UI
  /** @deprecated use {@link getButtonsFactory} or directly access {@link WebXRButtonFactory.getOrCreate} */
  getButtonsContainer() {
    return this.getButtonsFactory();
  }
  /**
   * Returns the WebXR button factory, creating one if it doesn't exist.
   * Use this to access and modify WebXR UI buttons.
   * @returns The WebXRButtonFactory instance
   */
  getButtonsFactory() {
    return this._buttonFactory || (this._buttonFactory = yo.getOrCreate()), this._buttonFactory;
  }
  /**
   * Creates and sets up UI elements for WebXR interaction based on component settings
   * and device capabilities. Handles creating AR, VR, QuickLook buttons and utility buttons like QR codes.
   */
  handleCreatingHTML() {
    if (this.createARButton || this.createVRButton || this.useQuicklookExport) {
      if ((X.isiOS() && X.isSafari() || w2) && this.useQuicklookExport) {
        const e = S.findObjectOfType(Ge);
        if (!e || e && e.allowCreateQuicklookButton) {
          const i = this.getButtonsFactory().createQuicklookButton();
          this.addButton(i, 50);
        }
      }
      if (this.createARButton) {
        const e = this.getButtonsFactory().createARButton();
        this.addButton(e, 50);
      }
      if (this.createVRButton) {
        const e = this.getButtonsFactory().createVRButton();
        this.addButton(e, 50);
      }
    }
    if (this.createSendToQuestButton && !X.isQuest() && J.isVRSupported().then((e) => {
      if (!e) {
        const i = this.getButtonsFactory().createSendToQuestButton();
        this.addButton(i, 50);
      }
    }), this.createQRCode) {
      const e = Uu(Fs);
      if (e && e.createQRCodeButton === !1)
        z() && console.warn("WebXR: QRCode button is disabled in the Needle Menu component");
      else if (!X.isMobileDevice()) {
        const i = zn.getOrCreate().createQRCode();
        this.addButton(i, 50);
      }
    }
  }
  /**
   * Adds a button to the UI with the specified priority.
   * @param button The HTML element to add
   * @param priority The button's priority value (lower numbers appear first)
   */
  addButton(t, e) {
    this._buttons.push(t), t.setAttribute("priority", e.toString()), this.context.menu.appendChild(t);
  }
  /**
   * Removes all buttons created by this component from the UI.
   */
  removeButtons() {
    for (const t of this._buttons)
      t.remove();
    this._buttons.length = 0;
  }
}, r(Up, "activeWebXRComponent", null), Up);
let et = da;
wt([
  f()
], et.prototype, "createVRButton", 2);
wt([
  f()
], et.prototype, "createARButton", 2);
wt([
  f()
], et.prototype, "createSendToQuestButton", 2);
wt([
  f()
], et.prototype, "createQRCode", 2);
wt([
  f()
], et.prototype, "useDefaultControls", 2);
wt([
  f()
], et.prototype, "showControllerModels", 2);
wt([
  f()
], et.prototype, "showHandModels", 2);
wt([
  f()
], et.prototype, "usePlacementReticle", 2);
wt([
  f(re)
], et.prototype, "customARPlacementReticle", 2);
wt([
  f()
], et.prototype, "usePlacementAdjustment", 2);
wt([
  f()
], et.prototype, "arScale", 2);
wt([
  f()
], et.prototype, "useXRAnchor", 2);
wt([
  f()
], et.prototype, "autoPlace", 2);
wt([
  f()
], et.prototype, "autoCenter", 2);
wt([
  f()
], et.prototype, "useQuicklookExport", 2);
wt([
  f()
], et.prototype, "useDepthSensing", 2);
wt([
  f()
], et.prototype, "useSpatialGrab", 2);
wt([
  f(re)
], et.prototype, "defaultAvatar", 2);
const Yh = x("debugusdzbehaviours");
class Cw {
  constructor() {
    r(this, "behaviours", []);
    r(this, "behaviourComponents", []);
    r(this, "behaviourComponentsCopy", []);
    r(this, "audioClips", []);
    r(this, "audioClipsCopy", []);
    r(this, "targetUuids", /* @__PURE__ */ new Set());
  }
  get extensionName() {
    return "Behaviour";
  }
  addBehavior(t) {
    this.behaviours.push(t);
  }
  /** Register audio clip for USDZ export. The clip will be embedded in the resulting file. */
  addAudioClip(t) {
    if (!t || typeof t != "string")
      return "";
    const i = "audio/" + nl.getName(t);
    return this.audioClips.push({ clipUrl: t, filesKey: i }), i;
  }
  getAllTargetUuids() {
    return this.targetUuids;
  }
  onBeforeBuildDocument(t) {
    if (!t.root)
      return Promise.resolve();
    const e = [];
    return t.root.traverse((i) => {
      S.foreachComponent(i, (n) => {
        var a;
        const o = n;
        if (typeof o.createBehaviours == "function" || typeof o.beforeCreateDocument == "function" || typeof o.afterCreateDocument == "function" || typeof o.afterSerialize == "function") {
          this.behaviourComponents.push(o);
          const l = (a = o.beforeCreateDocument) == null ? void 0 : a.call(o, this, t);
          l instanceof Promise && e.push(l);
        }
      }, !1);
    }), Yh && console.log("onBeforeBuildDocument: all components", this.behaviourComponents), Promise.all(e);
  }
  onExportObject(t, e, i) {
    var n;
    for (const o of this.behaviourComponents)
      (n = o.createBehaviours) == null || n.call(o, this, e, i);
  }
  onAfterBuildDocument(t) {
    for (const u of this.behaviourComponents)
      typeof u.afterCreateDocument == "function" && u.afterCreateDocument(this, t);
    this.behaviourComponentsCopy = this.behaviourComponents.slice(), this.behaviourComponents.length = 0, this.audioClipsCopy = this.audioClips.slice(), this.audioClips.length = 0;
    const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), a = Yh;
    let l = `graph LR
`, c = "";
    function h(u) {
      if (u instanceof nr) {
        a && (l += `subgraph Group_${u.id}
`);
        for (const p of u.actions)
          a && (l += `${u.id}[${u.id}] -- ${u.type},loops:${u.loops} --> ${p.id}[${p.id}]
`), h(p);
        a && (l += `end
`);
      } else if (u instanceof bi) {
        u.tokenId === "StartAnimation" && o.add(u);
        let p = u.tokenId;
        u.type !== void 0 && (p += ":" + u.type);
        const m = u.affectedObjects;
        if (m)
          if (Array.isArray(m))
            for (const _ of m)
              i.add(_), a && (c += `${u.id}[${u.id}
${p}] -- ${p} --> ${_.uuid}(("${_.displayName || _.name || _.uuid}"))
`);
          else
            typeof m == "object" ? (i.add(m), a && (c += `${u.id}[${u.id}
${p}] -- ${p} --> ${m.uuid}(("${m.displayName || m.name || m.uuid}"))
`)) : typeof m == "string" && i.add({ uuid: m });
        const g = u.xFormTarget;
        g && (typeof g == "object" ? (i.add(g), a && (c += `${u.id}[${u.id}
${p}] -- ${p} --> ${g.uuid}(("${g.displayName || g.name || g.uuid}"))
`)) : typeof g == "string" && i.add({ uuid: g }));
      }
    }
    function d(u, p) {
      if (Array.isArray(u))
        for (const m of u)
          d(m, p);
      else if (u instanceof _o) {
        let m = u.tokenId;
        u.type !== void 0 && (m += ":" + u.type), typeof u.targetId == "object" && (e.add(u.targetId), a && (c += `${u.targetId.uuid}(("${u.targetId.displayName}")) --> ${u.id}[${u.id}
${m}]
`)), a && (l += `${u.id}((${u.id})) -- ${m} --> ${p.id}[${p.tokenId || p.id}]
`);
      }
    }
    for (const u of this.behaviours)
      a && (l += `subgraph ${u.id}
`), h(u.action), d(u.trigger, u.action), a && (l += `end
`);
    a && (l += `
` + c), a && (console.log("All USDZ behaviours", this.behaviours), this.behaviours.length && (console.warn("The Mermaid graph can be pasted into https://massive-mermaid.glitch.me/ or https://mermaid.live/edit. It should be in your clipboard already!"), console.log(l), navigator.clipboard.writeText(l)));
    {
      let u = `gantt
title Animations
dateFormat X
axisFormat %s
`;
      const p = Array.from(o), m = /* @__PURE__ */ new Set();
      for (const b of p)
        if (b.affectedObjects && typeof b.affectedObjects != "string") {
          if (Array.isArray(b.affectedObjects))
            for (const w of b.affectedObjects)
              m.add(w);
          else
            m.add(b.affectedObjects);
          a && (u += `section ${b.animationName} (${b.id})
`, u += `${b.id} : ${b.start}, ${b.duration}s
`);
        }
      a && o.size && console.log(u);
      const g = /* @__PURE__ */ new Set();
      for (const b of m) {
        b.getPath || console.error("USDZExporter: Animation target object has no getPath method. This is likely a bug", b);
        let w = b.getPath();
        w.startsWith("<") && (w = w.substring(1)), w.endsWith(">") && (w = w.substring(0, w.length - 1)), g.add({ path: w, obj: b });
      }
      const _ = Array.from(g).sort((b, w) => b.path.length - w.path.length), y = new Array();
      for (let b = 0; b < _.length; b++)
        for (let w = b + 1; w < _.length; w++)
          if (_[w].path.startsWith(_[b].path)) {
            const P = _[w], k = _[b];
            y.push({ child: P.obj.displayName + " (" + P.path + ")", parent: k.obj.displayName + " (" + k.path + ")" });
          }
      y.length && console.warn(
        "USDZExporter: There are overlapping PlayAnimation actions. This can lead to undefined runtime behaviour when playing multiple animations. Please restructure the hierarchy so that animations don't overlap.",
        {
          overlappingTargets: y,
          playAnimationActions: o
        }
      );
    }
    for (const u of /* @__PURE__ */ new Set([...e, ...i]))
      if (Array.isArray(u))
        for (const p of u)
          n.add(p.uuid);
      else
        n.add(u.uuid);
    Yh && console.log("All Behavior trigger sources and action targets", e, i, n), this.targetUuids = new Set(n);
  }
  onAfterHierarchy(t, e) {
    var i;
    if ((i = this.behaviours) != null && i.length) {
      e.beginBlock('def Scope "Behaviors"');
      for (const n of this.behaviours)
        n.writeTo(this, t.document, e);
      e.closeBlock();
    }
  }
  async onAfterSerialize(t) {
    Yh && console.log("onAfterSerialize behaviours", this.behaviourComponentsCopy);
    for (const e of this.behaviourComponentsCopy)
      typeof e.afterSerialize == "function" && (e.afterSerialize.constructor.name === "AsyncFunction" ? await e.afterSerialize(this, t) : e.afterSerialize(this, t));
    for (const { clipUrl: e, filesKey: i } of this.audioClipsCopy) {
      if (t.files[i])
        return;
      const a = await (await (await fetch(e)).blob()).arrayBuffer(), l = new Uint8Array(a);
      t.files[i] = l;
    }
    this.behaviourComponentsCopy.length = 0, this.audioClipsCopy.length = 0;
  }
}
class Pw {
  get extensionName() {
    return "Physics";
  }
  onExportObject(t, e, i) {
    const n = S.getComponents(t, _e).filter((c) => c.enabled), o = S.getComponents(t, Ai).filter((c) => c.enabled && !c.isTrigger);
    let a = n.length > 0 ? n[0] : null;
    const l = o.length > 0 ? o[0] : null;
    l && !a && (a = new _e(), a.isKinematic = !0), a && e.addEventListener("serialize", (c, h) => {
      var d, u, p;
      if (a) {
        if (c.appendLine(), c.beginBlock('def RealityKitComponent "RigidBody"', "{", !0), a.useGravity || c.appendLine("bool gravityEnabled = 0"), c.appendLine('uniform token info:id = "RealityKit.RigidBody"'), a.isKinematic && c.appendLine('token motionType = "Kinematic"'), c.beginBlock('def RealityKitStruct "massFrame"', "{", !0), c.appendLine(`float m_mass = ${a.mass}`), c.beginBlock('def RealityKitStruct "m_pose"', "{", !0), c.appendLine(`float3 position = (${a.centerOfMass.x}, ${a.centerOfMass.y}, ${a.centerOfMass.z})`), c.closeBlock("}"), c.closeBlock("}"), o.length > 0) {
          const m = o[0];
          c.beginBlock('def RealityKitStruct "material"', "{", !0);
          const g = m.sharedMaterial;
          g && g.dynamicFriction !== void 0 && c.appendLine(`double dynamicFriction = ${(d = m.sharedMaterial) == null ? void 0 : d.dynamicFriction}`), g && g.bounciness !== void 0 && c.appendLine(`double restitution = ${(u = m.sharedMaterial) == null ? void 0 : u.bounciness}`), g && g.staticFriction !== void 0 && c.appendLine(`double staticFriction = ${(p = m.sharedMaterial) == null ? void 0 : p.staticFriction}`), c.closeBlock("}");
        }
        c.closeBlock("}");
      }
    }), l && (e.addEventListener("serialize", (c, h) => {
      var p;
      c.beginBlock('def RealityKitComponent "Collider"', "{", !0), c.appendLine("uint group = 1"), c.appendLine('uniform token info:id = "RealityKit.Collider"'), c.appendLine("uint mask = 4294967295");
      const u = l.isTrigger ? "Trigger" : "Default";
      if (c.appendLine(`token type = "${u}"`), c.beginBlock('def RealityKitStruct "Shape"', "{", !0), l instanceof th) {
        const m = l;
        c.appendLine('token shapeType = "Sphere"'), c.appendLine(`float radius = ${m.radius}`);
      } else if (l instanceof ih) {
        const m = l;
        c.appendLine('token shapeType = "Box"'), c.appendLine(`float3 extent = (${m.size.x}, ${m.size.y}, ${m.size.z})`);
      } else if (l instanceof So) {
        const m = l;
        c.appendLine('token shapeType = "Capsule"'), c.appendLine(`float radius = ${m.radius}`), c.appendLine(`float height = ${m.height}`);
      } else if (l instanceof jr && ((p = l.sharedMesh) != null && p.geometry)) {
        const m = l.sharedMesh.geometry;
        m.boundingBox || m.computeBoundingBox();
        const g = l.sharedMesh.geometry.boundingBox;
        g && (c.appendLine('token shapeType = "Box"'), c.appendLine(`float3 extent = (${g.max.x - g.min.x}, ${g.max.y - g.min.y}, ${g.max.z - g.min.z})`), console.log("[USDZ] Only Box, Sphere, and Capsule colliders are supported in visionOS/iOS. MeshCollider will be exported as Box", l));
      } else
        console.warn("[USDZ] Only Box, Sphere, and Capsule colliders are supported in visionOS/iOS. Ignoring collider:", l);
      c.beginBlock('def RealityKitStruct "pose"', "{", !0), c.closeBlock("}"), c.closeBlock("}"), c.closeBlock("}");
    }), o.length > 1 && console.log("WARNING: Multiple colliders detected. visionOS / iOS can only support objects with a single collider, only exporting the first collider: ", l));
  }
}
var x2 = Object.defineProperty, S2 = Object.getOwnPropertyDescriptor, hh = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? S2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && x2(t, e, n), n;
};
const gp = x("debugui"), _p = x("debuguilayout");
class C2 {
  constructor() {
    r(this, "width");
    r(this, "height");
  }
}
class P2 {
  constructor() {
    r(this, "x");
    r(this, "y");
    r(this, "width");
    r(this, "height");
  }
}
const dn = new v(), jl = new se(), Kh = new W(), Ow = class extends xn {
  constructor() {
    super(...arguments);
    r(this, "_anchoredPosition");
    r(this, "sizeDelta", new oe(100, 100));
    r(this, "pivot", new oe(0.5, 0.5));
    r(this, "anchorMin", new oe(0, 0));
    r(this, "anchorMax", new oe(1, 1));
    // @serializable(Vector2)
    // offsetMin: Vector2 = new Vector2(0, 0);
    // @serializable(Vector2)
    // offsetMax: Vector2 = new Vector2(0, 0);
    /** Optional min width in pixel, set to undefined to disable it */
    r(this, "minWidth");
    /** Optional min height in pixel, set to undefined to disable it */
    r(this, "minHeight");
    // private lastMatrixWorld!: Matrix4;
    r(this, "lastMatrix");
    r(this, "rectBlock");
    r(this, "_transformNeedsUpdate", !1);
    r(this, "_initialPosition");
    r(this, "_parentRectTransform");
    r(this, "_lastUpdateFrame", -1);
    // onAfterRender() {
    //     if (this._copyMatrixAfterRender) {
    //         // can we only have this event when the transform changed in this frame? Otherwise all RectTransforms will be iterated. Not sure what is better
    //         this.lastMatrixWorld.copy(this.gameObject.matrixWorld);
    //     }
    // }
    r(this, "_lastAnchoring");
    r(this, "_createdBlocks", []);
    r(this, "_createdTextBlocks", []);
  }
  get parent() {
    return this._parentRectTransform;
  }
  // @serializable(Object3D)
  // root? : Object3D;
  get translation() {
    return this.gameObject.position;
  }
  get rotation() {
    return this.gameObject.quaternion;
  }
  get scale() {
    return this.gameObject.scale;
  }
  get anchoredPosition() {
    return this._anchoredPosition || (this._anchoredPosition = new oe()), this._anchoredPosition;
  }
  set anchoredPosition(t) {
    this._anchoredPosition = t;
  }
  get width() {
    let t = this.sizeDelta.x;
    if (this.anchorMin.x !== this.anchorMax.x && this._parentRectTransform) {
      const e = this._parentRectTransform.width, i = this.anchorMax.x - this.anchorMin.x;
      t = e * i, t += this.sizeDelta.x;
    }
    return this.minWidth !== void 0 && t < this.minWidth ? this.minWidth : t;
  }
  get height() {
    let t = this.sizeDelta.y;
    if (this.anchorMin.y !== this.anchorMax.y && this._parentRectTransform) {
      const e = this._parentRectTransform.height, i = this.anchorMax.y - this.anchorMin.y;
      t = e * i, t += this.sizeDelta.y;
    }
    return this.minHeight !== void 0 && t < this.minHeight ? this.minHeight : t;
  }
  awake() {
    super.awake(), this._anchoredPosition || (this._anchoredPosition = new oe()), this.lastMatrix = new se(), this.rectBlock = new L(), this.rectBlock.name = this.name, this._initialPosition = this.gameObject.position.clone(), this._initialPosition.z = 0, ra(this, "_anchoredPosition", () => {
      this.markDirty();
    }), ra(this, "sizeDelta", () => {
      this.markDirty();
    }), ra(this, "pivot", () => {
      this.markDirty();
    }), ra(this, "anchorMin", () => {
      this.markDirty();
    }), ra(this, "anchorMax", () => {
      this.markDirty();
    });
  }
  onEnable() {
    var t;
    super.onEnable(), this.rectBlock || (this.rectBlock = new L()), this.lastMatrix || (this.lastMatrix = new se()), this._lastAnchoring || (this._lastAnchoring = new oe()), this._initialPosition || (this._initialPosition = new v()), this._anchoredPosition || (this._anchoredPosition = new oe()), this.addShadowComponent(this.rectBlock), this._transformNeedsUpdate = !0, (t = this.canvas) == null || t.registerTransform(this);
  }
  onDisable() {
    var t;
    super.onDisable(), this.removeShadowComponent(), (t = this.canvas) == null || t.unregisterTransform(this);
  }
  onParentRectTransformChanged(t) {
    this._transformNeedsUpdate || this.onApplyTransform(_p ? `${t.name} changed` : void 0);
  }
  get isDirty() {
    return this._transformNeedsUpdate || (this._transformNeedsUpdate = !this.lastMatrix.equals(this.gameObject.matrix)), this._transformNeedsUpdate;
  }
  // private _copyMatrixAfterRender: boolean = false;
  markDirty() {
    this._transformNeedsUpdate || (_p && console.warn("RectTransform markDirty()", this.name), this._transformNeedsUpdate = !0, this._lastUpdateFrame = -1);
  }
  /** Will update the transforms if it changed or is dirty */
  updateTransform() {
    (this._transformNeedsUpdate || !this.lastMatrix.equals(this.gameObject.matrix)) && this.canUpdate() && this.onApplyTransform(this._transformNeedsUpdate ? "Marked dirty" : "Matrix changed");
  }
  canUpdate() {
    return this._transformNeedsUpdate && this.activeAndEnabled && this._lastUpdateFrame !== this.context.time.frame;
  }
  onApplyTransform(t) {
    var n;
    if (this.context.time.frameCount === this._lastUpdateFrame)
      return;
    this._lastUpdateFrame = this.context.time.frameCount;
    const e = this.shadowComponent;
    if (!e)
      return;
    this.gameObject.parent ? this._parentRectTransform = S.getComponentInParent(this.gameObject.parent, Ow) : this._parentRectTransform = void 0, this._transformNeedsUpdate = !1, _p && console.warn("RectTransform → ApplyTransform", this.name + " because " + t), this.isRoot() ? this.Root.screenspace || (e.rotation.y = Math.PI) : (e.matrix.identity(), e.matrixAutoUpdate = !1, dn.set(0, 0, 0), this.applyPivot(dn), e.matrix.setPosition(dn.x, dn.y, 0), (this.gameObject.quaternion.x || this.gameObject.quaternion.y || this.gameObject.quaternion.z) && (Kh.copy(this.gameObject.quaternion), Kh.x *= -1, Kh.z *= -1, jl.makeRotationFromQuaternion(Kh), e.matrix.premultiply(jl)), dn.set(0, 0, 0), this.applyAnchoring(dn), (n = this.canvas) != null && n.screenspace ? dn.z += 0.1 : dn.z += 0.01, jl.identity(), jl.setPosition(dn.x, dn.y, dn.z), e.matrix.premultiply(jl), e.matrix.scale(this.gameObject.scale)), this.lastMatrix.copy(this.gameObject.matrix);
    const i = !0;
    for (const o of Tg(this.gameObject, xn, i, 1)) {
      if (o === this || !o.activeAndEnabled)
        continue;
      const a = o;
      a.onParentRectTransformChanged && a.onParentRectTransformChanged(this);
    }
  }
  /** applies the position offset to the passed in vector */
  applyAnchoring(t) {
    this._lastAnchoring || (this._lastAnchoring = new oe());
    const e = this._lastAnchoring.sub(this._anchoredPosition);
    this.gameObject.position.x += e.x, this.gameObject.position.y += e.y, this._lastAnchoring.copy(this._anchoredPosition), t.x += this._initialPosition.x - this.gameObject.position.x, t.y += this._initialPosition.y - this.gameObject.position.y, t.z += this._initialPosition.z - this.gameObject.position.z;
    const i = this._parentRectTransform;
    if (i) {
      let n = 0;
      const o = 1 - this.anchorMax.y - this.anchorMin.y;
      n -= i.height * 0.5 * o, t.y += n;
      let a = 0;
      const l = 1 - this.anchorMax.x - this.anchorMin.x;
      a -= i.width * 0.5 * l, t.x += a;
    }
  }
  /** applies the pivot offset to the passed in vector */
  applyPivot(t) {
    if (this.pivot && !this.isRoot()) {
      const e = this.pivot.x - 0.5;
      t.x -= e * this.sizeDelta.x * this.gameObject.scale.x;
      const i = this.pivot.y - 0.5;
      t.y -= i * this.sizeDelta.y * this.gameObject.scale.y;
    }
  }
  getBasicOptions() {
    const t = {
      width: this.sizeDelta.x,
      height: this.sizeDelta.y,
      // * this.context.mainCameraComponent!.aspect,
      offset: 0,
      backgroundOpacity: 0,
      borderWidth: 0,
      // if we dont specify width here a border will automatically propagated to child blocks
      borderRadius: 0,
      borderOpacity: 0,
      letterSpacing: -0.03
      // justifyContent: 'center',
      // alignItems: 'center',
      // alignContent: 'center',
      // backgroundColor: new Color(1, 1, 1),
    };
    return this.ensureValidSize(t), t;
  }
  // e.g. when a transform has the size 0,0 we still want to render the text
  ensureValidSize(t, e = 1e-4) {
    return t.width <= 0 && (t.width = e), t.height <= 0 && (t.height = 1e-4), t;
  }
  createNewBlock(t) {
    t = {
      ...this.getBasicOptions(),
      ...t
    }, gp && console.log(this.name, t);
    const e = new m0(t);
    return this._createdBlocks.push(e), e;
  }
  createNewText(t) {
    gp && console.log(t), t = {
      ...this.getBasicOptions(),
      ...t
    }, gp && console.log(this.name, t);
    const e = new p0(t);
    return this._createdTextBlocks.push(e), e;
  }
};
let ii = Ow;
hh([
  f(oe)
], ii.prototype, "anchoredPosition", 1);
hh([
  f(oe)
], ii.prototype, "sizeDelta", 2);
hh([
  f(oe)
], ii.prototype, "pivot", 2);
hh([
  f(oe)
], ii.prototype, "anchorMin", 2);
hh([
  f(oe)
], ii.prototype, "anchorMax", 2);
var O2 = Object.defineProperty, M2 = Object.getOwnPropertyDescriptor, Mw = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? M2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && O2(t, e, n), n;
};
class dh extends I {
  constructor() {
    super(...arguments);
    r(this, "effectColor");
    r(this, "effectDistance");
  }
}
Mw([
  f(we)
], dh.prototype, "effectColor", 2);
Mw([
  f(oe)
], dh.prototype, "effectDistance", 2);
var R2 = Object.defineProperty, k2 = Object.getOwnPropertyDescriptor, Rw = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? k2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && R2(t, e, n), n;
};
const Zh = {
  backgroundColor: new ae(1, 1, 1),
  backgroundOpacity: 1,
  borderColor: new ae(1, 1, 1),
  borderOpacity: 1
};
var Np;
const ec = (Np = class extends xn {
  constructor() {
    super(...arguments);
    r(this, "_alphaFactor", 1);
    r(this, "sRGBColor", new ae(1, 0, 1));
    r(this, "raycastTarget", !0);
    r(this, "uiObject", null);
    r(this, "_color", null);
    r(this, "_rect", null);
    r(this, "_stateManager", null);
    r(this, "_currentlyCreatingPanel", !1);
  }
  get isGraphic() {
    return !0;
  }
  get color() {
    return this._color || (this._color = new we(1, 1, 1, 1)), this._color;
  }
  set color(t) {
    (!this._color || this._color.r !== t.r || this._color.g !== t.g || this._color.b !== t.b || this._color.alpha !== t.alpha) && (this._color || (this._color = new we(1, 1, 1, 1)), this._color.copy(t), this.onColorChanged());
  }
  setAlphaFactor(t) {
    this._alphaFactor = t, this.onColorChanged();
  }
  get alphaFactor() {
    return this._alphaFactor;
  }
  onColorChanged() {
    this.uiObject && (this.sRGBColor.copy(this._color), this.sRGBColor.convertLinearToSRGB(), Zh.backgroundColor = this.sRGBColor, Zh.backgroundOpacity = this._color.alpha * this._alphaFactor, this.applyEffects(Zh, this._alphaFactor), this.uiObject.set(Zh), this.markDirty());
  }
  // used via animations
  get m_Color() {
    return this._color;
  }
  get rectTransform() {
    if (this._rect || (this._rect = S.getComponent(this.gameObject, ii)), !this._rect)
      throw new Error("Not Supported: Make sure to add a RectTransform component before adding a UI Graphic component.");
    return this._rect;
  }
  onParentRectTransformChanged() {
    var t;
    (t = this.uiObject) == null || t.set({ width: this.rectTransform.width, height: this.rectTransform.height }), this.markDirty();
  }
  __internalNewInstanceCreated(t) {
    return super.__internalNewInstanceCreated(t), this._rect = null, this.uiObject = null, this._color && (this._color = this._color.clone()), this;
  }
  setState(t) {
    this.makePanel(), this.uiObject && (this.uiObject.setState(t), this == null || this.markDirty());
  }
  setupState(t) {
    this.makePanel(), this.uiObject && (this._stateManager || (this._stateManager = new RS(this.uiObject)), this.uiObject.setupState(t.state, t.attributes));
  }
  setOptions(t) {
    this.makePanel(), this.uiObject && this.uiObject.set(t);
  }
  awake() {
    super.awake(), this.makePanel(), ra(this, "_color", () => VM(this, this.onColorChanged));
  }
  onEnable() {
    var t;
    super.onEnable(), this.uiObject && ((t = this.rectTransform.shadowComponent) == null || t.add(this.uiObject), this.addShadowComponent(this.uiObject, this.rectTransform));
  }
  onDisable() {
    super.onDisable(), this.uiObject && this.removeShadowComponent();
  }
  makePanel() {
    if (this.uiObject || this._currentlyCreatingPanel)
      return;
    this._currentlyCreatingPanel = !0;
    const t = 0.015, e = {
      backgroundColor: this.color,
      backgroundOpacity: this.color.alpha,
      offset: t
      // without a tiny offset we get z fighting
    };
    this.onBeforeCreate(e), this.applyEffects(e), this.onCreate(e), this.controlsChildLayout = !1, this._currentlyCreatingPanel = !1, this.onAfterCreated(), this.onColorChanged();
  }
  onBeforeCreate(t) {
  }
  onCreate(t) {
    this.uiObject = this.rectTransform.createNewBlock(t), this.uiObject.name = this.name;
  }
  onAfterCreated() {
  }
  applyEffects(t, e = 1) {
    var n;
    const i = (n = this.gameObject) == null ? void 0 : n.getComponent(dh);
    i && (i.effectDistance && (t.borderWidth = Math.max(Math.abs(i.effectDistance.x), Math.abs(i.effectDistance.y))), i.effectColor && (t.borderColor = i.effectColor, t.borderOpacity = i.effectColor.alpha * e));
  }
  async setTexture(t) {
    if (this.setOptions({ backgroundOpacity: 0 }), t) {
      if (ec.textureCache.has(t))
        t = ec.textureCache.get(t);
      else if (!t.isRenderTargetTexture) {
        const e = t.clone();
        e.colorSpace = wr, ec.textureCache.set(t, e), t = e;
      }
      this.setOptions({ backgroundImage: t, borderRadius: 0, backgroundOpacity: this.color.alpha, backgroundSize: "stretch" }), Ze.assignTextureLOD(t, 0).then((e) => {
        e instanceof Fe && (t && ec.textureCache.set(t, e), this.setOptions({ backgroundImage: e }), this.markDirty());
      });
    } else
      this.setOptions({ backgroundImage: void 0, borderRadius: 0, backgroundOpacity: this.color.alpha });
    this.markDirty();
  }
  onAfterAddedToScene() {
    super.onAfterAddedToScene(), this.shadowComponent && (this.shadowComponent.offset = this.shadowComponent.position.z);
  }
}, /** used internally to ensure textures assigned to UI use linear encoding */
r(Np, "textureCache", /* @__PURE__ */ new Map()), Np);
let al = ec;
Rw([
  f(we)
], al.prototype, "color", 1);
Rw([
  f()
], al.prototype, "raycastTarget", 2);
class nf extends al {
  constructor() {
    super(...arguments);
    r(this, "_flippedObject", !1);
  }
  onAfterCreated() {
    this.uiObject && !this._flippedObject && (this._flippedObject = !0, this.uiObject.scale.y *= -1);
  }
}
var T2 = Object.defineProperty, A2 = Object.getOwnPropertyDescriptor, zs = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? A2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && T2(t, e, n), n;
};
const $o = x("debugtext");
var ct = /* @__PURE__ */ ((s) => (s[s.UpperLeft = 0] = "UpperLeft", s[s.UpperCenter = 1] = "UpperCenter", s[s.UpperRight = 2] = "UpperRight", s[s.MiddleLeft = 3] = "MiddleLeft", s[s.MiddleCenter = 4] = "MiddleCenter", s[s.MiddleRight = 5] = "MiddleRight", s[s.LowerLeft = 6] = "LowerLeft", s[s.LowerCenter = 7] = "LowerCenter", s[s.LowerRight = 8] = "LowerRight", s))(ct || {}), kw = /* @__PURE__ */ ((s) => (s[s.Normal = 0] = "Normal", s[s.Bold = 1] = "Bold", s[s.Italic = 2] = "Italic", s[s.BoldAndItalic = 3] = "BoldAndItalic", s))(kw || {});
class si extends al {
  constructor() {
    super(...arguments);
    r(this, "alignment", 0);
    r(this, "verticalOverflow", 0);
    r(this, "horizontalOverflow", 0);
    r(this, "lineSpacing", 1);
    r(this, "supportRichText", !1);
    r(this, "font");
    r(this, "fontStyle", 0);
    r(this, "sRGBTextColor", new ae(1, 0, 1));
    r(this, "_text", "");
    r(this, "_fontSize", 12);
    r(this, "_textMeshUi", null);
    r(this, "_didHandleTextRenderOnTop", !1);
  }
  // private _alphaFactor : number = 1;
  setAlphaFactor(e) {
    var i;
    super.setAlphaFactor(e), (i = this.uiObject) == null || i.set({ fontOpacity: this.color.alpha * this.alphaFactor }), this.markDirty();
  }
  get text() {
    return this._text;
  }
  set text(e) {
    e !== this._text && (this._text = e, this.feedText(this.text, this.supportRichText), this.markDirty());
  }
  set_text(e) {
    this.text = e;
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(e) {
    var i;
    this._fontSize = e, (i = this.uiObject) == null || i.set({ fontSize: e });
  }
  onColorChanged() {
    var e;
    this.sRGBTextColor.copy(this.color), this.sRGBTextColor.convertLinearToSRGB(), (e = this.uiObject) == null || e.set({ color: this.sRGBTextColor, fontOpacity: this.color.alpha });
  }
  onParentRectTransformChanged() {
    super.onParentRectTransformChanged(), this.uiObject && this.updateOverflow();
  }
  // onBeforeRender(): void {
  //     // TODO TMUI @swingingtom this is so we don't have text clipping
  //     if (this.uiObject && (this.Canvas?.screenspace || this.context.isInVR)) {
  //         this.updateOverflow();
  //     }
  // }
  onBeforeCanvasRender(e) {
    this.updateOverflow();
  }
  updateOverflow() {
    var i;
    const e = (i = this.uiObject) == null ? void 0 : i._overflow;
    e && (e._needsUpdate = !0);
  }
  onCreate(e) {
    $o && console.log(this), this.horizontalOverflow == 1 && (e.whiteSpace = "pre"), this.verticalOverflow == 0 && (this.context.renderer.localClippingEnabled = !0, e.overflow = "hidden"), this.horizontalOverflow == 1 && this.verticalOverflow == 0, e.lineHeight = this.lineSpacing, delete e.backgroundOpacity, delete e.backgroundColor, $o && (e.backgroundColor = 16750848, e.backgroundOpacity = 0.5);
    const i = this.rectTransform;
    e = { ...e, ...this.getTextOpts() }, this.getAlignment(e), $o && (e.backgroundColor = Math.random() * 16777215, e.backgroundOpacity = 0.1), this.uiObject = i.createNewText(e), this.feedText(this.text, this.supportRichText);
  }
  onAfterAddedToScene() {
    super.onAfterAddedToScene(), this.handleTextRenderOnTop();
  }
  getTextOpts() {
    const e = this.fontSize, i = {
      color: this.color,
      fontOpacity: this.color.alpha,
      fontSize: e,
      fontKerning: "normal"
    };
    return this.setFont(i, this.fontStyle), i;
  }
  onEnable() {
    var e;
    super.onEnable(), this._didHandleTextRenderOnTop = !1, this.uiObject && this.uiObject.addAfterUpdate(() => {
      this.setShadowComponentOwner(this.uiObject), this.markDirty();
    }), setTimeout(() => this.markDirty(), 10), (e = this.canvas) == null || e.registerEventReceiver(this);
  }
  onDisable() {
    var e;
    super.onDisable(), (e = this.canvas) == null || e.unregisterEventReceiver(this);
  }
  getAlignment(e) {
    switch (e.flexDirection = "column", this.alignment) {
      case 0:
      case 3:
      case 6:
        e.textAlign = "left";
        break;
      case 1:
      case 4:
      case 7:
        e.textAlign = "center";
        break;
      case 2:
      case 5:
      case 8:
        e.textAlign = "right";
        break;
    }
    switch (this.alignment) {
      default:
      case 0:
      case 1:
      case 2:
        e.alignItems = "start";
        break;
      case 3:
      case 4:
      case 5:
        e.alignItems = "center";
        break;
      case 6:
      case 7:
      case 8:
        e.alignItems = "end";
        break;
    }
    return e;
  }
  feedText(e, i) {
    var n, o, a;
    if ($o && console.log("feedText", this.uiObject, e, i), !!this.uiObject)
      if (this._textMeshUi || (this._textMeshUi = []), this.uiObject.children.length = 0, !i || e.length === 0)
        this.uiObject.textContent = e;
      else {
        let l = this.getNextTag(e);
        if (l) {
          if (l.startIndex > 0) {
            for (let d = this.uiObject.children.length - 1; d >= 0; d--) {
              const u = this.uiObject.children[d];
              u.isUI && (this.uiObject.remove(u), u.clear());
            }
            const h = new Of({ textContent: e.substring(0, l.startIndex), color: "inherit" });
            this.uiObject.add(h);
          }
        } else {
          this.uiObject.textContent = "", this.setOptions({ textContent: e });
          return;
        }
        const c = [];
        for (; l; ) {
          const h = this.getNextTag(e, l.endIndex), d = {
            fontFamily: (n = this.uiObject) == null ? void 0 : n.get("fontFamily"),
            color: "inherit",
            textContent: ""
          };
          if (h) {
            d.textContent = this.getText(e, l, h), this.handleTag(l, d, c);
            const u = new Of(d);
            (o = this.uiObject) == null || o.add(u);
          } else {
            d.textContent = e.substring(l.endIndex), this.handleTag(l, d, c);
            const u = new Of(d);
            (a = this.uiObject) == null || a.add(u);
          }
          l = h;
        }
      }
  }
  handleTextRenderOnTop() {
    this._didHandleTextRenderOnTop || (this._didHandleTextRenderOnTop = !0, this.startCoroutine(this.renderOnTopCoroutine()));
  }
  // waits for all the text objects to be ready to set the render on top setting
  // @THH :  this isn't true anymore. We can set mesh and material properties before their counterparts are created.
  //         Values would automatically be passed when created. Not sure for depthWrite but it can be added;
  *renderOnTopCoroutine() {
    if (!this.canvas)
      return;
    const e = [], i = this.canvas, n = {
      renderOnTop: i.renderOnTop,
      depthWrite: i.depthWrite,
      doubleSided: i.doubleSided
    };
    for (; ; ) {
      let o = !1;
      if (this._textMeshUi)
        for (let a = 0; a < this._textMeshUi.length; a++) {
          if (e[a] === !0)
            continue;
          o = !0;
          const l = this._textMeshUi[a];
          l.textContent && (Kd(l, n), e[a] = !0);
        }
      if (!o)
        break;
      yield;
    }
  }
  handleTag(e, i, n) {
    if (!e.isEndTag) {
      if (e.type.includes("color")) {
        const o = new yp(e, { color: i.color });
        if (n.push(o), e.type.length > 6) {
          const a = parseInt("0x" + e.type.substring(7));
          i.color = a;
        } else
          i.color = new ae(1, 1, 1);
      } else if (e.type == "b") {
        this.setFont(
          i,
          1
          /* Bold */
        );
        const o = new yp(e, {
          fontWeight: 700
        });
        n.push(o);
      } else if (e.type == "i") {
        this.setFont(
          i,
          2
          /* Italic */
        );
        const o = new yp(e, {
          fontStyle: "italic"
        });
        n.push(o);
      }
    }
  }
  getText(e, i, n) {
    return e.substring(i.endIndex, n.startIndex);
  }
  getNextTag(e, i = 0) {
    const n = e.indexOf("<", i), o = e.indexOf(">", n);
    if (n >= 0 && o >= 0) {
      const a = e.substring(n + 1, o);
      return { type: a, startIndex: n, endIndex: o + 1, isEndTag: a.startsWith("/") };
    }
    return null;
  }
  /**
   * Update provided opts to have a proper fontDefinition : family+weight+style
   * Ensure Family and Variant are registered in FontLibrary
   *
   * @param opts
   * @param fontStyle
   * @private
   */
  setFont(e, i) {
    if (!this.font)
      return;
    const n = this.font, o = this.getFamilyNameWithCorrectSuffix(n, i);
    $o && console.log("Selected font family:" + o);
    let a = $_.getFontFamily(o);
    switch (a || (a = $_.addFontFamily(o)), e.fontFamily = a, i) {
      default:
      case 0:
        e.fontWeight = 400, e.fontStyle = "normal";
        break;
      case 1:
        e.fontWeight = 700, e.fontStyle = "normal";
        break;
      case 2:
        e.fontWeight = 400, e.fontStyle = "italic";
        break;
      case 3:
        e.fontStyle = "italic", e.fontWeight = 400;
    }
    let l = a.getVariant(e.fontWeight, e.fontStyle);
    if (!l) {
      let c = o;
      c != null && c.endsWith("-msdf.json") || (c += "-msdf.json");
      let h = o;
      h != null && h.endsWith(".png") || (h += ".png"), l = a.addVariant(e.fontWeight, e.fontStyle, c, h), l == null || l.addEventListener("ready", () => {
        this.markDirty();
      });
    }
  }
  getFamilyNameWithCorrectSuffix(e, i) {
    var d;
    const n = e.lastIndexOf("-");
    if (n < 0)
      return e;
    const o = (d = e.substring(n + 1)) == null ? void 0 : d.toLowerCase();
    if (E2.includes(o))
      return $o && console.warn("Unsupported font style: " + o), e;
    const a = e.lastIndexOf("/");
    let l = e;
    a >= 0 && (l = l.substring(a + 1));
    const c = l[0] === l[0].toUpperCase(), h = e.substring(0, n);
    switch ($o && console.log("Select font: ", e, kw[i], l, c, h), i) {
      case 0:
        return c ? h + "-Regular" : h + "-regular";
      case 1:
        return c ? h + "-Bold" : h + "-bold";
      case 2:
        return c ? h + "-Italic" : h + "-italic";
      case 3:
        return c ? h + "-BoldItalic" : h + "-bolditalic";
      default:
        return e;
    }
  }
}
zs([
  f()
], si.prototype, "alignment", 2);
zs([
  f()
], si.prototype, "verticalOverflow", 2);
zs([
  f()
], si.prototype, "horizontalOverflow", 2);
zs([
  f()
], si.prototype, "lineSpacing", 2);
zs([
  f()
], si.prototype, "supportRichText", 2);
zs([
  f(URL)
], si.prototype, "font", 2);
zs([
  f()
], si.prototype, "fontStyle", 2);
zs([
  f()
], si.prototype, "text", 1);
zs([
  f()
], si.prototype, "fontSize", 1);
class yp {
  constructor(t, e) {
    r(this, "tag");
    r(this, "previousValues");
    this.tag = t, this.previousValues = e;
  }
}
const E2 = [
  "medium",
  "mediumitalic",
  "black",
  "blackitalic",
  "thin",
  "thinitalic",
  "extrabold",
  "light",
  "lightitalic",
  "semibold"
];
class pa {
  constructor(t) {
    r(this, "id");
    r(this, "content", "");
    r(this, "font", []);
    r(this, "pointSize", 144);
    r(this, "width");
    r(this, "height");
    r(this, "depth");
    r(this, "wrapMode");
    r(this, "horizontalAlignment");
    r(this, "verticalAlignment");
    r(this, "material");
    this.id = t;
  }
  static getId() {
    return this.global_id++;
  }
  setDepth(t) {
    return this.depth = t, this;
  }
  setPointSize(t) {
    return this.pointSize = t, this;
  }
  setHorizontalAlignment(t) {
    return this.horizontalAlignment = t, this;
  }
  setVerticalAlignment(t) {
    return this.verticalAlignment = t, this;
  }
  writeTo(t, e) {
    var n;
    e.beginBlock(`def Preliminary_Text "${this.id}"`, "(", !1), e.appendLine('prepend apiSchemas = ["MaterialBindingAPI"]'), e.closeBlock(")"), e.beginBlock(), this.content && e.appendLine(`string content = "${this.content}"`), (!this.font || this.font.length <= 0) && (this.font || (this.font = []), (n = this.font) == null || n.push("sans-serif"));
    const i = this.font.map((o) => `"${o}"`).join(", ");
    e.appendLine(`string[] font = [ ${i} ]`), e.appendLine(`double pointSize = ${this.pointSize}`), typeof this.width == "number" && e.appendLine(`double width = ${this.width}`), typeof this.height == "number" && e.appendLine(`double height = ${this.height}`), typeof this.depth == "number" && e.appendLine(`double depth = ${this.depth}`), this.wrapMode && e.appendLine(`token wrapMode = "${this.wrapMode}"`), this.horizontalAlignment && e.appendLine(`token horizontalAlignment = "${this.horizontalAlignment}"`), this.verticalAlignment && e.appendLine(`token verticalAlignment = "${this.verticalAlignment}"`), this.material !== void 0 && e.appendLine(`rel material:binding = </StageRoot/Materials/${Xg(this.material)}>`), e.closeBlock();
  }
}
r(pa, "global_id", 0);
class Tw {
  static singleLine(t, e, i) {
    const n = new pa("text_" + pa.getId());
    return n.content = t, e && (n.pointSize = e), i && (n.depth = i), n;
  }
  static multiLine(t, e, i, n, o, a) {
    const l = new pa("text_" + pa.getId());
    return l.content = t, l.width = e, l.height = i, l.horizontalAlignment = n, l.verticalAlignment = o, a !== void 0 && (l.wrapMode = a), l;
  }
}
const I2 = new se().makeRotationY(Math.PI), D2 = new se().makeScale(-1, 1, -1);
class Jg {
  get extensionName() {
    return "text";
  }
  exportText(t, e, i) {
    const n = S.getComponent(t, si);
    if (!n)
      return;
    const o = S.getComponent(t, ii);
    let a = 100, l = 100;
    o && (a = o.width, l = o.height);
    const c = I2.clone();
    o && c.premultiply(D2), e.setMatrix(c);
    const h = n.color.clone();
    e.material = new It({ color: h, emissive: h }), e.addEventListener("serialize", (d, u) => {
      let p = n.text;
      p = p.replace(/\r/g, ""), p = p.replace(/\n/g, "\\n");
      const m = Tw.multiLine(
        p,
        a,
        l,
        "center",
        "bottom",
        "flowing"
        /* flowing */
      );
      this.setTextAlignment(m, n.alignment), this.setOverflow(m, n), e.material && (m.material = e.material), m.pointSize = this.convertToTextSize(n.fontSize), m.depth = 1e-3, m.writeTo(void 0, d);
    });
  }
  convertToTextSize(t) {
    return 1 / 0.0502 * 144 * t;
  }
  setOverflow(t, e) {
    e.horizontalOverflow ? t.wrapMode = "singleLine" : t.wrapMode = "flowing";
  }
  setTextAlignment(t, e) {
    switch (e) {
      case ct.LowerLeft:
      case ct.MiddleLeft:
      case ct.UpperLeft:
        t.horizontalAlignment = "left";
        break;
      case ct.LowerCenter:
      case ct.MiddleCenter:
      case ct.UpperCenter:
        t.horizontalAlignment = "center";
        break;
      case ct.LowerRight:
      case ct.MiddleRight:
      case ct.UpperRight:
        t.horizontalAlignment = "right";
        break;
    }
    switch (e) {
      case ct.LowerLeft:
      case ct.LowerCenter:
      case ct.LowerRight:
        t.verticalAlignment = "bottom";
        break;
      case ct.MiddleLeft:
      case ct.MiddleCenter:
      case ct.MiddleRight:
        t.verticalAlignment = "middle";
        break;
      case ct.UpperLeft:
      case ct.UpperCenter:
      case ct.UpperRight:
        t.verticalAlignment = "top";
        break;
    }
  }
}
var L2 = Object.defineProperty, j2 = Object.getOwnPropertyDescriptor, ot = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? j2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && L2(t, e, n), n;
};
const Cb = x("debuguilayout");
class ll {
  constructor() {
    r(this, "left", 0);
    r(this, "right", 0);
    r(this, "top", 0);
    r(this, "bottom", 0);
  }
  get vertical() {
    return this.top + this.bottom;
  }
  get horizontal() {
    return this.left + this.right;
  }
}
ot([
  f()
], ll.prototype, "left", 2);
ot([
  f()
], ll.prototype, "right", 2);
ot([
  f()
], ll.prototype, "top", 2);
ot([
  f()
], ll.prototype, "bottom", 2);
class Ii extends I {
  constructor() {
    super(...arguments);
    r(this, "_rectTransform", null);
    r(this, "_needsUpdate", !1);
    r(this, "childAlignment", 0);
    r(this, "reverseArrangement", !1);
    r(this, "spacing", 0);
    r(this, "padding");
    r(this, "minWidth", 0);
    r(this, "minHeight", 0);
    r(this, "flexibleHeight", 0);
    r(this, "flexibleWidth", 0);
    r(this, "preferredHeight", 0);
    r(this, "preferredWidth", 0);
  }
  get rectTransform() {
    return this._rectTransform;
  }
  onParentRectTransformChanged(e) {
    this._needsUpdate = !0;
  }
  get isDirty() {
    return this._needsUpdate;
  }
  get isLayoutGroup() {
    return !0;
  }
  updateLayout() {
    this._rectTransform && (Cb && console.warn("Layout Update", this.context.time.frame, this.name), this._needsUpdate = !1, this.onCalculateLayout(this._rectTransform));
  }
  start() {
    this._needsUpdate = !0;
  }
  onEnable() {
    Cb && console.log(this.name, this), this._rectTransform = this.gameObject.getComponent(ii);
    const e = this.gameObject.getComponentInParent(Ut);
    e && e.registerLayoutGroup(this), this._needsUpdate = !0;
  }
  onDisable() {
    const e = this.gameObject.getComponentInParent(Ut);
    e && e.unregisterLayoutGroup(this);
  }
  // for animation:
  set m_Spacing(e) {
    e !== this.spacing && (this._needsUpdate = !0, this.spacing = e);
  }
  get m_Spacing() {
    return this.spacing;
  }
}
ot([
  f()
], Ii.prototype, "childAlignment", 2);
ot([
  f()
], Ii.prototype, "reverseArrangement", 2);
ot([
  f()
], Ii.prototype, "spacing", 2);
ot([
  f(ll)
], Ii.prototype, "padding", 2);
ot([
  f()
], Ii.prototype, "minWidth", 2);
ot([
  f()
], Ii.prototype, "minHeight", 2);
ot([
  f()
], Ii.prototype, "flexibleHeight", 2);
ot([
  f()
], Ii.prototype, "flexibleWidth", 2);
ot([
  f()
], Ii.prototype, "preferredHeight", 2);
ot([
  f()
], Ii.prototype, "preferredWidth", 2);
class To extends Ii {
  constructor() {
    super(...arguments);
    r(this, "childControlHeight", !0);
    r(this, "childControlWidth", !0);
    r(this, "childForceExpandHeight", !1);
    r(this, "childForceExpandWidth", !1);
    r(this, "childScaleHeight", !1);
    r(this, "childScaleWidth", !1);
  }
  onCalculateLayout(e) {
    var B;
    const i = this.primaryAxis, n = e.width;
    let o = n;
    const a = e.height;
    let l = a;
    o -= this.padding.horizontal, l -= this.padding.vertical, i === "x" ? this.padding.horizontal : this.padding.vertical;
    const c = i === "x", h = c ? "y" : "x", d = c ? this.childControlWidth : this.childControlHeight, u = c ? this.childControlHeight : this.childControlWidth, p = c ? this.childForceExpandWidth : this.childForceExpandHeight, m = c ? this.childForceExpandHeight : this.childForceExpandWidth, g = c ? l : o, _ = c ? n : a, y = 0.5 * (c ? this.childAlignment % 3 : Math.floor(this.childAlignment / 3));
    let b = 0;
    c ? b += this.padding.left : b += this.padding.top;
    let w = 0, P = 0;
    for (let A = 0; A < this.gameObject.children.length; A++) {
      const F = this.gameObject.children[A], U = S.getComponent(F, ii);
      U != null && U.activeAndEnabled && (P += 1, c ? w += U.width : w += U.height);
    }
    let k = 0;
    const O = this.spacing * (P - 1);
    if (p || d) {
      let A = 0;
      c ? A = o -= O : A = l -= O, P > 0 && (k = A / P);
    }
    let M = 0;
    M += this.padding.left, M -= this.padding.right, y !== 0 && (b = _ - w, b *= y, b -= O * y, c ? (b -= this.padding.right * y, b += this.padding.left * (1 - y), b < this.padding.left && (b = this.padding.left)) : (b -= this.padding.bottom * y, b += this.padding.top * (1 - y), b < this.padding.top && (b = this.padding.top)));
    let E = 1;
    for (let A = 0; A < this.gameObject.children.length; A++) {
      const F = this.gameObject.children[A], U = S.getComponent(F, ii);
      if (U != null && U.activeAndEnabled) {
        (B = U.pivot) == null || B.set(0.5, 0.5), U.anchorMin.set(0, 1), U.anchorMax.set(0, 1);
        const Z = n * 0.5 + M * 0.5;
        U.anchoredPosition.x !== Z && (U.anchoredPosition.x = Z);
        const T = a * -0.5;
        U.anchoredPosition.y !== T && (U.anchoredPosition.y = T), m && u && U.sizeDelta[h] !== g && (U.sizeDelta[h] = g), p && d && U.sizeDelta[i] !== k && (U.sizeDelta[i] = k);
        const j = c ? U.width : U.height, H = j * 0.5;
        if (b += H, p) {
          const te = k * E - k * 0.5;
          te > b && (b = te - k * 0.5 + j + this.padding.left, b -= H);
        }
        let Y = b;
        i === "y" && (Y = -Y), U.anchoredPosition[i] !== Y && (U.anchoredPosition[i] = Y), b += H, b += this.spacing, E += 1;
      }
    }
  }
}
ot([
  f()
], To.prototype, "childControlHeight", 2);
ot([
  f()
], To.prototype, "childControlWidth", 2);
ot([
  f()
], To.prototype, "childForceExpandHeight", 2);
ot([
  f()
], To.prototype, "childForceExpandWidth", 2);
ot([
  f()
], To.prototype, "childScaleHeight", 2);
ot([
  f()
], To.prototype, "childScaleWidth", 2);
class Aw extends To {
  get primaryAxis() {
    return "y";
  }
}
class Ew extends To {
  get primaryAxis() {
    return "x";
  }
}
class Iw extends Ii {
  onCalculateLayout() {
  }
}
var B2 = Object.defineProperty, F2 = Object.getOwnPropertyDescriptor, Kn = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? F2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && B2(t, e, n), n;
}, Dw = /* @__PURE__ */ ((s) => (s[s.ScreenSpaceOverlay = 0] = "ScreenSpaceOverlay", s[s.ScreenSpaceCamera = 1] = "ScreenSpaceCamera", s[s.WorldSpace = 2] = "WorldSpace", s[s.Undefined = -1] = "Undefined", s))(Dw || {});
const bp = x("debuguilayout"), Lw = class extends Vu {
  constructor() {
    super(...arguments);
    r(this, "_renderOnTop");
    r(this, "_depthWrite", !1);
    r(this, "_doubleSided", !0);
    r(this, "_castShadows", !1);
    r(this, "_receiveShadows", !1);
    r(this, "_renderMode", -1);
    r(this, "_rootCanvas");
    r(this, "_scaleFactor", 1);
    r(this, "worldCamera");
    r(this, "planeDistance", -1);
    r(this, "_boundRenderSettingsChanged", this.onRenderSettingsChanged.bind(this));
    r(this, "previousParent", null);
    r(this, "_lastMatrixWorld", null);
    r(this, "_rectTransforms", []);
    r(this, "_layoutGroups", /* @__PURE__ */ new Map());
    r(this, "_receivers", []);
    r(this, "onBeforeRenderRoutine", () => {
      var t, e, i, n;
      if (this.previousParent = this.gameObject.parent, ((t = this.context.xr) != null && t.isVR || (e = this.context.xr) != null && e.isPassThrough) && this.screenspace) {
        this.gameObject.visible = !1, this.gameObject.removeFromParent();
        return;
      }
      this.renderOnTop || this.screenspace ? this.gameObject.removeFromParent() : (this.onUpdateRenderMode(), this.handleLayoutUpdates(), (i = this.shadowComponent) == null || i.updateMatrixWorld(!0), (n = this.shadowComponent) == null || n.updateWorldMatrix(!0, !0), this.invokeBeforeRenderEvents(), di.ensureUpdateMeshUI(W_, this.context));
    });
    r(this, "onAfterRenderRoutine", () => {
      var t, e, i, n, o;
      if (((t = this.context.xr) != null && t.isVR || (e = this.context.xr) != null && e.isPassThrough) && this.screenspace) {
        (i = this.previousParent) == null || i.add(this.gameObject);
        return;
      }
      if ((this.screenspace || this.renderOnTop) && this.previousParent && this.context.mainCamera) {
        if (this.screenspace) {
          const c = this.context.mainCamera;
          c == null || c.add(this.gameObject);
        } else
          this.previousParent.add(this.gameObject);
        const a = this.context.renderer.autoClear, l = this.context.renderer.autoClearColor;
        this.context.renderer.autoClear = !1, this.context.renderer.autoClearColor = !1, this.context.renderer.clearDepth(), this.onUpdateRenderMode(!0), this.handleLayoutUpdates(), (n = this.shadowComponent) == null || n.updateMatrixWorld(!0), this.invokeBeforeRenderEvents(), di.ensureUpdateMeshUI(W_, this.context, !0), this.context.renderer.render(this.gameObject, this.context.mainCamera), this.context.renderer.autoClear = a, this.context.renderer.autoClearColor = l, this.previousParent.add(this.gameObject);
      }
      (o = this._lastMatrixWorld) == null || o.copy(this.gameObject.matrixWorld);
    });
    r(this, "_updateRenderSettingsRoutine");
    r(this, "_activeRenderMode", -1);
    r(this, "_lastWidth", -1);
    r(this, "_lastHeight", -1);
  }
  get isCanvas() {
    return !0;
  }
  get screenspace() {
    return this.renderMode !== 2;
  }
  set renderOnTop(t) {
    t !== this._renderOnTop && (this._renderOnTop = t, this.onRenderSettingsChanged());
  }
  get renderOnTop() {
    return this._renderOnTop !== void 0 ? this._renderOnTop : !!(this.screenspace && this._renderMode === 0);
  }
  set depthWrite(t) {
    this._depthWrite !== t && (this._depthWrite = t, this.onRenderSettingsChanged());
  }
  get depthWrite() {
    return this._depthWrite;
  }
  set doubleSided(t) {
    this._doubleSided !== t && (this._doubleSided = t, this.onRenderSettingsChanged());
  }
  get doubleSided() {
    return this._doubleSided;
  }
  set castShadows(t) {
    this._castShadows !== t && (this._castShadows = t, this.onRenderSettingsChanged());
  }
  get castShadows() {
    return this._castShadows;
  }
  set receiveShadows(t) {
    this._receiveShadows !== t && (this._receiveShadows = t, this.onRenderSettingsChanged());
  }
  get receiveShadows() {
    return this._receiveShadows;
  }
  get renderMode() {
    return this._renderMode;
  }
  set renderMode(t) {
    this._renderMode !== t && (this._renderMode = t, this.onRenderSettingsChanged());
  }
  set rootCanvas(t) {
    this._rootCanvas instanceof Lw || (this._rootCanvas = t);
  }
  get rootCanvas() {
    return this._rootCanvas;
  }
  get scaleFactor() {
    return this._scaleFactor;
  }
  set scaleFactor(t) {
    this._scaleFactor = t;
  }
  awake() {
    var t;
    this.shadowComponent = this.gameObject, this.previousParent = this.gameObject.parent, bp && console.log("Canvas.Awake()", ((t = this.previousParent) == null ? void 0 : t.name) + "/" + this.gameObject.name), super.awake();
  }
  start() {
    this.applyRenderSettings();
  }
  onEnable() {
    super.onEnable(), this._updateRenderSettingsRoutine = void 0, this._lastMatrixWorld = new se(), this.applyRenderSettings(), document.addEventListener("resize", this._boundRenderSettingsChanged), this.context.pre_render_callbacks.push(this.onBeforeRenderRoutine), this.context.post_render_callbacks.push(this.onAfterRenderRoutine);
  }
  onDisable() {
    super.onDisable(), document.removeEventListener("resize", this._boundRenderSettingsChanged);
    const t = this.context.pre_render_callbacks.indexOf(this.onBeforeRenderRoutine);
    t !== -1 && this.context.pre_render_callbacks.splice(t, 1);
    const e = this.context.post_render_callbacks.indexOf(this.onAfterRenderRoutine);
    e !== -1 && this.context.post_render_callbacks.splice(e, 1);
  }
  registerTransform(t) {
    this._rectTransforms.push(t);
  }
  unregisterTransform(t) {
    const e = this._rectTransforms.indexOf(t);
    e !== -1 && this._rectTransforms.splice(e, 1);
  }
  registerLayoutGroup(t) {
    const e = t.gameObject;
    this._layoutGroups.set(e, t);
  }
  unregisterLayoutGroup(t) {
    const e = t.gameObject;
    this._layoutGroups.delete(e);
  }
  registerEventReceiver(t) {
    this._receivers.push(t);
  }
  unregisterEventReceiver(t) {
    const e = this._receivers.indexOf(t);
    e !== -1 && this._receivers.splice(e, 1);
  }
  async onEnterXR(t) {
    this.screenspace ? (t.xr.isVR || t.xr.isPassThrough) && (this.gameObject.visible = !1) : (this.gameObject.visible = !1, await ku(1).then(() => {
      this.gameObject.visible = !0;
    }));
  }
  onLeaveXR(t) {
    this.screenspace && (t.xr.isVR || t.xr.isPassThrough) && (this.gameObject.visible = !0);
  }
  invokeBeforeRenderEvents() {
    var t;
    for (const e of this._receivers)
      (t = e.onBeforeCanvasRender) == null || t.call(e, this);
  }
  handleLayoutUpdates() {
    this._lastMatrixWorld === null && (this._lastMatrixWorld = new se());
    const t = !this._lastMatrixWorld.equals(this.gameObject.matrixWorld);
    bp && t && console.log("Canvas Layout changed", this.context.time.frameCount, this.name);
    const e = !1;
    for (const i of this._rectTransforms) {
      t && i.markDirty();
      let n = this._layoutGroups.get(i.gameObject);
      i.isDirty && !n && (n = i.gameObject.getComponentInParent(Ii)), (i.isDirty || n != null && n.isDirty) && (bp && !e && console.log("CANVAS UPDATE ### " + i.name + " ##################################### " + this.context.time.frame), n == null || n.updateLayout(), i.updateTransform());
    }
  }
  applyRenderSettings() {
    this.onRenderSettingsChanged();
  }
  onRenderSettingsChanged() {
    this._updateRenderSettingsRoutine || (this._updateRenderSettingsRoutine = this.startCoroutine(this._updateRenderSettingsDelayed(), Re.OnBeforeRender));
  }
  *_updateRenderSettingsDelayed() {
    if (yield, this._updateRenderSettingsRoutine = void 0, this.shadowComponent) {
      this.onUpdateRenderMode(), Kd(this.shadowComponent, this);
      for (const t of S.getComponentsInChildren(this.gameObject, xn))
        Kd(t.shadowComponent, this);
    }
  }
  onUpdateRenderMode(t = !1) {
    if (!t && this._renderMode === this._activeRenderMode && this._lastWidth === this.context.domWidth && this._lastHeight === this.context.domHeight)
      return;
    this._activeRenderMode = this._renderMode;
    let e = this.context.mainCameraComponent, i = 10;
    switch (e && e.nearClipPlane > 0 && e.farClipPlane > 0 && (i = $.lerp(e.nearClipPlane, e.farClipPlane, 0.01)), this._renderMode === 1 && (this.worldCamera && (e = this.worldCamera), this.planeDistance > 0 && (i = this.planeDistance)), this._renderMode) {
      case 0:
      case 1:
        if (this._lastWidth = this.context.domWidth, this._lastHeight = this.context.domHeight, !e)
          return;
        const n = i + 0.01;
        this.gameObject.position.x = 0, this.gameObject.position.y = 0, this.gameObject.position.z = -n, this.gameObject.quaternion.identity();
        const o = this.gameObject.getComponent(ii);
        let a = !1;
        o.sizeDelta.x !== this.context.domWidth && (a = !0), o.sizeDelta.y !== this.context.domHeight && (a = !0);
        const l = e.fieldOfView * Math.PI / 180, c = 2 * Math.tan(l / 2) * Math.abs(n);
        this.gameObject.scale.x = c / this.context.domHeight, this.gameObject.scale.y = c / this.context.domHeight, this.gameObject.scale.z = 0.01, a && (o.sizeDelta.x = this.context.domWidth, o.sizeDelta.y = this.context.domHeight, o == null || o.markDirty());
        break;
      case 2:
        this._lastWidth = -1, this._lastHeight = -1;
        break;
    }
  }
};
let Ut = Lw;
Kn([
  f()
], Ut.prototype, "renderOnTop", 1);
Kn([
  f()
], Ut.prototype, "depthWrite", 1);
Kn([
  f()
], Ut.prototype, "doubleSided", 1);
Kn([
  f()
], Ut.prototype, "castShadows", 1);
Kn([
  f()
], Ut.prototype, "receiveShadows", 1);
Kn([
  f()
], Ut.prototype, "renderMode", 1);
Kn([
  f(Ut)
], Ut.prototype, "rootCanvas", 1);
Kn([
  f()
], Ut.prototype, "scaleFactor", 1);
Kn([
  f(Pe)
], Ut.prototype, "worldCamera", 2);
Kn([
  f()
], Ut.prototype, "planeDistance", 2);
var z2 = Object.defineProperty, U2 = Object.getOwnPropertyDescriptor, e_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? U2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && z2(t, e, n), n;
};
class Or extends I {
  constructor() {
    super(...arguments);
    r(this, "_alpha", 1);
    r(this, "interactable", !0);
    r(this, "blocksRaycasts", !0);
    r(this, "_isDirty", !1);
    r(this, "_buffer", []);
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(e) {
    e !== this._alpha && (this._alpha = e, this.markDirty());
  }
  get isCanvasGroup() {
    return !0;
  }
  markDirty() {
    this._isDirty || (this._isDirty = !0, this.startCoroutine(this.applyChangesDelayed(), Re.OnBeforeRender));
  }
  *applyChangesDelayed() {
    this._isDirty = !1, this.applyChangesNow();
  }
  applyChangesNow() {
    this._buffer.length = 0;
    for (const e of S.getComponentsInChildren(this.gameObject, xn, this._buffer)) {
      const i = e;
      i.setAlphaFactor && i.setAlphaFactor(this._alpha);
    }
  }
}
e_([
  f()
], Or.prototype, "alpha", 1);
e_([
  f()
], Or.prototype, "interactable", 2);
e_([
  f()
], Or.prototype, "blocksRaycasts", 2);
class jw {
  get extensionName() {
    return "tmui";
  }
  // TODO would probably be better to export each object instead of the entire Canvas
  // so that we don't export them twice (once as regular hierarchy, once as part of Canvas export)
  onExportObject(t, e, i) {
    const n = S.getComponent(t, Ut);
    if (n && n.enabled && n.renderMode === Dw.WorldSpace) {
      const o = new Jg(), a = S.getComponent(t, ii), l = S.getComponent(t, Or), c = new Array();
      if (a) {
        if (!S.isActiveSelf(t)) {
          const u = S.isActiveSelf(t);
          S.setActive(t, !0), a.onEnable(), a.updateTransform(), c.push(() => {
            a.onDisable(), S.setActive(t, u);
          });
        }
        t.traverse((u) => {
          if (!S.isActiveInHierarchy(u)) {
            const p = S.isActiveSelf(u);
            S.setActive(u, !0);
            const m = S.getComponent(u, xn);
            m && (m.onEnable(), c.push(() => {
              m.onDisable();
            }));
            const g = S.getComponent(u, ii);
            g && (g.onEnable(), g.updateTransform(), g.onApplyTransform(), c.push(() => {
              g.onDisable();
            }));
            const _ = S.getComponent(u, si);
            _ && (_.onEnable(), c.push(() => {
              _.onDisable();
            })), c.push(() => {
              S.setActive(u, p);
            });
          }
        }), a.width, a.height;
        const h = Lt.createEmpty(), d = a.shadowComponent;
        if (e.add(h), d) {
          const u = d.matrix;
          h.setMatrix(u);
          const p = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map();
          p.set(d, h), m.set(d, l ? l.alpha : 1), d.traverse((g) => {
            if (g === d)
              return;
            const _ = Lt.createEmpty();
            _.setMatrix(g.matrix);
            const y = g.parent, b = !!y && typeof y.textContent == "string" && y.textContent.length > 0;
            let w = m.get(y) || 1;
            const P = S.getComponent(g, Or);
            if (P && (w *= P.alpha), g instanceof q && b) {
              const O = g[Yi];
              O ? o.exportText(O.gameObject, _, i) : console.error("Error when exporting UI: shadow component owner not found. This is likely a bug.", g);
            }
            if (g instanceof q && !b) {
              const O = g.geometry.clone();
              O.scale(1, 1, -1), this.flipWindingOrder(O), _.geometry = O;
              const M = new ae(), E = g.material.opacity;
              M.copy(g.material.color), _.material = new Me({
                color: M,
                opacity: E * w,
                map: g.material.map,
                transparent: !0
              });
            }
            p.set(g, _), m.set(g, w);
            const k = p.get(y);
            if (!k) {
              console.error("Error when exporting UI: shadow component parent not found!", g, g.parent);
              return;
            }
            k.add(_);
          });
        }
      }
      for (const h of c)
        h();
    }
  }
  flipWindingOrder(t) {
    const e = t.index.array;
    for (let i = 0, n = e.length / 3; i < n; i++) {
      const o = e[i * 3];
      e[i * 3] = e[i * 3 + 2], e[i * 3 + 2] = o;
    }
    t.index.needsUpdate = !0;
  }
}
const tc = x("debugusdz");
function N2(s, t) {
  var l;
  const e = [], i = S.getComponentsInChildren(s, zt), n = S.getComponentsInChildren(s, ti), o = new Array(), a = new Array();
  if (t.injectImplicitBehaviours)
    for (const c of i) {
      if (!c || !c.runtimeAnimatorController || !c.enabled)
        continue;
      const h = c.runtimeAnimatorController.activeState;
      if (!h || !h.motion || !h.motion.clip || ((l = h.motion.clip.tracks) == null ? void 0 : l.length) < 1 || o.includes(c))
        continue;
      const d = new Xa();
      d.animator = c, d.stateName = h.name, d.trigger = "start", d.name = "PlayAnimationOnClick_implicitAtStart_" + d.stateName;
      const u = new L();
      S.addComponent(u, d), a.push(u), o.push(c), s.add(u);
    }
  else
    for (const c of i) {
      if (!c || !c.runtimeAnimatorController || !c.enabled)
        continue;
      tc && console.log(c);
      const h = [];
      for (const d of c.runtimeAnimatorController.enumerateActions()) {
        tc && console.log(d);
        const u = d.getClip();
        h.includes(u) || h.push(u);
      }
      e.push({ root: c.gameObject, clips: h });
    }
  if (t.injectImplicitBehaviours)
    for (const c of n) {
      if (!c || !c.clip || !c.enabled || !c.playAutomatically || o.includes(c))
        continue;
      const h = new Xa();
      h.animation = c, h.stateName = c.clip.name, h.trigger = "start", h.name = "PlayAnimationOnClick_implicitAtStart_" + h.stateName;
      const d = new L();
      S.addComponent(d, h), a.push(d), o.push(c), s.add(d);
    }
  else
    for (const c of n) {
      tc && console.log(c);
      const h = [];
      for (const d of c.animations)
        h.includes(d) || h.push(d);
      e.push({ root: c.gameObject, clips: h });
    }
  tc && (e == null ? void 0 : e.length) > 0 && console.log("USDZ Animation Clips without behaviours", e);
  for (const c of e)
    for (const h of c.clips)
      t.registerAnimation(c.root, h);
  return a;
}
function $2(s, t) {
  const e = S.getComponentsInChildren(s, qe), i = S.getComponentsInChildren(s, Cr), n = new Array(), o = new Array();
  tc && console.log({ audioSources: e, playAudioOnClicks: i });
  for (const a of i) {
    if (!a.target)
      continue;
    const l = e.indexOf(a.target);
    l > -1 && e.splice(l, 1);
  }
  for (const a of e) {
    if (!a || !a.clip || a.volume <= 0 || n.includes(a))
      continue;
    const l = new Cr();
    l.target = a, l.name = "PlayAudioOnClick_implicitAtStart_", l.trigger = "start";
    const c = new L();
    S.addComponent(c, l), console.log("implicit PlayAudioOnStart", c, l), o.push(c), n.push(a), s.add(c);
  }
  return o;
}
function W2(s) {
  return new kt(
    "DisableAtStart",
    Ft.sceneStartTrigger(),
    ge.fadeAction(s, 0, !1)
  );
}
function Pb(s, t) {
  const e = s.domElement.shadowRoot.querySelector("link[rel='ar']");
  if (e)
    return e;
  const i = document.createElement("div");
  i.classList.add("menu"), i.classList.add("quicklook-menu"), i.style.display = "none", i.style.visibility = "hidden";
  const n = document.createElement("button");
  n.id = "open-in-ar", t ? (n.innerText = "View in AR", n.title = "View this scene in AR. The scene will be exported to USDZ and opened with Apple's QuickLook.") : (n.innerText = "View in AR", n.title = "Download this scene for AR. Open the downloaded USDZ file to view it in AR using Apple's QuickLook."), i.appendChild(n);
  const o = document.createElement("a");
  o.id = "needle-usdz-link", o.style.display = "none", o.rel = "ar", o.href = "", o.target = "_blank", i.appendChild(o);
  const a = document.createElement("img");
  return a.id = "button", o.appendChild(a), s.domElement.shadowRoot.appendChild(i), o;
}
var V2 = Object.defineProperty, H2 = Object.getOwnPropertyDescriptor, Tt = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? H2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && V2(t, e, n), n;
};
const pi = x("debugusdz"), G2 = x("debugusdzpruning");
class cl {
  constructor() {
    r(this, "callToAction");
    r(this, "checkoutTitle");
    r(this, "checkoutSubtitle");
    r(this, "callToActionURL");
  }
}
Tt([
  f()
], cl.prototype, "callToAction", 2);
Tt([
  f()
], cl.prototype, "checkoutTitle", 2);
Tt([
  f()
], cl.prototype, "checkoutSubtitle", 2);
Tt([
  f()
], cl.prototype, "callToActionURL", 2);
var ld;
const zm = (ld = class extends I {
  constructor() {
    super(...arguments);
    r(this, "objectToExport");
    r(this, "autoExportAnimations", !0);
    r(this, "autoExportAudioSources", !0);
    r(this, "exportFileName");
    r(this, "customUsdzFile");
    r(this, "customBranding");
    r(this, "anchoringType", "plane");
    r(this, "maxTextureSize", 2048);
    r(this, "planeAnchoringAlignment", "horizontal");
    r(this, "interactive", !0);
    r(this, "physics", !0);
    r(this, "allowCreateQuicklookButton", !0);
    r(this, "quickLookCompatible", !0);
    /**
     * Extensions to add custom behaviors and interactions to the USDZ file.   
     * You can add your own extensions here by extending {@link IUSDExporterExtension}.
     */
    r(this, "extensions", []);
    r(this, "link");
    r(this, "button");
    r(this, "onClickedOpenInARElement", (t) => {
      t.preventDefault(), this.exportAndOpen();
    });
    r(this, "_currentExportTasks", /* @__PURE__ */ new Map());
    r(this, "_previousTimeScale", 1);
    r(this, "lastCallback");
    r(this, "_rootSessionRootWasAppliedTo", null);
    r(this, "_rootPositionBeforeExport", new v());
    r(this, "_rootRotationBeforeExport", new W());
    r(this, "_rootScaleBeforeExport", new v());
  }
  /** @internal */
  start() {
    var t, e, i;
    pi && (console.log("USDZExporter", this), console.log("Debug USDZ Mode. Press 'T' to export"), window.addEventListener("keydown", (n) => {
      switch (n.key) {
        case "t":
          this.exportAndOpen();
          break;
      }
    })), this.objectToExport || (this.objectToExport = this.gameObject), !((e = (t = this.objectToExport) == null ? void 0 : t.children) != null && e.length) && !((i = this.objectToExport) != null && i.isMesh) && (this.objectToExport = this.context.scene);
  }
  /** @internal */
  onEnable() {
    var i;
    const t = X.supportsQuickLookAR(), e = X.isiOS() || X.isiPad();
    !this.button && (pi || t || e) && (this.allowCreateQuicklookButton && (this.button = this.createQuicklookButton()), this.lastCallback = this.quicklookCallback.bind(this), this.link = Pb(this.context, t), this.link.addEventListener("message", this.lastCallback)), pi && We("USDZ Exporter enabled: " + this.name), (i = document.getElementById("open-in-ar")) == null || i.addEventListener("click", this.onClickedOpenInARElement), jc.registerExporter(this);
  }
  /** @internal */
  onDisable() {
    var t, e, i;
    (t = this.button) == null || t.remove(), (e = this.link) == null || e.removeEventListener("message", this.lastCallback), pi && We("USDZ Exporter disabled: " + this.name), (i = document.getElementById("open-in-ar")) == null || i.removeEventListener("click", this.onClickedOpenInARElement), jc.unregisterExporter(this);
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * Use the various public properties of USDZExporter to customize export behaviour.
   * @deprecated use {@link exportAndOpen} instead
   */
  async exportAsync() {
    return this.exportAndOpen();
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * @returns a Promise<Blob> containing the USDZ file
   */
  async exportAndOpen() {
    var i;
    let t = this.exportFileName ?? ((i = this.objectToExport) == null ? void 0 : i.name) ?? this.name;
    if (t += "-" + Pk(), fr() || (t !== "" && (t += "-"), t += "MadeWithNeedle"), this.link || (this.link = Pb(this.context, X.supportsQuickLookAR())), this.customUsdzFile)
      return pi && console.log("Exporting custom usdz", this.customUsdzFile), this.openInQuickLook(this.customUsdzFile, t), null;
    if (!this.objectToExport)
      return console.warn("No object to export", this), null;
    const e = await this.export(this.objectToExport);
    return e ? (pi && console.log("USDZ generation done. Downloading as " + t), this.openInQuickLook(e, t), e) : (console.error("USDZ generation failed. Please report a bug", this), null);
  }
  /**
   * Creates an USDZ file from the current scene or assigned objectToExport and opens it in QuickLook.
   * @returns a Promise<Blob> containing the USDZ file
   */
  async export(t) {
    if (!t)
      return console.warn("No object to export"), null;
    const e = this._currentExportTasks.get(t);
    if (e)
      return e;
    const i = this.internalExport(t);
    return i instanceof Promise ? (this._currentExportTasks.set(t, i), i.then((n) => (this._currentExportTasks.delete(t), n)).catch((n) => (this._currentExportTasks.delete(t), console.error("Error during USDZ export – please report a bug!", n), null))) : i;
  }
  async internalExport(t) {
    he.start("export-usdz", {
      onProgress: (O) => {
        this.dispatchEvent(new CustomEvent("export-progress", { detail: { progress: O } }));
      }
    }), he.report("export-usdz", { message: "Starting export", totalSteps: 40, currentStep: 0 }), he.report("export-usdz", { message: "Load progressive textures", autoStep: 5 }), he.start("export-usdz-textures", "export-usdz");
    const e = S.getComponentsInChildren(t, Ei);
    for (const O of e)
      O && O.enabled && O.updateSprite(!0);
    const i = S.getComponentsInChildren(t, Je), n = new Array();
    let o = 0;
    for (const O of i) {
      for (const M of O.sharedMeshes)
        if (M) {
          const E = Ze.assignMeshLOD(M, 0);
          E instanceof Promise && n.push(new Promise((B, A) => {
            E.then(() => {
              o++, he.report("export-usdz-textures", { message: "Loaded progressive mesh", currentStep: o, totalSteps: n.length }), B();
            }).catch((F) => A(F));
          }));
        }
      for (const M of O.sharedMaterials)
        if (M) {
          const E = Ze.assignTextureLOD(M, 0);
          E instanceof Promise && n.push(new Promise((B, A) => {
            E.then(() => {
              o++, he.report("export-usdz-textures", { message: "Loaded progressive texture", currentStep: o, totalSteps: n.length }), B();
            }).catch((F) => A(F));
          }));
        }
    }
    pi && We("Progressive Loading: " + n.length), await Promise.all(n), pi && We("Progressive Loading: done"), he.end("export-usdz-textures");
    const a = ei.Global.Mask;
    ei.Global.Set(ws.AR);
    const l = new Ek(), c = new Qg(this.quickLookCompatible);
    let h;
    const d = [];
    this.interactive && (d.push(new Cw()), d.push(new nl()), globalThis.true && S.getComponentsInChildren(t, _e).length > 0 && (this.physics ? (h = new Pw(), d.push(h)) : z() && console.warn("USDZExporter: Physics export is disabled, but there are active Rigidbody components in the scene. They will not be exported.")), d.push(new Jg()), d.push(new jw()));
    const u = [c, ...d, ...this.extensions], p = { self: this, exporter: l, extensions: u, object: t };
    he.report("export-usdz", "Invoking before-export"), this.dispatchEvent(new CustomEvent("before-export", { detail: p })), this.applyWebARSessionRoot(), this._previousTimeScale = this.context.time.timeScale, this.context.time.timeScale = 0, he.report("export-usdz", "auto export animations and audio sources");
    const m = new Array();
    this.autoExportAnimations && m.push(...N2(t, c)), u.find((O) => O.extensionName === "Audio") && this.autoExportAudioSources && m.push(...$2(t)), l.debug = pi, l.pruneUnusedNodes = !G2;
    const _ = ir.instance.objs.map((O) => O.batchedMesh);
    l.keepObject = (O) => {
      let M = !0;
      const E = S.getComponent(O, Je);
      return E && !E.enabled && (M = !1), M && _.includes(O) && (M = !1), M && S.getComponentInParent(O, Yn) && (M = !1), M && S.getComponentInParent(O, Ls) && (M = !1), pi && !M && console.log("USDZExporter: Discarding object", O), M;
    }, l.beforeWritingDocument = () => {
      if (z() && c && h) {
        const O = c.animatedRoots;
        for (const M of O) {
          const E = S.getComponentsInChildren(M, _e).filter((A) => A.enabled), B = S.getComponents(M, Ai).filter((A) => A.enabled && !A.isTrigger);
          (E.length > 0 || B.length > 0) && console.error("An animated object has physics components in its child hierarchy. This can lead to undefined behaviour due to a bug in Apple's QuickLook (FB15925487). Remove the physics components from child objects or verify that you get the expected results.", M);
        }
      }
    };
    const y = new Array();
    this.objectToExport && this.quickLookCompatible && this.interactive && this.objectToExport.traverse((O) => {
      O.visible || y.push(O);
    });
    const b = u.find((O) => O.extensionName === "Behaviour");
    this.interactive && b && y.length > 0 && b.addBehavior(W2(y));
    let w = !0;
    this.quickLookCompatible && !this.interactive && (w = !1), this.anchoringType !== "plane" && this.anchoringType !== "none" && this.anchoringType !== "image" && this.anchoringType !== "face" && (this.anchoringType = "plane"), this.planeAnchoringAlignment !== "horizontal" && this.planeAnchoringAlignment !== "vertical" && this.planeAnchoringAlignment !== "any" && (this.planeAnchoringAlignment = "horizontal"), he.report("export-usdz", "Invoking exporter.parse");
    const P = await l.parse(this.objectToExport, {
      ar: {
        anchoring: {
          type: this.anchoringType
        },
        planeAnchoring: {
          alignment: this.planeAnchoringAlignment
        }
      },
      extensions: u,
      quickLookCompatible: this.quickLookCompatible,
      maxTextureSize: this.maxTextureSize,
      exportInvisible: w
    }), k = new Blob([P], { type: "model/vnd.usdz+zip" });
    this.revertWebARSessionRoot(), this.context.time.timeScale = this._previousTimeScale, he.report("export-usdz", "Invoking after-export"), this.dispatchEvent(new CustomEvent("after-export", { detail: p }));
    for (const O of m)
      S.destroy(O);
    return ei.Global.Set(a), he.end("export-usdz"), k;
  }
  /**
   * Opens QuickLook on iOS/iPadOS/visionOS with the given content in AR mode.
   * @param content The URL to the .usdz or .reality file or a blob containing an USDZ file.
   * @param name Download filename
   */
  openInQuickLook(t, e) {
    const i = t instanceof Blob ? URL.createObjectURL(t) : t, n = this.buildQuicklookOverlay();
    pi && console.log("QuickLook Overlay", n);
    const o = n.callToAction ? encodeURIComponent(n.callToAction) : "", a = n.checkoutTitle ? encodeURIComponent(n.checkoutTitle) : "", l = n.checkoutSubtitle ? encodeURIComponent(n.checkoutSubtitle) : "";
    this.link.href = i + `#callToAction=${o}&checkoutTitle=${a}&checkoutSubtitle=${l}&callToActionURL=${n.callToActionURL}`, this.lastCallback || (this.lastCallback = this.quicklookCallback.bind(this), this.link.addEventListener("message", this.lastCallback)), this.link.download = e + ".usdz", this.link.click();
  }
  /**
   * Downloads the given blob as a file.
   */
  download(t, e) {
    zm.save(t, e);
  }
  // Matches GltfExport.save(blob, filename)
  static save(t, e) {
    const i = document.createElement("a");
    i.style.display = "none", document.body.appendChild(i), typeof t == "string" ? i.href = t : i.href = URL.createObjectURL(t), i.download = e, i.click(), i.remove();
  }
  quicklookCallback(t) {
    if ((t == null ? void 0 : t.data) == "_apple_ar_quicklook_button_tapped") {
      pi && ve("Quicklook closed via call to action button");
      var e = new CustomEvent("quicklook-button-tapped", { detail: this });
      if (this.dispatchEvent(e), !e.defaultPrevented) {
        const i = new URLSearchParams(this.link.href);
        if (i) {
          const n = i.get("callToActionURL");
          pi && We("Quicklook url: " + n), n && (fr() ? globalThis.open(n, "_blank") : console.warn("Quicklook closed: custom redirects require a Needle Engine Pro license: https://needle.tools/pricing", n));
        }
      }
    }
  }
  buildQuicklookOverlay() {
    var i, n, o, a, l, c;
    const t = {};
    return this.customBranding && Object.assign(t, this.customBranding), fr() || (console.log("Custom Quicklook banner text requires pro license: https://needle.tools/pricing"), t.callToAction = "Close", t.checkoutTitle = "🌵 Made with Needle", t.checkoutSubtitle = "_"), (((i = t.callToAction) == null ? void 0 : i.length) || ((n = t.checkoutTitle) == null ? void 0 : n.length) || ((o = t.checkoutSubtitle) == null ? void 0 : o.length)) && ((a = t.callToAction) != null && a.length || (t.callToAction = "\0"), (l = t.checkoutTitle) != null && l.length || (t.checkoutTitle = "\0"), (c = t.checkoutSubtitle) != null && c.length || (t.checkoutSubtitle = "\0")), this.dispatchEvent(new CustomEvent("quicklook-overlay", { detail: t })), t;
  }
  getARScaleAndTarget() {
    if (!this.objectToExport)
      return { scale: 1, _invertForward: !1, target: this.gameObject, sessionRoot: null };
    const t = S.findObjectOfType(et);
    let e = S.getComponentInParent(this.objectToExport, gn);
    e || (e = S.getComponentInChildren(this.objectToExport, gn));
    let i = 1, n = !1;
    const o = this.objectToExport;
    return t ? i = t.arScale : e && (i = e.arScale, n = e.invertForward), { scale: 1 / i, _invertForward: n, target: o, sessionRoot: (e == null ? void 0 : e.gameObject) ?? null };
  }
  applyWebARSessionRoot() {
    if (!this.objectToExport)
      return;
    const { scale: t, _invertForward: e, target: i, sessionRoot: n } = this.getARScaleAndTarget(), o = n == null ? void 0 : n.matrixWorld.clone().invert();
    this._rootSessionRootWasAppliedTo = i, this._rootPositionBeforeExport.copy(i.position), this._rootRotationBeforeExport.copy(i.quaternion), this._rootScaleBeforeExport.copy(i.scale), i.scale.multiplyScalar(t), e && i.quaternion.multiply(zm.invertForwardQuaternion), i.updateMatrix(), i.updateMatrixWorld(!0), n && o && i.matrix.premultiply(o);
  }
  revertWebARSessionRoot() {
    if (!this.objectToExport || !this._rootSessionRootWasAppliedTo)
      return;
    const t = this._rootSessionRootWasAppliedTo;
    t.position.copy(this._rootPositionBeforeExport), t.quaternion.copy(this._rootRotationBeforeExport), t.scale.copy(this._rootScaleBeforeExport), t.updateMatrix(), t.updateMatrixWorld(!0), this._rootSessionRootWasAppliedTo = null;
  }
  createQuicklookButton() {
    const e = yo.getOrCreate().createQuicklookButton();
    return e.parentNode || this.context.menu.appendChild(e), e;
  }
}, r(ld, "invertForwardMatrix", new se().makeRotationY(Math.PI)), r(ld, "invertForwardQuaternion", new W().setFromEuler(new jt(0, Math.PI, 0))), ld);
let Ge = zm;
Tt([
  f(L)
], Ge.prototype, "objectToExport", 2);
Tt([
  f()
], Ge.prototype, "autoExportAnimations", 2);
Tt([
  f()
], Ge.prototype, "autoExportAudioSources", 2);
Tt([
  f()
], Ge.prototype, "exportFileName", 2);
Tt([
  f(URL)
], Ge.prototype, "customUsdzFile", 2);
Tt([
  f(cl)
], Ge.prototype, "customBranding", 2);
Tt([
  f()
], Ge.prototype, "anchoringType", 2);
Tt([
  f()
], Ge.prototype, "maxTextureSize", 2);
Tt([
  f()
], Ge.prototype, "planeAnchoringAlignment", 2);
Tt([
  f()
], Ge.prototype, "interactive", 2);
Tt([
  f()
], Ge.prototype, "physics", 2);
Tt([
  f()
], Ge.prototype, "allowCreateQuicklookButton", 2);
Tt([
  f()
], Ge.prototype, "quickLookCompatible", 2);
var q2 = Object.defineProperty, X2 = Object.getOwnPropertyDescriptor, t_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? X2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && q2(t, e, n), n;
};
class uh extends I {
  constructor() {
    super(...arguments);
    r(this, "_fog");
  }
  get fog() {
    return this._fog || (this._fog = new Jb(0, 0, 50)), this._fog;
  }
  get mode() {
    return 1;
  }
  set near(e) {
    this.fog.near = e;
  }
  get near() {
    return this.fog.near;
  }
  set far(e) {
    this.fog.far = e;
  }
  get far() {
    return this.fog.far;
  }
  set color(e) {
    this.fog.color.copy(e);
  }
  get color() {
    return this.fog.color;
  }
  onEnable() {
    this.scene.fog = this.fog;
  }
  onDisable() {
    this.scene.fog === this._fog && (this.scene.fog = null);
  }
}
t_([
  f()
], uh.prototype, "near", 1);
t_([
  f()
], uh.prototype, "far", 1);
t_([
  f(ae)
], uh.prototype, "color", 1);
var Q2 = Object.defineProperty, Y2 = Object.getOwnPropertyDescriptor, i_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Y2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && Q2(t, e, n), n;
};
class hl extends I {
  constructor() {
    super(...arguments);
    r(this, "objectBounds", !1);
    r(this, "color");
    r(this, "isGizmo", !0);
    r(this, "_gizmoObject", null);
    r(this, "_boxHelper", null);
  }
  onEnable() {
    this.isGizmo && !Xc || (this._gizmoObject || (this.objectBounds ? this._gizmoObject = new M1(this.gameObject, this.color ?? 16776960) : (this.objectBounds = !1, this._gizmoObject = Sg(this.color ?? 16776960))), this.objectBounds ? (this.scene.add(this._gizmoObject), this._boxHelper = this._gizmoObject, this.startCoroutine(this.syncObjectBounds(), Re.OnBeforeRender)) : this.gameObject.add(this._gizmoObject));
  }
  onDisable() {
    this._gizmoObject && this.gameObject.remove(this._gizmoObject);
  }
  *syncObjectBounds() {
    var e;
    for (; this._boxHelper; )
      (e = this._boxHelper) == null || e.update(), yield;
  }
}
i_([
  f()
], hl.prototype, "objectBounds", 2);
i_([
  f(ae)
], hl.prototype, "color", 2);
i_([
  f()
], hl.prototype, "isGizmo", 2);
var K2 = Object.defineProperty, Z2 = Object.getOwnPropertyDescriptor, n_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Z2(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && K2(t, e, n), n;
};
class fh extends I {
  constructor() {
    super(...arguments);
    r(this, "isGizmo", !1);
    r(this, "color0");
    r(this, "color1");
    r(this, "gridHelper");
    r(this, "size");
    r(this, "divisions");
    r(this, "offset");
  }
  /** @internal */
  onEnable() {
    if (this.isGizmo && !Xc)
      return;
    const e = this.size, i = this.divisions;
    this.gridHelper || (this.gridHelper = new ig(e, i, this.color0 ?? new ae(0.4, 0.4, 0.4), this.color1 ?? new ae(0.6, 0.6, 0.6)), this.offset !== void 0 && (this.gridHelper.position.y += this.offset)), this.gridHelper && this.gameObject.add(this.gridHelper);
  }
  /** @internal */
  onDisable() {
    this.gridHelper && (this.gameObject.remove(this.gridHelper), this.gridHelper = null);
  }
}
n_([
  f()
], fh.prototype, "isGizmo", 2);
n_([
  f(ae)
], fh.prototype, "color0", 2);
n_([
  f(ae)
], fh.prototype, "color1", 2);
var J2 = Object.defineProperty, eT = Object.getOwnPropertyDescriptor, s_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? eT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && J2(t, e, n), n;
};
class o_ extends I {
  constructor() {
    super(...arguments);
    r(this, "connectedBody");
    r(this, "_rigidBody", null);
  }
  get rigidBody() {
    return this._rigidBody;
  }
  onEnable() {
    this._rigidBody || (this._rigidBody = this.gameObject.getComponent(_e)), this.rigidBody && this.connectedBody && this.startCoroutine(this.create());
  }
  *create() {
    yield, this.rigidBody && this.connectedBody && this.activeAndEnabled && this.createJoint(this.rigidBody, this.connectedBody);
  }
}
s_([
  f(_e)
], o_.prototype, "connectedBody", 2);
class Bw extends o_ {
  createJoint(t, e) {
    var i;
    (i = this.context.physics.engine) == null || i.addFixedJoint(t, e);
  }
}
class sf extends o_ {
  constructor() {
    super(...arguments);
    r(this, "anchor");
    r(this, "axis");
  }
  createJoint(e, i) {
    var n;
    this.axis && this.anchor && ((n = this.context.physics.engine) == null || n.addHingeJoint(e, i, this.anchor, this.axis));
  }
}
s_([
  f(v)
], sf.prototype, "anchor", 2);
s_([
  f(v)
], sf.prototype, "axis", 2);
var tT = Object.defineProperty, iT = Object.getOwnPropertyDescriptor, Zn = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? iT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && tT(t, e, n), n;
};
function vp(s) {
  return s * Math.PI / 180;
}
const Ob = 300, Gs = x("debuglights");
class Di extends I {
  constructor() {
    super(...arguments);
    r(this, "type", 0);
    /**
     * The maximum distance the light affects
     */
    r(this, "range", 1);
    /**
     * The full outer angle of the spotlight cone in degrees
     */
    r(this, "spotAngle", 1);
    /**
     * The angle of the inner cone in degrees for soft-edge spotlights
     */
    r(this, "innerSpotAngle", 1);
    r(this, "_color", new ae(16777215));
    r(this, "_shadowNearPlane", 0.1);
    r(this, "_shadowBias", 0);
    r(this, "_shadowNormalBias", 0);
    /** when enabled this will remove the multiplication when setting the shadow bias settings initially */
    r(this, "_overrideShadowBiasSettings", !1);
    r(this, "_shadows", 1);
    r(this, "lightmapBakeType", 4);
    r(this, "_intensity", -1);
    r(this, "_shadowDistance");
    // set from additional component
    r(this, "shadowWidth");
    r(this, "shadowHeight");
    r(this, "_shadowResolution");
    /**
     * The underlying three.js {@link ThreeLight} instance
     */
    r(this, "light");
    r(this, "_webXRStartedListener");
    r(this, "_webXREndedListener");
    r(this, "_webARRoot");
  }
  set color(e) {
    this._color = e, this.light !== void 0 && (this.light.color = e);
  }
  get color() {
    return this.light ? this.light.color : this._color;
  }
  set shadowNearPlane(e) {
    var i, n;
    if (e !== this._shadowNearPlane && (this._shadowNearPlane = e, ((n = (i = this.light) == null ? void 0 : i.shadow) == null ? void 0 : n.camera) !== void 0)) {
      const o = this.light.shadow.camera;
      o.near = e;
    }
  }
  get shadowNearPlane() {
    return this._shadowNearPlane;
  }
  set shadowBias(e) {
    var i, n;
    e !== this._shadowBias && (this._shadowBias = e, ((n = (i = this.light) == null ? void 0 : i.shadow) == null ? void 0 : n.bias) !== void 0 && (this.light.shadow.bias = e, this.light.shadow.needsUpdate = !0));
  }
  get shadowBias() {
    return this._shadowBias;
  }
  set shadowNormalBias(e) {
    var i, n;
    e !== this._shadowNormalBias && (this._shadowNormalBias = e, ((n = (i = this.light) == null ? void 0 : i.shadow) == null ? void 0 : n.normalBias) !== void 0 && (this.light.shadow.normalBias = e, this.light.shadow.needsUpdate = !0));
  }
  get shadowNormalBias() {
    return this._shadowNormalBias;
  }
  set shadows(e) {
    this._shadows = e, this.light && (this.light.castShadow = e !== 0, this.updateShadowSoftHard());
  }
  get shadows() {
    return this._shadows;
  }
  set intensity(e) {
    var i;
    if (this._intensity = e, this.light) {
      let n = 1;
      if (this.context.isInXR && this._webARRoot) {
        const o = (i = this._webARRoot) == null ? void 0 : i.arScale;
        typeof o == "number" && o > 0 && (n /= o);
      }
      this.light.intensity = e * n;
    }
    Gs && console.log("Set light intensity to " + this._intensity, e, this);
  }
  get intensity() {
    return this._intensity;
  }
  get shadowDistance() {
    const e = this.light;
    return e != null && e.shadow ? e.shadow.camera.far : -1;
  }
  set shadowDistance(e) {
    this._shadowDistance = e;
    const i = this.light;
    if (i != null && i.shadow) {
      const n = i.shadow.camera;
      n.far = e, n.updateProjectionMatrix();
    }
  }
  get shadowResolution() {
    const e = this.light;
    return e != null && e.shadow ? e.shadow.mapSize.x : -1;
  }
  set shadowResolution(e) {
    if (e === this._shadowResolution)
      return;
    this._shadowResolution = e;
    const i = this.light;
    i != null && i.shadow && (i.shadow.mapSize.set(e, e), i.shadow.needsUpdate = !0);
  }
  /**
   * Whether this light's illumination is entirely baked into lightmaps
   */
  get isBaked() {
    return this.lightmapBakeType === 2;
  }
  /**
   * Checks if the GameObject itself is a {@link ThreeLight} object
   */
  get selfIsLight() {
    if (this.gameObject.isLight === !0)
      return !0;
    switch (this.gameObject.type) {
      case "SpotLight":
      case "PointLight":
      case "DirectionalLight":
        return !0;
    }
    return !1;
  }
  /**
   * Gets the world position of the light
   * @param vec Vector3 to store the result
   * @returns The world position as a Vector3
   */
  getWorldPosition(e) {
    return this.light ? this.type === 1 ? this.light.getWorldPosition(e).multiplyScalar(1) : this.light.getWorldPosition(e) : e;
  }
  // public updateIntensity() {
  //     this.intensity = this._intensity;
  // }
  awake() {
    this.color = new ae(this.color ?? 16777215), Gs && console.log(this.name, this);
  }
  onEnable() {
    Gs && console.log("ENABLE LIGHT", this.name), this.createLight(), !this.isBaked && (this.light && (this.light.visible = !0, this.light.intensity = this._intensity, Gs && console.log("Set light intensity to " + this.light.intensity, this.name), this.selfIsLight || this.light.parent !== this.gameObject && this.gameObject.add(this.light)), this.type === 1 && this.startCoroutine(this.updateMainLightRoutine(), Re.LateUpdate));
  }
  onDisable() {
    Gs && console.log("DISABLE LIGHT", this.name), this.light && (this.selfIsLight ? this.light.intensity = 0 : this.light.visible = !1);
  }
  onEnterXR(e) {
    this._webARRoot = S.getComponentInParent(this.gameObject, gn) ?? void 0;
  }
  // private *_updateLightIntensityInARRoutine() {
  //     while (this.context.isInAR) {
  //         yield;
  //         // this.updateIntensity();
  //         for (let i = 0; i < 30; i++) yield;
  //     }
  // }
  onLeaveXR(e) {
  }
  /**
   * Creates the appropriate three.js light based on the configured light type
   * and applies all settings like shadows, intensity, and color.
   */
  createLight() {
    const e = this.selfIsLight;
    if (e && !this.light)
      switch (this.light = this.gameObject, this.light.name = this.name, this._intensity = this.light.intensity, this.type) {
        case 1:
          this.setDirectionalLight(this.light);
          break;
      }
    else if (!this.light)
      switch (this.type) {
        case 1:
          const i = new Yp(this.color, this.intensity * Math.PI);
          if (i.position.set(0, 0, -Ob * 0.5).applyQuaternion(this.gameObject.quaternion), this.gameObject.add(i.target), Fa(i.target, 0, 0, 0), this.light = i, this.gameObject.position.set(0, 0, 0), this.gameObject.rotation.set(0, 0, 0), Gs) {
            const l = new k1(this.light, 0.2, this.color);
            this.context.scene.add(l);
          }
          break;
        case 0:
          const n = new R1(this.color, this.intensity * Math.PI, this.range, vp(this.spotAngle / 2), 1 - vp(this.innerSpotAngle / 2) / vp(this.spotAngle / 2), 2);
          n.position.set(0, 0, 0), n.rotation.set(0, 0, 0), this.light = n;
          const o = n.target;
          n.add(o), o.position.set(0, 0, this.range), o.rotation.set(0, 0, 0);
          break;
        case 2:
          const a = new ng(this.color, this.intensity * Math.PI, this.range);
          this.light = a;
          break;
      }
    if (this.light) {
      if (this._intensity >= 0 ? this.light.intensity = this._intensity : this._intensity = this.light.intensity, this.shadows !== 0 ? this.light.castShadow = !0 : this.light.castShadow = !1, this.light.shadow) {
        this._shadowResolution !== void 0 && this._shadowResolution > 4 ? (this.light.shadow.mapSize.width = this._shadowResolution, this.light.shadow.mapSize.height = this._shadowResolution) : (this.light.shadow.mapSize.width = 2048, this.light.shadow.mapSize.height = 2048), Gs && console.log("Override shadow bias?", this._overrideShadowBiasSettings, this.shadowBias, this.shadowNormalBias), this.light.shadow.bias = this.shadowBias, this.light.shadow.normalBias = this.shadowNormalBias, this.updateShadowSoftHard();
        const i = this.light.shadow.camera;
        if (i.near = this.shadowNearPlane, this._shadowDistance !== void 0 && typeof this._shadowDistance == "number" ? i.far = this._shadowDistance : i.far = Ob * Math.abs(this.gameObject.scale.z), this.gameObject.scale.set(1, 1, 1), this.shadowWidth !== void 0)
          i.left = -this.shadowWidth / 2, i.right = this.shadowWidth / 2;
        else {
          const n = this.gameObject.scale.x;
          i.left *= n, i.right *= n;
        }
        if (this.shadowHeight !== void 0)
          i.top = this.shadowHeight / 2, i.bottom = -this.shadowHeight / 2;
        else {
          const n = this.gameObject.scale.y;
          i.top *= n, i.bottom *= n;
        }
        this.light.shadow.needsUpdate = !0, Gs && this.context.scene.add(new T1(i));
      }
      this.isBaked ? this.light.removeFromParent() : e || this.gameObject.add(this.light);
    }
  }
  /**
   * Coroutine that updates the main light reference in the context
   * if this directional light should be the main light
   */
  *updateMainLightRoutine() {
    for (; ; ) {
      this.type === 1 && ((!this.context.mainLight || this.intensity > this.context.mainLight.intensity) && (this.context.mainLight = this), yield);
      break;
    }
  }
  /**
   * Updates shadow settings based on whether the shadows are set to hard or soft
   */
  updateShadowSoftHard() {
    this.light && this.light.shadow && (this.shadows === 2 || (this.light.shadow.radius = 1, this.light.shadow.blurSamples = 1));
  }
  /**
   * Configures a directional light by adding and positioning its target
   * @param dirLight The directional light to set up
   */
  setDirectionalLight(e) {
    e.add(e.target), e.target.position.set(0, 0, -1);
  }
}
/**
 * Controls whether the renderer's shadow map type can be changed when soft shadows are used
 */
r(Di, "allowChangingRendererShadowMapType", !0);
Zn([
  f()
], Di.prototype, "type", 2);
Zn([
  f(ae)
], Di.prototype, "color", 1);
Zn([
  f()
], Di.prototype, "shadowNearPlane", 1);
Zn([
  f()
], Di.prototype, "shadowBias", 1);
Zn([
  f()
], Di.prototype, "shadowNormalBias", 1);
Zn([
  f()
], Di.prototype, "shadows", 1);
Zn([
  f()
], Di.prototype, "lightmapBakeType", 2);
Zn([
  f()
], Di.prototype, "intensity", 1);
Zn([
  f()
], Di.prototype, "shadowDistance", 1);
Zn([
  f()
], Di.prototype, "shadowResolution", 1);
new v(0, 0, 0);
var nT = Object.defineProperty, sT = Object.getOwnPropertyDescriptor, ph = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? sT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && nT(t, e, n), n;
};
const wp = x("debuglods"), oT = x("nolods");
class mh {
  constructor() {
    r(this, "screenRelativeTransitionHeight");
    r(this, "distance");
    r(this, "renderers");
  }
}
ph([
  f()
], mh.prototype, "screenRelativeTransitionHeight", 2);
ph([
  f()
], mh.prototype, "distance", 2);
ph([
  f(Je)
], mh.prototype, "renderers", 2);
class rT {
  constructor(t) {
    r(this, "model");
    this.model = t;
  }
  get renderers() {
    return this.model.renderers;
  }
}
class of extends I {
  constructor() {
    super(...arguments);
    r(this, "fadeMode", 0);
    r(this, "localReferencePoint");
    r(this, "lodCount", 0);
    r(this, "size", 0);
    r(this, "animateCrossFading", !1);
    r(this, "lodModels");
    r(this, "_lods", []);
    r(this, "_settings", []);
    // https://threejs.org/docs/#api/en/objects/LOD
    r(this, "_lodsHandler");
    r(this, "_distanceFactor", 1);
  }
  start() {
    if (wp && console.log("LODGROUP", this.name, this.lodModels, this), !oT && !this._lodsHandler && this.gameObject && this.lodModels && Array.isArray(this.lodModels)) {
      const e = [];
      for (const n of this.lodModels) {
        const o = new rT(n);
        this._lods.push(o);
        for (const a of o.renderers)
          e.includes(a) || e.push(a);
      }
      this._lodsHandler = new Array();
      for (let n = 0; n < e.length; n++) {
        const o = new A1();
        this._lodsHandler.push(o), this.gameObject.add(o);
      }
      const i = new L();
      i.name = "Cull " + this.name;
      for (let n = 0; n < e.length; n++) {
        const o = e[n], a = this._lodsHandler[n], l = o.gameObject;
        wp && console.log(n, l.name);
        for (const c of this._lods) {
          const h = c.model.distance;
          let d = null;
          if (c.renderers.includes(o) ? d = l : d = i, d.type === "Group") {
            console.warn(`LODGroup ${this.name}: Group or MultiMaterial object's are not supported as LOD object: ${d.name}`);
            continue;
          }
          wp && console.log("LEVEL", d.name, h), a.autoUpdate = !1, this.onAddLodLevel(a, d, c.model.distance);
        }
      }
    }
  }
  onAfterRender() {
    if (!this.gameObject || !this._lodsHandler)
      return;
    const e = this.context.mainCamera;
    if (e)
      for (const i of this._lodsHandler) {
        i.update(e);
        const n = i.getCurrentLevel(), o = i.levels[n];
        i.layers.mask = o.object.layers.mask;
      }
  }
  onAddLodLevel(e, i, n) {
    if (i === this.gameObject) {
      console.warn("LODGroup component must be on parent object and not mesh directly at the moment", i.name, i);
      return;
    }
    e.addLevel(i, n * this._distanceFactor, 0.01);
    const o = { lod: e, levelIndex: e.levels.length - 1, distance: n };
    this._settings.push(o);
  }
  distanceFactor(e) {
    if (e !== this._distanceFactor) {
      this._distanceFactor = e;
      for (const i of this._settings) {
        const n = i.lod.levels[i.levelIndex];
        n.distance = i.distance * e;
      }
    }
  }
}
ph([
  f(v)
], of.prototype, "localReferencePoint", 2);
ph([
  f(mh)
], of.prototype, "lodModels", 2);
var aT = Object.defineProperty, lT = Object.getOwnPropertyDescriptor, cT = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? lT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && aT(t, e, n), n;
};
const Jh = x("debugnestedgltf");
class r_ extends I {
  constructor() {
    super(...arguments);
    r(this, "filePath");
    /**
     * EXPERIMENTAL for cloud asset loading
     */
    r(this, "loadAssetInParent", !0);
    r(this, "_isLoadingOrDoneLoading", !1);
  }
  /** Register a callback that will be called when the progress of the loading changes */
  listenToProgress(e) {
    var i;
    (i = this.filePath) == null || i.beginListenDownload(e);
  }
  /** Begin loading the referenced gltf file in filePath */
  preload() {
    var e;
    (e = this.filePath) == null || e.preload();
  }
  /** @internal */
  async start() {
    var i, n, o, a, l;
    if (this._isLoadingOrDoneLoading)
      return;
    Jh && console.log(this, this.guid);
    const e = this.gameObject.parent;
    if (e) {
      this._isLoadingOrDoneLoading = !0;
      const c = new Qn();
      c.idProvider = new Bt(this.hash(this.guid)), c.parent = this.loadAssetInParent !== !1 ? e : this.gameObject, this.gameObject.updateMatrix();
      const h = this.gameObject.matrix;
      Jh && console.log("Load nested:", ((i = this.filePath) == null ? void 0 : i.url) ?? this.filePath, this.gameObject.position);
      const d = await ((o = (n = this.filePath) == null ? void 0 : n.instantiate) == null ? void 0 : o.call(this.filePath, c));
      Jh && console.log("Nested loaded:", ((a = this.filePath) == null ? void 0 : a.url) ?? this.filePath, d), d && this.loadAssetInParent !== !1 && (d.matrixAutoUpdate = !1, d.matrix.identity(), d.applyMatrix4(h), d.matrixAutoUpdate = !0, d.layers.disableAll(), d.layers.set(this.layer), this.dispatchEvent(new CustomEvent("loaded", { detail: { instance: d, assetReference: this.filePath } }))), Jh && console.log("Nested loading done:", ((l = this.filePath) == null ? void 0 : l.url) ?? this.filePath, d);
    }
  }
  /** @internal */
  onDestroy() {
    var e;
    (e = this.filePath) == null || e.unload();
  }
  hash(e) {
    let i = 0;
    for (let n = 0; n < e.length; n++)
      i = e.charCodeAt(n) + ((i << 5) - i);
    return i;
  }
}
cT([
  f(re)
], r_.prototype, "filePath", 2);
var hT = Object.defineProperty, dT = Object.getOwnPropertyDescriptor, a_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? dT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && hT(t, e, n), n;
};
const uT = x("debugnet"), Um = class extends I {
  constructor() {
    super(...arguments);
    r(this, "url", null);
    r(this, "urlParameterName", null);
    r(this, "localhost", null);
  }
  /** @internal */
  awake() {
    uT && console.log(this), this.context.connection.registerProvider(this);
  }
  /** 
   * Determines the websocket URL to use for networking connections.
   * Processes the configured URL, applying localhost fallbacks when appropriate and
   * handling URL parameter overrides if specified.
   * @returns The formatted websocket URL string or null if no valid URL could be determined
   * @internal
   */
  getWebsocketUrl() {
    let t = this.url ? Um.GetUrl(this.url, this.localhost) : null;
    if (this.urlParameterName) {
      const o = x(this.urlParameterName);
      o && typeof o == "string" && (t = o);
    }
    if (!t)
      return null;
    const i = new RegExp("(((https?)|(?<socket_prefix>wss?))://)?(www.)?(?<url>.+)", "gm").exec(t);
    return i != null && i.groups ? (i == null ? void 0 : i.groups.socket_prefix) ? t : "wss://" + (i == null ? void 0 : i.groups.url) : null;
  }
  /**
   * Processes a URL string applying various transformations based on network environment.
   * Handles relative paths and localhost fallbacks for local network environments.
   * @param url The original URL to process
   * @param localhostFallback Alternative URL to use when on a local network
   * @returns The processed URL string or null/undefined if input was invalid
   */
  static GetUrl(t, e) {
    let i = t;
    const n = Um.IsLocalNetwork() && e;
    if (n && (i = e), t != null && t.startsWith("/")) {
      const o = n ? i : window.location.origin;
      o != null && o.endsWith("/") && t.startsWith("/") && (t = t.substring(1)), i = o + t;
    }
    return i;
  }
  /**
   * Determines if the current connection is on a local network.
   * Useful for applying different networking configurations in local development environments.
   * This is the same as calling {@link isLocalNetwork}.
   * @param hostname Optional hostname to check instead of the current window location
   * @returns True if the connection is on a local network, false otherwise
   */
  static IsLocalNetwork(t = window.location.hostname) {
    return ui(t);
  }
};
let gh = Um;
a_([
  f()
], gh.prototype, "url", 2);
a_([
  f()
], gh.prototype, "urlParameterName", 2);
a_([
  f()
], gh.prototype, "localhost", 2);
var fT = Object.defineProperty, pT = Object.getOwnPropertyDescriptor, rf = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? pT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && fT(t, e, n), n;
};
class dl extends I {
  constructor() {
    super(...arguments);
    r(this, "referenceSpace");
    r(this, "from");
    r(this, "affectPosition", !1);
    r(this, "affectRotation", !1);
    r(this, "alignLookDirection", !1);
    r(this, "levelLookDirection", !1);
    r(this, "levelPosition", !1);
    r(this, "positionOffset", new v(0, 0, 0));
    r(this, "rotationOffset", new v(0, 0, 0));
    r(this, "offset", new v(0, 0, 0));
  }
  update() {
    if (!this.from)
      return;
    var e = ie(this.from), i = Ce(this.from);
    this.offset.copy(this.positionOffset);
    const n = this.offset.length();
    if (this.referenceSpace && this.offset.transformDirection(this.referenceSpace.matrixWorld).multiplyScalar(n), e.add(this.offset), this.levelPosition && this.referenceSpace) {
      const c = new vr(this.gameObject.up, 0), h = ie(this.referenceSpace);
      c.setFromNormalAndCoplanarPoint(this.gameObject.up, h);
      const d = new v(0, 0, 0);
      c.projectPoint(e, d), e.copy(d);
    }
    this.affectPosition && yt(this.gameObject, e);
    const o = new jt(this.rotationOffset.x, this.rotationOffset.y, this.rotationOffset.z), a = new W().setFromEuler(o);
    this.affectRotation && wn(this.gameObject, i.multiply(a));
    const l = new v();
    this.from.getWorldDirection(l).multiplyScalar(50), this.levelLookDirection && (l.y = 0), this.alignLookDirection && this.gameObject.lookAt(l);
  }
}
rf([
  f(S)
], dl.prototype, "referenceSpace", 2);
rf([
  f(S)
], dl.prototype, "from", 2);
rf([
  f(v)
], dl.prototype, "positionOffset", 2);
rf([
  f(v)
], dl.prototype, "rotationOffset", 2);
var mT = Object.defineProperty, gT = Object.getOwnPropertyDescriptor, Ao = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? gT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && mT(t, e, n), n;
};
class Ci {
  constructor(t = 0, e = 0) {
    r(this, "time", 0);
    r(this, "value", 0);
    r(this, "inTangent", 1 / 0);
    r(this, "inWeight");
    r(this, "outTangent", 1 / 0);
    r(this, "outWeight");
    r(this, "weightedMode");
    this.time = t, this.value = e;
  }
}
Ao([
  f()
], Ci.prototype, "time", 2);
Ao([
  f()
], Ci.prototype, "value", 2);
Ao([
  f()
], Ci.prototype, "inTangent", 2);
Ao([
  f()
], Ci.prototype, "inWeight", 2);
Ao([
  f()
], Ci.prototype, "outTangent", 2);
Ao([
  f()
], Ci.prototype, "outWeight", 2);
Ao([
  f()
], Ci.prototype, "weightedMode", 2);
const ic = class {
  constructor() {
    r(this, "keys", []);
  }
  /**
   * Creates an animation curve that goes from the `from` value to the `to` value over the given `duration`.
   */
  static linearFromTo(s, t, e) {
    const i = new ic(), n = new Ci();
    n.time = 0, n.value = s;
    const o = new Ci();
    return o.time = e, o.value = t, i.keys.push(n, o), i;
  }
  /** Creates an animation curve with just one keyframe */
  static constant(s) {
    const t = new ic(), e = new Ci();
    return e.time = 0, e.value = s, t.keys.push(e), t;
  }
  /** 
   * Clones this AnimationCurve and returns a new instance with the same keyframes (the keyframes are also cloned).
  */
  clone() {
    var t;
    const s = new ic();
    return s.keys = ((t = this.keys) == null ? void 0 : t.map((e) => {
      const i = new Ci();
      return i.time = e.time, i.value = e.value, i.inTangent = e.inTangent, i.inWeight = e.inWeight, i.outTangent = e.outTangent, i.outWeight = e.outWeight, i.weightedMode = e.weightedMode, i;
    })) || [], s;
  }
  /** The duration of the curve, which is the time of the last keyframe. */
  get duration() {
    return !this.keys || this.keys.length == 0 ? 0 : this.keys[this.keys.length - 1].time;
  }
  /** Evaluates the curve at the given time and returns the value of the curve at that time.
   * @param time The time at which to evaluate the curve.
   * @returns The value of the curve at the given time.
   */
  evaluate(s) {
    if (!this.keys || this.keys.length == 0)
      return 0;
    if (this.keys.length === 1)
      return this.keys[0].value;
    if (this.keys[0].time >= s)
      return this.keys[0].value;
    for (let t = 0; t < this.keys.length; t++) {
      const e = this.keys[t];
      if (e.time <= s)
        if (t + 1 < this.keys.length) {
          const n = this.keys[t + 1];
          if (n.time < s)
            continue;
          return !isFinite(e.outTangent) || !isFinite(n.inTangent) ? e.value : ic.interpolateValue(s, e, n);
        } else
          return e.value;
    }
    return this.keys[this.keys.length - 1].value;
  }
  static interpolateValue(s, t, e) {
    const i = t.time, n = t.value, o = t.outTangent, a = e.time, l = e.value, c = e.inTangent, h = a - i, d = h * h, u = d * h, p = ((o + c) * h - 2 * (l - n)) / u, m = (3 * (l - n) - (c + 2 * o) * h) / d, g = o, _ = n, y = s - i, b = y * y, w = b * y;
    return p * w + m * b + g * y + _;
  }
};
let _h = ic;
Ao([
  f(Ci)
], _h.prototype, "keys", 2);
var _T = Object.defineProperty, yT = Object.getOwnPropertyDescriptor, C = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? yT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && _T(t, e, n), n;
};
const ed = x("debugparticles");
var gs = /* @__PURE__ */ ((s) => (s[s.Billboard = 0] = "Billboard", s[s.Stretch = 1] = "Stretch", s[s.HorizontalBillboard = 2] = "HorizontalBillboard", s[s.VerticalBillboard = 3] = "VerticalBillboard", s[s.Mesh = 4] = "Mesh", s))(gs || {});
class ul {
  constructor() {
    r(this, "alphaKeys", []);
    r(this, "colorKeys", []);
  }
  get duration() {
    return 1;
  }
  evaluate(t, e) {
    let i, n = 0, o = null, a = 0;
    for (let l = 0; l < this.alphaKeys.length; l++) {
      const c = this.alphaKeys[l];
      (c.time < t || !i) && (i = c, n = l);
    }
    for (let l = 0; l < this.colorKeys.length; l++) {
      const c = this.colorKeys[l];
      (c.time < t || !o) && (o = c, a = l);
    }
    if (o)
      if (a + 1 < this.colorKeys.length) {
        const c = this.colorKeys[a + 1], h = $.remap(t, o.time, c.time, 0, 1);
        e.r = $.lerp(o.color.r, c.color.r, h), e.g = $.lerp(o.color.g, c.color.g, h), e.b = $.lerp(o.color.b, c.color.b, h);
      } else
        e.r = o.color.r, e.g = o.color.g, e.b = o.color.b;
    if (i)
      if (n + 1 < this.alphaKeys.length) {
        const c = this.alphaKeys[n + 1], h = $.remap(t, i.time, c.time, 0, 1);
        e.alpha = $.lerp(i.alpha, c.alpha, h);
      } else
        e.alpha = i.alpha;
    return e;
  }
}
C([
  f()
], ul.prototype, "alphaKeys", 2);
C([
  f()
], ul.prototype, "colorKeys", 2);
var $c = /* @__PURE__ */ ((s) => (s[s.Local = 0] = "Local", s[s.World = 1] = "World", s[s.Custom = 2] = "Custom", s))($c || {}), Nm = /* @__PURE__ */ ((s) => (s[s.Sphere = 0] = "Sphere", s[s.SphereShell = 1] = "SphereShell", s[s.Hemisphere = 2] = "Hemisphere", s[s.HemisphereShell = 3] = "HemisphereShell", s[s.Cone = 4] = "Cone", s[s.Box = 5] = "Box", s[s.Mesh = 6] = "Mesh", s[s.ConeShell = 7] = "ConeShell", s[s.ConeVolume = 8] = "ConeVolume", s[s.ConeVolumeShell = 9] = "ConeVolumeShell", s[s.Circle = 10] = "Circle", s[s.CircleEdge = 11] = "CircleEdge", s[s.SingleSidedEdge = 12] = "SingleSidedEdge", s[s.MeshRenderer = 13] = "MeshRenderer", s[s.SkinnedMeshRenderer = 14] = "SkinnedMeshRenderer", s[s.BoxShell = 15] = "BoxShell", s[s.BoxEdge = 16] = "BoxEdge", s[s.Donut = 17] = "Donut", s[s.Rectangle = 18] = "Rectangle", s[s.Sprite = 19] = "Sprite", s[s.SpriteRenderer = 20] = "SpriteRenderer", s))(Nm || {});
const nc = class {
  constructor() {
    r(this, "mode", "Constant");
    r(this, "constant");
    r(this, "constantMin");
    r(this, "constantMax");
    r(this, "curve");
    r(this, "curveMin");
    r(this, "curveMax");
    r(this, "curveMultiplier");
  }
  static constant(s) {
    const t = new nc();
    return t.setConstant(s), t;
  }
  static betweenTwoConstants(s, t) {
    const e = new nc();
    return e.setMinMaxConstant(s, t), e;
  }
  static curve(s, t = 1) {
    const e = new nc();
    return e.setCurve(s, t), e;
  }
  setConstant(s) {
    this.mode = 0, this.constant = s;
  }
  setMinMaxConstant(s, t) {
    this.mode = 3, this.constantMin = s, this.constantMax = t;
  }
  setCurve(s, t = 1) {
    this.mode = 1, this.curve = s, this.curveMultiplier = t;
  }
  clone() {
    var t, e, i;
    const s = new nc();
    return s.mode = this.mode, s.constant = this.constant, s.constantMin = this.constantMin, s.constantMax = this.constantMax, s.curve = (t = this.curve) == null ? void 0 : t.clone(), s.curveMin = (e = this.curveMin) == null ? void 0 : e.clone(), s.curveMax = (i = this.curveMax) == null ? void 0 : i.clone(), s.curveMultiplier = this.curveMultiplier, s;
  }
  evaluate(s, t) {
    const e = t === void 0 ? Math.random() : t;
    switch (this.mode) {
      case 0:
      case "Constant":
        return this.constant;
      case 1:
      case "Curve":
        return s = $.clamp01(s), this.curve.evaluate(s) * this.curveMultiplier;
      case 2:
      case "TwoCurves":
        const i = s * this.curveMin.duration, n = s * this.curveMax.duration;
        return $.lerp(this.curveMin.evaluate(i), this.curveMax.evaluate(n), e % 1) * this.curveMultiplier;
      case 3:
      case "TwoConstants":
        return $.lerp(this.constantMin, this.constantMax, e % 1);
      default:
        this.curveMax.evaluate(s) * this.curveMultiplier;
        break;
    }
    return 0;
  }
  getMax() {
    switch (this.mode) {
      case 0:
      case "Constant":
        return this.constant;
      case 1:
      case "Curve":
        return this.getMaxFromCurve(this.curve) * this.curveMultiplier;
      case 2:
      case "TwoCurves":
        return Math.max(this.getMaxFromCurve(this.curveMin), this.getMaxFromCurve(this.curveMax)) * this.curveMultiplier;
      case 3:
      case "TwoConstants":
        return Math.max(this.constantMin, this.constantMax);
      default:
        return 0;
    }
  }
  getMaxFromCurve(s) {
    if (!s)
      return 0;
    let t = Number.MIN_VALUE;
    for (let e = 0; e < s.keys.length; e++) {
      const i = s.keys[e];
      i.value > t && (t = i.value);
    }
    return t;
  }
};
let Q = nc;
C([
  f()
], Q.prototype, "mode", 2);
C([
  f()
], Q.prototype, "constant", 2);
C([
  f()
], Q.prototype, "constantMin", 2);
C([
  f()
], Q.prototype, "constantMax", 2);
C([
  f(_h)
], Q.prototype, "curve", 2);
C([
  f(_h)
], Q.prototype, "curveMin", 2);
C([
  f(_h)
], Q.prototype, "curveMax", 2);
C([
  f()
], Q.prototype, "curveMultiplier", 2);
var cd;
const Rt = (cd = class {
  constructor() {
    r(this, "mode", 0);
    r(this, "color");
    r(this, "colorMin");
    r(this, "colorMax");
    r(this, "gradient");
    r(this, "gradientMin");
    r(this, "gradientMax");
  }
  static constant(s) {
    const t = new Rt();
    return t.constant(s), t;
  }
  static betweenTwoColors(s, t) {
    const e = new Rt();
    return e.betweenTwoColors(s, t), e;
  }
  constant(s) {
    return this.mode = 0, this.color = s, this;
  }
  betweenTwoColors(s, t) {
    return this.mode = 2, this.colorMin = s, this.colorMax = t, this;
  }
  evaluate(s, t) {
    const e = t === void 0 ? Math.random() : t;
    switch (this.mode) {
      case 0:
      case "Color":
        return this.color;
      case 1:
      case "Gradient":
        return this.gradient.evaluate(s, Rt._temp), Rt._temp;
      case 2:
      case "TwoColors":
        return Rt._temp.lerpColors(this.colorMin, this.colorMax, e);
      case 3:
      case "TwoGradients":
        return this.gradientMin.evaluate(s, Rt._temp), this.gradientMax.evaluate(s, Rt._temp2), Rt._temp.lerp(Rt._temp2, e);
      case 4:
      case "RandomColor":
        const n = Math.random();
        return this.gradientMin.evaluate(s, Rt._temp), this.gradientMax.evaluate(s, Rt._temp2), Rt._temp.lerp(Rt._temp2, n);
    }
    return Rt._temp.set(16777215), Rt._temp.alpha = 1, Rt._temp;
  }
}, r(cd, "_temp", new we(0, 0, 0, 1)), r(cd, "_temp2", new we(0, 0, 0, 1)), cd);
let Li = Rt;
C([
  f()
], Li.prototype, "mode", 2);
C([
  f(we)
], Li.prototype, "color", 2);
C([
  f(we)
], Li.prototype, "colorMin", 2);
C([
  f(we)
], Li.prototype, "colorMax", 2);
C([
  f(ul)
], Li.prototype, "gradient", 2);
C([
  f(ul)
], Li.prototype, "gradientMin", 2);
C([
  f(ul)
], Li.prototype, "gradientMax", 2);
var $m = /* @__PURE__ */ ((s) => (s[s.Hierarchy = 0] = "Hierarchy", s[s.Local = 1] = "Local", s[s.Shape = 2] = "Shape", s))($m || {});
class oi {
  constructor() {
    r(this, "cullingMode");
    r(this, "duration");
    r(this, "emitterVelocityMode");
    r(this, "flipRotation");
    r(this, "gravityModifier");
    r(this, "gravityModifierMultiplier");
    r(this, "loop");
    r(this, "maxParticles");
    r(this, "playOnAwake");
    r(this, "prewarm");
    r(this, "ringBufferLoopRange");
    r(this, "ringBufferMode");
    r(this, "scalingMode");
    r(this, "simulationSpace");
    r(this, "simulationSpeed");
    r(this, "startColor");
    r(this, "startDelay");
    r(this, "startDelayMultiplier");
    r(this, "startLifetime");
    r(this, "startLifetimeMultiplier");
    r(this, "startRotation");
    r(this, "startRotationMultiplier");
    r(this, "startRotation3D");
    r(this, "startRotationX");
    r(this, "startRotationXMultiplier");
    r(this, "startRotationY");
    r(this, "startRotationYMultiplier");
    r(this, "startRotationZ");
    r(this, "startRotationZMultiplier");
    r(this, "startSize");
    r(this, "startSize3D");
    r(this, "startSizeMultiplier");
    r(this, "startSizeX");
    r(this, "startSizeXMultiplier");
    r(this, "startSizeY");
    r(this, "startSizeYMultiplier");
    r(this, "startSizeZ");
    r(this, "startSizeZMultiplier");
    r(this, "startSpeed");
    r(this, "startSpeedMultiplier");
    r(this, "stopAction");
    r(this, "useUnscaledTime");
  }
}
C([
  f(Q)
], oi.prototype, "gravityModifier", 2);
C([
  f(Li)
], oi.prototype, "startColor", 2);
C([
  f(Q)
], oi.prototype, "startDelay", 2);
C([
  f(Q)
], oi.prototype, "startLifetime", 2);
C([
  f(Q)
], oi.prototype, "startRotation", 2);
C([
  f(Q)
], oi.prototype, "startRotationX", 2);
C([
  f(Q)
], oi.prototype, "startRotationY", 2);
C([
  f(Q)
], oi.prototype, "startRotationZ", 2);
C([
  f(Q)
], oi.prototype, "startSize", 2);
C([
  f(Q)
], oi.prototype, "startSizeX", 2);
C([
  f(Q)
], oi.prototype, "startSizeY", 2);
C([
  f(Q)
], oi.prototype, "startSizeZ", 2);
C([
  f(Q)
], oi.prototype, "startSpeed", 2);
class Wm {
  constructor() {
    r(this, "cycleCount");
    r(this, "maxCount");
    r(this, "minCount");
    r(this, "probability");
    r(this, "repeatInterval");
    r(this, "time");
    r(this, "count");
    r(this, "_performed", 0);
  }
  reset() {
    this._performed = 0;
  }
  run(t) {
    if (t <= this.time)
      return 0;
    let e = 0;
    if (this.cycleCount === 0 || this._performed < this.cycleCount) {
      const i = this.time + this.repeatInterval * this._performed;
      if (t >= i && (this._performed += 1, Math.random() < this.probability))
        switch (this.count.mode) {
          case 0:
            e = this.count.constant;
            break;
          case 3:
            e = $.lerp(this.count.constantMin, this.count.constantMax, Math.random());
            break;
          case 1:
            e = this.count.curve.evaluate(Math.random());
            break;
          case 2:
            const n = Math.random();
            e = $.lerp(this.count.curveMin.evaluate(n), this.count.curveMax.evaluate(n), Math.random());
            break;
        }
    }
    return e;
  }
}
class Eo {
  constructor() {
    r(this, "enabled");
    r(this, "bursts");
    r(this, "rateOverTime");
    r(this, "rateOverTimeMultiplier");
    r(this, "rateOverDistance");
    r(this, "rateOverDistanceMultiplier");
    /** set from system */
    r(this, "system");
  }
  get burstCount() {
    var t;
    return ((t = this.bursts) == null ? void 0 : t.length) ?? 0;
  }
  reset() {
    var t;
    (t = this.bursts) == null || t.forEach((e) => e.reset());
  }
  getBurst() {
    let t = 0;
    if (this.burstCount > 0)
      for (let e = 0; e < this.burstCount; e++) {
        const i = this.bursts[e];
        this.system.main.loop && i.time >= this.system.time && i.reset(), t += Math.round(i.run(this.system.time));
      }
    return t;
  }
}
C([
  f()
], Eo.prototype, "enabled", 2);
C([
  f()
], Eo.prototype, "bursts", 2);
C([
  f(Q)
], Eo.prototype, "rateOverTime", 2);
C([
  f()
], Eo.prototype, "rateOverTimeMultiplier", 2);
C([
  f(Q)
], Eo.prototype, "rateOverDistance", 2);
C([
  f()
], Eo.prototype, "rateOverDistanceMultiplier", 2);
class l_ {
  constructor() {
    r(this, "enabled");
    r(this, "color");
  }
}
C([
  f(Li)
], l_.prototype, "color", 2);
class fl {
  constructor() {
    r(this, "enabled");
    r(this, "separateAxes");
    r(this, "size");
    r(this, "sizeMultiplier");
    r(this, "x");
    r(this, "xMultiplier");
    r(this, "y");
    r(this, "yMultiplier");
    r(this, "z");
    r(this, "zMultiplier");
    r(this, "_time", 0);
    r(this, "_temp", new v());
  }
  evaluate(t, e, i) {
    if (e || (e = this._temp), !this.enabled)
      return e.x = e.y = e.z = 1, e;
    if (this.separateAxes)
      e.x = this.x.evaluate(t, i) * this.xMultiplier, e.y = this.y.evaluate(t, i) * this.yMultiplier, e.z = this.z.evaluate(t, i) * this.zMultiplier;
    else {
      const n = this.size.evaluate(t, i) * this.sizeMultiplier;
      e.x = n;
    }
    return e;
  }
}
C([
  f(Q)
], fl.prototype, "size", 2);
C([
  f(Q)
], fl.prototype, "x", 2);
C([
  f(Q)
], fl.prototype, "y", 2);
C([
  f(Q)
], fl.prototype, "z", 2);
var hd;
const sc = (hd = class {
  constructor() {
    r(this, "shapeType", 5);
    r(this, "enabled", !0);
    r(this, "alignToDirection", !1);
    r(this, "angle", 0);
    r(this, "arc", 360);
    r(this, "arcSpread");
    r(this, "arcSpeedMultiplier");
    r(this, "arcMode");
    r(this, "boxThickness");
    r(this, "position");
    r(this, "rotation");
    r(this, "_rotation", new jt());
    r(this, "scale");
    r(this, "radius");
    r(this, "radiusThickness");
    r(this, "sphericalDirectionAmount");
    r(this, "randomDirectionAmount");
    r(this, "randomPositionAmount");
    r(this, "meshShapeType");
    r(this, "meshRenderer");
    r(this, "_meshObj");
    r(this, "_meshGeometry");
    r(this, "system");
    r(this, "_space");
    r(this, "_worldSpaceMatrix", new se());
    r(this, "_worldSpaceMatrixInverse", new se());
    /** nebula implementations: */
    /** initializer implementation */
    r(this, "_vector", new v(0, 0, 0));
    r(this, "_temp", new v(0, 0, 0));
    r(this, "_triangle", new E1());
    r(this, "_dir", new v());
    r(this, "_loopTime", 0);
    r(this, "_loopDirection", 1);
    ed && console.log(this);
  }
  // Emittershape start
  get type() {
    return Nm[this.shapeType];
  }
  initialize(s) {
    this.onInitialize(s), s.position.x = this._vector.x, s.position.y = this._vector.y, s.position.z = this._vector.z;
  }
  toJSON() {
    return this;
  }
  clone() {
    return new sc();
  }
  setMesh(s) {
    this.meshRenderer = s, s ? (this._meshObj = s.sharedMeshes[Math.floor(Math.random() * s.sharedMeshes.length)], this._meshGeometry = this._meshObj.geometry) : (this._meshObj = void 0, this._meshGeometry = void 0);
  }
  update(s, t) {
  }
  onUpdate(s, t, e, i) {
    this.system = s, this._space = e, e === 1 && (this._worldSpaceMatrix.copy(i.matrixWorld), this._worldSpaceMatrix.elements[0] = 1, this._worldSpaceMatrix.elements[5] = 1, this._worldSpaceMatrix.elements[10] = 1, this._worldSpaceMatrixInverse.copy(this._worldSpaceMatrix).invert());
  }
  applyRotation(s) {
    const t = this.rotation.x !== 0 || this.rotation.y !== 0 || this.rotation.z !== 0;
    return t && (this._rotation.x = $.toRadians(this.rotation.x), this._rotation.y = $.toRadians(this.rotation.y), this._rotation.z = $.toRadians(this.rotation.z), this._rotation.order = "ZYX", s.applyEuler(this._rotation)), t;
  }
  onInitialize(s) {
    this._vector.set(0, 0, 0), s.mesh = void 0, s.mesh_geometry = void 0;
    const t = this._temp.copy(this.position), e = this._space === 1;
    e && t.applyQuaternion(this.system.worldQuaternion);
    let i = this.radius;
    if (e && (i *= this.system.worldScale.x), this.enabled) {
      switch (this.shapeType) {
        case 5:
          ed && V.DrawWireBox(this.position, this.scale, 14540253, 1), this._vector.x = Math.random() * this.scale.x - this.scale.x / 2, this._vector.y = Math.random() * this.scale.y - this.scale.y / 2, this._vector.z = Math.random() * this.scale.z - this.scale.z / 2, this._vector.add(t);
          break;
        case 4:
          this.randomConePoint(this.position, this.angle, i, this.radiusThickness, this.arc, this.arcMode, this._vector);
          break;
        case 0:
          this.randomSpherePoint(this.position, i, this.radiusThickness, this.arc, this._vector);
          break;
        case 10:
          this.randomCirclePoint(this.position, i, this.radiusThickness, this.arc, this._vector);
          break;
        case 13:
          const n = this.meshRenderer;
          (n == null ? void 0 : n.destroyed) == !1 && this.setMesh(n);
          const o = s.mesh = this._meshObj, a = s.mesh_geometry = this._meshGeometry;
          if (o && a)
            switch (this.meshShapeType) {
              case 0:
                {
                  const l = a.getAttribute("position"), c = Math.floor(Math.random() * l.count);
                  this._vector.fromBufferAttribute(l, c), this._vector.applyMatrix4(o.matrixWorld), s.mesh_normal = c;
                }
                break;
              case 1:
                break;
              case 2:
                {
                  const l = a.index;
                  if (l) {
                    let c = Math.random(), h = Math.random();
                    c + h > 1 && (c = 1 - c, h = 1 - h);
                    const d = Math.floor(Math.random() * (l.count / 3));
                    let u = d * 3, p = d * 3 + 1, m = d * 3 + 2;
                    u = l.getX(u), p = l.getX(p), m = l.getX(m);
                    const g = a.getAttribute("position");
                    this._triangle.a.fromBufferAttribute(g, u), this._triangle.b.fromBufferAttribute(g, p), this._triangle.c.fromBufferAttribute(g, m), this._vector.set(0, 0, 0).addScaledVector(this._triangle.a, c).addScaledVector(this._triangle.b, h).addScaledVector(this._triangle.c, 1 - (c + h)), this._vector.applyMatrix4(o.matrixWorld), s.mesh_normal = d;
                  }
                }
                break;
            }
          break;
        default:
          this._vector.set(0, 0, 0), z() && !globalThis.__particlesystem_shapetype_unsupported && (console.warn("ParticleSystem ShapeType is not supported:", Nm[this.shapeType]), globalThis.__particlesystem_shapetype_unsupported = !0);
          break;
      }
      this.randomizePosition(this._vector, this.randomPositionAmount);
    }
    this.applyRotation(this._vector), e && (this._vector.applyQuaternion(this.system.worldQuaternion), this._vector.add(this.system.worldPos)), ed && V.DrawSphere(this._vector, 0.03, 16711680, 0.5, !0);
  }
  getDirection(s, t) {
    var e;
    if (!this.enabled)
      return this._dir.set(0, 0, 1), this._dir;
    switch (this.shapeType) {
      case 5:
        this._dir.set(0, 0, 1);
        break;
      case 4:
        this._dir.set(0, 0, 1);
        break;
      case 10:
      case 0:
        const i = t.x, n = t.y, o = t.z;
        this._dir.set(i, n, o), (e = this.system) != null && e.worldspace ? this._dir.sub(this.system.worldPos) : this._dir.sub(this.position);
        break;
      case 13:
        const a = s.mesh, l = s.mesh_geometry;
        if (a && l)
          switch (this.meshShapeType) {
            case 0:
              {
                const c = l.getAttribute("normal"), h = s.mesh_normal;
                this._dir.fromBufferAttribute(c, h);
              }
              break;
            case 1:
              break;
            case 2:
              {
                const c = l.index;
                if (c) {
                  const h = s.mesh_normal, d = c.getX(h * 3), u = c.getX(h * 3 + 1), p = c.getX(h * 3 + 2), m = l.getAttribute("position"), g = G(), _ = G(), y = G();
                  g.fromBufferAttribute(m, d), _.fromBufferAttribute(m, u), y.fromBufferAttribute(m, p), g.sub(_), y.sub(_), g.cross(y), this._dir.copy(g).multiplyScalar(-1);
                  const b = Ce(a);
                  this._dir.applyQuaternion(b);
                }
              }
              break;
          }
        break;
      default:
        this._dir.set(0, 0, 1);
        break;
    }
    return this._space === 1 && this._dir.applyQuaternion(this.system.worldQuaternion), this.applyRotation(this._dir), this._dir.normalize(), this.spherizeDirection(this._dir, this.sphericalDirectionAmount), this.randomizeDirection(this._dir, this.randomDirectionAmount), ed && (V.DrawSphere(t, 0.01, 8925952, 0.5, !0), V.DrawDirection(t, this._dir, 8925952, 0.5, !0)), this._dir;
  }
  randomizePosition(s, t) {
    if (t <= 0)
      return;
    const e = sc._tempVec;
    e.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1), e.x *= t * this.scale.x, e.y *= t * this.scale.y, e.z *= t * this.scale.z, s.add(e);
  }
  randomizeDirection(s, t) {
    if (t === 0)
      return;
    const e = sc._randomQuat, i = sc._tempVec;
    i.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(), e.setFromAxisAngle(i, t * Math.random() * Math.PI), s.applyQuaternion(e);
  }
  spherizeDirection(s, t) {
    if (t === 0)
      return;
    const e = Math.random() * Math.PI * 2, i = Math.acos(1 - Math.random() * 2), n = Math.sin(i) * Math.cos(e), o = Math.sin(i) * Math.sin(e), a = Math.cos(i), l = new v(n, o, a);
    s.lerp(l, t);
  }
  randomSpherePoint(s, t, e, i, n) {
    const o = Math.random(), a = Math.random(), l = 2 * Math.PI * o * (i / 360), c = Math.acos(2 * a - 1), h = $.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), e) * t, d = s.x + this.scale.x * (-h * Math.sin(c) * Math.cos(l)), u = s.y + this.scale.y * (h * Math.sin(c) * Math.sin(l)), p = s.z + this.scale.z * (h * Math.cos(c));
    n.x = d, n.y = u, n.z = p;
  }
  randomCirclePoint(s, t, e, i, n) {
    const o = Math.random(), a = 2 * Math.PI * o * (i / 360), l = $.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), e) * t, c = s.x + this.scale.x * l * Math.cos(a), h = s.y + this.scale.y * l * Math.sin(a), d = s.z;
    n.x = c, n.y = h, n.z = d;
  }
  randomConePoint(s, t, e, i, n, o, a) {
    let l = 0, c = 0;
    switch (o) {
      case 0:
        l = Math.random(), c = Math.random();
        break;
      case 2:
        this._loopTime > 1 && (this._loopDirection = -1), this._loopTime < 0 && (this._loopDirection = 1);
      case 1:
        l = 0.5, c = Math.random(), this._loopTime += this.system.deltaTime * this._loopDirection;
        break;
    }
    let h = 2 * Math.PI * l * (n / 360);
    switch (o) {
      case 2:
      case 1:
        h += Math.PI + 0.5, h += this._loopTime * Math.PI * 2, h %= $.toRadians(n);
        break;
    }
    const d = Math.acos(2 * c - 1), u = $.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), i) * e, p = s.x + -u * Math.sin(d) * Math.cos(h), m = s.y + u * Math.sin(d) * Math.sin(h), g = s.z;
    a.x = p * this.scale.x, a.y = m * this.scale.y, a.z = g * this.scale.z;
  }
}, r(hd, "_randomQuat", new W()), r(hd, "_tempVec", new v()), hd);
let tt = sc;
C([
  f()
], tt.prototype, "shapeType", 2);
C([
  f()
], tt.prototype, "enabled", 2);
C([
  f()
], tt.prototype, "alignToDirection", 2);
C([
  f()
], tt.prototype, "angle", 2);
C([
  f()
], tt.prototype, "arc", 2);
C([
  f()
], tt.prototype, "arcSpread", 2);
C([
  f()
], tt.prototype, "arcSpeedMultiplier", 2);
C([
  f()
], tt.prototype, "arcMode", 2);
C([
  f(v)
], tt.prototype, "boxThickness", 2);
C([
  f(v)
], tt.prototype, "position", 2);
C([
  f(v)
], tt.prototype, "rotation", 2);
C([
  f(v)
], tt.prototype, "scale", 2);
C([
  f()
], tt.prototype, "radius", 2);
C([
  f()
], tt.prototype, "radiusThickness", 2);
C([
  f()
], tt.prototype, "sphericalDirectionAmount", 2);
C([
  f()
], tt.prototype, "randomDirectionAmount", 2);
C([
  f()
], tt.prototype, "randomPositionAmount", 2);
C([
  f()
], tt.prototype, "meshShapeType", 2);
C([
  f(Yu)
], tt.prototype, "meshRenderer", 2);
class Oe {
  constructor() {
    r(this, "damping");
    r(this, "enabled");
    r(this, "frequency");
    r(this, "octaveCount");
    r(this, "octaveMultiplier");
    r(this, "octaveScale");
    r(this, "positionAmount");
    r(this, "quality");
    r(this, "remap");
    r(this, "remapEnabled");
    r(this, "remapMultiplier");
    r(this, "remapX");
    r(this, "remapXMultiplier");
    r(this, "remapY");
    r(this, "remapYMultiplier");
    r(this, "remapZ");
    r(this, "remapZMultiplier");
    r(this, "scrollSpeedMultiplier");
    r(this, "separateAxes");
    r(this, "strengthMultiplier");
    r(this, "strengthX");
    r(this, "strengthXMultiplier");
    r(this, "strengthY");
    r(this, "strengthYMultiplier");
    r(this, "strengthZ");
    r(this, "strengthZMultiplier");
    r(this, "_noise");
    r(this, "_time", 0);
    /** nebula implementations: */
    r(this, "_temp", new v());
  }
  update(t) {
    this._time += t.time.deltaTime * this.scrollSpeedMultiplier;
  }
  apply(t, e, i, n, o, a) {
    if (!this.enabled)
      return;
    this._noise || (this._noise = yS(() => 0));
    const l = this._temp.set(e.x, e.y, e.z).multiplyScalar(this.frequency), c = this._noise(l.x, l.y, l.z, this._time), h = this._noise(l.x, l.y, l.z, this._time + 1e3 * this.frequency), d = this._noise(l.x, l.y, l.z, this._time + 2e3 * this.frequency);
    this._temp.set(c, h, d).normalize();
    const u = o / a;
    let p = this.positionAmount.evaluate(u);
    this.separateAxes ? (this._temp.x *= p * this.strengthXMultiplier, this._temp.y *= p * this.strengthYMultiplier, this._temp.z *= p * this.strengthZMultiplier) : (this.strengthX && (p *= this.strengthX.evaluate(u) * 1.5), this._temp.multiplyScalar(p)), i.x += this._temp.x, i.y += this._temp.y, i.z += this._temp.z;
  }
}
C([
  f()
], Oe.prototype, "damping", 2);
C([
  f()
], Oe.prototype, "enabled", 2);
C([
  f()
], Oe.prototype, "frequency", 2);
C([
  f()
], Oe.prototype, "octaveCount", 2);
C([
  f()
], Oe.prototype, "octaveMultiplier", 2);
C([
  f()
], Oe.prototype, "octaveScale", 2);
C([
  f(Q)
], Oe.prototype, "positionAmount", 2);
C([
  f()
], Oe.prototype, "quality", 2);
C([
  f(Q)
], Oe.prototype, "remap", 2);
C([
  f()
], Oe.prototype, "remapEnabled", 2);
C([
  f()
], Oe.prototype, "remapMultiplier", 2);
C([
  f(Q)
], Oe.prototype, "remapX", 2);
C([
  f()
], Oe.prototype, "remapXMultiplier", 2);
C([
  f(Q)
], Oe.prototype, "remapY", 2);
C([
  f()
], Oe.prototype, "remapYMultiplier", 2);
C([
  f(Q)
], Oe.prototype, "remapZ", 2);
C([
  f()
], Oe.prototype, "remapZMultiplier", 2);
C([
  f()
], Oe.prototype, "scrollSpeedMultiplier", 2);
C([
  f()
], Oe.prototype, "separateAxes", 2);
C([
  f()
], Oe.prototype, "strengthMultiplier", 2);
C([
  f(Q)
], Oe.prototype, "strengthX", 2);
C([
  f()
], Oe.prototype, "strengthXMultiplier", 2);
C([
  f(Q)
], Oe.prototype, "strengthY", 2);
C([
  f()
], Oe.prototype, "strengthYMultiplier", 2);
C([
  f(Q)
], Oe.prototype, "strengthZ", 2);
C([
  f()
], Oe.prototype, "strengthZMultiplier", 2);
class Xe {
  constructor() {
    r(this, "enabled");
    r(this, "attachRibbonToTransform", !1);
    r(this, "colorOverLifetime");
    r(this, "colorOverTrail");
    r(this, "dieWithParticles", !0);
    r(this, "inheritParticleColor", !0);
    r(this, "lifetime");
    r(this, "lifetimeMultiplier");
    r(this, "minVertexDistance", 0.2);
    r(this, "mode", 0);
    r(this, "ratio", 1);
    r(this, "ribbonCount", 1);
    r(this, "shadowBias", 0);
    r(this, "sizeAffectsLifetime", !1);
    r(this, "sizeAffectsWidth", !1);
    r(this, "splitSubEmitterRibbons", !1);
    r(this, "textureMode", 0);
    r(this, "widthOverTrail");
    r(this, "widthOverTrailMultiplier");
    r(this, "worldSpace", !1);
  }
  getWidth(t, e, i, n) {
    const o = this.widthOverTrail.evaluate(i, n);
    return t *= o, t;
  }
  getColor(t, e, i) {
    const n = this.colorOverTrail.evaluate(i), o = this.colorOverLifetime.evaluate(e);
    t.x *= n.r * o.r, t.y *= n.g * o.g, t.z *= n.b * o.b, "alpha" in n && "alpha" in o && (t.w *= n.alpha * o.alpha);
  }
}
C([
  f()
], Xe.prototype, "enabled", 2);
C([
  f()
], Xe.prototype, "attachRibbonToTransform", 2);
C([
  f(Li)
], Xe.prototype, "colorOverLifetime", 2);
C([
  f(Li)
], Xe.prototype, "colorOverTrail", 2);
C([
  f()
], Xe.prototype, "dieWithParticles", 2);
C([
  f()
], Xe.prototype, "inheritParticleColor", 2);
C([
  f(Q)
], Xe.prototype, "lifetime", 2);
C([
  f()
], Xe.prototype, "lifetimeMultiplier", 2);
C([
  f()
], Xe.prototype, "minVertexDistance", 2);
C([
  f()
], Xe.prototype, "mode", 2);
C([
  f()
], Xe.prototype, "ratio", 2);
C([
  f()
], Xe.prototype, "ribbonCount", 2);
C([
  f()
], Xe.prototype, "shadowBias", 2);
C([
  f()
], Xe.prototype, "sizeAffectsLifetime", 2);
C([
  f()
], Xe.prototype, "sizeAffectsWidth", 2);
C([
  f()
], Xe.prototype, "splitSubEmitterRibbons", 2);
C([
  f()
], Xe.prototype, "textureMode", 2);
C([
  f(Q)
], Xe.prototype, "widthOverTrail", 2);
C([
  f()
], Xe.prototype, "widthOverTrailMultiplier", 2);
C([
  f()
], Xe.prototype, "worldSpace", 2);
class it {
  constructor() {
    r(this, "enabled");
    r(this, "space", 0);
    r(this, "orbitalX");
    r(this, "orbitalY");
    r(this, "orbitalZ");
    r(this, "orbitalXMultiplier");
    r(this, "orbitalYMultiplier");
    r(this, "orbitalZMultiplier");
    r(this, "orbitalOffsetX");
    r(this, "orbitalOffsetY");
    r(this, "orbitalOffsetZ");
    r(this, "speedModifier");
    r(this, "speedModifierMultiplier");
    r(this, "x");
    r(this, "xMultiplier");
    r(this, "y");
    r(this, "yMultiplier");
    r(this, "z");
    r(this, "zMultiplier");
    r(this, "_system");
    r(this, "_temp", new v());
    r(this, "_temp2", new v());
    r(this, "_temp3", new v());
    r(this, "_hasOrbital", !1);
    r(this, "_index", 0);
    r(this, "_orbitalMatrix", new se());
  }
  // private _worldRotation: Quaternion = new Quaternion();
  update(t) {
    this._system = t;
  }
  init(t) {
    this._index == 0 && (t.debug = !0), this._index += 1, t.orbitx = this.orbitalX.evaluate(Math.random()), t.orbity = this.orbitalY.evaluate(Math.random()), t.orbitz = this.orbitalZ.evaluate(Math.random()), this._hasOrbital = t.orbitx != 0 || t.orbity != 0 || t.orbitz != 0;
  }
  apply(t, e, i, n, o, a, l) {
    var m;
    if (!this.enabled)
      return;
    const c = a / l, h = this.speedModifier.evaluate(c) * this.speedModifierMultiplier, d = this.x.evaluate(c), u = this.y.evaluate(c), p = this.z.evaluate(c);
    if (this._temp.set(-d, u, p), this._system && this._system.main.simulationSpace === 1 && this._temp.applyQuaternion(this._system.worldQuaternion), this._hasOrbital && ((m = this._system) == null ? void 0 : m.worldPos)) {
      const _ = this._temp2.set(i.x, i.y, i.z), y = this.orbitalXMultiplier, b = this.orbitalYMultiplier, w = this.orbitalZMultiplier, P = h * Math.PI * 2 * 10, k = Math.cos(P * y), O = Math.sin(P * y), M = Math.cos(P * b), E = Math.sin(P * b), B = Math.cos(P * w), A = Math.sin(P * w), F = _.x * (M * B) + _.y * (M * A) + _.z * -E, U = _.x * (O * E * B - k * A) + _.y * (O * E * A + k * B) + _.z * (O * M), Z = _.x * (k * E * B + O * A) + _.y * (k * E * A - O * B) + _.z * (k * M), T = this._temp3.set(_.x - F, _.y - U, _.z - Z);
      T.normalize(), T.multiplyScalar(0.2 / o * Math.max(this.orbitalXMultiplier, this.orbitalYMultiplier, this.orbitalZMultiplier)), n.x += T.x, n.y += T.y, n.z += T.z;
    }
    n.x += this._temp.x, n.y += this._temp.y, n.z += this._temp.z, n.x *= h, n.y *= h, n.z *= h;
  }
}
C([
  f()
], it.prototype, "enabled", 2);
C([
  f()
], it.prototype, "space", 2);
C([
  f(Q)
], it.prototype, "orbitalX", 2);
C([
  f(Q)
], it.prototype, "orbitalY", 2);
C([
  f(Q)
], it.prototype, "orbitalZ", 2);
C([
  f()
], it.prototype, "orbitalXMultiplier", 2);
C([
  f()
], it.prototype, "orbitalYMultiplier", 2);
C([
  f()
], it.prototype, "orbitalZMultiplier", 2);
C([
  f()
], it.prototype, "orbitalOffsetX", 2);
C([
  f()
], it.prototype, "orbitalOffsetY", 2);
C([
  f()
], it.prototype, "orbitalOffsetZ", 2);
C([
  f(Q)
], it.prototype, "speedModifier", 2);
C([
  f()
], it.prototype, "speedModifierMultiplier", 2);
C([
  f(Q)
], it.prototype, "x", 2);
C([
  f()
], it.prototype, "xMultiplier", 2);
C([
  f(Q)
], it.prototype, "y", 2);
C([
  f()
], it.prototype, "yMultiplier", 2);
C([
  f(Q)
], it.prototype, "z", 2);
C([
  f()
], it.prototype, "zMultiplier", 2);
class ri {
  constructor() {
    r(this, "animation");
    r(this, "enabled");
    r(this, "cycleCount");
    r(this, "frameOverTime");
    r(this, "frameOverTimeMultiplier");
    r(this, "numTilesX");
    r(this, "numTilesY");
    r(this, "startFrame");
    r(this, "startFrameMultiplier");
    r(this, "rowMode");
    r(this, "rowIndex");
    r(this, "spriteCount");
    r(this, "timeMode");
  }
  sampleOnceAtStart() {
    if (this.timeMode === 0)
      switch (this.frameOverTime.mode) {
        case 0:
        case 3:
        case 2:
        case 1:
          return !0;
      }
    return !1;
  }
  getStartIndex() {
    return this.sampleOnceAtStart() ? Math.random() * (this.numTilesX * this.numTilesY) : 0;
  }
  evaluate(t) {
    if (!this.sampleOnceAtStart())
      return this.getIndex(t);
  }
  getIndex(t) {
    const e = this.numTilesX * this.numTilesY;
    t = t * this.cycleCount;
    let i = this.frameOverTime.evaluate(t % 1);
    return i *= this.frameOverTimeMultiplier, i *= e, i = i % e, i = Math.floor(i), i;
  }
}
C([
  f()
], ri.prototype, "animation", 2);
C([
  f()
], ri.prototype, "enabled", 2);
C([
  f()
], ri.prototype, "cycleCount", 2);
C([
  f(Q)
], ri.prototype, "frameOverTime", 2);
C([
  f()
], ri.prototype, "frameOverTimeMultiplier", 2);
C([
  f()
], ri.prototype, "numTilesX", 2);
C([
  f()
], ri.prototype, "numTilesY", 2);
C([
  f(Q)
], ri.prototype, "startFrame", 2);
C([
  f()
], ri.prototype, "startFrameMultiplier", 2);
C([
  f()
], ri.prototype, "rowMode", 2);
C([
  f()
], ri.prototype, "rowIndex", 2);
C([
  f()
], ri.prototype, "spriteCount", 2);
C([
  f()
], ri.prototype, "timeMode", 2);
class Jn {
  constructor() {
    r(this, "enabled");
    r(this, "separateAxes");
    r(this, "x");
    r(this, "xMultiplier");
    r(this, "y");
    r(this, "yMultiplier");
    r(this, "z");
    r(this, "zMultiplier");
  }
  evaluate(t, e) {
    return this.enabled ? this.separateAxes ? 0 : this.z.evaluate(t, e) * -1 : 0;
  }
}
C([
  f()
], Jn.prototype, "enabled", 2);
C([
  f()
], Jn.prototype, "separateAxes", 2);
C([
  f(Q)
], Jn.prototype, "x", 2);
C([
  f()
], Jn.prototype, "xMultiplier", 2);
C([
  f(Q)
], Jn.prototype, "y", 2);
C([
  f()
], Jn.prototype, "yMultiplier", 2);
C([
  f(Q)
], Jn.prototype, "z", 2);
C([
  f()
], Jn.prototype, "zMultiplier", 2);
class Cn {
  constructor() {
    r(this, "enabled");
    r(this, "range");
    r(this, "separateAxes");
    r(this, "x");
    r(this, "xMultiplier");
    r(this, "y");
    r(this, "yMultiplier");
    r(this, "z");
    r(this, "zMultiplier");
  }
  evaluate(t, e) {
    if (!this.enabled)
      return 0;
    if (!this.separateAxes) {
      const i = $.lerp(this.range.x, this.range.y, e);
      return this.z.evaluate(i) * -1;
    }
    return 0;
  }
}
C([
  f()
], Cn.prototype, "enabled", 2);
C([
  f()
], Cn.prototype, "range", 2);
C([
  f()
], Cn.prototype, "separateAxes", 2);
C([
  f(Q)
], Cn.prototype, "x", 2);
C([
  f()
], Cn.prototype, "xMultiplier", 2);
C([
  f(Q)
], Cn.prototype, "y", 2);
C([
  f()
], Cn.prototype, "yMultiplier", 2);
C([
  f(Q)
], Cn.prototype, "z", 2);
C([
  f()
], Cn.prototype, "zMultiplier", 2);
class xt {
  constructor() {
    r(this, "enabled");
    r(this, "dampen");
    r(this, "drag");
    r(this, "dragMultiplier");
    r(this, "limit");
    r(this, "limitMultiplier");
    r(this, "separateAxes");
    r(this, "limitX");
    r(this, "limitXMultiplier");
    r(this, "limitY");
    r(this, "limitYMultiplier");
    r(this, "limitZ");
    r(this, "limitZMultiplier");
    r(this, "multiplyDragByParticleSize", !1);
    r(this, "multiplyDragByParticleVelocity", !1);
    r(this, "space");
    r(this, "_temp", new v());
    r(this, "_temp2", new v());
  }
  apply(t, e, i, n, o, a, l) {
    if (this.enabled) {
      const c = this.limit.evaluate(o) * this.limitMultiplier;
      if (e.length() > c) {
        this._temp.copy(e).normalize().multiplyScalar(c);
        const d = this.dampen * 0.5;
        e.x = $.lerp(e.x, this._temp.x, d), e.y = $.lerp(e.y, this._temp.y, d), e.z = $.lerp(e.z, this._temp.z, d), i.x = $.lerp(i.x, this._temp.x, d), i.y = $.lerp(i.y, this._temp.y, d), i.z = $.lerp(i.z, this._temp.z, d);
      }
    }
  }
}
C([
  f()
], xt.prototype, "enabled", 2);
C([
  f()
], xt.prototype, "dampen", 2);
C([
  f(Q)
], xt.prototype, "drag", 2);
C([
  f()
], xt.prototype, "dragMultiplier", 2);
C([
  f(Q)
], xt.prototype, "limit", 2);
C([
  f()
], xt.prototype, "limitMultiplier", 2);
C([
  f()
], xt.prototype, "separateAxes", 2);
C([
  f(Q)
], xt.prototype, "limitX", 2);
C([
  f()
], xt.prototype, "limitXMultiplier", 2);
C([
  f(Q)
], xt.prototype, "limitY", 2);
C([
  f()
], xt.prototype, "limitYMultiplier", 2);
C([
  f(Q)
], xt.prototype, "limitZ", 2);
C([
  f()
], xt.prototype, "limitZMultiplier", 2);
C([
  f()
], xt.prototype, "multiplyDragByParticleSize", 2);
C([
  f()
], xt.prototype, "multiplyDragByParticleVelocity", 2);
C([
  f()
], xt.prototype, "space", 2);
const Fw = class {
  constructor() {
    r(this, "enabled");
    r(this, "curve");
    r(this, "curveMultiplier");
    r(this, "mode");
    r(this, "system");
    r(this, "_temp", new v());
    r(this, "_firstUpdate", !0);
    r(this, "_frames", 0);
  }
  clone() {
    var t;
    const s = new Fw();
    return s.enabled = this.enabled, s.curve = (t = this.curve) == null ? void 0 : t.clone(), s.curveMultiplier = this.curveMultiplier, s.mode = this.mode, s;
  }
  get _lastWorldPosition() {
    return this.system._iv_lastWorldPosition || (this.system._iv_lastWorldPosition = new v()), this.system._iv_lastWorldPosition;
  }
  get _velocity() {
    return this.system._iv_velocity || (this.system._iv_velocity = new v()), this.system._iv_velocity;
  }
  awake(s) {
    this.system = s, this.reset();
  }
  reset() {
    this._firstUpdate = !0;
  }
  update(s) {
    this.enabled && this.system.worldspace !== !1 && (this._firstUpdate ? (this._firstUpdate = !1, this._velocity.set(0, 0, 0), this._lastWorldPosition.copy(this.system.worldPos)) : this._lastWorldPosition && (this._velocity.copy(this.system.worldPos).sub(this._lastWorldPosition).multiplyScalar(1 / this.system.deltaTime), this._lastWorldPosition.copy(this.system.worldPos)));
  }
  // TODO: make work for subsystems
  applyInitial(s) {
    if (this.enabled && this.system.worldspace !== !1 && this.mode === 0) {
      const t = this.curve.evaluate(Math.random(), Math.random());
      this._temp.copy(this._velocity).multiplyScalar(t), s.x += this._temp.x, s.y += this._temp.y, s.z += this._temp.z;
    }
  }
  applyCurrent(s, t, e) {
    if (this.enabled && this.system && this.system.worldspace !== !1 && this.mode === 1) {
      const i = this.curve.evaluate(t, e);
      this._temp.copy(this._velocity).multiplyScalar(i), s.x += this._temp.x, s.y += this._temp.y, s.z += this._temp.z;
    }
  }
};
let pl = Fw;
C([
  f()
], pl.prototype, "enabled", 2);
C([
  f(Q)
], pl.prototype, "curve", 2);
C([
  f()
], pl.prototype, "curveMultiplier", 2);
C([
  f()
], pl.prototype, "mode", 2);
class ji {
  constructor() {
    r(this, "enabled");
    r(this, "range");
    r(this, "separateAxes");
    r(this, "size");
    r(this, "sizeMultiplier");
    r(this, "x");
    r(this, "xMultiplier");
    r(this, "y");
    r(this, "yMultiplier");
    r(this, "z");
    r(this, "zMultiplier");
  }
  evaluate(t, e, i, n) {
    const o = t.length(), a = $.remap(o, this.range.x, this.range.y, 0, 1), l = this.size.evaluate(a, i);
    return n.x *= l, n.y *= l, n.z *= l, n;
  }
}
C([
  f()
], ji.prototype, "enabled", 2);
C([
  f(oe)
], ji.prototype, "range", 2);
C([
  f()
], ji.prototype, "separateAxes", 2);
C([
  f(Q)
], ji.prototype, "size", 2);
C([
  f()
], ji.prototype, "sizeMultiplier", 2);
C([
  f(Q)
], ji.prototype, "x", 2);
C([
  f()
], ji.prototype, "xMultiplier", 2);
C([
  f(Q)
], ji.prototype, "y", 2);
C([
  f()
], ji.prototype, "yMultiplier", 2);
C([
  f(Q)
], ji.prototype, "z", 2);
C([
  f()
], ji.prototype, "zMultiplier", 2);
class yh {
  constructor() {
    r(this, "enabled");
    r(this, "range");
    r(this, "color");
  }
  evaluate(t, e, i) {
    const n = t.length(), o = $.remap(n, this.range.x, this.range.y, 0, 1), a = this.color.evaluate(o, e);
    i.x *= a.r, i.y *= a.g, i.z *= a.b, "alpha" in a && (i.w *= a.alpha);
  }
}
C([
  f()
], yh.prototype, "enabled", 2);
C([
  f(oe)
], yh.prototype, "range", 2);
C([
  f(Li)
], yh.prototype, "color", 2);
new v(1, 1, 1);
new v(0, 0, 1);
class zw {
  constructor(t, e, i, n) {
    r(this, "type", "NeedleParticleSubEmitter");
    r(this, "emitterType");
    r(this, "emitterProbability");
    //private matrix_ = new Matrix4();
    r(this, "q_", new W());
    r(this, "v_", new v());
    r(this, "v2_", new v());
    r(this, "_emitterMatrix", new Pf());
    r(this, "_circularBuffer");
    this.system = t, this.particleSystem = e, this.subSystem = i, this.subParticleSystem = n, this.subParticleSystem && this.subParticleSystem && (this.subParticleSystem.onlyUsedByOther = !0);
    const o = 1e3;
    this._circularBuffer = new tn(() => new Pf(), o);
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  initialize(t) {
    t.emissionState = {
      burstIndex: 0,
      burstWaveIndex: 0,
      time: 0,
      waitEmiting: 0
      // matrix: new Matrix4(),
    }, this._emitterMatrix.copy(this.subSystem.matrixWorld).invert().premultiply(this.system.matrixWorld), this._emitterMatrix.setPosition(0, 0, 0), this.emitterType === Vm.Birth && this.run(t);
  }
  update(t, e) {
    this.run(t);
  }
  frameUpdate(t) {
  }
  toJSON() {
  }
  reset() {
  }
  run(t) {
    if (this.subSystem.currentParticles >= this.subSystem.main.maxParticles || !this.subParticleSystem || !t.emissionState || this.emitterProbability && Math.random() > this.emitterProbability)
      return;
    const e = this.system.deltaTime;
    if (this.emitterType === Vm.Death) {
      let n = t.life;
      if (t[ma] !== void 0 && (n = t[ma]), !(t.age + e * 1.2 >= n))
        return;
      const a = this.subSystem.main.maxParticles - this.subSystem.currentParticles;
      t.emissionState.waitEmiting = a;
    }
    const i = new Pf();
    i.set(
      1,
      0,
      0,
      t.position.x,
      0,
      1,
      0,
      t.position.y,
      0,
      0,
      1,
      t.position.z,
      0,
      0,
      0,
      1
    ), this.particleSystem.worldSpace || i.multiplyMatrices(this._emitterMatrix, i), this.subParticleSystem.emit(e, t.emissionState, i);
  }
}
var bT = Object.defineProperty, vT = Object.getOwnPropertyDescriptor, He = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? vT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && bT(t, e, n), n;
};
const to = x("debugparticles"), wT = x("noprogressive"), xT = x("debugprogressive");
var Vm = /* @__PURE__ */ ((s) => (s[s.Birth = 0] = "Birth", s[s.Collision = 1] = "Collision", s[s.Death = 2] = "Death", s[s.Trigger = 3] = "Trigger", s[s.Manual = 4] = "Manual", s))(Vm || {});
class Pn extends I {
  constructor() {
    super(...arguments);
    r(this, "renderMode");
    r(this, "particleMaterial");
    r(this, "trailMaterial");
    // @serializable(Mesh)
    r(this, "particleMesh");
    r(this, "maxParticleSize");
    r(this, "minParticleSize");
    r(this, "velocityScale");
    r(this, "cameraVelocityScale");
    r(this, "lengthScale");
  }
  start() {
    if (this.maxParticleSize !== 0.5 && this.minParticleSize !== 0 && z()) {
      const e = `ParticleSystem "${this.name}" has non-default min/max particle size. This may not render correctly. Please set min size to 0 and the max size to 0.5 and use the "StartSize" setting instead`;
      console.warn(e);
    }
  }
  get transparent() {
    var i;
    return ((i = this.particleMaterial) == null ? void 0 : i.transparent) ?? !1;
  }
  getMaterial(e = !1) {
    let i = e === !0 && this.trailMaterial ? this.trailMaterial : this.particleMaterial;
    if (i) {
      if (i.type === "MeshStandardMaterial") {
        to && console.debug("ParticleSystemRenderer.getMaterial: MeshStandardMaterial detected, converting to MeshBasicMaterial. See https://github.com/Alchemist0823/three.quarks/issues/101"), "map" in i && i.map && (i.map.colorSpace = wr, i.map.premultiplyAlpha = !1);
        const n = new Me();
        n.copy(i), e ? this.trailMaterial = n : this.particleMaterial = n;
      }
      i.map && (i.map.colorSpace = wr, i.map.premultiplyAlpha = !1), e && i.side === xo && (i = i.clone(), i.side = Cu, e ? this.trailMaterial = i : this.particleMaterial = i);
    }
    return i && !wT && i._didRequestTextureLOD === void 0 && (i._didRequestTextureLOD = 0, xT && console.log("Load material LOD", i.name), Ze.assignTextureLOD(i, 0)), i;
  }
  getMesh(e) {
    let i = null;
    if (!i && (this.particleMesh instanceof q && (i = this.particleMesh.geometry), i === null)) {
      i = new Xn(1, 1);
      const o = i.attributes.uv;
      for (let a = 0; a < o.count; a++)
        o.setX(a, 1 - o.getX(a));
    }
    return new q(i, this.getMaterial());
  }
}
He([
  f()
], Pn.prototype, "renderMode", 2);
He([
  f(Se)
], Pn.prototype, "particleMaterial", 2);
He([
  f(Se)
], Pn.prototype, "trailMaterial", 2);
He([
  f()
], Pn.prototype, "maxParticleSize", 2);
He([
  f()
], Pn.prototype, "minParticleSize", 2);
He([
  f()
], Pn.prototype, "velocityScale", 2);
He([
  f()
], Pn.prototype, "cameraVelocityScale", 2);
He([
  f()
], Pn.prototype, "lengthScale", 2);
class td {
  constructor(t, e = 1) {
    r(this, "_curve");
    r(this, "_factor");
    r(this, "type", "function");
    this._curve = t, this._factor = e;
  }
  startGen(t) {
  }
  genValue(t, e) {
    return this._curve.evaluate(e, Math.random()) * this._factor;
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
}
class c_ {
  constructor(t) {
    r(this, "type", "value");
    r(this, "system");
    this.system = t;
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  startGen(t) {
  }
}
class ST extends c_ {
  genValue() {
    return this.system.textureSheetAnimation.getStartIndex();
  }
}
class CT extends c_ {
  constructor() {
    super(...arguments);
    r(this, "_lastPosition", new v());
    r(this, "_lastDistance", 0);
  }
  update() {
    const e = ie(this.system.gameObject);
    this._lastDistance = this._lastPosition.distanceTo(e), this._lastPosition.copy(e);
  }
  genValue() {
    if (!this.system.isPlaying || !this.system.emission.enabled || this.system.currentParticles >= this.system.maxParticles)
      return 0;
    let e = this.system.emission.rateOverTime.evaluate(this.system.time / this.system.duration, Math.random());
    if (this.system.deltaTime > 0) {
      const o = this.system.emission.rateOverDistance.evaluate(this.system.time / this.system.duration, Math.random());
      let l = this._lastDistance / this.system.deltaTime * o;
      Number.isFinite(l) || (l = 0), e += l;
    }
    const i = this.system.emission.getBurst();
    i > 0 && (e += i / this.system.deltaTime);
    const n = this.system.maxParticles - this.system.currentParticles;
    return $.clamp(e, 0, n / this.system.deltaTime);
  }
}
class PT extends c_ {
  genValue() {
    return this.system.isPlaying, 0;
  }
}
class Fr {
  constructor(t) {
    r(this, "system");
    r(this, "type");
    this.type = Object.getPrototypeOf(this).constructor.name || "ParticleSystemBaseBehaviour", t && (this.system = t);
  }
  get context() {
    return this.system.context;
  }
  initialize(t) {
  }
  update(t, e) {
  }
  frameUpdate(t) {
  }
  toJSON() {
    throw new Error("Method not implemented.");
  }
  clone() {
    throw new Error("Method not implemented.");
  }
  reset() {
  }
}
class OT extends Fr {
  constructor() {
    super(...arguments);
    r(this, "type", "NeedleTextureSheet");
  }
  // initialize(_particle: Particle): void {
  //     _particle[$startFrame] = this.system.textureSheetAnimation.getStartIndex();
  // }
  update(e, i) {
    const n = this.system.textureSheetAnimation;
    if (n.enabled) {
      const o = e.age / e.life, a = n.evaluate(o);
      a !== void 0 && (e.uvTile = a);
    }
  }
}
const Mb = Symbol("particleRotation");
class MT extends Fr {
  constructor() {
    super(...arguments);
    r(this, "type", "NeedleRotation");
  }
  initialize(e) {
    e[Mb] = Math.random();
  }
  update(e, i) {
    if (e.rotation === void 0)
      return;
    const n = e.age / e.life;
    if (typeof e.rotation == "number" && (this.system.rotationOverLifetime.enabled ? e.rotation += this.system.rotationOverLifetime.evaluate(n, e[Mb]) * i : this.system.renderer.renderMode === gs.Billboard && (e.rotation = Math.PI), this.system.rotationBySpeed.enabled)) {
      const o = e.velocity.length();
      e.rotation += this.system.rotationBySpeed.evaluate(n, o) * i;
    }
  }
}
const Rb = Symbol("sizeLerpFactor"), RT = new v();
class kT extends Fr {
  constructor() {
    super(...arguments);
    r(this, "type", "NeedleSize");
    r(this, "_minSize", 0);
    r(this, "_maxSize", 1);
  }
  initialize(e) {
    e[Rb] = Math.random(), this._minSize = this.system.renderer.minParticleSize, this._maxSize = this.system.renderer.maxParticleSize;
  }
  update(e, i) {
    const n = e.age / e.life;
    let o = 1;
    this.system.sizeOverLifetime.enabled && (o *= this.system.sizeOverLifetime.evaluate(n, void 0, e[Rb]).x);
    let a = 1;
    this.system.renderer.renderMode !== gs.Mesh && (a = this.system.worldScale.x / this.system.cameraScale);
    const l = G(e.startSize).multiplyScalar(o * a);
    if (e.size.set(l.x, l.y, l.z), this.system.localspace) {
      const c = Uw(this.system, RT);
      e.size.x *= c.x, e.size.y *= c.y, e.size.z *= c.z;
    }
  }
}
const ma = Symbol("particleLife"), xp = Symbol("trailLifetime"), kb = Symbol("trailStartLength"), Sp = Symbol("trailWidthRandom");
class TT extends Fr {
  constructor() {
    super(...arguments);
    r(this, "type", "NeedleTrail");
  }
  initialize(e) {
    e instanceof N_ && (e[ma] = e.life, this.system.trails.enabled && this.system.trails.dieWithParticles === !1 && (e[xp] = this.system.trails.lifetime.evaluate(Math.random(), Math.random()), e.life += e[xp]), e[kb] = e.length, e[Sp] = Math.random());
  }
  update(e) {
    var i;
    if ((i = this.system.trails) != null && i.enabled && e instanceof N_) {
      const n = e, o = e.age / e[ma], a = e.previous.values(), l = e.previous.length;
      for (let c = 0; c < l; c++) {
        const d = a.next().value, u = 1 - c / (l - 1), p = e.size;
        if (p.x <= 0 && !this.system.trails.sizeAffectsWidth) {
          const m = 20 * this.system.trails.widthOverTrail.evaluate(0.5, n[Sp]);
          p.x = m, p.y = m, p.z = m;
        }
        d.size = this.system.trails.getWidth(p.x, o, u, n[Sp]), d.color.copy(e.color), this.system.trails.getColor(d.color, o, u);
      }
      if (e.age > e[ma]) {
        e.velocity.set(0, 0, 0);
        const c = (e.age - e[ma]) / e[xp];
        n.length = $.lerp(e[kb], 0, c);
      }
    }
  }
}
const id = Symbol("startVelocity"), Tb = Symbol("gravityModifier"), Cp = Symbol("gravitySpeed"), nd = Symbol("velocity lerp factor"), Hm = new v();
class AT extends Fr {
  constructor() {
    super(...arguments);
    r(this, "type", "NeedleVelocity");
    r(this, "_gravityDirection", new v());
  }
  initialize(e) {
    var a, l;
    const i = this.system.main.simulationSpeed;
    e.startSpeed = this.system.main.startSpeed.evaluate(Math.random(), Math.random());
    const n = this.system.shape.getDirection(e, e.position);
    e.velocity.x = n.x * e.startSpeed, e.velocity.y = n.y * e.startSpeed, e.velocity.z = n.z * e.startSpeed, (a = this.system.inheritVelocity) != null && a.enabled && this.system.inheritVelocity.applyInitial(e.velocity), e[id] ? e[id].copy(e.velocity) : e[id] = e.velocity.clone();
    const o = this.system.main.gravityModifier.evaluate(Math.random(), Math.random());
    e[Tb] = o * i, e[Cp] = o * i * 0.5, e[nd] = Math.random(), (l = this.system.velocityOverLifetime) == null || l.init(e), this._gravityDirection.set(0, -1, 0), this.system.main.simulationSpace === $c.Local && this._gravityDirection.applyQuaternion(this.system.worldQuaternionInverted).normalize();
  }
  update(e, i) {
    var p;
    const n = e[id], o = e[Tb];
    if (o !== 0) {
      const m = o * e[Cp];
      Hm.copy(this._gravityDirection).multiplyScalar(m), e[Cp] += i * 0.05, n.add(Hm);
    }
    e.velocity.copy(n);
    const a = e.age / e.life;
    (p = this.system.inheritVelocity) != null && p.enabled && this.system.inheritVelocity.applyCurrent(e.velocity, a, e[nd]);
    const l = this.system.noise;
    l.enabled && l.apply(0, e.position, e.velocity, i, e.age, e.life);
    const c = this.system.sizeBySpeed;
    c != null && c.enabled && (e.size = c.evaluate(e.velocity, a, e[nd], e.size));
    const h = this.system.colorBySpeed;
    h != null && h.enabled && h.evaluate(e.velocity, e[nd], e.color);
    const d = this.system.velocityOverLifetime;
    d.enabled && d.apply(e, 0, e.position, e.velocity, i, e.age, e.life);
    const u = this.system.limitVelocityOverLifetime;
    if (u.enabled && u.apply(e.position, n, e.velocity, e.size, a, i, 1), this.system.worldspace) {
      const m = this.system.worldScale;
      e.velocity.x *= m.x, e.velocity.y *= m.y, e.velocity.z *= m.z;
    }
  }
}
const Ab = Symbol("colorLerpFactor"), Eb = new we(1, 1, 1, 1), Wo = new we(1, 1, 1, 1);
class ET extends Fr {
  constructor() {
    super(...arguments);
    r(this, "type", "NeedleColor");
  }
  initialize(e) {
  }
  _init(e) {
    const i = this.system.renderer.particleMaterial;
    Wo.copy(this.system.main.startColor.evaluate(Math.random())), i != null && i.color && (Eb.copy(i.color), Wo.multiply(Eb)), Wo.convertLinearToSRGB(), e.startColor.set(Wo.r, Wo.g, Wo.b, Wo.alpha), e.color.copy(e.startColor), e[Ab] = Math.random();
  }
  update(e, i) {
    if (e.age === 0 && this._init(e), this.system.colorOverLifetime.enabled) {
      const n = e.age / e.life, o = this.system.colorOverLifetime.color.evaluate(n, e[Ab]);
      e.color.set(o.r, o.g, o.b, "alpha" in o ? o.alpha : 1).multiply(e.startColor);
    } else
      e.color.copy(e.startColor);
  }
}
class IT {
  constructor(t) {
    r(this, "system");
    r(this, "emission");
    r(this, "autoDestroy");
    r(this, "startLength");
    /** not used - burst is controled via emissionOverTime */
    r(this, "emissionBursts");
    r(this, "onlyUsedByOther");
    r(this, "behaviors", []);
    r(this, "rendererEmitterSettings", {
      startLength: new SS(220),
      followLocalOrigin: !1
    });
    r(this, "flatWhiteTexture");
    r(this, "clonedTexture", { original: void 0, clone: void 0 });
    this.system = t, this.emission = new CT(this.system);
  }
  get anim() {
    return this.system.textureSheetAnimation;
  }
  get prewarm() {
    return !1;
  }
  // force disable three.quark prewarm, we have our own!
  get material() {
    return this.system.renderer.getMaterial(this.system.trails.enabled);
  }
  get layers() {
    return this.system.gameObject.layers;
  }
  update() {
    this.emission.update();
  }
  get looping() {
    return this.system.main.loop;
  }
  get duration() {
    return this.system.duration;
  }
  get shape() {
    return this.system.shape;
  }
  get startLife() {
    return new td(this.system.main.startLifetime);
  }
  get startSpeed() {
    return new td(this.system.main.startSpeed);
  }
  get startRotation() {
    return new td(this.system.main.startRotation);
  }
  get startSize() {
    return new td(this.system.main.startSize);
  }
  /** start length is for trails */
  get startColor() {
    return new wS(new xS(1, 1, 1, 1));
  }
  get emissionOverTime() {
    return this.emission;
  }
  /** this is not supported yet */
  get emissionOverDistance() {
    return new PT(this.system);
  }
  get instancingGeometry() {
    return this.system.renderer.getMesh(this.system.renderer.renderMode).geometry;
  }
  get renderMode() {
    if (this.system.trails.enabled === !0)
      return fs.Trail;
    switch (this.system.renderer.renderMode) {
      case gs.Billboard:
        return fs.BillBoard;
      case gs.Stretch:
        return fs.StretchedBillBoard;
      case gs.HorizontalBillboard:
        return fs.HorizontalBillBoard;
      case gs.VerticalBillboard:
        return fs.VerticalBillBoard;
      case gs.Mesh:
        return fs.Mesh;
    }
    return fs.BillBoard;
  }
  get speedFactor() {
    var e;
    let t = this.system.main.simulationSpeed;
    return ((e = this.system.renderer) == null ? void 0 : e.renderMode) === gs.Stretch && (t *= this.system.renderer.velocityScale ?? 1), t;
  }
  get texture() {
    const t = this.material;
    if (t && t.map) {
      const e = t.map;
      if (this.clonedTexture.original !== e || !this.clonedTexture.clone) {
        const i = e.clone();
        i.premultiplyAlpha = !1, i.colorSpace = wr, this.clonedTexture.original = e, this.clonedTexture.clone = i;
      }
      return this.clonedTexture.clone;
    }
    return this.flatWhiteTexture || (this.flatWhiteTexture = Ag(new we(1, 1, 1, 1), 1)), this.flatWhiteTexture;
  }
  get startTileIndex() {
    return new ST(this.system);
  }
  get uTileCount() {
    var t;
    return this.anim.enabled ? (t = this.anim) == null ? void 0 : t.numTilesX : void 0;
  }
  get vTileCount() {
    var t;
    return this.anim.enabled ? (t = this.anim) == null ? void 0 : t.numTilesY : void 0;
  }
  get renderOrder() {
    return 1;
  }
  get blending() {
    var t;
    return ((t = this.system.renderer.particleMaterial) == null ? void 0 : t.blending) ?? I1;
  }
  get transparent() {
    return this.system.renderer.transparent;
  }
  get worldSpace() {
    return this.system.main.simulationSpace === $c.World;
  }
}
class DT {
  constructor() {
    r(this, "burstParticleIndex", 0);
    r(this, "burstParticleCount", 0);
    r(this, "isBursting", !1);
    r(this, "travelDistance", 0);
    r(this, "previousWorldPos");
    r(this, "burstIndex", 0);
    r(this, "burstWaveIndex", 0);
    r(this, "time", 0);
    r(this, "waitEmiting", 0);
  }
}
const Rd = class extends I {
  constructor() {
    super(...arguments);
    r(this, "_state");
    r(this, "colorOverLifetime");
    r(this, "main");
    r(this, "emission");
    r(this, "sizeOverLifetime");
    r(this, "shape");
    r(this, "noise");
    r(this, "trails");
    r(this, "velocityOverLifetime");
    r(this, "limitVelocityOverLifetime");
    r(this, "inheritVelocity");
    r(this, "colorBySpeed");
    r(this, "textureSheetAnimation");
    r(this, "rotationOverLifetime");
    r(this, "rotationBySpeed");
    r(this, "sizeBySpeed");
    r(this, "_cameraScale", 1);
    r(this, "__worldQuaternion", new W());
    r(this, "_worldQuaternionInverted", new W());
    r(this, "_worldScale", new v());
    r(this, "_worldPositionFrame", -1);
    r(this, "_worldPos", new v());
    r(this, "_renderer");
    r(this, "_batchSystem");
    r(this, "_particleSystem");
    r(this, "_interface");
    // private _system!: System;
    // private _emitter: Emitter;
    // private _size!: SizeBehaviour;
    r(this, "_container");
    r(this, "_time", 0);
    r(this, "_isPlaying", !0);
    r(this, "_isUsedAsSubsystem", !1);
    r(this, "_didPreWarm", !1);
    r(this, "_bursts");
    r(this, "_subEmitterSystems");
    r(this, "_lastBatchesCount", -1);
  }
  play(t = !1) {
    var e;
    t && S.foreachComponent(this.gameObject, (i) => {
      i instanceof Rd && i !== this && i.play(!1);
    }, !0), this._isPlaying = !0, this._particleSystem && (this._particleSystem.emissionState.time = 0, this._particleSystem.emitEnded = !1), (e = this.emission) == null || e.reset();
  }
  pause(t = !0) {
    t && S.foreachComponent(this.gameObject, (e) => {
      e instanceof Rd && e !== this && e.pause(!1);
    }, !0), this._isPlaying = !1;
  }
  /** clear=true removes all emitted particles */
  stop(t = !0, e = !1) {
    t && S.foreachComponent(this.gameObject, (i) => {
      i instanceof Rd && i !== this && i.stop(!1, e);
    }, !0), this._isPlaying = !1, this._time = 0, e && this.reset();
  }
  /** remove emitted particles and reset time */
  reset() {
    var t;
    this._time = 0, this._particleSystem && (this._particleSystem.particleNum = 0, this._particleSystem.emissionState.time = 0, this._particleSystem.emitEnded = !1, (t = this.emission) == null || t.reset());
  }
  emit(t) {
    if (this._particleSystem) {
      this.onUpdate(), t = Math.min(t, this.maxParticles - this.currentParticles), this._state || (this._state = new DT()), this._state.waitEmiting = t, this._state.time = 0;
      const e = this._particleSystem.emitEnded;
      this._particleSystem.emitEnded = !1, this._particleSystem.emit(this.deltaTime, this._state, this._particleSystem.emitter.matrixWorld), this._particleSystem.emitEnded = e;
    }
  }
  get playOnAwake() {
    return this.main.playOnAwake;
  }
  set playOnAwake(t) {
    this.main.playOnAwake = t;
  }
  get renderer() {
    return this._renderer;
  }
  get isPlaying() {
    return this._isPlaying;
  }
  get currentParticles() {
    var t;
    return ((t = this._particleSystem) == null ? void 0 : t.particleNum) ?? 0;
  }
  get maxParticles() {
    return this.main.maxParticles;
  }
  get time() {
    return this._time;
  }
  get duration() {
    return this.main.duration;
  }
  get deltaTime() {
    return this.context.time.deltaTime * this.main.simulationSpeed;
  }
  get scale() {
    return this.gameObject.scale.x;
  }
  get cameraScale() {
    return this._cameraScale;
  }
  get container() {
    return this._container;
  }
  get worldspace() {
    return this.main.simulationSpace === $c.World;
  }
  get localspace() {
    return this.main.simulationSpace === $c.Local;
  }
  get worldQuaternion() {
    return this.__worldQuaternion;
  }
  get worldQuaternionInverted() {
    return this._worldQuaternionInverted;
  }
  get worldScale() {
    return this._worldScale;
  }
  get worldPos() {
    return this._worldPositionFrame !== this.context.time.frame && (this._worldPositionFrame = this.context.time.frame, ie(this.gameObject, this._worldPos)), this._worldPos;
  }
  get matrixWorld() {
    return this._container.matrixWorld;
  }
  get isSubsystem() {
    return this._isUsedAsSubsystem;
  }
  /** Add a custom quarks behaviour to the particle system.   
   * You can add a quarks.Behaviour type or derive from {@link ParticleSystemBaseBehaviour}  
   * @link https://github.com/Alchemist0823/three.quarks    
   * @example
   * ```typescript
   * class MyBehaviour extends ParticleSystemBaseBehaviour {
   *    initialize(particle: Particle) {
   *       // initialize the particle
   *   }
   *    update(particle: Particle, delta: number) {  
   *        // do something with the particle
   *   }
   * }
   * 
   * const system = gameObject.getComponent(ParticleSystem);
   * system.addBehaviour(new MyBehaviour());
   * ```
  */
  addBehaviour(t) {
    return this._particleSystem ? (t instanceof Fr && (t.system = this), to && console.debug("Add custom ParticleSystem Behaviour", t), this._particleSystem.addBehavior(t), !0) : !1;
  }
  /** Remove a custom quarks behaviour from the particle system. **/
  removeBehaviour(t) {
    if (!this._particleSystem)
      return !1;
    const e = this._particleSystem.behaviors, i = e.indexOf(t);
    return i !== -1 && ((z() || to) && console.debug("Remove custom ParticleSystem Behaviour", i, t), e.splice(i, 1)), !0;
  }
  /** Removes all behaviours from the particle system  
   * **Note:** this will also remove the default behaviours like SizeBehaviour, ColorBehaviour etc.
   */
  removeAllBehaviours() {
    return this._particleSystem ? (this._particleSystem.behaviors.length = 0, !0) : !1;
  }
  /** Get the underlying three.quarks particle system behaviours. This can be used to fully customize the behaviour of the particles. */
  get behaviours() {
    return this._particleSystem ? this._particleSystem.behaviors : null;
  }
  /** Get access to the underlying quarks particle system if you need more control  
   * @link https://github.com/Alchemist0823/three.quarks
   */
  get particleSystem() {
    return this._particleSystem ?? null;
  }
  /** called from deserialization */
  set bursts(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      if (!(i instanceof Wm)) {
        const n = new Wm();
        $a(n, i), t[e] = n;
      }
    }
    this._bursts = t;
  }
  /** called from deserialization */
  set subEmitterSystems(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      if (!(i instanceof Gm)) {
        const n = new Gm();
        $a(n, i), t[e] = n;
      }
    }
    to && t.length > 0 && console.log("SubEmitters: ", t, this), this._subEmitterSystems = t;
  }
  /** @internal */
  onAfterDeserialize(t) {
    if (this._subEmitterSystems && Array.isArray(this._subEmitterSystems))
      for (const e of this._subEmitterSystems)
        e._deserialize(this.context, this.gameObject);
  }
  /** @internal */
  awake() {
    if (this._worldPositionFrame = -1, this._renderer = this.gameObject.getComponent(Pn), !this.main)
      throw new Error("Not Supported: ParticleSystem needs a serialized MainModule. Creating new particle systems at runtime is currently not supported.");
    this._container = new L(), this._container.matrixAutoUpdate = !1, this.context.scene.add(this._container), this._batchSystem = new bS(), this._batchSystem.name = this.gameObject.name, this._container.add(this._batchSystem), this._interface = new IT(this), this._particleSystem = new vS(this._interface), this._particleSystem.addBehavior(new kT(this)), this._particleSystem.addBehavior(new ET(this)), this._particleSystem.addBehavior(new OT(this)), this._particleSystem.addBehavior(new MT(this)), this._particleSystem.addBehavior(new AT(this)), this._particleSystem.addBehavior(new TT(this)), this._batchSystem.addSystem(this._particleSystem);
    const t = this._particleSystem.emitter;
    this.context.scene.add(t), this.inheritVelocity.system && this.inheritVelocity.system !== this && (this.inheritVelocity = this.inheritVelocity.clone()), this.inheritVelocity.awake(this), to && (console.log(this), this.gameObject.add(new Oi(1)));
  }
  /** @internal */
  start() {
    this.addSubParticleSystems(), this.updateLayers(), this.renderer.particleMesh instanceof q && this._interface.renderMode == fs.Mesh && Ze.assignMeshLOD(this.renderer.particleMesh, 0).then((t) => {
      t && this.particleSystem && this._interface.renderMode == fs.Mesh && (this.particleSystem.instancingGeometry = t);
    });
  }
  /** @internal */
  onDestroy() {
    var t, e, i, n;
    (t = this._container) == null || t.removeFromParent(), (e = this._batchSystem) == null || e.removeFromParent(), (i = this._particleSystem) == null || i.emitter.removeFromParent(), (n = this._particleSystem) == null || n.dispose();
  }
  /** @internal */
  onEnable() {
    this.main && (this.inheritVelocity && (this.inheritVelocity.system = this), this._batchSystem && (this._batchSystem.visible = !0), this.playOnAwake && this.play(), this._isPlaying = this.playOnAwake);
  }
  onDisable() {
    this._batchSystem && (this._batchSystem.visible = !1);
  }
  /** @internal */
  onBeforeRender() {
    var t;
    this.main && (this._didPreWarm === !1 && ((t = this.main) == null ? void 0 : t.prewarm) === !0 && (this._didPreWarm = !0, this.preWarm()), this.onUpdate(), this.onSimulate(this.deltaTime));
  }
  preWarm() {
    var h;
    if (!((h = this.emission) != null && h.enabled) || this.emission.rateOverTime.getMax() <= 0)
      return;
    const e = 1 / 60, i = this.main.duration, n = this.main.startLifetime.getMax(), o = 1e3, a = Math.min(Math.max(i, n) / Math.max(0.01, this.main.simulationSpeed), o), l = Math.ceil(a / e), c = Date.now();
    to && console.log(`Particles ${this.name} - Prewarm for ${l} frames (${a} sec). Duration: ${i}, Lifetime: ${n}`);
    for (let d = 0; d < l && !(this.currentParticles >= this.maxParticles); d++) {
      const u = Date.now() - c;
      if (u > 2e3) {
        console.warn(`Particles ${this.name} - Prewarm took too long. Aborting: ${u}`);
        break;
      }
      this.onUpdate(), this.onSimulate(e);
    }
  }
  onSimulate(t) {
    if (this._batchSystem) {
      let e = this.context.time.frameCount % 60 === 0;
      this._lastBatchesCount !== this._batchSystem.batches.length && (this._lastBatchesCount = this._batchSystem.batches.length, e = !0), e && this.updateLayers(), this._batchSystem.update(t);
    }
    this._time += t, this._time > this.duration && (this._time = 0);
  }
  updateLayers() {
    if (this._batchSystem)
      for (let t = 0; t < this._batchSystem.batches.length; t++) {
        const e = this._batchSystem.batches[t];
        e.layers.disableAll();
        const i = this.layer;
        e.layers.mask = 1 << i;
      }
  }
  // private lastMaterialVersion: number = -1;
  onUpdate() {
    var n, o;
    if (this._bursts && (this.emission.bursts = this._bursts, delete this._bursts), !this._isPlaying)
      return;
    const t = this.context.mainCamera;
    if (t) {
      const a = Ke(t);
      this._cameraScale = a.x;
    }
    const e = !this.worldspace, i = this.gameObject;
    if (Ce(i, this.__worldQuaternion), this._worldQuaternionInverted.copy(this.__worldQuaternion).invert(), Ke(this.gameObject, this._worldScale), e && this._container && ((n = this.gameObject) != null && n.parent)) {
      const a = Uw(this, Hm);
      this._container.matrix.makeScale(a.x, a.y, a.z), this._container.matrix.makeRotationFromQuaternion(this.__worldQuaternion), this._container.matrix.setPosition(this.worldPos), this._container.matrix.scale(this.gameObject.scale);
    }
    this.emission.system = this, this._interface.update(), this.shape.onUpdate(this, this.context, this.main.simulationSpace, this.gameObject), this.noise.update(this.context), (o = this.inheritVelocity) == null || o.update(this.context), this.velocityOverLifetime.update(this);
  }
  addSubParticleSystems() {
    var t;
    if (this._subEmitterSystems && this._particleSystem)
      for (const e of this._subEmitterSystems) {
        e.particleSystem && (e.particleSystem.__internalAwake ? e.particleSystem.__internalAwake() : z() && console.warn("SubParticleSystem serialization issue(?)", e.particleSystem, e));
        const i = (t = e.particleSystem) == null ? void 0 : t._particleSystem;
        if (i) {
          e.particleSystem._isUsedAsSubsystem = !0;
          const n = new zw(this, this._particleSystem, e.particleSystem, i);
          n.emitterType = e.type, n.emitterProbability = e.emitProbability, this._particleSystem.addBehavior(n);
        } else
          to && console.warn("Could not add SubParticleSystem", e, this);
      }
  }
};
let ut = Rd;
He([
  f(l_)
], ut.prototype, "colorOverLifetime", 2);
He([
  f(oi)
], ut.prototype, "main", 2);
He([
  f(Eo)
], ut.prototype, "emission", 2);
He([
  f(fl)
], ut.prototype, "sizeOverLifetime", 2);
He([
  f(tt)
], ut.prototype, "shape", 2);
He([
  f(Oe)
], ut.prototype, "noise", 2);
He([
  f(Xe)
], ut.prototype, "trails", 2);
He([
  f(it)
], ut.prototype, "velocityOverLifetime", 2);
He([
  f(xt)
], ut.prototype, "limitVelocityOverLifetime", 2);
He([
  f(pl)
], ut.prototype, "inheritVelocity", 2);
He([
  f(yh)
], ut.prototype, "colorBySpeed", 2);
He([
  f(ri)
], ut.prototype, "textureSheetAnimation", 2);
He([
  f(Jn)
], ut.prototype, "rotationOverLifetime", 2);
He([
  f(Cn)
], ut.prototype, "rotationBySpeed", 2);
He([
  f(ji)
], ut.prototype, "sizeBySpeed", 2);
class Gm {
  constructor() {
    r(this, "particleSystem");
    r(this, "emitProbability", 1);
    r(this, "properties");
    r(this, "type");
  }
  _deserialize(t, e) {
    const i = this.particleSystem;
    if (i instanceof ut)
      return;
    let n = "";
    i && typeof i.guid == "string" && (n = i.guid, this.particleSystem = S.findByGuid(n, e)), to && !(this.particleSystem instanceof ut) && console.warn("Could not find particle system for sub emitter", n, e, this);
  }
}
function Uw(s, t) {
  if (t.set(1, 1, 1), s.gameObject.parent && s.localspace)
    switch (s.main.scalingMode) {
      case $m.Local:
        t = Ke(s.gameObject.parent, t), t.x = 1 / t.x, t.y = 1 / t.y, t.z = 1 / t.z;
        break;
      default:
        if (!s.unsupported_scaling_mode) {
          s.unsupported_scaling_mode = !0;
          const e = "ParticleSystem scale mode " + $m[s.main.scalingMode] + " is not supported";
          z() && ve(e), console.warn(e, s.name, s);
        }
        t = Ke(s.gameObject, t);
        break;
    }
  return t;
}
class Wc extends I {
  constructor() {
    super(...arguments);
    r(this, "_didAssignPlayerColor", !1);
    r(this, "tryAssignColor", () => {
      const e = S.getComponentInParent(this.gameObject, Ji);
      if (e && e.owner)
        return this._didAssignPlayerColor = !0, this.assignUserColor(e.owner), !0;
      const i = S.getComponentInParent(this.gameObject, _t);
      return i != null && i.connectionId ? (this._didAssignPlayerColor = !0, this.assignUserColor(i.connectionId), !0) : !1;
    });
  }
  onEnable() {
    this.context.connection.beginListen(ne.JoinedRoom, this.tryAssignColor), this._didAssignPlayerColor || this.startCoroutine(this.waitForConnection());
  }
  onDisable() {
    this.context.connection.stopListen(ne.JoinedRoom, this.tryAssignColor);
  }
  *waitForConnection() {
    for (; !this.destroyed && this.activeAndEnabled && (yield Sv(0.2), !this.tryAssignColor()); )
      ;
  }
  assignUserColor(e) {
    const i = Wc.hashCode(e), n = Wc.colorFromHashCode(i);
    if (this.gameObject.type === "Mesh") {
      const o = this.gameObject;
      this.assignColor(n, e, o);
    } else if (this.gameObject.children)
      for (const o of this.gameObject.children) {
        const a = o;
        a.material && a.material.color && this.assignColor(n, e, a);
      }
  }
  assignColor(e, i, n) {
    let o = n.material;
    o && (o._playerMaterial !== i && (o = o.clone(), o._playerMaterial = i, n.material = o), o.color = e);
  }
  static hashCode(e) {
    var i = 0, n, o;
    if (e.length === 0)
      return i;
    for (n = 0; n < e.length; n++)
      o = e.charCodeAt(n), i = (i << 5) - i + o, i |= 0;
    return i;
  }
  static colorFromHashCode(e) {
    const i = (e & 16711680) >> 16, n = (e & 65280) >> 8, o = e & 255;
    return new ae(i / 255, n / 255, o / 255);
  }
}
const LT = x("debugpost");
let qm = null;
function jT(s) {
  qm = s;
}
function Nw(s) {
  let t = s.gameObject;
  for (; t; ) {
    for (const e of Tg(t))
      if (e.isPostProcessingManager === !0)
        return e;
    t = t.parent;
  }
  return null;
}
function BT(s) {
  let t = Nw(s);
  if (!t)
    if (qm) {
      LT && console.warn("Adding postprocessing manager to the scene.");
      const e = s.scene;
      t = en(e, qm);
    } else
      z() && console.warn("No post processing manager found");
  return t;
}
var FT = Object.defineProperty, zT = Object.getOwnPropertyDescriptor, $w = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? zT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && FT(t, e, n), n;
};
const UT = x("debugpost");
class N {
  constructor(t) {
    r(this, "isVolumeParameter", !0);
    r(this, "_isInitialized", !1);
    r(this, "_active", !0);
    r(this, "_value");
    r(this, "_valueRaw");
    r(this, "_defaultValue");
    /** called to modify a changing value before it is saved */
    r(this, "valueProcessor");
    /** called when a value has changed (with the final value) */
    r(this, "onValueChanged");
    t !== void 0 && this.initialize(t);
  }
  get isInitialized() {
    return this._isInitialized;
  }
  initialize(t) {
    t !== void 0 && (this._value = t, this._defaultValue = t, this._valueRaw = t, this._isInitialized = !0);
  }
  get overrideState() {
    return this._active;
  }
  set overrideState(t) {
    if (this._active === t)
      return;
    this._active = t;
    const e = t ? this._valueRaw : this._defaultValue;
    this.processValue(e, !0);
  }
  get value() {
    return this._valueRaw;
  }
  set value(t) {
    this.isInitialized || this.initialize(t), this.processValue(t, !1);
  }
  set defaultValue(t) {
    this._defaultValue = t;
  }
  /** enforce the value to be set and onValueChanged to be called if assigned */
  __init() {
    this.processValue(this._valueRaw, !0);
  }
  processValue(t, e) {
    if (t == null || !e && this.testIfValueChanged(t) === !1)
      return;
    const i = this._value;
    UT && typeof i == "number" && typeof t == "number" && (i == null || i.toFixed(4), t == null || t.toFixed(4)), !this._active && this._defaultValue !== void 0 ? (this._value = this._defaultValue, t = this._defaultValue, this._valueRaw = t) : (this._valueRaw = t, this._active && this.valueProcessor && (t = this.valueProcessor(t)), this._value = t), this.onValueChanged && this.onValueChanged(t, i, this);
  }
  testIfValueChanged(t) {
    return this._valueRaw !== t;
  }
}
$w([
  f()
], N.prototype, "overrideState", 1);
$w([
  f()
], N.prototype, "value", 1);
class NT extends rn {
  constructor() {
    super([N]);
  }
  onSerialize(t, e) {
  }
  onDeserialize(t, e) {
    const i = e.target, n = e.path;
    let o;
    if (i && n && (o = i[n]), (typeof o != "object" || typeof o == "object" && o.isVolumeParameter !== !0) && (o = new N()), typeof t == "object" && "value" in t) {
      const a = t.value;
      o.initialize(a), o.overrideState = t.overrideState;
    } else
      o.value = t;
    return o;
  }
}
new NT();
var $T = Object.defineProperty, WT = Object.getOwnPropertyDescriptor, VT = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? WT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && $T(t, e, n), n;
};
const Pp = x("debugpost");
class dt extends I {
  constructor(e = void 0) {
    super();
    r(this, "active", !0);
    r(this, "_manager", null);
    /** previously created effect (if any) */
    r(this, "_result");
    r(this, "_postprocessingContext", null);
    if (e)
      for (const i of Object.keys(e)) {
        const n = e[i], o = this[i];
        o instanceof N ? o.initialize(n) : o !== void 0 && (this[i] = n);
      }
  }
  get isPostProcessingEffect() {
    return !0;
  }
  onEnable() {
    super.onEnable(), Pp && console.warn("onEnable effect", this, this.__internalDidAwakeAndStart), this.__internalDidAwakeAndStart && (this.active = !0), this.onEffectEnabled();
  }
  onDisable() {
    var e;
    super.onDisable(), Pp && console.warn("onDisable effect", this), (e = this._manager) == null || e.removeEffect(this), this.active = !1;
  }
  onEffectEnabled(e) {
    var i;
    e && e.isPostProcessingManager === !0 ? this._manager = e : this._manager || (this._manager = BT(this)), (i = this._manager) == null || i.addEffect(this);
  }
  /** override to initialize bindings on parameters */
  init() {
  }
  get postprocessingContext() {
    return this._postprocessingContext;
  }
  /** Apply post settings. Make sure to call super.apply() if you also create an effect */
  apply(e) {
    var i;
    return this._postprocessingContext = e, this._result || (this.initParameters(), this._result = (i = this.onCreateEffect) == null ? void 0 : i.call(this)), this._result && this.initParameters(), this._result;
  }
  /** Reset previously set values (e.g. when adjusting settings on the renderer like Tonemapping) */
  unapply() {
  }
  dispose() {
    Pp && console.warn("DISPOSE", this), this._result && (Array.isArray(this._result) ? this._result.forEach((e) => e.dispose()) : this._result.dispose()), this._result = void 0;
  }
  initParameters() {
    const e = Object.keys(this);
    for (const i of e) {
      const n = this[i];
      n instanceof N && n.__init();
    }
  }
  // TODO this is currently not used for post processing effects that are part of Volume stacks,
  // since these handle that already.
  onEditorModification(e) {
    const i = e.propertyName;
    if (this[i] instanceof N) {
      const n = e.value;
      return this[i].value = n, !0;
    }
  }
}
VT([
  f()
], dt.prototype, "active", 2);
var HT = Object.defineProperty, GT = Object.getOwnPropertyDescriptor, qT = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? GT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && HT(t, e, n), n;
};
const XT = x("debugpost"), Xm = {};
function On(s, t) {
  Xm[s] = t;
}
function QT(s) {
  return s.__type in Xm ? Xm[s.__type] : (XT && s.__type && console.warn("Unknown postprocessing type", s.__type, s), dt);
}
class h_ {
  constructor() {
    r(this, "components", []);
  }
  /**
   * call init on all components 
   * @hidden
   **/
  __init(t) {
    var e;
    (e = this.components) == null || e.forEach((i) => {
      i.gameObject === void 0 && t.gameObject.addComponent(i), i.init();
    });
  }
  addEffect(t) {
    this.components.push(t);
  }
  removeEffect(t) {
    const e = this.components.indexOf(t);
    e >= 0 && this.components.splice(e, 1);
  }
}
qT([
  Ka([(s) => QT(s), dt])
], h_.prototype, "components", 2);
var YT = Object.defineProperty, KT = Object.getOwnPropertyDescriptor, ZT = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? KT(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && YT(t, e, n), n;
};
class af extends dt {
  constructor() {
    super(...arguments);
    r(this, "preset", new N(2));
  }
  get typeName() {
    return "Antialiasing";
  }
  // 2 is HIGH: https://github.com/pmndrs/postprocessing/blob/main/src/enums/SMAAPreset.js#L14
  onCreateEffect() {
    const e = new D.POSTPROCESSING.MODULE.SMAAEffect({
      preset: D.POSTPROCESSING.MODULE.SMAAPreset.HIGH,
      edgeDetectionMode: D.POSTPROCESSING.MODULE.EdgeDetectionMode.DEPTH
    });
    return this.preset.onValueChanged = (i) => {
      e.applyPreset(i);
    }, e;
  }
}
ZT([
  f(N)
], af.prototype, "preset", 2);
On("Antialiasing", af);
var JT = Object.defineProperty, eA = Object.getOwnPropertyDescriptor, d_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? eA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && JT(t, e, n), n;
}, $p;
const Ww = ($p = class extends dt {
  constructor() {
    super(...arguments);
    r(this, "threshold", new N(0.9));
    r(this, "intensity", new N(1));
    r(this, "scatter", new N(0.3));
    /**
     * Set to true to use selective bloom when the effect gets created.
     * @default false
     */
    r(this, "selectiveBloom");
  }
  get typeName() {
    return "Bloom";
  }
  init() {
    this.threshold.valueProcessor = (t) => t, this.intensity.valueProcessor = (t) => t, this.scatter.valueProcessor = (t) => t;
  }
  onCreateEffect() {
    let t;
    if (this.selectiveBloom == null && (this.selectiveBloom = Ww.useSelectiveBloom), this.selectiveBloom) {
      const e = t = new D.POSTPROCESSING.MODULE.SelectiveBloomEffect(this.context.scene, this.context.mainCamera, {
        blendFunction: D.POSTPROCESSING.MODULE.BlendFunction.ADD,
        mipmapBlur: !0,
        luminanceThreshold: this.threshold.value,
        luminanceSmoothing: this.scatter.value,
        radius: 0.85,
        // default value
        intensity: this.intensity.value
      });
      e.inverted = !0;
    } else
      t = new D.POSTPROCESSING.MODULE.BloomEffect({
        blendFunction: D.POSTPROCESSING.MODULE.BlendFunction.ADD,
        mipmapBlur: !0,
        luminanceThreshold: this.threshold.value,
        luminanceSmoothing: this.scatter.value,
        radius: 0.85,
        // default value
        intensity: this.intensity.value
      });
    return this.intensity.onValueChanged = (e) => {
      t.intensity = e;
    }, this.threshold.onValueChanged = (e) => {
      t.luminanceMaterial.threshold = Math.pow(e, 2.2);
    }, this.scatter.onValueChanged = (e) => {
      t.luminancePass.enabled = !0, t.luminanceMaterial.smoothing = e, t.mipmapBlurPass && (t.mipmapBlurPass.radius = Cs.lerp(0.1, 0.9, e));
    }, t;
  }
}, /** Whether to use selective bloom by default */
r($p, "useSelectiveBloom", !1), $p);
let ml = Ww;
d_([
  f(N)
], ml.prototype, "threshold", 2);
d_([
  f(N)
], ml.prototype, "intensity", 2);
d_([
  f(N)
], ml.prototype, "scatter", 2);
On("Bloom", ml);
var tA = Object.defineProperty, iA = Object.getOwnPropertyDescriptor, nA = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? iA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && tA(t, e, n), n;
};
class lf extends dt {
  constructor() {
    super(...arguments);
    r(this, "intensity", new N(0));
  }
  get typeName() {
    return "ChromaticAberration";
  }
  onCreateEffect() {
    const e = new D.POSTPROCESSING.MODULE.ChromaticAberrationEffect();
    return e.offset = new oe(0, 0), e.radialModulation = !0, e.modulationOffset = 0.15, this.intensity.valueProcessor = (i) => i * 0.02, this.intensity.onValueChanged = (i) => {
      e.offset.x = -i, e.offset.y = i;
    }, e;
  }
}
nA([
  f(N)
], lf.prototype, "intensity", 2);
On("ChromaticAberration", lf);
var sA = Object.defineProperty, oA = Object.getOwnPropertyDescriptor, Vw = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? oA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && sA(t, e, n), n;
};
const Ib = x("debugpost");
var kd = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Neutral = 1] = "Neutral", s[s.ACES = 2] = "ACES", s[s.AgX = 3] = "AgX", s[s.KhronosNeutral = 4] = "KhronosNeutral", s))(kd || {});
function Op(s) {
  switch (s) {
    case 0:
      return Ou;
    case 1:
      return cg;
    case 2:
      return lg;
    case 3:
      return Pu;
    case 4:
      return Ec;
    default:
      return Ec;
  }
}
function rA(s) {
  switch (s) {
    case Ou:
      return 0;
    case lg:
      return 2;
    case Pu:
      return 3;
    case Ec:
      return 1;
    case cg:
      return 1;
    default:
      return 0;
  }
}
function Db(s) {
  switch (s) {
    case Ou:
      return D.POSTPROCESSING.MODULE.ToneMappingMode.LINEAR;
    case lg:
      return D.POSTPROCESSING.MODULE.ToneMappingMode.ACES_FILMIC;
    case Pu:
      return D.POSTPROCESSING.MODULE.ToneMappingMode.AGX;
    case Ec:
      return D.POSTPROCESSING.MODULE.ToneMappingMode.NEUTRAL;
    case cg:
      return D.POSTPROCESSING.MODULE.ToneMappingMode.REINHARD;
    default:
      return D.POSTPROCESSING.MODULE.ToneMappingMode.LINEAR;
  }
}
const Hw = class extends dt {
  constructor() {
    super(...arguments);
    r(this, "mode", new N(void 0));
    r(this, "exposure", new N(1));
  }
  get typeName() {
    return "ToneMapping";
  }
  /** Set the tonemapping mode to e.g. "agx" */
  setMode(t) {
    const e = kd[t];
    return e === void 0 ? (console.error("Invalid ToneMapping mode", t), this) : (this.mode.value = e, this);
  }
  get isToneMapping() {
    return !0;
  }
  onEffectEnabled() {
    const t = Nw(this);
    t && super.onEffectEnabled(t);
  }
  onCreateEffect() {
    if (this.postprocessingContext)
      for (const i of this.postprocessingContext.components) {
        if (i === this)
          break;
        if (i != this && i instanceof Hw) {
          console.warn("Multiple tonemapping effects found in the same postprocessing stack: Please check your scene setup.", { activeEffect: i, ignoredEffect: this });
          return;
        }
      }
    if (this.mode.isInitialized == !1) {
      const i = rA(this.context.renderer.toneMapping);
      this.mode.initialize(i);
    }
    const t = Op(this.mode.value), e = new D.POSTPROCESSING.MODULE.ToneMappingEffect({
      mode: Db(t)
    });
    return this.mode.onValueChanged = (i) => {
      const n = Op(i);
      e.mode = Db(n), Ib && console.log("ToneMapping mode changed to", kd[i], n, e.mode);
    }, Ib && console.log("Use ToneMapping", kd[this.mode.value], t, e.mode, "renderer.tonemapping: " + this.context.renderer.toneMapping), this.exposure.onValueChanged = (i) => {
      this.context.renderer.toneMappingExposure = i;
    }, e;
  }
  onBeforeRender() {
    this.mode.overrideState && (this.context.renderer.toneMapping = Op(this.mode.value)), this.exposure.overrideState && this.exposure.value !== void 0 && (this.context.renderer.toneMappingExposure = this.exposure.value);
  }
};
let Mr = Hw;
Vw([
  f(N)
], Mr.prototype, "mode", 2);
Vw([
  f(N)
], Mr.prototype, "exposure", 2);
On("Tonemapping", Mr);
var aA = Object.defineProperty, lA = Object.getOwnPropertyDescriptor, cf = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? lA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && aA(t, e, n), n;
};
class zr extends dt {
  constructor() {
    super(...arguments);
    r(this, "postExposure", new N(0));
    r(this, "contrast", new N(0));
    r(this, "hueShift", new N(0));
    r(this, "saturation", new N(0));
  }
  get typeName() {
    return "ColorAdjustments";
  }
  init() {
    this.postExposure.valueProcessor = (e) => (e = Math.pow(2, e), e), this.contrast.valueProcessor = (e) => {
      let i = 1;
      return e > 0 ? i = 200 : e < 0 && (i = 100), e / i;
    }, this.contrast.defaultValue = 0, this.hueShift.valueProcessor = (e) => Math.PI * e / 180, this.hueShift.defaultValue = 0, this.saturation.valueProcessor = (e) => e < 0 ? e / 100 : e / (100 * Math.PI), this.saturation.defaultValue = 0;
  }
  onCreateEffect() {
    var a, l;
    const e = [];
    this.context.renderer.toneMapping !== ja && this.postExposure.overrideState && (this.context.renderer.toneMapping = ja);
    let i = (a = this.postprocessingContext) == null ? void 0 : a.components.find((c) => c instanceof Mr);
    i || (i = new Mr(), (l = this.postprocessingContext) == null || l.components.push(i)), this.postExposure.onValueChanged = (c) => {
      this.postExposure.overrideState && (i.exposure.value = c);
    };
    const n = new D.POSTPROCESSING.MODULE.BrightnessContrastEffect();
    this.contrast.onValueChanged = (c) => n.contrast = c;
    const o = new D.POSTPROCESSING.MODULE.HueSaturationEffect();
    return e.push(n), e.push(o), this.hueShift.onValueChanged = (c) => o.hue = c, this.saturation.onValueChanged = (c) => o.saturation = c, e;
  }
}
cf([
  f(N)
], zr.prototype, "postExposure", 2);
cf([
  f(N)
], zr.prototype, "contrast", 2);
cf([
  f(N)
], zr.prototype, "hueShift", 2);
cf([
  f(N)
], zr.prototype, "saturation", 2);
On("ColorAdjustments", zr);
var cA = Object.defineProperty, hA = Object.getOwnPropertyDescriptor, Ur = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? hA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && cA(t, e, n), n;
};
const dA = x("debugpost");
class es extends dt {
  constructor() {
    super(...arguments);
    r(this, "mode");
    r(this, "focusDistance", new N(1));
    r(this, "focalLength", new N(0.2));
    r(this, "aperture", new N(20));
    r(this, "gaussianMaxRadius", new N());
    r(this, "resolutionScale", new N(1 * 1 / window.devicePixelRatio));
    r(this, "bokehScale", new N());
  }
  get typeName() {
    return "DepthOfField";
  }
  init() {
    this.focalLength.valueProcessor = (i) => {
      const n = i / 300, o = 2;
      return $.lerp(o, 0.01, n);
    };
    const e = 20;
    this.aperture.valueProcessor = (i) => {
      const n = 1 - i / 32;
      return $.lerp(1, e, n);
    };
  }
  onCreateEffect() {
    if (this.mode === 0) {
      dA && console.warn("DepthOfField: Mode is set to Off");
      return;
    }
    const e = new D.POSTPROCESSING.MODULE.DepthOfFieldEffect(this.context.mainCamera, {
      worldFocusRange: 0.2,
      focalLength: 1,
      bokehScale: 20,
      resolutionScale: this.resolutionScale.value
    });
    return this.focusDistance.onValueChanged = (i) => {
      e.cocMaterial.worldFocusDistance = i;
    }, this.focalLength.onValueChanged = (i) => e.cocMaterial.worldFocusRange = i, this.aperture.onValueChanged = (i) => e.bokehScale = i, this.resolutionScale && (this.resolutionScale.onValueChanged = (i) => e.resolution.scale = i), [e];
  }
  unapply() {
  }
}
Ur([
  f()
], es.prototype, "mode", 2);
Ur([
  f(N)
], es.prototype, "focusDistance", 2);
Ur([
  f(N)
], es.prototype, "focalLength", 2);
Ur([
  f(N)
], es.prototype, "aperture", 2);
Ur([
  f(N)
], es.prototype, "gaussianMaxRadius", 2);
Ur([
  f(N)
], es.prototype, "resolutionScale", 2);
Ur([
  f(N)
], es.prototype, "bokehScale", 2);
On("DepthOfField", es);
class nu extends dt {
  constructor(e) {
    super();
    r(this, "effect");
    this.effect = e;
  }
  get typeName() {
    return this.effect.constructor.name;
  }
  onCreateEffect() {
    return this.effect;
  }
}
var uA = Object.defineProperty, fA = Object.getOwnPropertyDescriptor, pA = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? fA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && uA(t, e, n), n;
};
class hf extends dt {
  constructor() {
    super(...arguments);
    r(this, "granularity", new N(10));
  }
  get typeName() {
    return "PixelationEffect";
  }
  onCreateEffect() {
    const e = new D.POSTPROCESSING.MODULE.PixelationEffect();
    return this.granularity.onValueChanged = (i) => {
      e.granularity = i;
    }, e;
  }
}
pA([
  f(N)
], hf.prototype, "granularity", 2);
On("PixelationEffect", hf);
var mA = Object.defineProperty, gA = Object.getOwnPropertyDescriptor, bh = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? gA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && mA(t, e, n), n;
};
class Io extends dt {
  constructor() {
    super(...arguments);
    r(this, "intensity", new N(2));
    r(this, "falloff", new N(1));
    r(this, "samples", new N(9));
    r(this, "color", new N(new ae(0, 0, 0)));
    r(this, "luminanceInfluence", new N(0.7));
    r(this, "_ssao");
  }
  get typeName() {
    return "ScreenSpaceAmbientOcclusion";
  }
  onBeforeRender() {
    if (this._ssao && this.context.mainCamera instanceof ye) {
      const e = this.context.mainCamera.far - this.context.mainCamera.near;
      this._ssao.ssaoMaterial.worldDistanceFalloff = e * 0.01, this._ssao.ssaoMaterial.worldDistanceThreshold = this.context.mainCamera.far;
    }
  }
  onCreateEffect() {
    const e = this.context.mainCamera, i = new D.POSTPROCESSING.MODULE.NormalPass(this.context.scene, e), n = new D.POSTPROCESSING.MODULE.DepthDownsamplingPass({
      normalBuffer: i.texture,
      resolutionScale: 0.5
    }), o = this._ssao = new D.POSTPROCESSING.MODULE.SSAOEffect(e, i.texture, {
      normalDepthBuffer: n.texture,
      worldDistanceThreshold: 1,
      // when it starts to fade out
      worldDistanceFalloff: 1,
      // smoothness of cutoff
      worldProximityThreshold: 0.1,
      worldProximityFalloff: 2,
      intensity: 1,
      blendFunction: D.POSTPROCESSING.MODULE.BlendFunction.MULTIPLY,
      luminanceInfluence: 0.5
    });
    this.intensity.onValueChanged = (l) => {
      o.intensity = l;
    }, this.falloff.onValueChanged = (l) => {
      o.ssaoMaterial.radius = l * 0.1;
    }, this.samples.onValueChanged = (l) => {
      o.ssaoMaterial.samples = l;
    }, this.color.onValueChanged = (l) => {
      o.color || (o.color = new ae()), o.color.copy(l);
    }, this.luminanceInfluence.onValueChanged = (l) => {
      o.luminanceInfluence = l;
    };
    const a = new Array();
    return a.push(i), a.push(n), a.push(o), a;
  }
}
bh([
  f(N)
], Io.prototype, "intensity", 2);
bh([
  f(N)
], Io.prototype, "falloff", 2);
bh([
  f(N)
], Io.prototype, "samples", 2);
bh([
  f(N)
], Io.prototype, "color", 2);
bh([
  f(N)
], Io.prototype, "luminanceInfluence", 2);
On("ScreenSpaceAmbientOcclusion", Io);
var _A = Object.defineProperty, yA = Object.getOwnPropertyDescriptor, Nr = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? yA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && _A(t, e, n), n;
};
const bA = x("debugN8AO");
var Qm = /* @__PURE__ */ ((s) => (s[s.Performance = 0] = "Performance", s[s.Low = 1] = "Low", s[s.Medium = 2] = "Medium", s[s.High = 3] = "High", s[s.Ultra = 4] = "Ultra", s))(Qm || {});
class ts extends dt {
  constructor() {
    super(...arguments);
    r(this, "gammaCorrection", !0);
    r(this, "aoRadius", new N(1));
    r(this, "falloff", new N(1));
    r(this, "intensity", new N(1));
    r(this, "color", new N(new ae(0, 0, 0)));
    r(this, "screenspaceRadius", !1);
    r(this, "quality", 2);
    r(this, "_ssao");
  }
  get typeName() {
    return "ScreenSpaceAmbientOcclusionN8";
  }
  get pass() {
    return this._ssao;
  }
  onValidate() {
    this._ssao && (this._ssao.setQualityMode(Qm[this.quality]), this._ssao.configuration.gammaCorrection = this.gammaCorrection, this._ssao.configuration.screenSpaceRadius = this.screenspaceRadius);
  }
  onCreateEffect() {
    const e = this.context.mainCamera, i = this.context.domWidth, n = this.context.domHeight, o = this._ssao = new D.POSTPROCESSING_AO.MODULE.N8AOPostPass(
      this.context.scene,
      e,
      i,
      n
    ), a = Qm[this.quality];
    o.setQualityMode(a), o.configuration.transparencyAware = !1;
    const l = new ks(i, n);
    return o.configuration.beautyRenderTarget = l, o.configuration.autoRenderBeauty = !1, o.configuration.gammaCorrection = this.gammaCorrection, o.configuration.screenSpaceRadius = this.screenspaceRadius, bA && (o.enableDebugMode(), console.log(o), setInterval(() => {
      console.log("SSAO", o.lastTime);
    }, 1e3), setInterval(() => {
      console.log("SSAO", o.enabled, { ssao: o, autoRenderBeauty: o.configuration.autoRenderBeauty });
    }, 4e3)), this.intensity.onValueChanged = (c) => {
      o.configuration.intensity = c;
    }, this.falloff.onValueChanged = (c) => {
      o.configuration.distanceFalloff = c;
    }, this.aoRadius.onValueChanged = (c) => {
      o.configuration.aoRadius = c;
    }, this.color.onValueChanged = (c) => {
      o.color || (o.color = new ae()), o.configuration.color.copy(c);
    }, o;
  }
}
Nr([
  Nt(),
  f()
], ts.prototype, "gammaCorrection", 2);
Nr([
  f(N)
], ts.prototype, "aoRadius", 2);
Nr([
  f(N)
], ts.prototype, "falloff", 2);
Nr([
  f(N)
], ts.prototype, "intensity", 2);
Nr([
  f(N)
], ts.prototype, "color", 2);
Nr([
  Nt(),
  f()
], ts.prototype, "screenspaceRadius", 2);
Nr([
  Nt(),
  f()
], ts.prototype, "quality", 2);
On("ScreenSpaceAmbientOcclusionN8", ts);
var vA = Object.defineProperty, wA = Object.getOwnPropertyDescriptor, Gw = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? wA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && vA(t, e, n), n;
};
class df extends dt {
  constructor() {
    super(...arguments);
    r(this, "_effect");
    r(this, "_amount", 1);
    r(this, "_radius", 1);
  }
  get typeName() {
    return "Sharpening";
  }
  onCreateEffect() {
    return this._effect ?? (this._effect = new (xA())()), this.effect;
  }
  get effect() {
    return this._effect;
  }
  set amount(e) {
    this._amount = e, this._effect && (this._effect.uniforms.get("amount").value = e);
  }
  get amount() {
    return this._effect ? this._effect.uniforms.get("amount").value : this._amount;
  }
  set radius(e) {
    this._radius = e, this._effect && (this._effect.uniforms.get("radius").value = e);
  }
  get radius() {
    return this._effect ? this._effect.uniforms.get("radius").value : this._radius;
  }
  // @serializable()
  // set threshold(value: number) {
  //     this.effect.uniforms.get("threshold")!.value = value;
  // }
  // get threshold() {
  //     return this.effect.uniforms.get("threshold")!.value;
  // }
}
Gw([
  f()
], df.prototype, "amount", 1);
Gw([
  f()
], df.prototype, "radius", 1);
function xA() {
  const s = `
      void mainSupport() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `, t = `
    uniform sampler2D tDiffuse;
    uniform float amount;
    uniform float radius;
    
    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        float tx = 1.0 / resolution.x;
        float ty = 1.0 / resolution.y;
        vec2 texelSize = vec2(tx, ty);
    
        vec4 blurred = vec4(0.0);
        float total = 0.0;
    
        for (float x = -radius; x <= radius; x++) {
            for (float y = -radius; y <= radius; y++) {
                vec2 offset = vec2(x, y) * texelSize;
                vec4 diffuse = texture2D(tDiffuse, uv + offset);
                float weight = exp(-length(offset) * amount);
                blurred += diffuse * weight;
                total += weight;
            }
        }
    
        if (total > 0.0) {
            blurred /= total;
        }
    
        // Calculate the sharpened color using inputColor
        vec4 sharp = inputColor + clamp(inputColor - blurred, 0.0, 1.0) * amount;
        // Keep original alpha
        sharp.a = inputColor.a;
    
        // Ensure the sharp color does not go below 0 or above 1
        // This means: sharpening must happen AFTER tonemapping.
        sharp = clamp(sharp, 0.0, 1.0);
    
        outputColor = sharp;
    }
    
    `;
  class e extends D.POSTPROCESSING.MODULE.Effect {
    constructor() {
      super("Sharpening", t, {
        vertexShader: s,
        blendFunction: D.POSTPROCESSING.MODULE.BlendFunction.NORMAL,
        uniforms: /* @__PURE__ */ new Map([
          ["amount", new co(1)],
          ["radius", new co(1)]
          // ["threshold", new Uniform(0)],
        ])
      });
    }
  }
  return e;
}
var SA = Object.defineProperty, CA = Object.getOwnPropertyDescriptor, gl = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? CA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && SA(t, e, n), n;
};
class Us extends dt {
  constructor() {
    super(...arguments);
    r(this, "offset", new N(0));
    r(this, "rotation", new N(0));
    r(this, "focusArea", new N(0.4));
    r(this, "feather", new N(0.3));
    r(this, "kernelSize", new N(2));
    r(this, "resolutionScale", new N(1 / window.devicePixelRatio));
  }
  get typeName() {
    return "TiltShiftEffect";
  }
  init() {
    this.offset.defaultValue = 0, this.rotation.defaultValue = 0, this.focusArea.defaultValue = 0.4, this.feather.defaultValue = 0.3, this.kernelSize.defaultValue = D.POSTPROCESSING.MODULE.KernelSize.MEDIUM, this.resolutionScale.defaultValue = 1 / window.devicePixelRatio;
  }
  onCreateEffect() {
    const e = new D.POSTPROCESSING.MODULE.TiltShiftEffect({
      kernelSize: D.POSTPROCESSING.MODULE.KernelSize.VERY_LARGE,
      offset: this.offset.value,
      rotation: this.rotation.value,
      focusArea: this.focusArea.value,
      feather: this.feather.value
    });
    return this.offset.onValueChanged = (i) => e.offset = i, this.rotation.onValueChanged = (i) => e.rotation = i, this.focusArea.onValueChanged = (i) => e.focusArea = i, this.feather.onValueChanged = (i) => e.feather = i, this.kernelSize.onValueChanged = (i) => e.blurPass.kernelSize = i, this.resolutionScale.onValueChanged = (i) => e.resolution.scale = i / window.devicePixelRatio, e;
  }
}
gl([
  f(N)
], Us.prototype, "offset", 2);
gl([
  f(N)
], Us.prototype, "rotation", 2);
gl([
  f(N)
], Us.prototype, "focusArea", 2);
gl([
  f(N)
], Us.prototype, "feather", 2);
gl([
  f(N)
], Us.prototype, "kernelSize", 2);
gl([
  f(N)
], Us.prototype, "resolutionScale", 2);
On("TiltShiftEffect", Us);
var PA = Object.defineProperty, OA = Object.getOwnPropertyDescriptor, u_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? OA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && PA(t, e, n), n;
};
class _l extends dt {
  constructor() {
    super(...arguments);
    r(this, "color", new N({ r: 0, g: 0, b: 0, a: 1 }));
    r(this, "intensity", new N(0));
    r(this, "center", new N({ x: 0.5, y: 0.5 }));
  }
  get typeName() {
    return "Vignette";
  }
  init() {
    this.color.defaultValue = { r: 0, g: 0, b: 0, a: 1 }, this.intensity.defaultValue = 0, this.center.defaultValue = { x: 0.5, y: 0.5 };
  }
  onCreateEffect() {
    const e = new D.POSTPROCESSING.MODULE.VignetteEffect();
    return this.intensity.onValueChanged = (i) => {
      e.offset = i, this.updateDarkness(e);
    }, this.color.onValueChanged = (i) => {
      this.updateDarkness(e);
    }, e;
  }
  updateDarkness(e) {
    const i = this.intensity.value;
    e.darkness = i;
  }
}
u_([
  f(N)
], _l.prototype, "color", 2);
u_([
  f(N)
], _l.prototype, "intensity", 2);
u_([
  f(N)
], _l.prototype, "center", 2);
On("Vignette", _l);
globalThis.true = globalThis.true !== void 0 ? globalThis.true : !0;
const qs = x("debugpost"), MA = x("debugpostpasses"), Mp = Symbol("needle:postprocessing-handler"), Rp = Symbol("needle:previous-autoclear-state");
class qw {
  constructor(t) {
    r(this, "_composer", null);
    r(this, "_lastVolumeComponents");
    r(this, "_effects", []);
    r(this, "_isActive", !1);
    r(this, "context");
    r(this, "_menuEntry", null);
    r(this, "_passIndices", null);
    this.context = t;
  }
  get isActive() {
    return this._isActive;
  }
  get composer() {
    return this._composer;
  }
  apply(t) {
    return "env" in import.meta && {}.VITE_NEEDLE_USE_POSTPROCESSING === "false" ? (qs ? console.warn("Postprocessing is disabled via vite env setting") : console.debug("Postprocessing is disabled via vite env setting"), Promise.resolve()) : (this._isActive = !0, this.onApply(this.context, t));
  }
  unapply() {
    var i;
    if (qs && console.log("Unapplying postprocessing effects"), this._isActive = !1, this._lastVolumeComponents) {
      for (const n of this._lastVolumeComponents)
        n.unapply();
      this._lastVolumeComponents.length = 0;
    }
    const t = this.context;
    t[Mp] === this && delete t[Mp], t.composer === this._composer && ((i = t.composer) == null || i.dispose(), t.composer = null), typeof t.renderer[Rp] == "boolean" && (t.renderer.autoClear = t.renderer[Rp]);
  }
  dispose() {
    this.unapply();
    for (const t of this._effects)
      t.dispose();
    this._effects.length = 0, this._composer = null;
  }
  async onApply(t, e) {
    if (!e)
      return;
    await Promise.all([
      D.POSTPROCESSING.load(),
      D.POSTPROCESSING_AO.load()
      // import("./Effects/Sharpening.effect")
    ]), t[Mp] = this, qs && console.log("Apply Postprocessing Effects", e), this._lastVolumeComponents = [...e], this._effects.length = 0;
    const i = {
      handler: this,
      components: this._lastVolumeComponents
    };
    for (let n = 0; n < this._lastVolumeComponents.length; n++) {
      const o = this._lastVolumeComponents[n];
      if (o.context = t, o.apply) {
        if (o.active) {
          if (!t.mainCameraComponent) {
            console.error("No camera in scene found or available yet - can not create postprocessing effects");
            return;
          }
          const a = o.apply(i);
          if (!a)
            continue;
          Array.isArray(a) ? this._effects.push(...a) : this._effects.push(a);
        }
      } else
        o.active && ve("Volume component is not a VolumeComponent: " + o.__type);
    }
    if (this.context.renderer.toneMapping != ja && !this._effects.find((n) => n instanceof D.POSTPROCESSING.MODULE.ToneMappingEffect)) {
      const n = new D.POSTPROCESSING.MODULE.ToneMappingEffect();
      this._effects.push(n);
    }
    this.applyEffects(t);
  }
  /** Build composer passes */
  applyEffects(t) {
    const e = this._effects;
    if (e.length <= 0)
      return;
    const i = t.mainCameraComponent, n = t.renderer, o = t.scene, a = i.threeCamera;
    n[Rp] = n.autoClear, this._composer || (this._composer = new D.POSTPROCESSING.MODULE.EffectComposer(n, {
      frameBufferType: D1,
      stencilBuffer: !0
    })), t.composer && t.composer !== this._composer && console.warn("There's already an active EffectComposer in your scene: replacing it with a new one. This might cause unexpected behaviour. Make sure to only use one PostprocessingManager/Volume in your scene."), t.composer = this._composer;
    const l = t.composer;
    l.setMainCamera(a), l.setRenderer(n), l.setMainScene(o);
    for (const h of l.passes)
      h.dispose();
    l.removeAllPasses();
    const c = new D.POSTPROCESSING.MODULE.RenderPass(o, a);
    if (c.name = "Render To Screen", c.mainScene = o, l.addPass(c), MA) {
      this.orderEffects();
      for (const h of e)
        if (h instanceof D.POSTPROCESSING.MODULE.Effect) {
          const d = new D.POSTPROCESSING.MODULE.EffectPass(a, h);
          d.name = h.name, l.addPass(d);
        } else
          h instanceof D.POSTPROCESSING.MODULE.Pass, l.addPass(h);
    } else
      try {
        this.orderEffects();
        const h = [];
        for (const d of e)
          d instanceof D.POSTPROCESSING.MODULE.Effect ? h.push(d) : (d instanceof D.POSTPROCESSING.MODULE.Pass, l.addPass(d));
        if (h.length > 0) {
          const d = new D.POSTPROCESSING.MODULE.EffectPass(a, ...h);
          d.name = h.map((u) => u.name).join(" "), d.mainScene = o, d.enabled = !0, l.addPass(d);
        }
      } catch (h) {
        console.error("Error while applying postprocessing effects", h), l.removeAllPasses();
      }
    if (qs) {
      console.log("[PostProcessing] Passes →", l.passes);
      const h = new D.POSTPROCESSING.MODULE.DepthEffect({
        blendFunction: D.POSTPROCESSING.MODULE.BlendFunction.NORMAL,
        inverted: !0
      });
      h.name = "Depth Effect";
      const d = new D.POSTPROCESSING.MODULE.EffectPass(a, h);
      if (d.name = "Depth Effect Pass", d.enabled = !1, l.passes.push(d), this._passIndices !== null) {
        const p = [l.passes[0]];
        this._passIndices.length > 0 && p.push(
          ...this._passIndices.filter((m) => m !== 0).map((m) => l.passes[m]).filter((m) => m)
        ), p.length > 0 && console.log("[PostProcessing] Passes (selected) →", p), l.passes.length = 0;
        for (const m of p)
          m.enabled = !0, m.renderToScreen = !1, l.addPass(m);
      }
      const u = this.context.menu;
      if (u && this._passIndices === null) {
        this._menuEntry && this._menuEntry.remove();
        const p = document.createElement("select");
        p.multiple = !0;
        const m = document.createElement("option");
        m.innerText = "Final Output", m.value = "-1", p.appendChild(m);
        for (const g of l.passes) {
          const _ = document.createElement("option");
          _.innerText = g.name, _.value = `${l.passes.indexOf(g)}`, _.title = g.name, p.appendChild(_);
        }
        u.appendChild(p), this._menuEntry = p, p.addEventListener("change", () => {
          const g = Array.from(p.selectedOptions).map((_) => parseInt(_.value));
          g.length === 1 && g[0] === -1 ? this._passIndices = null : this._passIndices = g, this.applyEffects(t);
        });
      }
    }
  }
  orderEffects() {
    var e;
    qs && console.log("Before ordering effects", [...this._effects]), kp ?? (kp = [
      D.POSTPROCESSING.MODULE.NormalPass,
      D.POSTPROCESSING.MODULE.DepthDownsamplingPass,
      D.POSTPROCESSING.MODULE.SMAAEffect,
      D.POSTPROCESSING.MODULE.SSAOEffect,
      D.POSTPROCESSING_AO.MODULE.N8AOPostPass,
      D.POSTPROCESSING.MODULE.TiltShiftEffect,
      D.POSTPROCESSING.MODULE.DepthOfFieldEffect,
      D.POSTPROCESSING.MODULE.ChromaticAberrationEffect,
      D.POSTPROCESSING.MODULE.BloomEffect,
      D.POSTPROCESSING.MODULE.SelectiveBloomEffect,
      D.POSTPROCESSING.MODULE.VignetteEffect,
      D.POSTPROCESSING.MODULE.PixelationEffect,
      D.POSTPROCESSING.MODULE.ToneMappingEffect,
      D.POSTPROCESSING.MODULE.HueSaturationEffect,
      D.POSTPROCESSING.MODULE.BrightnessContrastEffect
      // __SHARPENING_MODULE._SharpeningEffect,
    ]);
    const t = this._effects;
    t.sort((i, n) => {
      const o = kp.findIndex((l) => i.constructor.name.endsWith(l.name)), a = kp.findIndex((l) => n.constructor.name.endsWith(l.name));
      return o < 0 ? (qs && console.warn("Unknown effect found: ", i.constructor.name), -1) : a < 0 ? (qs && console.warn("Unknown effect found: ", n.constructor.name), 1) : o < 0 ? 1 : a < 0 ? -1 : o - a;
    }), qs && console.log("After ordering effects", [...this._effects]);
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      if (((e = n == null ? void 0 : n.configuration) == null ? void 0 : e.gammaCorrection) !== void 0) {
        const o = i === t.length - 1;
        n.configuration.gammaCorrection = o;
      }
    }
  }
}
let kp = null;
var RA = Object.defineProperty, kA = Object.getOwnPropertyDescriptor, Xw = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? kA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && RA(t, e, n), n;
};
const Zr = x("debugpost");
class vh extends I {
  constructor() {
    super(...arguments);
    r(this, "sharedProfile");
    r(this, "multisampling", "auto");
    r(this, "_postprocessing");
    r(this, "_activeEffects", []);
    r(this, "_effects", []);
    r(this, "_componentEnabledTime", -1);
    r(this, "_multisampleAutoChangeTime", 0);
    r(this, "_multisampleAutoDecreaseTime", 0);
    r(this, "_lastApplyTime");
    r(this, "_rapidApplyCount", 0);
    r(this, "_isDirty", !1);
    r(this, "_modificationQueue");
    r(this, "_recreateId", -1);
  }
  get isPostProcessingManager() {
    return !0;
  }
  /** Currently active postprocessing effects */
  get effects() {
    return this._activeEffects;
  }
  /**
   * Add a post processing effect to the stack and schedules the effect stack to be re-created.  
   */
  addEffect(e) {
    let i = e;
    return i instanceof dt || (i = new nu(i)), i.gameObject === void 0 && this.gameObject.addComponent(i), this._effects.includes(i) || (this._effects.push(i), this._isDirty = !0), e;
  }
  /**
   * Remove a post processing effect from the stack and schedules the effect stack to be re-created.
   */
  removeEffect(e) {
    var n, o, a, l;
    let i = -1;
    if (e instanceof dt ? i = this._effects.indexOf(e) : i = this._effects.findIndex((c) => c instanceof nu && c.effect === e), i !== -1)
      return this._effects.splice(i, 1), this._isDirty = !0, e;
    if (e instanceof dt) {
      const c = (o = (n = this.sharedProfile) == null ? void 0 : n.components) == null ? void 0 : o.indexOf(e);
      c !== void 0 && c !== -1 && (this._isDirty = !0, (l = (a = this.sharedProfile) == null ? void 0 : a.components) == null || l.splice(c, 1));
    }
    return e;
  }
  /**
   * When dirty the post processing effects will be re-applied
   */
  markDirty() {
    this._isDirty = !0;
  }
  /** @internal */
  awake() {
    var e;
    Zr && (console.log("PostprocessingManager Awake", this), console.log("Press P to toggle post processing"), window.addEventListener("keydown", (i) => {
      i.key === "p" && (this.enabled = !this.enabled, We("Toggle PostProcessing " + this.name + ": Enabled=" + this.enabled), this.markDirty());
    })), (e = this.sharedProfile) == null || e.__init(this);
  }
  /** @internal */
  onEnable() {
    this._componentEnabledTime = this.context.time.realtimeSinceStartup, this._isDirty = !0;
  }
  /** @internal */
  onDisable() {
    var e;
    (e = this._postprocessing) == null || e.unapply(), this._isDirty = !1;
  }
  /** @internal */
  onBeforeRender() {
    if (!this.context.isInXR && (this.context.mainCamera && this._isDirty && this.apply(), this.context.composer && this._postprocessing && this._postprocessing.composer === this.context.composer)) {
      this.context.renderer.getContext().isContextLost() && this.context.renderer.forceContextRestore(), this.context.composer.getRenderer() !== this.context.renderer && this.context.composer.setRenderer(this.context.renderer), this.context.composer.setMainScene(this.context.scene);
      const e = this.context.composer;
      if (this.multisampling === "auto") {
        const i = this.context.time.realtimeSinceStartup - this._multisampleAutoChangeTime;
        if (this.context.time.realtimeSinceStartup - this._componentEnabledTime > 2 && i > 0.5) {
          const n = e.multisampling;
          e.multisampling > 0 && this.context.time.smoothedFps <= 50 ? (this._multisampleAutoChangeTime = this.context.time.realtimeSinceStartup, this._multisampleAutoDecreaseTime = this.context.time.realtimeSinceStartup, e.multisampling *= 0.5, e.multisampling = Math.floor(e.multisampling), Zr && console.debug(`[PostProcessing] Reduced multisampling from ${n} to ${e.multisampling}`)) : i > 1 && this.context.time.smoothedFps >= 59 && e.multisampling < this.context.renderer.capabilities.maxSamples && this.context.time.realtimeSinceStartup - this._multisampleAutoDecreaseTime > 10 && (this._multisampleAutoChangeTime = this.context.time.realtimeSinceStartup, e.multisampling = e.multisampling <= 0 ? 1 : e.multisampling * 2, e.multisampling = Math.floor(e.multisampling), Zr && console.debug(`[PostProcessing] Increased multisampling from ${n} to ${e.multisampling}`));
        }
      } else
        e.multisampling = Math.max(0, Math.min(this.multisampling, this.context.renderer.capabilities.maxSamples));
      if (this.context.mainCamera) {
        const i = this.context.composer.passes;
        for (const n of i)
          if (n.mainCamera && n.mainCamera !== this.context.mainCamera) {
            this.context.composer.setMainCamera(this.context.mainCamera);
            break;
          }
      }
    }
  }
  /** @internal */
  onDestroy() {
    var e;
    (e = this._postprocessing) == null || e.dispose();
  }
  apply() {
    var e, i;
    if (Zr && console.log(`Apply PostProcessing "${this.name}"`), z() && (this._lastApplyTime !== void 0 && Date.now() - this._lastApplyTime < 100 && (this._rapidApplyCount++, this._rapidApplyCount === 5 && console.warn("Detected rapid post processing modifications - this might be a bug", this)), this._lastApplyTime = Date.now()), this._isDirty = !1, this.unapply(), this._activeEffects.length = 0, (e = this.sharedProfile) != null && e.components) {
      const n = this.sharedProfile.components;
      for (const o of n)
        o.active && o.enabled && !this._activeEffects.includes(o) && this._activeEffects.push(o);
    }
    for (const n of this._effects)
      n.active && n.enabled && !this._activeEffects.includes(n) && this._activeEffects.push(n);
    this._activeEffects.length > 0 && (this._postprocessing || (this._postprocessing = new qw(this.context)), (i = this._postprocessing.apply(this._activeEffects)) == null || i.then(() => {
      var o;
      if (!this.activeAndEnabled)
        return;
      this._applyPostQueue();
      const n = (o = this._postprocessing) == null ? void 0 : o.composer;
      n ? (this.multisampling === "auto" ? n.multisampling = X.isMobileDevice() ? 2 : 4 : n.multisampling = Math.max(0, Math.min(this.multisampling, this.context.renderer.capabilities.maxSamples)), Zr && console.debug(`[PostProcessing] Set multisampling to ${n.multisampling} (Is Mobile: ${X.isMobileDevice()})`)) : Zr && console.warn("[PostProcessing] No composer found");
    }));
  }
  unapply() {
    var e;
    (e = this._postprocessing) == null || e.unapply();
  }
  _applyPostQueue() {
    if (this._modificationQueue) {
      for (const e of this._modificationQueue.values())
        this.onEditorModification(e);
      this._modificationQueue.clear();
    }
  }
  /** called from needle editor sync package if its active */
  onEditorModification(e) {
    var i, n;
    if (e.propertyName.startsWith("postprocessing.")) {
      if (!this._postprocessing)
        return this._modificationQueue || (this._modificationQueue = /* @__PURE__ */ new Map()), this._modificationQueue.set(e.propertyName, e), !0;
      if (!((i = this._activeEffects) != null && i.length))
        return;
      const o = e.propertyName.split(".");
      if (o.length === 3 || o.length === 4) {
        const a = o[1], l = o[2];
        for (const c of this._activeEffects)
          if (((n = c.typeName) == null ? void 0 : n.toLowerCase()) === a.toLowerCase()) {
            if (l === "active") {
              c.active = e.value, this.scheduleRecreate();
              return;
            }
            if (!sd.has(a)) {
              const h = new Array();
              sd.set(a, h);
              const d = Object.keys(c);
              for (const u of d)
                c[u] instanceof N && h.push(u);
            }
            if (sd.has(a)) {
              const h = l.toLowerCase(), d = sd.get(a);
              for (const u of d)
                if (u.toLowerCase() === h) {
                  const p = c[u];
                  p instanceof N && (o.length === 4 && o[3] === "active" ? (p.overrideState = e.value, this.scheduleRecreate()) : p && p.value !== void 0 && (p.value = e.value));
                  return;
                }
            }
            console.warn("Unknown modification", l);
            return;
          }
      }
      return !0;
    }
    return !1;
  }
  scheduleRecreate() {
    const e = ++this._recreateId;
    setTimeout(() => {
      e === this._recreateId && (this.onDisable(), this.onEnable());
    }, 200);
  }
}
Xw([
  Ka(h_)
], vh.prototype, "sharedProfile", 2);
Xw([
  Ka()
], vh.prototype, "multisampling", 2);
const sd = /* @__PURE__ */ new Map();
jT(vh);
async function f_(s) {
  const { NeedleEngineHTMLElement: t } = await Promise.resolve().then(() => vI);
  t.observedAttributes.includes(s) || t.observedAttributes.push(s);
}
var TA = Object.defineProperty, AA = Object.getOwnPropertyDescriptor, St = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? AA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && TA(t, e, n), n;
};
const Yt = x("debugsceneswitcher"), EA = x("sceneswitcher:clearscene"), Td = "scene";
f_(Td);
const Xs = Promise.resolve(!1);
class rt extends I {
  constructor() {
    super(...arguments);
    r(this, "autoLoadFirstScene", !0);
    r(this, "scenes", []);
    r(this, "loadingScene");
    r(this, "queryParameterName", "scene");
    r(this, "useSceneName", !0);
    r(this, "clamp", !0);
    r(this, "useHistory", !0);
    r(this, "useKeyboard", !0);
    r(this, "useSwipe", !0);
    r(this, "useSceneLighting", !0);
    r(this, "useSceneBackground", !0);
    r(this, "preloadNext", 1);
    r(this, "preloadPrevious", 1);
    r(this, "preloadConcurrent", 2);
    r(this, "createMenuButtons", !1);
    r(this, "sceneLoadingStart", new xe());
    r(this, "sceneLoadingProgress", new xe());
    r(this, "sceneLoaded", new xe());
    r(this, "_currentIndex", -1);
    r(this, "_currentScene");
    r(this, "_engineElementOverserver");
    r(this, "_preloadScheduler");
    r(this, "_menuButtons");
    r(this, "onPopState", async (e) => {
      if (!this.useHistory)
        return;
      const i = this.useHistory;
      try {
        this.useHistory = !1;
        let n = !1;
        if (this.queryParameterName && (n = await this.tryLoadFromQueryParam()), !n) {
          const o = e == null ? void 0 : e.state;
          if (o && o.startsWith(this.guid)) {
            const a = o.substr(this.guid.length + 2);
            Yt && console.log("PopState", a), await this.trySelectSceneFromValue(a);
          }
        }
      } finally {
        this.useHistory = i;
      }
    });
    r(this, "normalizedSwipeThresholdX", 0.1);
    r(this, "_didSwipe", !1);
    r(this, "onInputPointerMove", (e) => {
      if (this.useSwipe && !this._didSwipe && e.button === 0 && e.pointerType === "touch" && this.context.input.getPointerPressedCount() === 1) {
        const i = this.context.input.getPointerPositionDelta(e.button);
        if (i) {
          const n = i.x / this.context.domWidth;
          n >= this.normalizedSwipeThresholdX ? (this._didSwipe = !0, this.selectPrev()) : n <= -this.normalizedSwipeThresholdX && (this._didSwipe = !0, this.selectNext());
        }
      }
    });
    r(this, "onInputPointerUp", (e) => {
      e.button === 0 && (this._didSwipe = !1);
    });
    r(this, "onInputKeyDown", (e) => {
      if (!this.useKeyboard || !this.scenes)
        return;
      const i = e.key.toLowerCase();
      if (!i)
        return;
      const n = parseInt(i) - 1;
      if (n >= 0) {
        this.trySelectSceneFromValue(n);
        return;
      }
      switch (i) {
        case "arrowright":
        case "d":
          this.selectNext();
          break;
        case "arrowleft":
        case "a":
          this.selectPrev();
          break;
      }
    });
    // this is the scene that was requested last
    r(this, "__lastSwitchScene");
    r(this, "__lastSwitchScenePromise");
    r(this, "_currentlyLoadingScene");
    r(this, "_lastLoadingScene");
    r(this, "_loadingScenePromise");
    r(this, "_isCurrentlyLoading", !1);
    r(this, "_currentLoadingProgress");
  }
  /** The index of the currently loaded and active scene */
  get currentIndex() {
    return this._currentIndex;
  }
  /** Get the progress of the currently loading scene. This is undefined if no scene is loading  
   * You can also subscribe to the loading event by adding an event listener to the scene switcher.  
   * For example like this `sceneSwitcher.addEventListeneer("progress", (e) => {...})`
   */
  get currentLoadingProgress() {
    return this._currentLoadingProgress;
  }
  /** The currently loading scene. This is undefined if no scene is loading. */
  get currentlyLoadingScene() {
    return this._currentlyLoadingScene;
  }
  /**
   * The currently loaded scene. This is undefined if no scene is loaded.
   */
  get currentlyLoadedScene() {
    return this._currentScene;
  }
  /** @internal */
  awake() {
    this.scenes === void 0 && (this.scenes = []);
    for (const e of this.scenes)
      e && !e.hasUrl && e.asset instanceof L && e.asset.removeFromParent();
    Yt && console.log("SceneSwitcher", this);
  }
  /** @internal */
  async onEnable() {
    if (globalThis.addEventListener("popstate", this.onPopState), this.context.input.addEventListener(Ne.KeyDown, this.onInputKeyDown), this.context.input.addEventListener(Ne.PointerMove, this.onInputPointerMove), this.context.input.addEventListener(Ne.PointerUp, this.onInputPointerUp), this._engineElementOverserver || (this._engineElementOverserver = new MutationObserver((e) => {
      for (const i of e)
        if (i.type === "attributes" && i.attributeName === Td) {
          const n = this.context.domElement.getAttribute(Td);
          n !== null && this.trySelectSceneFromValue(n);
        }
    })), this._engineElementOverserver.observe(this.context.domElement, {
      attributes: !0
    }), this._preloadScheduler || (this._preloadScheduler = new IA(this)), this._preloadScheduler.maxLoadAhead = this.preloadNext, this._preloadScheduler.maxLoadBehind = this.preloadPrevious, this._preloadScheduler.maxConcurrent = this.preloadConcurrent, this._preloadScheduler.begin(2e3), this.autoLoadFirstScene && this._currentIndex === -1 && !await this.tryLoadFromQueryParam()) {
      const e = this.context.domElement.getAttribute(Td);
      try {
        (e === null || !await this.trySelectSceneFromValue(e)) && this._currentIndex === -1 && this.select(0);
      } finally {
      }
    }
    this.createMenuButtons && (this._menuButtons ?? (this._menuButtons = []), this._menuButtons.push(this.context.menu.appendChild({
      label: "Previous",
      icon: "arrow_back_ios",
      onClick: () => this.selectPrev(),
      priority: -1005,
      class: "row2"
    })), this._menuButtons.push(this.context.menu.appendChild({
      label: "Next",
      icon: "arrow_forward_ios",
      iconSide: "right",
      onClick: () => this.selectNext(),
      priority: -1e3,
      class: "row2"
    })));
  }
  /** @internal */
  onDisable() {
    var e;
    if (globalThis.removeEventListener("popstate", this.onPopState), this.context.input.removeEventListener(Ne.KeyDown, this.onInputKeyDown), this.context.input.removeEventListener(Ne.PointerMove, this.onInputPointerMove), this.context.input.removeEventListener(Ne.PointerUp, this.onInputPointerUp), (e = this._preloadScheduler) == null || e.stop(), this._menuButtons) {
      for (const i of this._menuButtons)
        i.remove();
      this._menuButtons = void 0;
    }
  }
  /**
   * Add a scene to the SceneSwitcher.     
   * If the scene is already added it will be added again.
   * @param urlOrAssetReference The url of the scene or an AssetReference to the scene  
   * @returns The AssetReference of the scene that was added
   * @example
   * ```ts
   * // adding a scene:
   * sceneSwitcher.addScene("scene1.glb");
   * // add another scene and load it:
   * const scene2 = sceneSwitcher.addScene("scene2.glb");
   * sceneSwitcher.switchScene(scene2).then(res => { console.log("Scene loaded", res); });
   * ```
   */
  addScene(e) {
    if (typeof e == "string") {
      let i = this.context.addressables.findAssetReference(e);
      return i || (i = new re(e), this.context.addressables.registerAssetReference(i)), this.scenes.push(i), i;
    }
    return this.scenes.push(e), e;
  }
  /**
   * Load the next scene in the scenes array ({@link this.currentIndex} + 1)  
   * If the current scene is the last scene in the array and {@link this.clamp} is disabled then the first scene will be loaded.
   * @returns a promise that resolves to true if the scene was loaded successfully    
   */
  selectNext() {
    return this.select(this._currentIndex + 1);
  }
  /**
   * Load the previous scene in the scenes array ({@link this.currentIndex} - 1)  
   * If the current scene is the first scene in the array and {@link this.clamp} is disabled then the last scene will be loaded.
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  selectPrev() {
    return this.select(this._currentIndex - 1);
  }
  /**
   * Load a scene by its index in the scenes array.
   * @param index The index of the scene or a string that represents the scene uri (if the url is not known to the SceneSwitcher it will try to load the scene by its uri but it won't be added to the current scenes array. Use {@link addScene} to add a scene to the SceneSwitcher)  
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  select(e) {
    var n, o, a;
    if (Yt && console.log("select", e), typeof e == "object" && console.warn('Switching to "' + e + '" might not work. Please either use an index or a AssetReference (not a scene reference)'), typeof e == "string") {
      const l = (n = this.scenes) == null ? void 0 : n.find((c) => c.url === e);
      if (!l) {
        const c = re.getOrCreate(this.sourceId ?? "", e, this.context);
        return this.switchScene(c);
      }
      if (l)
        e = (o = this.scenes) == null ? void 0 : o.indexOf(l);
      else
        return Xs;
    }
    if (!((a = this.scenes) != null && a.length))
      return Xs;
    if (e < 0) {
      if (this.clamp)
        return Xs;
      e = this.scenes.length - 1;
    } else if (e >= this.scenes.length) {
      if (this.clamp)
        return Xs;
      e = 0;
    }
    const i = this.scenes[e];
    return this.switchScene(i);
  }
  /**
   * Unload the currently loaded scene.
   */
  unload() {
    return this.__lastSwitchScene = void 0, this.__lastSwitchScenePromise = void 0, this.__unloadCurrentScene();
  }
  /**
   * Reload the last scene that was loaded
   * @returns a promise that resolves to true if the scene was loaded successfully
   */
  async reload() {
    if (this.__lastSwitchScene) {
      const e = this.__lastSwitchScene;
      return this.__lastSwitchScene = void 0, this.switchScene(e);
    }
    return !1;
  }
  /**
   * Switch to a scene by its AssetReference.  
   * If the scene is already loaded it will be unloaded and the new scene will be loaded.  
   * If the scene is already loading it will wait for the scene to be loaded.  
   * If the scene is already loaded and the same scene is requested again it will return the same promise that was returned the first time the scene was requested.  
   * @param scene The AssetReference of the scene to switch to
   * @returns a promise that resolves to true if the scene was loaded successfully
   * @example
   * ```ts
   * const myAssetReference = new AssetReference("scene1.glb");
   * sceneSwitcher.switchScene(myAssetReference).then(res => { console.log("Scene loaded", res); });
   * ```
   */
  async switchScene(e) {
    if (!(e instanceof re)) {
      const n = typeof e;
      return n === "string" ? this.select(e) : n === "number" ? this.select(e) : (console.warn("SceneSwitcher: Can't switch to scene", e, "of type", n), !1);
    }
    return e.url === this.sourceId ? (console.warn("SceneSwitcher: can't load own scene - prevent recursive loading", this.sourceId), !1) : this.__lastSwitchScene === e && this.__lastSwitchScenePromise ? this.__lastSwitchScenePromise : (this.__lastSwitchScene = e, this.__lastSwitchScenePromise = this.__internalSwitchScene(e), await this.__lastSwitchScenePromise);
  }
  async __unloadCurrentScene() {
    const e = this._currentScene;
    if (this._currentScene = void 0, e) {
      Yt && console.log("UNLOAD", e.url, "HasURL?: " + e.hasUrl);
      const i = this.tryGetSceneEventListener(e.asset);
      if (i != null && i.sceneClosing) {
        const n = i.sceneClosing();
        n instanceof Promise && await n;
      }
      e.hasUrl ? e.unload() : e.asset instanceof L && e.asset.removeFromParent();
    }
  }
  /** @internal */
  async __internalSwitchScene(e) {
    var n, o, a, l, c;
    await this.__unloadCurrentScene();
    const i = this._currentIndex = ((n = this.scenes) == null ? void 0 : n.indexOf(e)) ?? -1;
    try {
      this._currentlyLoadingScene = e, this._currentLoadingProgress = new ProgressEvent("progress", { loaded: 0, total: 1 });
      const h = new CustomEvent("loadscene-start", { detail: { scene: e, switcher: this, index: i } });
      this.dispatchEvent(h), (o = this.sceneLoadingStart) == null || o.invoke(h.detail), await this.onStartLoading(), await e.loadAssetAsync((u, p) => {
        var m;
        this._currentLoadingProgress = p, this.dispatchEvent(p), (m = this.sceneLoadingProgress) == null || m.invoke(p);
      }).catch(console.error), await this.onEndLoading();
      const d = new CustomEvent("loadscene-finished", { detail: { scene: e, switcher: this, index: i } });
      if (this.dispatchEvent(d), this._currentLoadingProgress = void 0, this._currentlyLoadingScene = void 0, d.defaultPrevented)
        return Yt && console.warn("Adding loaded scene prevented:", e, d), !1;
      if (!e.asset)
        return Yt && console.warn("Failed loading scene:", e), !1;
      if (this._currentIndex === i) {
        if (Yt && console.log("ADD", e.url), this._currentScene = e, EA) {
          const m = ((a = this.context.mainCameraComponent) == null ? void 0 : a.gameObject) || this.context.mainCamera;
          m == null || m.removeFromParent();
          const g = this.gameObject.removeFromParent();
          nn(this.context.scene, !0, !0), this.context.scene = new Mi(), this.context.scene.add(g), m && this.context.scene.add(m);
        }
        if (S.add(e.asset, this.gameObject), this.useSceneLighting && this.context.sceneLighting.enable(e), this.useSceneBackground) {
          const m = this.context.lightmaps.tryGetSkybox(e.url);
          m ? (m.mapping = Ms, this.context.scene.background = m) : Yt && console.warn("SceneSwitcher: Can't find skybox for scene " + e.url);
        }
        if (this.useHistory && i >= 0) {
          let m = i.toString();
          if (this.useSceneName && (m = Lb(e.url)), (l = this.queryParameterName) != null && l.length)
            jd(this.queryParameterName, m, this.useHistory);
          else {
            const g = history.state, _ = this.guid + "::" + i;
            g !== _ && history.pushState(_, "unused", location.href);
          }
        }
        const u = this.tryGetSceneEventListener(e.asset);
        if (u != null && u.sceneOpened) {
          const m = u.sceneOpened(this);
          m instanceof Promise && await m;
        }
        const p = new CustomEvent("scene-opened", { detail: { scene: e, switcher: this, index: i } });
        return this.dispatchEvent(p), (c = this.sceneLoaded) == null || c.invoke(this), !0;
      }
    } catch (h) {
      console.error(h);
    }
    return !1;
  }
  preload(e) {
    if (e >= 0 && e < this.scenes.length) {
      const i = this.scenes[e];
      if (i instanceof re)
        return i.preload();
    }
    return Xs;
  }
  tryLoadFromQueryParam() {
    var i;
    if (!((i = this.queryParameterName) != null && i.length))
      return Xs;
    const e = x(this.queryParameterName);
    return typeof e == "boolean" ? Xs : this.trySelectSceneFromValue(e);
  }
  /** try to select a scene from a string or index */
  trySelectSceneFromValue(e) {
    if (typeof e == "string") {
      const i = parseInt(e);
      if (i >= 0 && i < this.scenes.length)
        return this.select(i);
      {
        const n = e.toLowerCase();
        for (let o = 0; o < this.scenes.length; o++) {
          const a = this.scenes[o];
          if (a && Lb(a.url).toLowerCase().includes(n))
            return this.select(o);
        }
      }
    } else if (typeof e == "number" && e >= 0 && e < this.scenes.length)
      return this.select(e);
    return ui() && console.warn('Can not find scene: "' + e + '"', this), Xs;
  }
  async onStartLoading() {
    var e, i;
    if (this._isCurrentlyLoading = !0, this.loadingScene && (this._lastLoadingScene !== this.loadingScene && (this._loadingScenePromise = void 0), this._lastLoadingScene = this.loadingScene, this._loadingScenePromise || (this._loadingScenePromise = (e = this.loadingScene) == null ? void 0 : e.loadAssetAsync().then((n) => n != null)), await this._loadingScenePromise, this._isCurrentlyLoading && ((i = this.loadingScene) != null && i.asset))) {
      Yt && console.log("Add loading scene", this.loadingScene.url, this.loadingScene.asset);
      const n = this.loadingScene.asset;
      S.add(n, this.gameObject);
      const o = this.tryGetSceneEventListener(n);
      if (o != null && o.sceneOpened) {
        const a = o.sceneOpened(this);
        a instanceof Promise && await a;
      }
    }
    if (this._isCurrentlyLoading) {
      const n = this.tryGetSceneEventListener(this.gameObject);
      if (n && n.sceneOpened) {
        const o = n.sceneOpened(this);
        o instanceof Promise && await o;
      }
    }
  }
  async onEndLoading() {
    var e;
    if (this._isCurrentlyLoading = !1, (e = this.loadingScene) != null && e.asset) {
      Yt && console.log("Remove loading scene", this.loadingScene.url);
      const i = this.loadingScene.asset, n = this.tryGetSceneEventListener(i);
      if (typeof (n == null ? void 0 : n.sceneClosing) == "function") {
        const o = n.sceneClosing();
        o instanceof Promise && await o;
      }
      S.remove(i);
    }
    if (!this._isCurrentlyLoading) {
      const i = this.tryGetSceneEventListener(this.gameObject);
      if (i && i.sceneClosing) {
        const n = i.sceneClosing();
        n instanceof Promise && await n;
      }
    }
  }
  tryGetSceneEventListener(e, i = 0) {
    if (!e)
      return null;
    const n = S.foreachComponent(e, (o) => {
      const a = o;
      if (a.sceneClosing || a.sceneOpened)
        return a;
    });
    if (i === 0 && !n && e.children.length)
      for (const o of e.children) {
        const a = this.tryGetSceneEventListener(o, i + 1);
        if (a)
          return a;
      }
    return n || null;
  }
}
St([
  f()
], rt.prototype, "autoLoadFirstScene", 2);
St([
  f(re)
], rt.prototype, "scenes", 2);
St([
  f(re)
], rt.prototype, "loadingScene", 2);
St([
  f()
], rt.prototype, "queryParameterName", 2);
St([
  f()
], rt.prototype, "useSceneName", 2);
St([
  f()
], rt.prototype, "clamp", 2);
St([
  f()
], rt.prototype, "useHistory", 2);
St([
  f()
], rt.prototype, "useKeyboard", 2);
St([
  f()
], rt.prototype, "useSwipe", 2);
St([
  f()
], rt.prototype, "useSceneLighting", 2);
St([
  f()
], rt.prototype, "useSceneBackground", 2);
St([
  f()
], rt.prototype, "preloadNext", 2);
St([
  f()
], rt.prototype, "preloadPrevious", 2);
St([
  f()
], rt.prototype, "preloadConcurrent", 2);
St([
  f()
], rt.prototype, "createMenuButtons", 2);
St([
  f(xe)
], rt.prototype, "sceneLoadingStart", 2);
St([
  f(xe)
], rt.prototype, "sceneLoadingProgress", 2);
St([
  f(xe)
], rt.prototype, "sceneLoaded", 2);
function Lb(s) {
  const t = s.split("/").pop(), e = t == null ? void 0 : t.split(".").shift();
  return e != null && e.length ? e : s;
}
class IA {
  /**
   * Creates a new PreLoadScheduler instance
   * @param rooms The SceneSwitcher that this scheduler belongs to
   * @param ahead Number of scenes to preload ahead of current scene
   * @param behind Number of scenes to preload behind current scene
   * @param maxConcurrent Maximum number of concurrent preloads allowed
   */
  constructor(t, e = 1, i = 1, n = 2) {
    /** Maximum number of scenes to preload ahead of the current scene */
    r(this, "maxLoadAhead");
    /** Maximum number of scenes to preload behind the current scene */
    r(this, "maxLoadBehind");
    /** Maximum number of scenes that can be preloaded concurrently */
    r(this, "maxConcurrent");
    r(this, "_isRunning", !1);
    r(this, "_switcher");
    r(this, "_loadTasks", []);
    r(this, "_maxConcurrentLoads", 1);
    this._switcher = t, this.maxLoadAhead = e, this.maxLoadBehind = i, this.maxConcurrent = n;
  }
  /**
   * Starts the preloading process after a specified delay
   * @param delay Time in milliseconds to wait before starting preload
   */
  begin(t) {
    if (this._isRunning)
      return;
    Yt && console.log("Preload begin", { delay: t }), this._isRunning = !0;
    let e = -10, i, n;
    const o = this._switcher.scenes, a = Date.now() + t, l = setInterval(() => {
      if (this.allLoaded() && (Yt && console.log("All scenes (pre-)loaded"), this.stop()), !this._isRunning) {
        clearInterval(l);
        return;
      }
      if (Date.now() < a || this.canLoadNewScene() === !1)
        return;
      (e === -10 || e !== this._switcher.currentIndex) && (e = this._switcher.currentIndex, n = 0, i = 0);
      const c = n % 2 === 0;
      c && (i += 1), n += 1;
      const h = c ? this.maxLoadAhead : this.maxLoadBehind;
      if (i > h)
        return;
      const d = c ? e + i : e - i;
      if (!(d < 0) && !(d < 0 || d >= o.length) && !this._loadTasks.some((u) => u.index === d)) {
        const u = o[d];
        Yt && console.log("Preload scene", { roomIndex: d, searchForward: c, lastRoom: e, currentIndex: this._switcher.currentIndex, tasks: this._loadTasks.length }, u == null ? void 0 : u.url), new DA(d, u, this._loadTasks);
      }
    }, 200);
  }
  /**
   * Stops the preloading process
   */
  stop() {
    this._isRunning = !1;
  }
  /**
   * Checks if a new scene can be loaded based on current load limits
   * @returns True if a new scene can be loaded, false otherwise
   */
  canLoadNewScene() {
    return this._loadTasks.length < this._maxConcurrentLoads;
  }
  /**
   * Checks if all scenes in the SceneSwitcher have been loaded
   * @returns True if all scenes are loaded, false otherwise
   */
  allLoaded() {
    if (this._switcher.scenes) {
      for (const t of this._switcher.scenes)
        if ((t == null ? void 0 : t.isLoaded()) === !1)
          return !1;
    }
    return !0;
  }
}
class DA {
  /**
   * Creates a new LoadTask and begins loading immediately
   * @param index The index of the scene in the scenes array
   * @param asset The AssetReference to preload
   * @param tasks The collection of active load tasks
   */
  constructor(t, e, i) {
    /** The index of the scene in the scenes array */
    r(this, "index");
    /** The AssetReference to be loaded */
    r(this, "asset");
    /** The collection of active load tasks this task belongs to */
    r(this, "tasks");
    this.index = t, this.asset = e, this.tasks = i, i.push(this), this.awaitLoading();
  }
  /**
   * Asynchronously loads the asset and removes this task from the active tasks list when complete
   */
  async awaitLoading() {
    this.asset && !this.asset.isLoaded() && (Yt && console.log("Preload start: " + this.asset.url, this.index), await this.asset.preload(), Yt && console.log("Preload finished: " + this.asset.url, this.index));
    const t = this.tasks.indexOf(this);
    t >= 0 && this.tasks.splice(t, 1);
  }
}
function LA() {
  return new Promise((s, t) => {
    const i = () => {
      i != null && (document.removeEventListener("pointerdown", i), document.removeEventListener("click", i), document.removeEventListener("dragstart", i), document.removeEventListener("touchstart", i), s());
    };
    document.addEventListener("pointerdown", i), document.addEventListener("click", i), document.addEventListener("dragstart", i), document.addEventListener("touchstart", i);
  });
}
async function jA(s) {
  await LA(), s();
}
var BA = Object.defineProperty, FA = Object.getOwnPropertyDescriptor, Bi = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? FA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && BA(t, e, n), n;
};
const pt = x("debugvideo");
var Qw = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.AdjustHeight = 1] = "AdjustHeight", s[s.AdjustWidth = 2] = "AdjustWidth", s))(Qw || {}), Yw = /* @__PURE__ */ ((s) => (s[s.VideoClip = 0] = "VideoClip", s[s.Url = 1] = "Url", s))(Yw || {}), Kw = /* @__PURE__ */ ((s) => (s[s.CameraFarPlane = 0] = "CameraFarPlane", s[s.CameraNearPlane = 1] = "CameraNearPlane", s[s.RenderTexture = 2] = "RenderTexture", s[s.MaterialOverride = 3] = "MaterialOverride", s))(Kw || {});
class bt extends I {
  /**
   * @internal
   */
  constructor() {
    super();
    r(this, "playOnAwake", !0);
    r(this, "aspectMode", 0);
    r(this, "clip", null);
    r(this, "source", 1);
    r(this, "_url", null);
    r(this, "renderMode");
    r(this, "targetMaterialProperty");
    r(this, "targetMaterialRenderer");
    r(this, "targetTexture");
    r(this, "time", 0);
    r(this, "_playbackSpeed", 1);
    r(this, "_isLooping", !1);
    r(this, "_muted", !1);
    r(this, "_audioOutputMode", 2);
    /** Set this to false to pause video playback while the tab is not active 
     * @default true
    */
    r(this, "playInBackground", !0);
    r(this, "_crossOrigin", "anonymous");
    r(this, "_videoElement", null);
    r(this, "_videoTexture", null);
    r(this, "_videoMaterial", null);
    r(this, "_isPlaying", !1);
    r(this, "wasPlaying", !1);
    r(this, "visibilityChanged", (e) => {
      switch (document.visibilityState) {
        case "hidden":
          this.playInBackground || (this.wasPlaying = this._isPlaying, this.pause());
          break;
        case "visible":
          this.wasPlaying && !this._isPlaying && this.play();
          break;
      }
    });
    r(this, "_receivedInput", !1);
    r(this, "_overlay", null);
    r(this, "_targetObjects");
    r(this, "_updateAspectRoutineId", -1);
    r(this, "_hls");
    r(this, "onHlsAvailable", () => {
      var e;
      pt && console.log("HLS: available", this.clip), !(!this.shouldUseM3U || !this.url) && (this._hls || (this._hls = new Hls()), this.videoElement.autoplay = !0, this._hls.loadSource(this.url), this._hls.attachMedia(this.videoElement), (e = this._videoElement) == null || e.play(), pt && console.log("HLS: loaded", this.clip));
    });
    jA(() => {
      this._receivedInput = !0, this.updateVideoElementSettings();
    }), this._targetObjects = [], x("videoscreenspace") && window.addEventListener("keydown", (e) => {
      e.key === "f" && (this.screenspace = !this.screenspace);
    });
  }
  get url() {
    return this._url;
  }
  /**
   * The video clip to play. 
   */
  set url(e) {
    const n = this._url !== e;
    this.__didAwake ? n && this.setClipURL(e ?? "") : this._url = e;
  }
  get playbackSpeed() {
    var e;
    return ((e = this._videoElement) == null ? void 0 : e.playbackRate) ?? this._playbackSpeed;
  }
  /**
   * Set the video playback speed. Increasing this value will speed up the video, decreasing it will slow it down.
   */
  set playbackSpeed(e) {
    this._playbackSpeed = e, this._videoElement && (this._videoElement.playbackRate = e);
  }
  get isLooping() {
    var e;
    return ((e = this._videoElement) == null ? void 0 : e.loop) ?? this._isLooping;
  }
  set isLooping(e) {
    this._isLooping = e, this._videoElement && (this._videoElement.loop = e);
  }
  /**
   * @returns the current time of the video in seconds
   */
  get currentTime() {
    var e;
    return ((e = this._videoElement) == null ? void 0 : e.currentTime) ?? this.time;
  }
  /**
   * set the current time of the video in seconds
   */
  set currentTime(e) {
    this._videoElement ? this._videoElement.currentTime = e : this.time = e;
  }
  /**
   * @returns true if the video is currently playing
   */
  get isPlaying() {
    const e = this._videoElement;
    if (e) {
      if (e.currentTime > 0 && !e.paused && !e.ended && e.readyState > e.HAVE_CURRENT_DATA)
        return !0;
      if (e.srcObject && e.srcObject.active)
        return !0;
    }
    return !1;
  }
  get crossOrigin() {
    var e;
    return ((e = this._videoElement) == null ? void 0 : e.crossOrigin) ?? this._crossOrigin;
  }
  set crossOrigin(e) {
    this._crossOrigin = e, this._videoElement && (e !== null ? this._videoElement.setAttribute("crossorigin", e) : this._videoElement.removeAttribute("crossorigin"));
  }
  /**
   * the material that is used to render the video
   */
  get videoMaterial() {
    return !this._videoMaterial && !this.create(!1) ? null : this._videoMaterial;
  }
  /**
   * the video texture that is used to render the video
   */
  get videoTexture() {
    return !this._videoTexture && !this.create(!1) ? null : this._videoTexture;
  }
  /**
   * the HTMLVideoElement that is used to play the video
   */
  get videoElement() {
    return !this._videoElement && !this.create(!1) ? null : this._videoElement;
  }
  /**
   * Request the browser to enter picture in picture mode
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Picture-in-Picture_API
   * @returns the promise returned by the browser
   */
  requestPictureInPicture() {
    return this._videoElement ? this._videoElement.requestPictureInPicture() : null;
  }
  /**
   * @returns true if the video is muted
   */
  get muted() {
    var e;
    return ((e = this._videoElement) == null ? void 0 : e.muted) ?? this._muted;
  }
  /**
   * set the video to be muted
   */
  set muted(e) {
    this._muted = e, this._videoElement && (this._videoElement.muted = e);
  }
  /**
   * The current video clip that is being played
   */
  get currentVideo() {
    return this.clip;
  }
  set audioOutputMode(e) {
    e !== this._audioOutputMode && (e === 1 && z() && console.warn("VideoAudioOutputMode.AudioSource is not yet implemented"), this._audioOutputMode = e, this.updateVideoElementSettings());
  }
  get audioOutputMode() {
    return this._audioOutputMode;
  }
  /** ensure's the video element has been created and will start loading the clip */
  preloadVideo() {
    pt && console.log("Video Preload: " + this.name, this.clip), this.create(!1);
  }
  /** @deprecated use `preloadVideo()` */
  preload() {
    this.preloadVideo();
  }
  /** Set a new video stream  
   * starts to play automatically if the videoplayer hasnt been active before and playOnAwake is true */
  setVideo(e) {
    this.clip = e, this.source = 0, this._videoElement ? (this._videoElement.srcObject = e, this._isPlaying && this.play(), this.updateAspect()) : this.create(this.playOnAwake);
  }
  setClipURL(e) {
    this._url !== e && (this._url = e, this.source = 1, pt && console.log("set url", e), this._videoElement ? e.endsWith(".m3u8") || e.includes(".m3u") ? this.ensureM3UCanBePlayed() : (this._videoElement.src = e, this._isPlaying && (this.stop(), this.play())) : this.create(this.playOnAwake));
  }
  /** @internal */
  onEnable() {
    var e, i;
    pt && console.log("VideoPlayer.onEnable", Yw[this.source], this.clip, this.url, this), window.addEventListener("visibilitychange", this.visibilityChanged), this.playOnAwake === !0 ? this.create(!0) : this.preloadVideo(), this.screenspace ? (e = this._overlay) == null || e.start() : (i = this._overlay) == null || i.stop();
  }
  /** @internal */
  onDisable() {
    var e;
    window.removeEventListener("visibilitychange", this.visibilityChanged), (e = this._overlay) == null || e.stop(), this.pause();
  }
  /** @internal */
  onDestroy() {
    var e;
    this._videoElement && ((e = this.videoElement) == null || e.remove(), this._videoElement = null), this._videoTexture && (this._videoTexture.dispose(), this._videoTexture = null);
  }
  /** start playing the video source */
  play() {
    var e, i;
    if (this._videoElement || this.create(!1), !this._videoElement) {
      pt && console.warn("Can not play: no video element found", this);
      return;
    }
    if (!(this._isPlaying && !((e = this._videoElement) != null && e.ended) && !((i = this._videoElement) != null && i.paused))) {
      if (this._isPlaying = !0, this._receivedInput || (this._videoElement.muted = !0), this.handleBeginPlaying(!1), this.shouldUseM3U) {
        this.ensureM3UCanBePlayed();
        return;
      }
      pt && console.log("Video Play()", this.clip, this._videoElement, this.time), this._videoElement.currentTime = this.time, this._videoElement.play().catch((n) => {
        var o;
        console.log(n), pt && console.error("Error playing video", n, "CODE=" + n.code, (o = this.videoElement) == null ? void 0 : o.src, this), setTimeout(() => {
          this._isPlaying && !this.destroyed && this.activeAndEnabled && this.play();
        }, 1e3);
      }), pt && console.log("play", this._videoElement, this.time);
    }
  }
  /**
   * Stop the video playback. This will reset the video to the beginning
   */
  stop() {
    this._isPlaying = !1, this.time = 0, this._videoElement && (this._videoElement.currentTime = 0, this._videoElement.pause(), pt && console.log("STOP", this));
  }
  /**
   * Pause the video playback
   */
  pause() {
    var e, i;
    this.time = ((e = this._videoElement) == null ? void 0 : e.currentTime) ?? 0, this._isPlaying = !1, (i = this._videoElement) == null || i.pause(), pt && console.log("PAUSE", this, this.currentTime);
  }
  /** create the video element and assign the video source url or stream */
  create(e) {
    let i;
    switch (this.source) {
      case 0:
        i = this.clip;
        break;
      case 1:
        i = this.url, !(i != null && i.length) && typeof this.clip == "string" && (i = this.clip);
        break;
    }
    return i ? (this._videoElement || (pt && console.warn("Create VideoElement", this), this._videoElement = this.createVideoElement(), this.context.domElement.shadowRoot.prepend(this._videoElement), this.updateVideoElementStyles()), typeof i == "string" ? (pt && console.log("Set Video src", i), this._videoElement.src = i) : (pt && console.log("Set Video srcObject", i), this._videoElement.srcObject = i), this._videoTexture || (this._videoTexture = new L1(this._videoElement)), this._videoTexture.flipY = !1, this._videoTexture.colorSpace = vn, e && this.handleBeginPlaying(e), pt && console.log("Video: handle playing done...", i, e), !0) : (pt && console.warn("No video source set", this), !1);
  }
  updateAspect() {
    this.aspectMode !== 0 && this.startCoroutine(this.updateAspectImpl());
  }
  /**
   * If true the video will be rendered in screenspace mode and overlayed on top of the scene.
   * Alternatively you can also request the video to be played in PictureInPicture mode by calling `requestPictureInPicture()`
   */
  get screenspace() {
    var e;
    return ((e = this._overlay) == null ? void 0 : e.enabled) ?? !1;
  }
  set screenspace(e) {
    var i;
    if (e) {
      if (!this._videoTexture)
        return;
      this._overlay || (this._overlay = new zA(this.context)), this._overlay.add(this._videoTexture);
    } else
      (i = this._overlay) == null || i.remove(this._videoTexture);
    this._overlay && (this._overlay.enabled = e);
  }
  createVideoElement() {
    const e = document.createElement("video");
    return this._crossOrigin && e.setAttribute("crossorigin", this._crossOrigin), pt && console.log("created video element", e), e;
  }
  handleBeginPlaying(e) {
    var o, a;
    if (!this.activeAndEnabled || !this._videoElement)
      return;
    this._targetObjects.length = 0;
    let i = this.gameObject;
    switch (this.renderMode) {
      case 3:
        i = (o = this.targetMaterialRenderer) == null ? void 0 : o.gameObject, i || (i = (a = S.getComponent(this.gameObject, Je)) == null ? void 0 : a.gameObject);
        break;
      case 2:
        console.error("VideoPlayer renderTexture not implemented yet. Please use material override instead");
        return;
    }
    if (!i) {
      console.error("Missing target for video material renderer", this.name, Kw[this.renderMode], this);
      return;
    }
    const n = i.material;
    if (n) {
      this._targetObjects.push(i), n !== this._videoMaterial && (this._videoMaterial = n.clone(), i.material = this._videoMaterial);
      const l = "map", c = this._videoMaterial;
      if (!this.targetMaterialProperty)
        c[l] = this._videoTexture;
      else
        switch (this.targetMaterialProperty) {
          default:
            c[l] = this._videoTexture;
            break;
        }
    } else {
      console.warn("Can not play video, no material found, this might be a multimaterial case which is not supported yet");
      return;
    }
    this.updateVideoElementSettings(), this.updateVideoElementStyles(), e && (this.shouldUseM3U && this.ensureM3UCanBePlayed(), this.play());
  }
  updateVideoElementSettings() {
    if (!this._videoElement)
      return;
    this._videoElement.loop = this._isLooping, this._videoElement.currentTime = this.currentTime, this._videoElement.playbackRate = this._playbackSpeed, this._videoElement.playsInline = !0;
    let e = !this._receivedInput || this.audioOutputMode === 0;
    !e && this._muted && (e = !0), this._videoElement.muted = e, this.playOnAwake && (this._videoElement.autoplay = !0);
  }
  updateVideoElementStyles() {
    this._videoElement && (this._videoElement.style.userSelect = "none", this._videoElement.style.visibility = "hidden", this._videoElement.style.display = "none", this.updateAspect());
  }
  *updateAspectImpl() {
    const e = ++this._updateAspectRoutineId, i = void 0, n = this.clip;
    for (; e === this._updateAspectRoutineId && this.aspectMode !== 0 && this.clip && n === this.clip && this._isPlaying; ) {
      if (!n || typeof n == "string")
        return;
      let o;
      for (const a of n.getVideoTracks()) {
        const l = a.getSettings();
        if (l && l.width && l.height) {
          o = l.width / l.height;
          break;
        } else
          o = this.context.renderer.domElement.clientWidth / this.context.renderer.domElement.clientHeight;
      }
      if (o === void 0) {
        for (let a = 0; a < 10; a++)
          yield;
        if (!this.isPlaying)
          break;
        continue;
      }
      if (i === o) {
        yield;
        continue;
      }
      for (const a of this._targetObjects) {
        let l = 1;
        if (a.parent) {
          const c = Ke(a.parent);
          l = c.x / c.y;
        }
        switch (this.aspectMode) {
          case 1:
            a.scale.y = 1 / o * a.scale.x * l;
            break;
          case 2:
            a.scale.x = o * a.scale.y * l;
            break;
        }
      }
      for (let a = 0; a < 3; a++)
        yield;
    }
  }
  get shouldUseM3U() {
    return this.url != null && (this.url.endsWith(".m3u8") || this.url.endsWith(".m3u")) && this.source === 1;
  }
  ensureM3UCanBePlayed() {
    if (!this.shouldUseM3U)
      return;
    let e = document.head.querySelector("script[data-hls_library]");
    e ? globalThis.Hls ? this.onHlsAvailable() : e.addEventListener("load", this.onHlsAvailable) : (pt && console.log("HLS: load script"), e = document.createElement("script"), e.dataset.hls_library = "hls.js", e.src = "https://cdn.jsdelivr.net/npm/hls.js@1", e.addEventListener("load", this.onHlsAvailable), document.head.append(e));
  }
}
Bi([
  f()
], bt.prototype, "playOnAwake", 2);
Bi([
  f()
], bt.prototype, "aspectMode", 2);
Bi([
  f(URL)
], bt.prototype, "clip", 2);
Bi([
  f()
], bt.prototype, "source", 2);
Bi([
  f(URL)
], bt.prototype, "url", 1);
Bi([
  f()
], bt.prototype, "renderMode", 2);
Bi([
  f()
], bt.prototype, "targetMaterialProperty", 2);
Bi([
  f(Je)
], bt.prototype, "targetMaterialRenderer", 2);
Bi([
  f(Fe)
], bt.prototype, "targetTexture", 2);
Bi([
  f()
], bt.prototype, "time", 2);
Bi([
  f()
], bt.prototype, "playbackSpeed", 1);
Bi([
  f()
], bt.prototype, "isLooping", 1);
Bi([
  f()
], bt.prototype, "audioOutputMode", 1);
class zA {
  constructor(t) {
    r(this, "context");
    r(this, "_videos", []);
    r(this, "_screenspaceModeQuad");
    r(this, "_isInScreenspaceMode", !1);
    r(this, "_input");
    this.context = t, this._input = new UA(this);
  }
  get enabled() {
    return this._isInScreenspaceMode;
  }
  set enabled(t) {
    t ? this.start() : this.stop();
  }
  add(t) {
    this._videos.indexOf(t) === -1 && this._videos.push(t);
  }
  remove(t) {
    if (!t)
      return;
    const e = this._videos.indexOf(t);
    e >= 0 && this._videos.splice(e, 1);
  }
  start() {
    var n;
    if (this._isInScreenspaceMode || this._videos.length < 0)
      return;
    const t = this._videos[this._videos.length - 1];
    if (!t)
      return;
    if (this._isInScreenspaceMode = !0, !this._screenspaceModeQuad) {
      if (this._screenspaceModeQuad = Ar.createPrimitive(Na.Quad, {
        material: new NA(t)
      }), !this._screenspaceModeQuad)
        return;
      this._screenspaceModeQuad.geometry.scale(2, 2, 2);
    }
    const e = this._screenspaceModeQuad;
    this.context.scene.add(e), this.updateScreenspaceMaterialUniforms();
    const i = e.material;
    i == null || i.reset(), (n = this._input) == null || n.enable(i);
  }
  stop() {
    var t;
    this._isInScreenspaceMode = !1, this._screenspaceModeQuad && ((t = this._input) == null || t.disable(), this._screenspaceModeQuad.removeFromParent());
  }
  updateScreenspaceMaterialUniforms() {
    var e;
    const t = (e = this._screenspaceModeQuad) == null ? void 0 : e.material;
    t && (t.screenAspect = this.context.domElement.clientWidth / this.context.domElement.clientHeight);
  }
}
class UA {
  constructor(t) {
    r(this, "_onResizeScreenFn");
    r(this, "_onKeyUpFn");
    r(this, "_onMouseWheelFn");
    r(this, "context");
    r(this, "overlay");
    r(this, "_material");
    r(this, "_isPinching", !1);
    r(this, "_lastPinch", 0);
    this.overlay = t, this.context = t.context;
  }
  enable(t) {
    this._material = t, window.addEventListener("resize", this._onResizeScreenFn = () => {
      this.overlay.updateScreenspaceMaterialUniforms();
    }), window.addEventListener("keyup", this._onKeyUpFn = (n) => {
      n.key === "Escape" && this.overlay.stop();
    }), window.addEventListener("wheel", this._onMouseWheelFn = (n) => {
      this.overlay.enabled && (t.zoom += n.deltaY * 5e-4, n.preventDefault());
    }, { passive: !1 });
    const e = new oe();
    window.addEventListener("mousemove", (n) => {
      if (this.overlay.enabled && this.context.input.getPointerPressed(0)) {
        const o = new oe(n.movementX, n.movementY);
        o.x /= this.context.domElement.clientWidth, o.y /= this.context.domElement.clientHeight, e.set(o.x, o.y), e.multiplyScalar(t.zoom / -this.context.time.deltaTime * 0.01), t.offset = t.offset.add(e);
      }
    }), window.addEventListener("pointermove", (n) => {
      this.overlay.enabled && this.context.input.getPointerPressed(0) && this.context.input.getTouchesPressedCount() === 1 && (e.set(n.movementX, n.movementY), e.multiplyScalar(t.zoom * -this.context.time.deltaTime * 0.05), t.offset = t.offset.add(e));
    });
    let i = 0;
    window.addEventListener("touchstart", (n) => {
      if (n.touches.length < 2) {
        this.context.time.time - i < 0.3 && this.overlay.stop(), i = this.context.time.time;
        return;
      }
      this._isPinching = !0, this._lastPinch = 0;
    }), window.addEventListener("touchmove", (n) => {
      if (!this._isPinching || !this._material)
        return;
      const o = n.touches[0], a = n.touches[1], l = o.clientX - a.clientX, c = o.clientY - a.clientY, h = Math.sqrt(l * l + c * c);
      if (this._lastPinch !== 0) {
        const d = h - this._lastPinch;
        this._material.zoom -= d * 4e-3;
      }
      this._lastPinch = h;
    }), window.addEventListener("touchend", () => {
      this._isPinching = !1;
    });
  }
  disable() {
    this._onResizeScreenFn && (window.removeEventListener("resize", this._onResizeScreenFn), this._onResizeScreenFn = void 0), this._onKeyUpFn && (window.removeEventListener("keyup", this._onKeyUpFn), this._onKeyUpFn = void 0), this._onMouseWheelFn && (window.removeEventListener("wheel", this._onMouseWheelFn), this._onMouseWheelFn = void 0);
  }
}
class NA extends bn {
  // maxZoom : number = 10
  constructor(e) {
    super();
    r(this, "_offset", new oe());
    this.uniforms = {
      map: { value: e },
      screenAspect: { value: 1 },
      offsetScale: { value: new me(0, 0, 1, 1) }
    }, this.vertexShader = `
        uniform sampler2D map;
        uniform float screenAspect;
        uniform vec4 offsetScale;
        varying vec2 vUv;

        void main() {

            gl_Position = vec4( position , 1.0 );
            vUv = uv;
            vUv.y = 1. - vUv.y;

            // fit into screen
            ivec2 res = textureSize(map, 0);
            float videoAspect = float(res.x) / float(res.y);
            float aspect = videoAspect / screenAspect;
            if(aspect >= 1.0) 
            {
                vUv.y = vUv.y * aspect;
                float offset = (1. - aspect) * .5;
                vUv.y = vUv.y + offset;
            }
            else
            {
                vUv.x = vUv.x / aspect;
                float offset = (1. - 1. / aspect) * .5;
                vUv.x = vUv.x + offset;
            }

            vUv.x -= .5;
            vUv.y -= .5;

            vUv.x *= offsetScale.z;
            vUv.y *= offsetScale.z;
            vUv.x += offsetScale.x;
            vUv.y += offsetScale.y;

            vUv.x += .5;
            vUv.y += .5;
        }

        `, this.fragmentShader = `
        uniform sampler2D map;
        varying vec2 vUv;
        void main() {
            if(vUv.x < 0. || vUv.x > 1. || vUv.y < 0. || vUv.y > 1.)
                gl_FragColor = vec4(0., 0., 0., 1.);
            else
            {
                vec4 texcolor = texture2D(map, vUv);
                gl_FragColor = texcolor;
            }
        }
        `;
  }
  set screenAspect(e) {
    this.uniforms.screenAspect.value = e, this.needsUpdate = !0;
  }
  set offset(e) {
    const i = this.uniforms.offsetScale.value;
    i.x = e.x, i.y = e.y, this.uniforms.offsetScale.value = i, this.needsUpdate = !0;
  }
  get offset() {
    const e = this.uniforms.offsetScale.value;
    return this._offset.set(e.x, e.y), this._offset;
  }
  set zoom(e) {
    const i = this.uniforms.offsetScale.value;
    e < 1e-3 && (e = 1e-3), i.z = e, this.needsUpdate = !0;
  }
  get zoom() {
    return this.uniforms.offsetScale.value.z;
  }
  reset() {
    this.offset = this.offset.set(0, 0), this.zoom = 1, this.needsUpdate = !0;
  }
}
var $A = Object.defineProperty, WA = Object.getOwnPropertyDescriptor, wh = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? WA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && $A(t, e, n), n;
};
const Pt = x("debugscreensharing");
var Zw = /* @__PURE__ */ ((s) => (s[s.Screen = 0] = "Screen", s[s.Camera = 1] = "Camera", s[s.Canvas = 2] = "Canvas", s[s.Microphone = 3] = "Microphone", s))(Zw || {});
class $r extends I {
  constructor() {
    super(...arguments);
    r(this, "allowStartOnClick", !0);
    r(this, "autoConnect", !1);
    r(this, "_videoPlayer");
    r(this, "_audioSource");
    r(this, "device", "Screen");
    r(this, "deviceName");
    /**
     * Filter which device should be chosen for sharing by id or label.  
     * Assign a method to this property to manually filter the available devices.  
     */
    r(this, "deviceFilter");
    r(this, "_net");
    r(this, "_requestOpen", !1);
    r(this, "_currentStream", null);
    r(this, "_currentMode", 0);
    r(this, "onJoinedRoom", async () => {
      await Gn(1e3), this.autoConnect && !this.isSending && !this.isReceiving && this.context.connection.isInRoom && this.share();
    });
    r(this, "_activeShareRequest", null);
    r(this, "onReceiveStream", (e) => {
      var i;
      ((i = e.stream) == null ? void 0 : i.active) === !0 && this.setStream(
        e.stream,
        2
        /* Receiving */
      );
    });
    r(this, "onCallEnded", (e) => {
      Pt && console.log("CALL ENDED", this.isReceiving, this == null ? void 0 : this.screenspace), this.isReceiving && (this.screenspace = !1);
    });
  }
  /** @internal */
  onPointerEnter() {
    this.context.connection.allowEditing != !1 && this.allowStartOnClick && this.context.input.setCursor("pointer");
  }
  /** @internal */
  onPointerExit() {
    this.context.connection.allowEditing != !1 && this.allowStartOnClick && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerClick(e) {
    var i;
    if (this.context.connection.allowEditing != !1 && this.allowStartOnClick && !(e && e.pointerId !== 0)) {
      if (this.isReceiving && ((i = this.videoPlayer) != null && i.isPlaying)) {
        this.videoPlayer && (this.videoPlayer.screenspace = !this.videoPlayer.screenspace);
        return;
      }
      if (this.isSending) {
        this.close();
        return;
      }
      this.share();
    }
  }
  set videoPlayer(e) {
    this._videoPlayer && (this.isSending || this.isReceiving) && this._videoPlayer.stop(), this._videoPlayer = e, this._videoPlayer && this._currentStream && (this.isSending || this.isReceiving) && this._videoPlayer.setVideo(this._currentStream);
  }
  get videoPlayer() {
    return this._videoPlayer;
  }
  /**
   * When enabled the video will be displayed in the screenspace of the VideoPlayer component.
   */
  get screenspace() {
    var e;
    return ((e = this.videoPlayer) == null ? void 0 : e.screenspace) ?? !1;
  }
  set screenspace(e) {
    this.videoPlayer && (this.videoPlayer.screenspace = e);
  }
  /**
   * the current stream that is being shared or received  
   * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream
   */
  get currentScream() {
    return this._currentStream;
  }
  get currentMode() {
    return this._currentMode;
  }
  /**
   * @returns true if the component is currently sending a stream
   */
  get isSending() {
    var e;
    return ((e = this._currentStream) == null ? void 0 : e.active) && this._currentMode === 1;
  }
  /**
   * @returns true if the component is currently receiving a stream
   */
  get isReceiving() {
    if (this._currentMode === 2) {
      if (!this._currentStream || this._currentStream.active === !1)
        return !1;
      const e = this._currentStream.getTracks();
      for (const i of e)
        if (i.readyState === "live")
          return !0;
    }
    return !1;
  }
  get requiresVideoPlayer() {
    return this.device !== "Microphone";
  }
  /** @internal */
  awake() {
    typeof this.device == "number" && (this.device = Zw[this.device]), Pt && console.log("Screensharing", this.name, this), qe.registerWaitForAllowAudio(() => {
      this._videoPlayer && this._currentStream && this._currentMode === 2 && (this._videoPlayer.playInBackground = !0, this._videoPlayer.setVideo(this._currentStream));
    }), this._net = new Gu(this);
  }
  /** @internal */
  onEnable() {
    var e, i, n;
    (e = this._net) == null || e.enable(), (i = this._net) == null || i.addEventListener(xs.StreamReceived, this.onReceiveStream), (n = this._net) == null || n.addEventListener(xs.StreamEnded, this.onCallEnded), this.context.connection.beginListen(ne.JoinedRoom, this.onJoinedRoom), this.autoConnect && Gn(1e3).then(() => (this.enabled && this.autoConnect && !this.isReceiving && !this.isSending && this.context.connection.isInRoom && this.share(), 0));
  }
  /** @internal */
  onDisable() {
    var e, i, n;
    (e = this._net) == null || e.removeEventListener(xs.StreamReceived, this.onReceiveStream), (i = this._net) == null || i.removeEventListener(xs.StreamEnded, this.onCallEnded), this.context.connection.stopListen(ne.JoinedRoom, this.onJoinedRoom), (n = this._net) == null || n.disable(), this.close();
  }
  _ensureVideoPlayer() {
    const e = new bt();
    e.aspectMode = Qw.AdjustWidth, S.addComponent(this.gameObject, e), this._videoPlayer = e;
  }
  /** Call to begin screensharing */
  async share(e) {
    return this._activeShareRequest ? this._activeShareRequest : (this._activeShareRequest = this.internalShare(e), this._activeShareRequest.then(() => this._activeShareRequest = null));
  }
  async internalShare(e) {
    if (this.context.connection.isInRoom === !1) {
      console.warn("Can not start screensharing: requires network connection"), z() && ve("Can not start screensharing: requires network connection. Add a SyncedRoom component or join a room first.");
      return;
    }
    if (e != null && e.device && (this.device = e.device), !this.videoPlayer && this.requiresVideoPlayer && (this._videoPlayer || (this._videoPlayer = S.getComponent(this.gameObject, bt) ?? void 0), this.videoPlayer || this._ensureVideoPlayer(), !this.videoPlayer)) {
      console.warn("Can not share video without a videoPlayer assigned");
      return;
    }
    this._requestOpen = !0;
    try {
      const i = (e == null ? void 0 : e.constraints) ?? {
        echoCancellation: !0,
        autoGainControl: !1
      }, n = {
        video: i,
        audio: i
      }, o = n.video;
      switch (o !== void 0 && typeof o != "boolean" && (o.width || (o.width = { max: 1920 }), o.height || (o.height = { max: 1920 }), o.aspectRatio || (o.aspectRatio = { ideal: 1.7777777778 }), o.frameRate || (o.frameRate = { ideal: 24 }), o.facingMode || (o.facingMode = { ideal: "user" })), this.device) {
        case "Camera":
          this.tryShareUserCamera(n, e);
          break;
        case "Screen":
          {
            if (!navigator.mediaDevices.getDisplayMedia) {
              console.error("No getDisplayMedia support");
              return;
            }
            const c = await navigator.mediaDevices.getDisplayMedia(n);
            this._requestOpen ? this.setStream(
              c,
              1
              /* Sending */
            ) : Ss(c);
          }
          break;
        case "Canvas":
          const a = 0, l = this.context.renderer.domElement.captureStream(a);
          this.setStream(
            l,
            1
            /* Sending */
          );
          break;
        case "Microphone":
          {
            if (!navigator.mediaDevices.getUserMedia) {
              console.error("No getDisplayMedia support");
              return;
            }
            n.video = !1;
            const c = await navigator.mediaDevices.getUserMedia(n);
            this._requestOpen ? this.setStream(
              c,
              1
              /* Sending */
            ) : Ss(c);
          }
          break;
        default:
          console.error("Can not start screen sharing: Unknown device type", this.device);
      }
    } catch (i) {
      if (i.name === "NotAllowedError") {
        console.log("Selection cancelled"), this._requestOpen = !1;
        return;
      }
      console.error("Error opening video", i);
    }
  }
  close() {
    var e;
    this._requestOpen = !1, this._currentStream && (Pt && console.warn("Close current stream / disposing resources, stream was active?", this._currentStream.active), (e = this._net) == null || e.stopSendingStream(this._currentStream), Ss(this._currentStream), this._currentMode = 0, this._currentStream = null);
  }
  setStream(e, i) {
    var a, l, c;
    if (e === this._currentStream || (this.close(), !e))
      return;
    this._currentStream = e, this._requestOpen = !0, this._currentMode = i;
    const n = this.device !== "Microphone", o = i === 1;
    n ? (this._videoPlayer || this._ensureVideoPlayer(), this._videoPlayer ? this._videoPlayer.setVideo(e) : console.error("No video player assigned for video stream")) : (this._audioSource || (this._audioSource = new qe(), this._audioSource.spatialBlend = 0, this._audioSource.volume = 1, this.gameObject.addComponent(this._audioSource)), o || (Pt && console.log("PLAY", e.getAudioTracks()), this._audioSource.volume = 1, (a = this._audioSource) == null || a.play(e))), o && ((l = this._net) == null || l.startSendingStream(e)), o && (this._videoPlayer && (this._videoPlayer.muted = !0), (c = this._audioSource) == null || c.stop());
    for (const h of e.getTracks())
      h.addEventListener("ended", () => {
        Pt && console.log("Track ended", h), this.close();
      }), Pt && h.kind === "video" && console.log(o ? "Video →" : "Video ←", h.getSettings());
  }
  async tryShareUserCamera(e, i) {
    const n = (await navigator.mediaDevices.enumerateDevices()).filter((a) => a.kind === "videoinput");
    Pt && console.log(`Request camera. These are your kind:videoinput devices:
`, n);
    let o = !1;
    for (const a of n)
      try {
        if (!this._requestOpen) {
          Pt && console.log("Camera selection cancelled");
          break;
        }
        if (a.kind !== "videoinput") {
          Pt && console.log("Skipping non-video device", a);
          continue;
        }
        const l = a.deviceId;
        if ((i == null ? void 0 : i.deviceId) != null || (i == null ? void 0 : i.deviceFilter) != null) {
          if ((i == null ? void 0 : i.deviceId) !== void 0 && l !== i.deviceId) {
            Pt && console.log("Skipping device due to options.deviceId: " + a.label + "; " + a.deviceId);
            continue;
          }
          if (i != null && i.deviceFilter && i.deviceFilter(a) === !1) {
            Pt && console.log("Skipping device due to options.deviceFilter: " + a.label + "; " + a.deviceId);
            continue;
          }
        } else if (this.deviceFilter)
          if (this.deviceFilter(a) === !1) {
            Pt && console.log("Skipping device due to ScreenShare.deviceFilter: " + a.label + "; " + a.deviceId);
            continue;
          } else
            Pt && console.log("Selected device by filter", a);
        else if (this.deviceName) {
          const d = a.label.toLowerCase(), u = this.deviceName.toLowerCase(), p = d.includes(u), m = a.deviceId === this.deviceName;
          if (!p && !m) {
            Pt && console.log("Skipping device due to ScreenShare.deviceName: " + a.label + "; " + a.deviceId);
            continue;
          } else
            Pt && console.log("Selected device by name", a);
        }
        e.video !== !1 && ((typeof e.video > "u" || typeof e.video == "boolean") && (e.video = {}), e.video.deviceId = l), o = !0;
        const h = await navigator.mediaDevices.getUserMedia(e).catch((d) => (console.error("Failed to get user media", d), null));
        if (h === null)
          continue;
        this._requestOpen ? (this.setStream(
          h,
          1
          /* Sending */
        ), Pt && console.log("Selected camera", a)) : (Ss(h), Pt && console.log("Camera selection cancelled"));
        break;
      } catch (l) {
        if (l.message === "Failed to allocate videosource" || l.message === "Could not start video source") {
          ve("Failed to start video: Try another camera (Code " + l.code + ")"), console.warn(l);
          continue;
        } else
          console.error("Failed to get user media", l.message, l.code, l);
      }
    !o && z() && (ve("No camera found for sharing. Please connect a camera (see console for more information)"), console.warn("No camera found for sharing. Please connect a camera", n, this.deviceName, "Using deviceFilter? " + this.deviceFilter != null, "Using options? " + i != null, "Using deviceName? " + this.deviceName != null, "Using options.deviceId? " + (i == null ? void 0 : i.deviceId) != null, "Using options.deviceFilter? " + (i == null ? void 0 : i.deviceFilter) != null));
  }
  // private _cameraSelectionWindow : Window | null = null;
  // private openWindowToSelectCamera(){
  // }
}
wh([
  f()
], $r.prototype, "allowStartOnClick", 2);
wh([
  f()
], $r.prototype, "autoConnect", 2);
wh([
  f(bt)
], $r.prototype, "videoPlayer", 1);
wh([
  f()
], $r.prototype, "device", 2);
wh([
  f()
], $r.prototype, "deviceName", 2);
var VA = Object.defineProperty, HA = Object.getOwnPropertyDescriptor, Jw = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? HA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && VA(t, e, n), n;
};
class uf extends I {
  constructor() {
    super(...arguments);
    r(this, "mode", 0);
    r(this, "shadowColor", new we(0, 0, 0, 1));
    r(this, "targetMesh");
  }
  /** @internal */
  start() {
    if (this.gameObject instanceof q)
      this.gameObject instanceof q && this.gameObject.material && (this.gameObject.material = this.gameObject.material.clone(), this.targetMesh = this.gameObject, this.targetMesh.receiveShadow = !0);
    else {
      const e = Ar.createPrimitive(Na.Quad, {
        name: "ShadowCatcher",
        material: new It({
          // HACK heuristic to get approx. the same colors out as with the current default ShadowCatcher material
          // not clear why this is needed; assumption is that the Renderer component does something we're not respecting here
          color: 10066329,
          roughness: 1,
          metalness: 0,
          transparent: !0
        })
      });
      e.receiveShadow = !0, e.geometry.rotateX(-Math.PI / 2), this.gameObject.add(e), this.targetMesh = e;
    }
    if (!this.targetMesh) {
      console.warn("ShadowCatcher: no mesh to apply shadow catching to. Groups are currently not supported.");
      return;
    }
    switch (this.targetMesh.layers.set(2), this.mode) {
      case 0:
        this.applyShadowMaterial();
        break;
      case 1:
        this.applyLightBlendMaterial();
        break;
      case 2:
        this.applyOccluderMaterial();
        break;
    }
  }
  // Custom blending, diffuse-only lighting blended onto the scene additively.
  // Works great for Point Lights and spot lights, 
  // doesn't work for directional lights (since they're lighting up everything else).
  // Works even better with an additional black-ish gradient to darken parts of the AR scene
  // so that lights become more visible on bright surfaces.
  applyLightBlendMaterial() {
    if (!this.targetMesh)
      return;
    const e = this.targetMesh.material;
    e.blending = o0, this.applyMaterialOptions(e), e.onBeforeCompile = (i) => {
      i.fragmentShader = i.fragmentShader.replace(
        "vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;",
        `vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
            // diffuse-only lighting with overdrive to somewhat compensate
            // for the loss of indirect lighting and to make it more visible.
            vec3 direct = (reflectedLight.directDiffuse + reflectedLight.directSpecular) * 6.6;
            float max = max(direct.r, max(direct.g, direct.b));
            
            // early out - we're simply returning direct lighting and some alpha based on it so it can 
            // be blended onto the scene.
            gl_FragColor = vec4(direct, max);
            return;
            `
      );
    }, e.userData.isLightBlendMaterial = !0;
  }
  // ShadowMaterial: only does a mask; shadowed areas are fully black.
  // doesn't take light attenuation into account.
  // works great for Directional Lights.
  applyShadowMaterial() {
    if (this.targetMesh)
      if (this.targetMesh.material.type !== "ShadowMaterial") {
        const e = new Yb();
        e.color = this.shadowColor, e.opacity = this.shadowColor.alpha, this.applyMaterialOptions(e), this.targetMesh.material = e, e.userData.isShadowCatcherMaterial = !0;
      } else {
        const e = this.targetMesh.material;
        e.color = this.shadowColor, e.opacity = this.shadowColor.alpha, this.applyMaterialOptions(e), e.userData.isShadowCatcherMaterial = !0;
      }
  }
  applyOccluderMaterial() {
    if (this.targetMesh) {
      let e = this.targetMesh.material;
      if (!e) {
        const i = new Me();
        this.targetMesh.material = i, e = i;
      }
      e.depthWrite = !0, e.stencilWrite = !0, e.colorWrite = !1, this.gameObject.renderOrder = -100;
    }
  }
  applyMaterialOptions(e) {
    e && (e.depthWrite = !1, e.stencilWrite = !1);
  }
}
Jw([
  f()
], uf.prototype, "mode", 2);
Jw([
  f(we)
], uf.prototype, "shadowColor", 2);
var GA = Object.defineProperty, qA = Object.getOwnPropertyDescriptor, xh = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? qA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && GA(t, e, n), n;
};
const qi = x("debugskybox");
f_("skybox-image");
f_("environment-image");
function jb(s, t, e, i, n) {
  const o = new Is();
  o.allowDrop = !1, o.allowNetworking = !1, o.background = e, o.environment = i, S.addComponent(s.scene, o);
  const a = (l) => {
    typeof l == "string" && (qi && console.log(n, "CHANGED TO", l), o.setSkybox(l));
  };
  return BS(s.domElement, n, a), o.addEventListener("destroy", () => {
    qi && console.log("Destroyed attribute remote skybox", n), FS(s.domElement, n, a);
  }), o.setSkybox(t);
}
const su = new Array();
fe.registerCallback(pe.ContextCreationStart, (s) => {
  var n;
  const t = s.context, e = t.domElement.getAttribute("skybox-image") || t.domElement.getAttribute("background-image"), i = t.domElement.getAttribute("environment-image");
  if (e) {
    qi && console.log("Creating remote skybox to load " + e), ((n = t.mainCameraComponent) == null ? void 0 : n.clearFlags) !== _r.Skybox && console.warn('"skybox-image"/"background-image" attribute has no effect: camera clearflags are not set to "Skybox"');
    const o = jb(t, e, !0, !1, "skybox-image");
    su.push(o);
  }
  if (i) {
    qi && console.log("Creating remote environment to load " + i);
    const o = jb(t, i, !1, !0, "environment-image");
    su.push(o);
  }
});
fe.registerCallback(pe.ContextCreationStart, () => Promise.all(su).finally(() => {
  su.length = 0;
}));
function ex() {
  return globalThis.NEEDLE_ENGINE_SKYBOX_TEXTURES || (globalThis.NEEDLE_ENGINE_SKYBOX_TEXTURES = new Array()), globalThis.NEEDLE_ENGINE_SKYBOX_TEXTURES;
}
function Bb(s) {
  const e = ex().find((i) => i.src === s);
  return e ? (qi && console.log("Skybox: Found previously loaded texture for " + s), e.texture) : null;
}
async function XA(s) {
  const t = await s;
  J0(t, !0), Ae(t);
}
function QA(s, t) {
  const e = ex();
  for (; e.length > 5; ) {
    const i = e.shift();
    i && XA(i.texture);
  }
  t.then((i) => J0(i, !1)), e.push({ src: s, texture: t });
}
class Is extends I {
  constructor() {
    super(...arguments);
    r(this, "url");
    r(this, "allowDrop", !0);
    r(this, "background", !0);
    r(this, "environment", !0);
    r(this, "allowNetworking", !0);
    r(this, "_loader");
    r(this, "_prevUrl");
    r(this, "_prevLoadedEnvironment");
    r(this, "_prevEnvironment", null);
    r(this, "_prevBackground", null);
    r(this, "validTextureTypes", [".ktx2", ".hdr", ".exr", ".jpg", ".jpeg", ".png"]);
    r(this, "onDragOverEvent", (e) => {
      if (this.allowDrop && e.dataTransfer)
        for (const i of e.dataTransfer.types)
          (i === "text/uri-list" || i === "Files") && e.preventDefault();
    });
    r(this, "onDrop", (e) => {
      var i, n, o, a;
      if (this.allowDrop && e.dataTransfer) {
        for (const l of e.dataTransfer.types)
          if (qi && console.log(l), l === "text/uri-list") {
            const c = e.dataTransfer.getData(l);
            qi && console.log(l, c);
            let h = (n = (i = new RegExp(/polyhaven.com\/asset_img\/.+?\/(?<name>.+)\.png/).exec(c)) == null ? void 0 : i.groups) == null ? void 0 : n.name;
            if (h || (h = (a = (o = new RegExp(/polyhaven\.com\/a\/(?<name>.+)/).exec(c)) == null ? void 0 : o.groups) == null ? void 0 : a.name), qi && console.log(h), h) {
              const d = "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/" + h + "_1k.exr";
              console.log(`[Remote Skybox] Setting skybox from url: ${d}`), e.preventDefault(), this.setSkybox(d);
              break;
            } else if (this.isValidTextureType(c)) {
              console.log("[Remote Skybox] Setting skybox from url: " + c), e.preventDefault(), this.setSkybox(c);
              break;
            } else {
              console.warn(`[RemoteSkybox] Unknown url ${c}. If you want to load a skybox from a url, make sure it is a valid image url. Url must end with${this.validTextureTypes.join(", ")}.`);
              const d = new CustomEvent("dropped-unknown-url", {
                detail: {
                  sender: this,
                  event: e,
                  url: c,
                  apply: (u) => {
                    e.preventDefault(), this.setSkybox(u);
                  }
                }
              });
              this.dispatchEvent(d);
            }
          } else if (l == "Files") {
            const c = e.dataTransfer.files.item(0);
            if (qi && console.log(l, c), !c)
              continue;
            if (!this.isValidTextureType(c.name)) {
              console.warn(`[RemoteSkybox]: File "${c.name}" is not supported. Supported files are ${this.validTextureTypes.join(", ")}`);
              return;
            }
            if (Bb(c.name) === null) {
              const h = new Blob([c]), d = URL.createObjectURL(h);
              e.preventDefault(), this.setSkybox(d, c.name);
            } else
              e.preventDefault(), this.setSkybox(c.name);
            break;
          }
      }
    });
  }
  /** @internal */
  onEnable() {
    this.setSkybox(this.url), this.registerDropEvents();
  }
  /** @internal */
  onDisable() {
    var e;
    this.context.scene.environment === this._prevLoadedEnvironment && (this.context.scene.environment = this._prevEnvironment, Pe.backgroundShouldBeTransparent(this.context) || (this.context.scene.background = this._prevBackground), this._prevLoadedEnvironment = void 0), this.unregisterDropEvents(), (e = this.context.mainCameraComponent) == null || e.applyClearFlags();
  }
  urlChangedSyncField() {
    this.allowNetworking && this.url && this.isRemoteTexture(this.url) && this.setSkybox(this.url);
  }
  /**
   * Set the skybox from a given url
   * @param url The url of the skybox image
   * @param name Define name of the file with extension if it isn't apart of the url
   * @returns Whether the skybox was successfully set
   */
  async setSkybox(e, i) {
    var a;
    if (!this.activeAndEnabled || (e = YA(e, this.environment, this.background), !e))
      return !1;
    if (i ?? (i = e), this.isValidTextureType(i) || console.warn("Potentially invalid skybox url", i, "on", this.name), qi && console.log("Set remote skybox url: " + e), this._prevUrl === e && this._prevLoadedEnvironment)
      return this.applySkybox(), !0;
    (a = this._prevLoadedEnvironment) == null || a.dispose(), this._prevLoadedEnvironment = void 0, this._prevUrl = e;
    const n = await this.loadTexture(e, i);
    if (!n || !this.enabled)
      return !1;
    this.url = e;
    const o = e.lastIndexOf("/");
    return n.name = e.substring(o >= 0 ? o + 1 : 0), this._loader instanceof wa && (n.colorSpace = vn), this._prevLoadedEnvironment = n, this.applySkybox(), !0;
  }
  async loadTexture(e, i) {
    var d, u, p, m, g;
    if (!e)
      return Promise.resolve(null);
    i ?? (i = e);
    const n = Bb(i);
    if (n) {
      const _ = await n;
      if (((u = (d = _.source) == null ? void 0 : d.data) == null ? void 0 : u.length) > 0 || (g = (m = (p = _.source) == null ? void 0 : p.data) == null ? void 0 : m.data) != null && g.length)
        return _;
    }
    const o = i.endsWith(".exr"), a = i.endsWith(".hdr"), l = i.endsWith(".ktx2");
    if (o)
      this._loader instanceof Ld || (this._loader = new Ld());
    else if (a)
      this._loader instanceof em || (this._loader = new em());
    else if (l) {
      if (!(this._loader instanceof cS)) {
        const { ktx2Loader: _ } = hg(this.context.renderer);
        this._loader = _;
      }
    } else
      this._loader instanceof wa || (this._loader = new wa());
    qi && console.log("Loading skybox: " + e);
    const c = this._loader.loadAsync(e);
    return QA(i, c), await c;
  }
  applySkybox() {
    var i;
    const e = this._prevLoadedEnvironment;
    e && (e instanceof j1 || e instanceof B1 || (e.mapping = F1, e.needsUpdate = !0), this.context.scene.background !== e && (this._prevBackground = this.context.scene.background), this.context.scene.environment !== e && (this._prevEnvironment = this.context.scene.environment), qi && console.log("Set remote skybox", this.url, !Pe.backgroundShouldBeTransparent(this.context)), this.environment && (this.context.scene.environment = e), this.background && !Pe.backgroundShouldBeTransparent(this.context) && (this.context.scene.background = e), ((i = this.context.mainCameraComponent) == null ? void 0 : i.backgroundBlurriness) !== void 0 && (this.context.scene.backgroundBlurriness = this.context.mainCameraComponent.backgroundBlurriness));
  }
  isRemoteTexture(e) {
    return e.startsWith("http://") || e.startsWith("https://");
  }
  isValidTextureType(e) {
    for (const i of this.validTextureTypes)
      if (e.endsWith(i))
        return !0;
    return !1;
  }
  registerDropEvents() {
    this.unregisterDropEvents(), this.context.domElement.addEventListener("dragover", this.onDragOverEvent), this.context.domElement.addEventListener("drop", this.onDrop);
  }
  unregisterDropEvents() {
    this.context.domElement.removeEventListener("dragover", this.onDragOverEvent), this.context.domElement.removeEventListener("drop", this.onDrop);
  }
}
xh([
  xw(Is.prototype.urlChangedSyncField),
  f(URL)
], Is.prototype, "url", 2);
xh([
  f()
], Is.prototype, "allowDrop", 2);
xh([
  f()
], Is.prototype, "background", 2);
xh([
  f()
], Is.prototype, "environment", 2);
xh([
  f()
], Is.prototype, "allowNetworking", 2);
function YA(s, t, e) {
  const i = t && !e;
  switch (s == null ? void 0 : s.toLowerCase()) {
    case "studio":
      return i ? "https://cdn.needle.tools/static/skybox/modelviewer-Neutral-small.hdr" : "https://cdn.needle.tools/static/skybox/modelviewer-Neutral.hdr";
    case "blurred-skybox":
      return i ? "https://cdn.needle.tools/static/skybox/blurred-skybox-small.exr" : "https://cdn.needle.tools/static/skybox/blurred-skybox.exr";
    case "quicklook-ar":
      return i ? "https://cdn.needle.tools/static/skybox/QuickLook-ARMode-small.exr" : "https://cdn.needle.tools/static/skybox/QuickLook-ARMode.exr";
    case "quicklook":
      return i ? "https://cdn.needle.tools/static/skybox/QuickLook-ObjectMode-small.exr" : "https://cdn.needle.tools/static/skybox/QuickLook-ObjectMode.exr";
  }
  return s === void 0 ? null : s;
}
var KA = Object.defineProperty, ZA = Object.getOwnPropertyDescriptor, ff = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? ZA(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && KA(t, e, n), n;
}, Wp;
const tx = (Wp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "target", null);
    r(this, "followFactor", 0.1);
    r(this, "rotateFactor", 0.1);
    r(this, "positionAxes", Ql.All);
    r(this, "flipForward", !1);
    r(this, "_firstUpdate", !0);
  }
  /**
   * Update the position and rotation of the GameObject to follow the target.
   */
  onBeforeRender() {
    this.updateNow(!1);
  }
  updateNow(t) {
    if (!(!this.target || this.target === this.gameObject)) {
      if (this.followFactor > 0) {
        const e = ie(this.target), i = this._firstUpdate || t ? 1 : $.clamp01(this.context.time.deltaTime * this.followFactor), n = this.worldPosition;
        this.positionAxes & Ql.X && (n.x = $.lerp(n.x, e.x, i)), this.positionAxes & Ql.Y && (n.y = $.lerp(n.y, e.y, i)), this.positionAxes & Ql.Z && (n.z = $.lerp(n.z, e.z, i)), this.worldPosition = n;
      }
      if (this.rotateFactor > 0) {
        const e = Ce(this.target);
        this.flipForward && e.premultiply(tx._invertForward);
        const i = this._firstUpdate || t ? 1 : $.clamp01(this.context.time.deltaTime * this.rotateFactor);
        this.worldQuaternion = this.worldQuaternion.slerp(e, i);
      }
      this._firstUpdate = !1;
    }
  }
}, r(Wp, "_invertForward", new W().setFromAxisAngle(new v(0, 1, 0), Math.PI)), Wp);
let Wr = tx;
ff([
  f(L)
], Wr.prototype, "target", 2);
ff([
  f()
], Wr.prototype, "followFactor", 2);
ff([
  f()
], Wr.prototype, "rotateFactor", 2);
ff([
  f()
], Wr.prototype, "positionAxes", 2);
var JA = Object.defineProperty, eE = Object.getOwnPropertyDescriptor, Sh = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? eE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && JA(t, e, n), n;
};
const vc = x("debugspatialtrigger"), Fb = new vo(), zb = new vo();
function tE(s, t) {
  return Fb.mask = s, zb.mask = t, Fb.test(zb);
}
class Rs extends I {
  constructor() {
    super(...arguments);
    r(this, "triggerMask", 0);
    r(this, "onEnter");
    r(this, "onStay");
    r(this, "onExit");
    /** Array of triggers currently intersecting with this receiver */
    r(this, "currentIntersected", []);
    /** Array of triggers that intersected with this receiver in the previous frame */
    r(this, "lastIntersected", []);
  }
  /** 
   * Initializes the receiver and logs debug info if enabled
   * @internal
   */
  start() {
    vc && console.log(this.name, this.triggerMask, this);
  }
  /**
   * Checks for intersections with spatial triggers and fires appropriate events
   * Handles enter, stay, and exit events for all relevant triggers
   * @internal
   */
  update() {
    this.currentIntersected.length = 0;
    for (const e of pf.triggers)
      tE(e.triggerMask, this.triggerMask) && e.test(this.gameObject) && this.currentIntersected.push(e);
    for (let e = this.lastIntersected.length - 1; e >= 0; e--) {
      const i = this.lastIntersected[e];
      this.currentIntersected.indexOf(i) < 0 && (this.onExitTrigger(i), this.lastIntersected.splice(e, 1));
    }
    for (const e of this.currentIntersected)
      this.lastIntersected.indexOf(e) < 0 && this.onEnterTrigger(e), this.onStayTrigger(e);
    this.lastIntersected.length = 0, this.lastIntersected.push(...this.currentIntersected);
  }
  /**
   * Handles trigger enter events.
   * @param trigger The spatial trigger that was entered
   */
  onEnterTrigger(e) {
    var i;
    vc && console.log("ENTER TRIGGER", this.name, e.name, this, e), e.raiseOnEnterEvent(this), (i = this.onEnter) == null || i.invoke();
  }
  /**
   * Handles trigger exit events.
   * @param trigger The spatial trigger that was exited
   */
  onExitTrigger(e) {
    var i;
    vc && console.log("EXIT TRIGGER", this.name, e.name), e.raiseOnExitEvent(this), (i = this.onExit) == null || i.invoke();
  }
  /**
   * Handles trigger stay events.
   * @param trigger The spatial trigger that the receiver is staying in
   */
  onStayTrigger(e) {
    var i;
    e.raiseOnStayEvent(this), (i = this.onStay) == null || i.invoke();
  }
}
Sh([
  f()
], Rs.prototype, "triggerMask", 2);
Sh([
  f(xe)
], Rs.prototype, "onEnter", 2);
Sh([
  f(xe)
], Rs.prototype, "onStay", 2);
Sh([
  f(xe)
], Rs.prototype, "onExit", 2);
var Vp;
const Ad = (Vp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "triggerMask");
    /** Box helper component used to visualize and calculate the trigger area */
    r(this, "boxHelper");
  }
  /**
   * Initializes the trigger and logs debug info if enabled
   */
  start() {
    vc && console.log(this.name, this.triggerMask, this);
  }
  /**
   * Registers this trigger in the global registry and sets up debug visualization if enabled
   */
  onEnable() {
    var t;
    Ad.triggers.push(this), this.boxHelper || (this.boxHelper = S.addComponent(this.gameObject, wi), (t = this.boxHelper) == null || t.showHelper(null, vc));
  }
  /**
   * Removes this trigger from the global registry when disabled
   */
  onDisable() {
    Ad.triggers.splice(Ad.triggers.indexOf(this), 1);
  }
  /**
   * Tests if an object is inside this trigger's box
   * @param obj The object to test against this trigger
   * @returns True if the object is inside the trigger box
   */
  test(t) {
    return this.boxHelper ? this.boxHelper.isInBox(t) ?? !1 : !1;
  }
  // private args: SpatialTriggerEventArgs = new SpatialTriggerEventArgs();
  /**
   * Raises the onEnter event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that entered this trigger
   */
  raiseOnEnterEvent(t) {
    S.foreachComponent(this.gameObject, (e) => {
      e !== t && e instanceof Rs && e.onEnterTrigger(this);
    }, !1);
  }
  /**
   * Raises the onStay event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that is staying in this trigger
   */
  raiseOnStayEvent(t) {
    S.foreachComponent(this.gameObject, (e) => {
      e !== t && e instanceof Rs && e.onStayTrigger(this);
    }, !1);
  }
  /**
   * Raises the onExit event on any SpatialTriggerReceiver components attached to this trigger's GameObject
   * @param rec The receiver that exited this trigger
   */
  raiseOnExitEvent(t) {
    S.foreachComponent(this.gameObject, (e) => {
      e !== t && e instanceof Rs && e.onExitTrigger(this);
    }, !1);
  }
}, /** Global registry of all active spatial triggers in the scene */
r(Vp, "triggers", []), Vp);
let pf = Ad;
Sh([
  f()
], pf.prototype, "triggerMask", 2);
var iE = Object.defineProperty, nE = Object.getOwnPropertyDescriptor, sE = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? nE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && iE(t, e, n), n;
};
const xi = x("debugspectator");
class p_ extends I {
  constructor() {
    super(...arguments);
    /** Reference to the Camera component on this GameObject */
    r(this, "cam", null);
    r(this, "useKeys", !0);
    r(this, "_mode", 0);
    // private currentViewport : Vector4 = new Vector4();
    // private currentScissor : Vector4 = new Vector4();
    // private currentScissorTest : boolean = false;
    r(this, "orbit", null);
    r(this, "_handler");
    r(this, "eventSub_WebXRRequestStartEvent", null);
    r(this, "eventSub_WebXRStartEvent", null);
    r(this, "eventSub_WebXREndEvent", null);
    r(this, "_debug");
    r(this, "_networking");
  }
  /** Gets the current spectator perspective mode */
  get mode() {
    return this._mode;
  }
  /** Sets the current spectator perspective mode */
  set mode(e) {
    this._mode = e;
  }
  /** Returns whether this user is currently spectating another user */
  get isSpectating() {
    var e;
    return ((e = this._handler) == null ? void 0 : e.currentTarget) !== void 0;
  }
  /**
   * Checks if this instance is spectating the user with the given ID
   * @param userId The user ID to check
   * @returns True if spectating the specified user, false otherwise
   */
  isSpectatingUser(e) {
    var i;
    return ((i = this.target) == null ? void 0 : i.userId) === e;
  }
  /**
   * Checks if the user with the specified ID is following this user
   * @param userId The user ID to check
   * @returns True if the specified user is following this user, false otherwise
   */
  isFollowedBy(e) {
    var i;
    return (i = this.followers) == null ? void 0 : i.includes(e);
  }
  /** List of user IDs that are currently following the user */
  get followers() {
    return this._networking.followers;
  }
  /** Stops the current spectating session */
  stopSpectating() {
    if (this.context.isInXR) {
      this.followSelf();
      return;
    }
    this.target = void 0;
  }
  /** Gets the local player's connection ID */
  get localId() {
    return this.context.connection.connectionId ?? "local";
  }
  /** 
   * Sets the player view to follow
   * @param target The PlayerView to follow, or undefined to stop spectating
   */
  set target(e) {
    var i;
    if (this._handler) {
      const n = (i = this._handler.currentTarget) == null ? void 0 : i.userId, o = this.context.players.getPlayerView(this.localId);
      e === void 0 || this.context.isInXR === !1 && (o == null ? void 0 : o.currentObject) === e.currentObject ? this._handler.currentTarget !== void 0 && (this._handler.disable(), S.setActive(this.gameObject, !1), this.orbit && (this.orbit.enabled = !0), this._networking.onSpectatedObjectChanged(e, n)) : this._handler.currentTarget !== e && (this._handler.set(e), S.setActive(this.gameObject, !0), this.orbit && (this.orbit.enabled = !1), this._networking.onSpectatedObjectChanged(e, n));
    }
  }
  /** Gets the currently followed player view */
  get target() {
    var e;
    return (e = this._handler) == null ? void 0 : e.currentTarget;
  }
  /** Sends a network request for all users to follow this player */
  requestAllFollowMe() {
    this._networking.onRequestFollowMe();
  }
  /** Determines if the camera is spectating the local player */
  get isSpectatingSelf() {
    var e, i;
    return this.isSpectating && ((e = this.target) == null ? void 0 : e.currentObject) === ((i = this.context.players.getPlayerView(this.localId)) == null ? void 0 : i.currentObject);
  }
  awake() {
    if (this._debug = new aE(this.context, this), this._networking = new hE(this.context, this), this._networking.awake(), S.setActive(this.gameObject, !1), this.cam = S.getComponent(this.gameObject, Pe), !this.cam) {
      console.warn("SpectatorCamera: Spectator camera needs camera component on the same object.", this);
      return;
    }
    !this._handler && this.cam && (this._handler = new oE(this.context, this.cam, this)), this.orbit = S.getComponent(this.context.mainCamera, be);
  }
  onDestroy() {
    var e, i;
    this.stopSpectating(), (e = this._handler) == null || e.destroy(), (i = this._networking) == null || i.destroy();
  }
  /**
   * Checks if the current platform supports spectator mode
   * @returns True if the platform is supported, false otherwise
   */
  isSupportedPlatform() {
    const e = window.navigator.userAgent, i = /Windows|MacOS/.test(e), n = /Windows NT/.test(e) && /Edg/.test(e) && !/Win64/.test(e);
    return i && !n;
  }
  /**
   * Called before entering WebXR mode
   * @param _evt The WebXR event
   */
  onBeforeXR(e) {
    this.isSupportedPlatform() && S.setActive(this.gameObject, !0);
  }
  /**
   * Called when entering WebXR mode
   * @param _evt The WebXR event
   */
  onEnterXR(e) {
    this.isSupportedPlatform() && (xi && console.log(this.context.mainCamera), this.context.mainCamera && this.followSelf());
  }
  /**
   * Called when exiting WebXR mode
   * @param _evt The WebXR event
   */
  onLeaveXR(e) {
    var i, n;
    this.context.removeCamera(this.cam), S.setActive(this.gameObject, !1), this.orbit && (this.orbit.enabled = !0), (i = this._handler) == null || i.set(void 0), (n = this._handler) == null || n.disable(), this.isSpectatingSelf && this.stopSpectating();
  }
  /**
   * Sets the target to follow the local player
   */
  followSelf() {
    this.target = this.context.players.getPlayerView(this.context.connection.connectionId), this.target || (this.context.players.setPlayerView(this.localId, this.context.mainCamera, dr.Headset), this.target = this.context.players.getPlayerView(this.localId)), xi && console.log("Follow self", this.target);
  }
  // TODO: only show Spectator cam for DesktopVR;
  // don't show for AR, don't show on Quest
  // TODO: properly align cameras on enter/exit VR, seems currently spectator cam breaks alignment
  /**
   * Called after the main rendering pass to render the spectator view
   */
  onAfterRender() {
    var d, u, p;
    if (!this.cam)
      return;
    const e = this.context.renderer, i = e.xr.enabled;
    if (!e.xr.isPresenting && !((d = this._handler) != null && d.currentTarget))
      return;
    (u = this._handler) == null || u.update(this._mode);
    const n = e.getRenderTarget();
    let o = null;
    const a = e.state;
    if (!n) {
      if (!e.state.bindFramebuffer || !a.bindXRFramebuffer)
        return;
      o = e._framebuffer, a.bindXRFramebuffer(null);
    }
    this.setAvatarFlagsBeforeRender();
    const l = this.context.mainCameraComponent;
    if (l) {
      const m = l.backgroundColor;
      m && e.setClearColor(m, m.alpha), this.cam.backgroundColor = m, this.cam.clearFlags = l.clearFlags, this.cam.nearClipPlane = l.nearClipPlane, this.cam.farClipPlane = l.farClipPlane;
    } else
      e.setClearColor(new ae(1, 1, 1));
    e.setRenderTarget(null), e.xr.enabled = !1;
    const c = (p = this.cam) == null ? void 0 : p.threeCamera;
    this.context.updateAspect(c);
    const h = e.xr.isPresenting;
    e.xr.isPresenting = !1, e.setSize(this.context.domWidth, this.context.domHeight), e.render(this.context.scene, c), e.xr.isPresenting = h, e.xr.enabled = i, n ? e.setRenderTarget(n) : a.bindXRFramebuffer && a.bindXRFramebuffer(o), this.resetAvatarFlags();
  }
  /**
   * Updates avatar visibility flags for rendering in spectator mode
   */
  setAvatarFlagsBeforeRender() {
    const e = this._mode === 0;
    for (const i of _t.instances)
      if (i.avatar && "isLocalAvatar" in i.avatar && "flags" in i.avatar) {
        let n = ws.All;
        this.isSpectatingSelf && (n = e && i.avatar.isLocalAvatar ? ws.FirstPerson : ws.ThirdPerson);
        const o = i.avatar.flags;
        if (!o)
          continue;
        for (const a of o)
          a.UpdateVisible(n);
      }
  }
  /**
   * Restores avatar visibility flags after spectator rendering
   */
  resetAvatarFlags() {
    var e;
    for (const i of _t.instances)
      if (i.avatar && "flags" in i.avatar) {
        const n = i.avatar.flags;
        if (!n)
          continue;
        for (const o of n)
          "isLocalAvatar" in i.avatar && ((e = i.avatar) != null && e.isLocalAvatar) ? o.UpdateVisible(ws.FirstPerson) : o.UpdateVisible(ws.ThirdPerson);
      }
  }
}
sE([
  f()
], p_.prototype, "useKeys", 2);
class oE {
  constructor(t, e, i) {
    r(this, "context");
    r(this, "cam");
    r(this, "spectator");
    r(this, "follow");
    r(this, "target");
    r(this, "view");
    r(this, "currentObject");
    this.context = t, this.cam = e, this.spectator = i;
  }
  /** Gets the currently targeted player view */
  get currentTarget() {
    return this.view;
  }
  /**
   * Sets the target player view to follow
   * @param view The PlayerView to follow
   */
  set(t) {
    const e = t == null ? void 0 : t.currentObject;
    if (!e) {
      this.spectator.stopSpectating();
      return;
    }
    e !== this.currentObject && (this.currentObject = e, this.view = t, this.follow || (this.follow = S.addComponent(this.cam.gameObject, Wr)), this.target || (this.target = new L()), e.add(this.target), this.follow.enabled = !0, this.follow.target = this.target, xi && console.log("FOLLOW", e), this.context.isInXR ? this.context.removeCamera(this.cam) : this.context.setCurrentCamera(this.cam));
  }
  /** Disables the spectator following behavior */
  disable() {
    xi && console.log("STOP FOLLOW", this.currentObject), this.view = void 0, this.currentObject = void 0, this.context.removeCamera(this.cam), this.follow && (this.follow.enabled = !1);
  }
  /** Cleans up resources used by the handler */
  destroy() {
    var t;
    (t = this.target) == null || t.removeFromParent(), this.follow && S.destroy(this.follow);
  }
  /**
   * Updates the camera position and orientation based on the spectator mode
   * @param mode The current spectator mode (first or third person)
   */
  update(t) {
    var n, o, a, l, c, h;
    if (((n = this.currentTarget) == null ? void 0 : n.isConnected) === !1 || ((o = this.currentTarget) == null ? void 0 : o.removed) === !0) {
      xi && console.log("Target disconnected or timeout", this.currentTarget), this.spectator.stopSpectating();
      return;
    }
    this.currentTarget && ((a = this.currentTarget) == null ? void 0 : a.currentObject) !== this.currentObject && (xi && console.log("Target changed", this.currentObject, "to", this.currentTarget.currentObject), this.set(this.currentTarget));
    const e = this.context.mainCamera;
    if (e) {
      const d = this.cam.threeCamera;
      (d.near !== e.near || d.far !== e.far) && (d.near = e.near, d.far = e.far, d.updateProjectionMatrix());
    }
    const i = (l = this.follow) == null ? void 0 : l.target;
    if (!(!i || !this.follow)) {
      switch (t) {
        case 0:
          ((c = this.view) == null ? void 0 : c.viewDevice) !== dr.Browser ? (this.follow.followFactor = 5, this.follow.rotateFactor = 5) : (this.follow.followFactor = 50, this.follow.rotateFactor = 50), i.position.set(0, 0, 0);
          break;
        case 1:
          this.follow.followFactor = 3, this.follow.rotateFactor = 2, i.position.set(0, 0.5, 1.5);
          break;
      }
      this.follow.flipForward = !1, ((h = this.view) == null ? void 0 : h.viewDevice) !== dr.Browser ? i.quaternion.copy(rE) : i.quaternion.identity();
    }
  }
}
const rE = new W().setFromAxisAngle(new v(0, 1, 0), Math.PI);
class aE {
  constructor(t, e) {
    r(this, "context");
    r(this, "spectator");
    this.context = t, this.spectator = e, console.log("[Spectator Camera] Click other avatars or cameras to follow them. Press ESC to exit spectator mode."), this.context.domElement.addEventListener("keydown", (n) => {
      if (!this.spectator.useKeys)
        return;
      n.key === "Escape" && this.spectator.stopSpectating();
    });
    let i = 0;
    this.context.input.addEventListener(Ne.PointerDown, (n) => {
      i = this.context.time.time;
    }), this.context.input.addEventListener(Ne.PointerUp, (n) => {
      const o = this.context.time.time - i;
      o > 1 ? this.spectator.stopSpectating() : this.context.input.getPointerClicked(0) && o < 0.3 && this.trySelectObject();
    });
  }
  /**
   * Attempts to select an avatar to spectate through raycasting
   */
  trySelectObject() {
    const t = new Ts();
    t.setMask(16777215);
    const e = this.context.physics.raycast(t);
    if (xi && console.log(...e), e != null && e.length)
      for (const i of e) {
        if (i.distance < 0.2)
          continue;
        const n = i.object, o = S.getComponentInParent(n, _t), a = o == null ? void 0 : o.connectionId;
        if (a) {
          const l = this.context.players.getPlayerView(a);
          this.spectator.target = l, xi && console.log("spectate", a, o);
          break;
        }
      }
  }
}
class lE {
  constructor(t, e, i) {
    /** The user ID that is following */
    r(this, "guid");
    r(this, "dontSave", !0);
    /** The user ID being followed */
    r(this, "targetUserId");
    /** Indicates if the user stopped following */
    r(this, "stoppedFollowing");
    this.guid = t, this.targetUserId = e, this.stoppedFollowing = i;
  }
}
class cE {
  constructor(t, e) {
    r(this, "guid");
    r(this, "userId");
    this.guid = t.guid, this.userId = e;
  }
}
class hE {
  constructor(t, e) {
    /** List of user IDs currently following this player */
    r(this, "followers", []);
    r(this, "context");
    r(this, "spectator");
    r(this, "_followerEventMethod");
    r(this, "_requestFollowMethod");
    r(this, "_joinedRoomMethod");
    r(this, "_lastRequestFollowUser");
    r(this, "_enforceFollowInterval");
    this.context = t, this.spectator = e, this._followerEventMethod = this.onFollowerEvent.bind(this), this._requestFollowMethod = this.onRequestFollowEvent.bind(this), this._joinedRoomMethod = this.onUserJoinedRoom.bind(this);
  }
  /**
   * Initializes network event listeners
   */
  awake() {
    this.context.connection.beginListen("spectator-follower-changed", this._followerEventMethod), this.context.connection.beginListen("spectator-request-follow", this._requestFollowMethod), this.context.connection.beginListen(ne.JoinedRoom, this._joinedRoomMethod), this.context.domElement.addEventListener("keydown", (t) => {
      this.spectator.useKeys && (t.key === "f" ? this.onRequestFollowMe() : t.key === "Escape" && this.onRequestFollowMe(!0));
    });
  }
  /**
   * Removes network event listeners
   */
  destroy() {
    this.context.connection.stopListen("spectator-follower-changed", this._followerEventMethod), this.context.connection.stopListen("spectator-request-follow", this._requestFollowMethod), this.context.connection.stopListen(ne.JoinedRoom, this._joinedRoomMethod);
  }
  /**
   * Notifies other users about spectating target changes
   * @param target The new target being spectated
   * @param _prevId The previous target's user ID
   */
  onSpectatedObjectChanged(t, e) {
    if (xi && console.log(this.context.connection.connectionId, "onSpectatedObjectChanged", t, e), this.context.connection.connectionId) {
      const i = (t == null ? void 0 : t.userId) === void 0, n = i ? e : t == null ? void 0 : t.userId, o = new lE(this.context.connection.connectionId, n, i);
      this.context.connection.send("spectator-follower-changed", o);
    }
  }
  /**
   * Requests other users to follow this player or stop following
   * @param stop Whether to request users to stop following
   */
  onRequestFollowMe(t = !1) {
    if (xi && console.log("Request follow", this.context.connection.connectionId), this.context.connection.connectionId) {
      this.spectator.stopSpectating();
      const e = t ? void 0 : this.context.connection.connectionId, i = new cE(this.spectator, e);
      this.context.connection.send("spectator-request-follow", i);
    }
  }
  /**
   * Handles room join events
   */
  onUserJoinedRoom() {
    x("followme") && this.onRequestFollowMe();
  }
  /**
   * Processes follower status change events from the network
   * @param evt The follower change event data
   */
  onFollowerEvent(t) {
    const e = t.targetUserId, i = t.guid;
    if (xi && console.log(t), e === this.context.connection.connectionId)
      if (t.stoppedFollowing) {
        const n = this.followers.indexOf(i);
        n !== -1 && (this.followers.splice(n, 1), this.removeDisconnectedFollowers(), console.log(i, "unfollows you", this.followers.length));
      } else
        this.followers.includes(i) || (this.followers.push(i), this.removeDisconnectedFollowers(), console.log(i, "follows you", this.followers.length));
  }
  /**
   * Removes followers that are no longer connected to the room
   */
  removeDisconnectedFollowers() {
    for (let t = this.followers.length - 1; t >= 0; t--) {
      const e = this.followers[t];
      this.context.connection.userIsInRoom(e) === !1 && this.followers.splice(t, 1);
    }
  }
  /**
   * Handles follow requests from other users
   * @param evt The follow request event
   * @returns True if the request was handled successfully
   */
  onRequestFollowEvent(t) {
    if (this._lastRequestFollowUser = t, t.userId === this.context.connection.connectionId)
      this.spectator.stopSpectating();
    else if (t.userId === void 0)
      this.spectator.stopSpectating();
    else {
      const e = this.context.players.getPlayerView(t.userId);
      if (e)
        this.spectator.target = e;
      else
        return xi && console.warn("Could not find view", t.userId), this.enforceFollow(), !1;
    }
    return !0;
  }
  /**
   * Periodically retries following a user if the initial attempt failed
   */
  enforceFollow() {
    this._enforceFollowInterval || (this._enforceFollowInterval = setInterval(() => {
      this._lastRequestFollowUser === void 0 || this._lastRequestFollowUser.userId && this.spectator.isFollowedBy(this._lastRequestFollowUser.userId) ? (clearInterval(this._enforceFollowInterval), this._enforceFollowInterval = void 0) : (xi && console.log("REQUEST FOLLOW AGAIN", this._lastRequestFollowUser.userId), this.onRequestFollowEvent(this._lastRequestFollowUser));
    }, 1e3));
  }
}
class jn {
  constructor() {
    r(this, "bb", null);
    r(this, "bb_pos", 0);
  }
  __init(t, e) {
    return this.bb_pos = t, this.bb = e, this;
  }
  static getRootAsSyncedCameraModel(t, e) {
    return (e || new jn()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsSyncedCameraModel(t, e) {
    return t.setPosition(t.position() + f0), (e || new jn()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  userId(t) {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__string(this.bb_pos + e, t) : null;
  }
  guid(t) {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__string(this.bb_pos + e, t) : null;
  }
  dontSave() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  pos(t) {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? (t || new mr()).__init(this.bb_pos + e, this.bb) : null;
  }
  rot(t) {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? (t || new mr()).__init(this.bb_pos + e, this.bb) : null;
  }
  static startSyncedCameraModel(t) {
    t.startObject(5);
  }
  static addUserId(t, e) {
    t.addFieldOffset(0, e, 0);
  }
  static addGuid(t, e) {
    t.addFieldOffset(1, e, 0);
  }
  static addDontSave(t, e) {
    t.addFieldInt8(2, +e, 0);
  }
  static addPos(t, e) {
    t.addFieldStruct(3, e, 0);
  }
  static addRot(t, e) {
    t.addFieldStruct(4, e, 0);
  }
  static endSyncedCameraModel(t) {
    return t.endObject();
  }
  static finishSyncedCameraModelBuffer(t, e) {
    t.finish(e);
  }
  static finishSizePrefixedSyncedCameraModelBuffer(t, e) {
    t.finish(e, void 0, !0);
  }
}
var dE = Object.defineProperty, uE = Object.getOwnPropertyDescriptor, fE = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? uE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && dE(t, e, n), n;
};
const ou = "SCAM";
q0(ou, jn.getRootAsSyncedCameraModel);
const mi = new ug();
class pE {
  // dontSave: boolean = true;
  // pos: { x: number, y: number, z: number } = { x: 0, y: 0, z: 0 };
  // rot: { x: number, y: number, z: number } = { x: 0, y: 0, z: 0 };
  constructor(t, e) {
    r(this, "userId");
    r(this, "guid");
    this.guid = e, this.userId = t;
  }
  send(t, e) {
    if (t) {
      mi.clear();
      const i = mi.createString(this.guid), n = mi.createString(this.userId);
      jn.startSyncedCameraModel(mi), jn.addGuid(mi, i), jn.addUserId(mi, n);
      const o = ie(t), a = Au(t);
      jn.addPos(mi, mr.createVec3(mi, o.x, o.y, o.z)), jn.addRot(mi, mr.createVec3(mi, a.x, a.y, a.z));
      const l = jn.endSyncedCameraModel(mi);
      mi.finish(l, ou), e.sendBinary(mi.asUint8Array());
    }
  }
}
var Hp;
const Ym = (Hp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "cameraPrefab", null);
    r(this, "_lastWorldPosition");
    r(this, "_lastWorldQuaternion");
    r(this, "_model", null);
    r(this, "_needsUpdate", !0);
    r(this, "_lastUpdateTime", 0);
    r(this, "remoteCams", {});
    r(this, "userToCamMap", {});
    r(this, "_camTimeoutInSeconds", 10);
    r(this, "_receiveCallback", null);
  }
  getCameraObject(t) {
    const e = this.userToCamMap[t];
    return e ? this.remoteCams[e].obj : null;
  }
  /** @internal */
  async awake() {
    this._lastWorldPosition = this.worldPosition.clone(), this._lastWorldQuaternion = this.worldQuaternion.clone(), this.cameraPrefab && ("uri" in this.cameraPrefab && (this.cameraPrefab = await this.cameraPrefab.instantiate(this.gameObject)), this.cameraPrefab && "isObject3D" in this.cameraPrefab && (this.cameraPrefab.visible = !1));
  }
  /** @internal */
  onEnable() {
    this._receiveCallback = this.context.connection.beginListenBinary(ou, this.onReceivedRemoteCameraInfoBin.bind(this));
  }
  /** @internal */
  onDisable() {
    this.context.connection.stopListenBinary(ou, this._receiveCallback);
  }
  /** @internal */
  update() {
    for (const n in this.remoteCams) {
      const o = this.remoteCams[n], a = this.context.time.realtimeSinceStartup - o.lastUpdate;
      if (!o || a > this._camTimeoutInSeconds) {
        z() && console.log("Remote cam timeout", n), o != null && o.obj && S.destroy(o.obj), delete this.remoteCams[n], o && delete this.userToCamMap[o.userId], Ym.instances.push(o), this.context.players.removePlayerView(o.userId, dr.Browser);
        continue;
      }
    }
    if (this.context.isInXR)
      return;
    const t = this.context.mainCamera;
    if (t === null) {
      this.enabled = !1;
      return;
    }
    if (!this.context.connection.isConnected || this.context.connection.connectionId === null)
      return;
    this._model === null && (this._model = new pE(this.context.connection.connectionId, this.context.connection.connectionId + "_camera"));
    const e = ie(t), i = Ce(t);
    (e.distanceTo(this._lastWorldPosition) > 1e-3 || i.angleTo(this._lastWorldQuaternion) > 0.01) && (this._needsUpdate = !0), this._lastWorldPosition.copy(e), this._lastWorldQuaternion.copy(i), !((!this._needsUpdate || this.context.time.frameCount % 2 !== 0) && !(this.context.time.realtimeSinceStartup - this._lastUpdateTime > this._camTimeoutInSeconds * 0.5)) && (this._lastUpdateTime = this.context.time.realtimeSinceStartup, this._needsUpdate = !1, this._model.send(t, this.context.connection), this.context.isInXR || this.context.players.setPlayerView(this.context.connection.connectionId, t, dr.Browser));
  }
  onReceivedRemoteCameraInfoBin(t) {
    const e = t.guid();
    if (!e)
      return;
    const i = t.userId();
    if (!i || !this.context.connection.userIsInRoom(i) || !this.cameraPrefab)
      return;
    let n = this.remoteCams[e];
    if (!n)
      if ("isObject3D" in this.cameraPrefab) {
        const c = new Qn();
        c.context = this.context;
        const h = S.instantiate(this.cameraPrefab, c);
        n = this.remoteCams[e] = { obj: h, lastUpdate: this.context.time.realtimeSinceStartup, userId: i }, n.obj.visible = !0, this.gameObject.add(h), this.userToCamMap[i] = e, Ym.instances.push(n);
        const d = S.getOrAddComponent(h, _t);
        d.connectionId = i, d.avatar = h;
      } else
        return;
    const o = n.obj;
    this.context.players.setPlayerView(i, o, dr.Browser), n.lastUpdate = this.context.time.realtimeSinceStartup, _n.markDirty(o);
    const a = t.pos();
    a && Fa(o, a.x(), a.y(), a.z());
    const l = t.rot();
    l && Eu(o, l.x(), l.y(), l.z());
  }
}, r(Hp, "instances", []), Hp);
let m_ = Ym;
fE([
  f([L, re])
], m_.prototype, "cameraPrefab", 2);
var mE = Object.defineProperty, gE = Object.getOwnPropertyDescriptor, Do = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? gE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && mE(t, e, n), n;
};
const Tp = "view", Ap = x("debugsyncedroom");
class is extends I {
  constructor() {
    super(...arguments);
    r(this, "roomName", "");
    r(this, "urlParameterName", "room");
    r(this, "joinRandomRoom");
    r(this, "requireRoomParameter", !1);
    r(this, "autoRejoin", !0);
    r(this, "createJoinButton", !0);
    r(this, "createViewOnlyButton", !1);
    r(this, "_lastJoinedRoom");
    r(this, "_roomPrefix", "");
    r(this, "_lastPingTime", 0);
    r(this, "_lastRoomTime", -1);
    r(this, "_userWantsToBeInARoom", !1);
    r(this, "_roomButton");
    r(this, "_roomButtonIconJoin");
    r(this, "_roomButtonIconLeave");
    r(this, "updateRoomButtonState", () => {
      var e, i;
      this._roomButton && (this.context.connection.isInRoom ? (this._roomButton.title = "Leave the networked room", this._roomButton.textContent = "Leave Room", (e = this._roomButtonIconJoin) == null || e.remove(), this._roomButton.prepend(this._roomButtonIconLeave)) : (this._roomButton.title = "Create or join a networked room", this._roomButton.textContent = "Join Room", (i = this._roomButtonIconLeave) == null || i.remove(), this._roomButton.prepend(this._roomButtonIconJoin)));
    });
    r(this, "_viewOnlyButton");
    r(this, "onCreateViewOnlyButton", () => {
      if (!this._viewOnlyButton) {
        const e = document.createElement("button");
        this._viewOnlyButton = e, e.classList.add("view-only-button"), e.setAttribute("priority", "90"), e.onclick = () => {
          var n;
          const i = this.getViewOnlyUrl();
          i != null && i.length ? navigator.canShare({ url: i }) ? (n = navigator.share({ url: i })) == null || n.catch((o) => {
            console.warn(o);
          }) : (navigator.clipboard.writeText(i), We("View only URL copied to clipboard")) : ve("Could not create view only URL");
        }, e.title = "Copy the view only URL: A page accessed by the view only URL can not be modified by visiting users.", e.textContent = "Share View URL", e.prepend(Dt("visibility"));
      }
      this.context.menu.appendChild(this._viewOnlyButton);
    });
  }
  /**
   * Get current room name from the URL parameter or the view parameter.
   */
  get currentRoomName() {
    const e = x(Tp);
    return e || x(this.urlParameterName);
  }
  set roomPrefix(e) {
    this._roomPrefix = e;
  }
  get roomPrefix() {
    return this._roomPrefix;
  }
  /** @internal */
  awake() {
    var e;
    this.joinRandomRoom === void 0 && ((e = this.roomName) == null ? void 0 : e.length) <= 0 && (this.joinRandomRoom = !0), Ap && console.log(`SyncedRoom roomName:${this.roomName}, urlParamName:${this.urlParameterName}, joinRandomRoom:${this.joinRandomRoom}`);
  }
  /** @internal */
  onEnable() {
    const e = x(Tp);
    if (e && typeof e == "string" && e.length > 0) {
      console.log("Join as viewer"), this.context.connection.joinRoom(e, !0);
      return;
    }
    if (this.tryJoinRoom(), this.createJoinButton) {
      const i = this.createRoomButton();
      this.context.menu.appendChild(i);
    }
    this.createViewOnlyButton && this.onEnableViewOnlyButton();
  }
  /** @internal */
  onDisable() {
    var e;
    (e = this._roomButton) == null || e.remove(), this.onDisableViewOnlyButton(), this.roomName && this.roomName.length > 0 && this.context.connection.leaveRoom(this.roomName);
  }
  /** @internal */
  onDestroy() {
    this.destroyRoomButton();
  }
  /** Will generate a random room name, set it as an URL parameter and attempt to join the room */
  tryJoinRandomRoom() {
    this.setRandomRoomUrlParameter(), this.tryJoinRoom();
  }
  /** Try to join the currently set roomName */
  tryJoinRoom(e = 0) {
    var n;
    e === void 0 && (e = 0);
    let i = !1;
    if (((n = this.urlParameterName) == null ? void 0 : n.length) > 0) {
      const o = x(this.urlParameterName);
      if (o && (typeof o == "string" || typeof o == "number")) {
        i = !0;
        const a = IS(o.toString());
        this.roomName = a;
      } else if (this.joinRandomRoom && (console.log("No room name found in url, generating random one"), this.setRandomRoomUrlParameter(), e < 1))
        return this.tryJoinRoom(e + 1);
    } else
      this.joinRandomRoom && (this.roomName === null || this.roomName === void 0 || this.roomName.length <= 0) && (this.roomName = this.generateRoomName());
    return this.requireRoomParameter && !i ? ((Ap || z()) && console.warn('[SyncedRoom] Missing required room parameter "' + this.urlParameterName + `" in url - will not connect.
To allow joining a room without a query parameter you can set "requireRoomParameter" to false.`), !1) : (this.context.connection.isConnected || this.context.connection.connect(), this._lastJoinedRoom = this.roomName, this._roomPrefix && (this.roomName = this._roomPrefix + this.roomName), this.roomName.length <= 0 ? (console.warn(`[SyncedRoom] Room name is not set so we can not join a networked room.
Please choose one of the following options to fix this:
A) Set a room name in the SyncedRoom component
B) Set a room name in the URL parameter "?` + this.urlParameterName + `=my_room"
C) Set "joinRandomRoom" to true`), !1) : (Ap && console.log("Join " + this.roomName), this._userWantsToBeInARoom = !0, this.context.connection.joinRoom(this.roomName), !0));
  }
  /** @internal */
  update() {
    this.context.connection.isConnected && (this.context.time.time - this._lastPingTime > 3 && (this._lastPingTime = this.context.time.time, this.context.connection.sendPing()), this.context.connection.isInRoom && (this._lastRoomTime = this.context.time.time)), this._lastRoomTime > 0 && this.context.time.time - this._lastRoomTime > 0.3 && (this._lastRoomTime = -1, this.autoRejoin ? this._userWantsToBeInARoom && (console.log("Disconnected from networking backend - attempt reconnecting now"), this.tryJoinRoom()) : z() && console.warn("You are not connected to a room anymore (possibly because the tab was inactive for too long and the server kicked you?)"));
  }
  /**
   * Get the URL to view the current room in view only mode.
   */
  getViewOnlyUrl() {
    if (this.context.connection.isConnected && this.context.connection.currentRoomViewId) {
      const e = window.location.search, i = new URLSearchParams(e);
      return i.has(this.urlParameterName) && i.delete(this.urlParameterName), i.set(Tp, this.context.connection.currentRoomViewId), window.location.origin + window.location.pathname + "?" + i.toString();
    }
    return null;
  }
  setRandomRoomUrlParameter() {
    const e = Mu(), i = this.generateRoomName();
    x(this.urlParameterName) ? e.set(this.urlParameterName, i) : e.append(this.urlParameterName, i), y0(i, e);
  }
  generateRoomName() {
    let e = "";
    for (let i = 0; i < 6; i++)
      e += Math.floor(Math.random() * 10).toFixed(0);
    return e;
  }
  createRoomButton() {
    if (this._roomButton)
      return this._roomButton;
    const e = document.createElement("button");
    return this._roomButton = e, e.classList.add("create-room-button"), e.setAttribute("priority", "90"), e.onclick = () => {
      if (this.context.connection.isInRoom)
        this.urlParameterName && jd(this.urlParameterName, null), this.context.connection.leaveRoom(), this._userWantsToBeInARoom = !1;
      else {
        if (this.urlParameterName) {
          const i = x(this.urlParameterName);
          (!i || i === !0) && (this._lastJoinedRoom ? jd(this.urlParameterName, this._lastJoinedRoom) : this.setRandomRoomUrlParameter());
        }
        this.tryJoinRoom();
      }
    }, this._roomButtonIconJoin = Dt("group"), this._roomButtonIconLeave = Dt("group_off"), this.updateRoomButtonState(), this.context.connection.beginListen(ne.JoinedRoom, this.updateRoomButtonState), this.context.connection.beginListen(ne.LeftRoom, this.updateRoomButtonState), e;
  }
  destroyRoomButton() {
    this.context.connection.stopListen(ne.JoinedRoom, this.updateRoomButtonState), this.context.connection.stopListen(ne.LeftRoom, this.updateRoomButtonState);
  }
  onEnableViewOnlyButton() {
    this.context.connection.isConnected ? this.onCreateViewOnlyButton() : (this.context.connection.stopListen(ne.JoinedRoom, this.onCreateViewOnlyButton), this.context.connection.beginListen(ne.JoinedRoom, this.onCreateViewOnlyButton));
  }
  onDisableViewOnlyButton() {
    var e;
    this.context.connection.stopListen(ne.JoinedRoom, this.onCreateViewOnlyButton), (e = this._viewOnlyButton) == null || e.remove();
  }
}
Do([
  f()
], is.prototype, "roomName", 2);
Do([
  f()
], is.prototype, "urlParameterName", 2);
Do([
  f()
], is.prototype, "joinRandomRoom", 2);
Do([
  f()
], is.prototype, "requireRoomParameter", 2);
Do([
  f()
], is.prototype, "autoRejoin", 2);
Do([
  f()
], is.prototype, "createJoinButton", 2);
Do([
  f()
], is.prototype, "createViewOnlyButton", 2);
Do([
  f()
], is.prototype, "roomPrefix", 1);
function _E() {
  const s = x("testwindowcount") || 0;
  s && s > 0 && yE(s);
}
function yE(s) {
  if (x("testwindow"))
    return null;
  const t = new URL(window.location.href);
  G_(t.searchParams, uR, 1), G_(t.searchParams, "testwindow", 1);
  const e = t.toString(), i = [];
  window.onbeforeunload = () => {
    for (const c of i)
      c.close();
  };
  const n = 0.05, o = 128;
  let a = 0, l = 0;
  for (let c = 0; c < s; c++) {
    a * o + o * 0.01 >= window.innerWidth && (l += 1, a = 0);
    const h = a * (o * (1 + n)) + window.screenLeft, d = l * (o * (1 + n)) + window.screenTop + 90 + 60 * l;
    a += 1;
    const u = window.open(e, "test window " + c, `popup=yes width=${o} height=${o} top=${d} left=${h}`);
    if (!u) {
      console.warn("Failed to open window");
      continue;
    }
    i.push(u), u.onload = () => {
      u.onbeforeunload = () => {
        for (let p = 0; p < i.length; p++) {
          const m = i[p];
          m !== u && m.close();
        }
        i.length = 0;
      };
    };
  }
  return i;
}
class ix extends I {
  awake() {
    _E();
  }
}
class nx extends I {
  constructor() {
    super(...arguments);
    r(this, "transformsPerFrame", 10);
    r(this, "interval", 0);
    r(this, "useFlatbuffers", !0);
    r(this, "builder", null);
    r(this, "models", null);
  }
  awake() {
    if (this.useFlatbuffers)
      this.context.connection.beginListenBinary(Uc, (e) => {
      });
    else {
      this.models = [];
      for (let e = 0; e < this.transformsPerFrame; e++)
        this.models.push(new sx(this.context.connection.connectionId + "_simulatedTransform_" + e, this));
    }
  }
  update() {
    if (this.context.connection.isConnected) {
      if (this.useFlatbuffers) {
        if (!this.context.connection.connectionId || this.context.time.frameCount % this.interval !== 0)
          return;
        this.builder === null && (this.builder = new ug(1024));
        const e = this.builder;
        for (let i = 0; i < this.transformsPerFrame; i++) {
          e.clear();
          const n = jv(this.context.connection.connectionId, this);
          this.context.connection.sendBinary(n);
        }
      } else if (this.models)
        for (let e = 0; e < this.models.length; e++) {
          const i = this.models[e];
          i.dontSave = !0, i.update(this, null), this.context.connection.send("TestSimulateUserData-" + e, i);
        }
    }
  }
}
class sx {
  constructor(t, e) {
    r(this, "guid");
    r(this, "fast", !1);
    r(this, "position");
    r(this, "rotation");
    // scale : { x : number, y : number, z : number } | undefined = undefined;
    r(this, "velocity");
    r(this, "dontSave");
    this.guid = t, this.position = { x: 0, y: 0, z: 0 }, this.rotation = { x: 0, y: 0, z: 0, w: 0 }, this.update(e, null);
  }
  isValid() {
    return this.fast !== void 0 || this.position !== void 0 || this.rotation !== void 0 || this.velocity !== void 0;
  }
  update(t, e) {
    const i = t.worldPosition;
    this.position.x = i.x, this.position.y = i.y, this.position.z = i.z;
    const n = t.worldQuaternion;
    if (this.rotation.x = n.x, this.rotation.y = n.y, this.rotation.z = n.z, this.rotation.w = n.w, this.fast = !1, e) {
      const o = e.getVelocity();
      this.velocity === void 0 && (this.velocity = { x: 0, y: 0, z: 0 }), this.velocity.x = o.x, this.velocity.y = o.y, this.velocity.z = o.z;
    }
  }
}
r(sx, "temp", new v());
var bE = Object.defineProperty, vE = Object.getOwnPropertyDescriptor, mf = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? vE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && bE(t, e, n), n;
};
const wE = x("debugsignals");
class g_ {
  constructor() {
    r(this, "guid");
  }
}
mf([
  f()
], g_.prototype, "guid", 2);
class gf {
  constructor() {
    r(this, "signal");
    r(this, "reaction");
  }
}
mf([
  f(g_)
], gf.prototype, "signal", 2);
mf([
  f(xe)
], gf.prototype, "reaction", 2);
var Gp;
const ds = (Gp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "events");
  }
  static invoke(t) {
    if (ds.receivers[t]) {
      const e = ds.receivers[t];
      if (!e)
        return;
      for (const i of e)
        i.invoke(t);
    }
  }
  /** @internal */
  awake() {
    wE && console.log("SignalReceiver awake", this);
  }
  /** @internal */
  onEnable() {
    if (this.events)
      for (const t of this.events)
        ds.receivers[t.signal.guid] || (ds.receivers[t.signal.guid] = []), ds.receivers[t.signal.guid].push(this);
  }
  /** @internal */
  onDisable() {
    if (this.events) {
      for (const t of this.events)
        if (ds.receivers[t.signal.guid]) {
          const e = ds.receivers[t.signal.guid].indexOf(this);
          e >= 0 && ds.receivers[t.signal.guid].splice(e, 1);
        }
    }
  }
  invoke(t) {
    if (!this.events || !Array.isArray(this.events))
      return;
    const e = typeof t == "object" ? t.guid : t;
    for (const i of this.events)
      if (i.signal.guid === e)
        try {
          if (i.reaction) {
            if (!i.reaction.invoke) {
              console.warn("Missing invoke - possibly a serialization error", i, this);
              continue;
            }
          } else {
            console.warn("Missing reaction for signal", i, this);
            continue;
          }
          i.reaction.invoke();
        } catch (n) {
          console.error(n);
        }
  }
  // onDeserialize(key: string, value: any): any | void
  // {
  //     switch(key){
  //         case "events":
  //             console.log(value);
  //             const evt = eventListSerializer;
  //             for(const e in value){
  //             }
  //             break;
  //     }
  // }
}, r(Gp, "receivers", {}), Gp);
let Ch = ds;
mf([
  f(gf)
], Ch.prototype, "events", 2);
var Vi = /* @__PURE__ */ ((s) => (s.Activation = "ActivationTrack", s.Animation = "AnimationTrack", s.Audio = "AudioTrack", s.Control = "ControlTrack", s.Marker = "MarkerTrack", s.Signal = "SignalTrack", s))(Vi || {}), us = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Hold = 1] = "Hold", s[s.Loop = 2] = "Loop", s[s.PingPong = 3] = "PingPong", s[s.Continue = 4] = "Continue", s))(us || {}), ox = /* @__PURE__ */ ((s) => (s.Signal = "SignalEmitter", s))(ox || {});
const Nn = x("debugtimeline");
class _f {
  constructor() {
    r(this, "director");
    r(this, "track");
  }
  get muted() {
    return this.track.muted;
  }
  set muted(t) {
    var e;
    t !== this.track.muted && (this.track.muted = t, (e = this.onMuteChanged) == null || e.call(this));
  }
  *forEachClip(t = !1) {
    var e;
    if ((e = this.track) != null && e.clips)
      if (t)
        for (let i = this.track.clips.length - 1; i >= 0; i--)
          yield this.track.clips[i];
      else
        for (const i of this.track.clips)
          yield i;
  }
  getClipTime(t, e) {
    return e.clipIn + (t - e.start) * e.timeScale;
  }
  getClipTimeNormalized(t, e) {
    return (t - e.start) / e.duration;
  }
  evaluateWeight(t, e, i, n = !0) {
    if (e < 0 || e >= i.length)
      return 0;
    const o = i[e];
    if (n || t >= o.start && t <= o.end) {
      let a = 1;
      const l = !1;
      if (o.easeInDuration > 0) {
        const c = Math.min((t - o.start) / o.easeInDuration, 1);
        a *= c;
      }
      if (o.easeOutDuration > 0 && !l) {
        const c = Math.min((o.end - t) / o.easeOutDuration, 1);
        a *= c;
      }
      return a;
    }
    return 0;
  }
}
class xE {
  constructor(t) {
    r(this, "clip");
    r(this, "rootPositionOffset");
    r(this, "rootQuaternionOffset");
    // not necessary
    r(this, "rootStartPosition");
    r(this, "rootEndPosition");
    r(this, "rootStartQuaternion");
    r(this, "rootEndQuaternion");
    const e = t.getClip();
    this.clip = e;
    const i = t.getRoot(), n = i.name + ".position", o = i.name + ".quaternion";
    Nn && console.log(e.name, e.tracks, n);
    for (const a of e.tracks)
      if (!(a.times.length <= 0)) {
        if (a.name.endsWith(n))
          this.rootStartPosition = new v().fromArray(a.values, 0), this.rootEndPosition = new v().fromArray(a.values, a.values.length - 3), this.rootPositionOffset = this.rootEndPosition.clone().sub(this.rootStartPosition), Nn && console.log(this.rootPositionOffset);
        else if (a.name.endsWith(o) && (this.rootStartQuaternion = new W().fromArray(a.values, 0), this.rootEndQuaternion = new W().fromArray(a.values, a.values.length - 4), this.rootQuaternionOffset = this.rootEndQuaternion.clone().multiply(this.rootStartQuaternion), Nn)) {
          const l = new jt().setFromQuaternion(this.rootQuaternionOffset);
          console.log("ROT", l);
        }
      }
  }
  get hasOffsets() {
    return this.rootPositionOffset !== void 0 || this.rootQuaternionOffset !== void 0;
  }
}
class __ extends _f {
  constructor() {
    super(...arguments);
    /** @internal */
    r(this, "models", []);
    /** @internal */
    r(this, "trackOffset");
    /** The object that is being animated. */
    r(this, "target");
    /** The AnimationMixer, should be shared with the animator if an animator is bound */
    r(this, "mixer");
    r(this, "clips", []);
    r(this, "actions", []);
    /**
     * You can use the weight to blend the timeline animation tracks with multiple animation tracks on the same object.
     * @default 1
     */
    r(this, "weight", 1);
    /** holds data/info about clips differences */
    r(this, "_actionOffsets", []);
    r(this, "_didBind", !1);
    r(this, "_animator", null);
    r(this, "_useclipOffsets", !0);
    r(this, "_totalOffsetPosition", new v());
    r(this, "_totalOffsetRotation", new W());
    r(this, "_totalOffsetPosition2", new v());
    r(this, "_totalOffsetRotation2", new W());
    r(this, "_summedPos", new v());
    r(this, "_tempPos", new v());
    r(this, "_summedRot", new W());
    r(this, "_tempRot", new W());
    r(this, "_clipRotQuat", new W());
  }
  onDisable() {
    var e;
    (e = this.mixer) == null || e.stopAllAction();
  }
  onDestroy() {
    this.director.context.animations.unregisterAnimationMixer(this.mixer);
  }
  // Using this callback instead of onEnable etc 
  // because we want to re-enable the animator when the director is at the end and wrap mode is set to none
  // in which case the director is stopped (but not disabled)
  // which means we want to notify the object that it's not animated anymore
  // and the animator can then take over
  onStateChanged() {
    this._animator && Jy(this._animator.gameObject, this, this.director.isPlaying);
  }
  createHooks(e, i) {
    var d, u;
    if (((d = i.tracks) == null ? void 0 : d.length) <= 0) {
      console.warn("No tracks in AnimationClip", i);
      return;
    }
    const n = i.tracks[0].name.split("."), o = n[n.length - 2], a = o + ".position", l = o + ".quaternion";
    let c = !1, h = !1;
    for (const p of i.tracks)
      p.name.endsWith(a) ? (c = !0, this.createPositionInterpolant(i, e, p)) : p.name.endsWith(l) && (h = !0, this.createRotationInterpolant(i, e, p));
    if (!c || !h) {
      const p = (u = this.mixer) == null ? void 0 : u.getRoot(), m = i.tracks[0], g = m.name.lastIndexOf("."), _ = m.name.substring(0, g), y = _.substring(_.lastIndexOf(".") + 1), b = p.getObjectByName(y);
      if (b)
        if (c) {
          if (!h) {
            const w = i.tracks[0].name.substring(0, g) + ".quaternion";
            Nn && console.warn("Create quaternion track", y, b);
            const P = b.quaternion, k = new U1(w, [0, i.duration], [P.x, P.y, P.z, P.w, P.x, P.y, P.z, P.w]);
            i.tracks.push(k), this.createRotationInterpolant(i, e, k);
          }
        } else {
          const w = _ + ".position";
          Nn && console.warn("Create position track", y, b);
          const P = b.position, k = new z1(w, [0, i.duration], [P.x, P.y, P.z, P.x, P.y, P.z]);
          i.tracks.push(k), this.createPositionInterpolant(i, e, k);
        }
    }
  }
  bind() {
    if (!this._didBind) {
      this._didBind = !0, Nn && console.log(this.models), this.mixer ? this.target = this.mixer.getRoot() : console.warn("No mixer was assigned to animation track");
      for (const e of this.actions) {
        const i = new xE(e);
        this._actionOffsets.push(i);
      }
      this.target && (this._animator = S.getComponent(this.target, zt) ?? null, this._animator && Jy(this._animator.gameObject, this, !0));
      for (const e of this.models) {
        const i = e.asset, n = i.position, o = i.rotation;
        n && n.x !== void 0 && (n.isVector3 || (i.position = new v(n.x, n.y, n.z)), o.isQuaternion || (i.rotation = new W(o.x, o.y, o.z, o.w)));
      }
      this.ensureTrackOffsets();
    }
  }
  ensureTrackOffsets() {
    if (this.trackOffset) {
      const e = this.trackOffset.position;
      e && (e.isVector3 || (this.trackOffset.position = new v(e.x, e.y, e.z)));
      const i = this.trackOffset.rotation;
      i && (i.isQuaternion || (this.trackOffset.rotation = new W(i.x, i.y, i.z, i.w)));
    }
  }
  evaluate(e) {
    var c, h, d, u, p, m, g;
    if (this.track.muted || !this.mixer)
      return;
    this.bind(), this._totalOffsetPosition.set(0, 0, 0), this._totalOffsetRotation.set(0, 0, 0, 1), this._totalOffsetPosition2.set(0, 0, 0), this._totalOffsetRotation2.set(0, 0, 0, 1);
    let i = 0, n = 0, o = !1, a = !1, l = 0;
    for (let _ = 0; _ < this.clips.length; _++) {
      const y = this.models[_], b = this.actions[_], w = y.asset;
      b.weight = 0;
      const P = e >= y.start && e <= y.end, k = y.preExtrapolationMode, O = y.postExtrapolationMode, M = _ < this.clips.length - 1 ? this.models[_ + 1] : null;
      let E = P, B = !1;
      if (!E && !o && y.end < e && O !== us.None ? (!M || M.start > e) && (E = !0, o = !0) : _ == 0 && !E && !a && y.start > e && k !== us.None && (!M || M.start < e) && (E = !0, B = !0, a = !0), E) {
        let A = this.weight;
        A *= this.evaluateWeight(e, _, this.models, E), A *= this.director.weight;
        let F = P;
        if (B)
          switch (k) {
            case us.Hold:
              break;
            case us.Loop:
              e += y.start, F = !0;
              break;
            default:
              e += y.start, F = !0;
              break;
          }
        let U = this.getClipTime(e, y), Z = 0;
        const T = w.duration;
        if (B && k === us.Hold && (U = 0), F) {
          if (w.loop)
            for (Z += Math.floor(U / (T + 1e-6)); U > T; )
              U -= T;
        } else if (!P && o)
          switch (O) {
            case us.Hold:
              U = this.getClipTime(y.end, y);
              break;
            case us.Loop:
              U %= T;
              break;
            case us.PingPong:
              const Y = Math.floor(U / T) % 2 !== 0;
              U %= T, Y && (U = T - U);
              break;
          }
        y.reversed === !0 ? b.time = b.getClip().duration - U : b.time = U, b.timeScale = 0;
        const j = Math.max(0, A);
        if (b.weight = j, l += j, b.clampWhenFinished = !1, b.isRunning() || b.play(), this._useclipOffsets) {
          const H = i == 0 ? this._totalOffsetPosition : this._totalOffsetPosition2, Y = i == 0 ? this._totalOffsetRotation : this._totalOffsetRotation2;
          i < 1 && (n = 1 - A), i += 1;
          const te = this._summedPos.set(0, 0, 0), le = this._tempPos.set(0, 0, 0), de = this._summedRot.identity(), De = this._tempRot.identity(), Ct = w.rotation;
          Ct && (this._clipRotQuat.identity(), this._clipRotQuat.slerp(Ct, A));
          const ai = this._actionOffsets[_];
          if (ai.hasOffsets)
            for (let $t = 0; $t < Z; $t++)
              ai.rootPositionOffset ? le.copy(ai.rootPositionOffset) : le.set(0, 0, 0), le.applyQuaternion(de), this._clipRotQuat && le.applyQuaternion(this._clipRotQuat), ai.rootQuaternionOffset && (De.copy(ai.rootQuaternionOffset), de.multiply(De)), te.add(le);
          this._clipRotQuat && Y.multiply(this._clipRotQuat), Y.multiply(de), w.position && te.add(w.position), H.add(te);
        }
      }
    }
    if (this._useclipOffsets && (this._totalOffsetPosition.lerp(this._totalOffsetPosition2, n), this._totalOffsetRotation.slerp(this._totalOffsetRotation2, n)), this.__mixerError === void 0 && (Nn || z()) && ((h = (c = this._animator) == null ? void 0 : c.runtimeAnimatorController) != null && h.mixer) && this.mixer !== ((u = (d = this._animator) == null ? void 0 : d.runtimeAnimatorController) == null ? void 0 : u.mixer) && (this.__mixerError = !0, console.error("AnimationTrack mixer is not shared with the animator controller - this might result in the timeline to not animate properly. Please report a bug to the Needle Engine team!", this)), (p = this._animator) != null && p.runtimeAnimatorController) {
      const _ = Math.max(0, 1 - l);
      (g = (m = this._animator) == null ? void 0 : m.runtimeAnimatorController) == null || g.update(_);
    } else
      this.mixer.update(e);
  }
  createRotationInterpolant(e, i, n) {
    var c;
    const o = n.createInterpolant.bind(n), a = new W();
    this.ensureTrackOffsets();
    const l = (c = this.trackOffset) == null ? void 0 : c.rotation;
    n.createInterpolant = () => {
      const h = o(), d = h.evaluate.bind(h);
      return h.evaluate = (u) => {
        var m;
        const p = d(u);
        if (a.set(p[0], p[1], p[2], p[3]), a.premultiply(this._totalOffsetRotation), l && a.premultiply(l), this.director.animationCallbackReceivers)
          for (const g of this.director.animationCallbackReceivers)
            (m = g == null ? void 0 : g.onTimelineRotation) == null || m.call(g, this.director, this.target, u, a);
        return p[0] = a.x, p[1] = a.y, p[2] = a.z, p[3] = a.w, p;
      }, h;
    };
  }
  createPositionInterpolant(e, i, n) {
    var d, u;
    const o = n.createInterpolant.bind(n), a = new v();
    this.ensureTrackOffsets();
    const l = (d = this.trackOffset) == null ? void 0 : d.rotation, c = (u = this.trackOffset) == null ? void 0 : u.position;
    let h;
    n.createInterpolant = () => {
      const p = o(), m = p.evaluate.bind(p);
      return p.evaluate = (g) => {
        var y, b, w;
        const _ = m(g);
        if (a.set(_[0], _[1], _[2]), i.removeStartOffset && (h === void 0 ? (h = null, h = (b = (y = this._actionOffsets.find((P) => P.clip === e)) == null ? void 0 : y.rootStartPosition) == null ? void 0 : b.clone()) : h != null && h.isVector3 && a.sub(h)), a.applyQuaternion(this._totalOffsetRotation), a.add(this._totalOffsetPosition), l && a.applyQuaternion(l), c && (a.x -= c.x, a.y += c.y, a.z += c.z), this.director.animationCallbackReceivers)
          for (const P of this.director.animationCallbackReceivers)
            (w = P == null ? void 0 : P.onTimelinePosition) == null || w.call(P, this.director, this.target, g, a);
        return _[0] = a.x, _[1] = a.y, _[2] = a.z, _;
      }, p;
    };
  }
}
const SE = x("mutetimeline"), va = class extends _f {
  constructor() {
    super(...arguments);
    r(this, "models", []);
    r(this, "listener");
    r(this, "audio", []);
    r(this, "audioContextTimeOffset", []);
    r(this, "lastTime", 0);
    r(this, "audioSource");
    r(this, "_audioLoader", null);
    r(this, "_playableDirectorResumed", !1);
  }
  getAudioFilePath(e) {
    const i = this.director.sourceId;
    return Tr(i, e);
  }
  onAllowAudioChanged(e) {
    for (let i = 0; i < this.models.length; i++) {
      const n = this.models[i];
      this.audio[i].setVolume(e ? n.asset.volume : 0);
    }
  }
  addModel(e) {
    const i = new N1(this.listener);
    this.audio.push(i);
    const n = e;
    n._didTriggerPlay = !1, this.models.push(n);
  }
  onDisable() {
    for (const e of this.audio)
      e.isPlaying && e.stop();
    for (const e of this.models)
      e._didTriggerPlay = !1;
  }
  onDestroy() {
    for (const e of this.audio)
      e.source && (e == null || e.disconnect());
    this.audio.length = 0;
  }
  onMuteChanged() {
    if (this.muted)
      for (let e = 0; e < this.audio.length; e++) {
        const i = this.audio[e];
        i != null && i.isPlaying && i.stop();
      }
  }
  stop() {
    for (let e = 0; e < this.audio.length; e++) {
      const i = this.audio[e];
      i != null && i.isPlaying && i.stop();
    }
    for (const e of this.models)
      e._didTriggerPlay = !1;
  }
  onPauseChanged() {
    for (let e = 0; e < this.audio.length; e++) {
      const i = this.audio[e];
      i != null && i.isPlaying && i.stop();
    }
    this._playableDirectorResumed = this.director.isPlaying;
  }
  evaluate(e) {
    if (SE || this.track.muted || this.director.speed < 0)
      return;
    const i = this.director.context.application.muted, n = this._playableDirectorResumed;
    this._playableDirectorResumed = !1;
    const o = i ? 0.1 : 0;
    for (let a = 0; a < this.models.length; a++) {
      const l = this.models[a], c = this.audio[a], h = l.asset;
      if ((!c || !c.buffer) && this.isInTimeRange(l, e - 1, e + 1) && this.handleAudioLoading(l, c), qe.userInteractionRegistered !== !1 && !(c === null || !c.buffer))
        if (c.playbackRate = this.director.context.time.timeScale * this.director.speed, c.loop = h.loop, e >= l.start && e <= l.end && e < this.director.duration) {
          if (!c.isPlaying || !this.director.isPlaying)
            (n || !l._didTriggerPlay && this.lastTime < e) && (l.duration * l.timeScale > 0.3 ? c.offset = l.clipIn + (e - l.start) * l.timeScale : c.offset = 0, Nn && console.log("Timeline Audio (" + this.track.name + ") play with offset " + c.offset + " - " + l.asset.clip), c.play(o), l._didTriggerPlay = !0);
          else {
            const u = l.clipIn + (e - l.start) * l.timeScale, p = c.context.currentTime - c._startedAt + c.offset;
            Math.abs(u - p) > 0.3 && (c.offset = u, c.stop(), c.play(o));
          }
          let d = h.volume;
          if (this.track.volume !== void 0 && (d *= this.track.volume), i && (d = 0), l.easeInDuration > 0) {
            const u = Math.min((e - l.start) / l.easeInDuration, 1);
            d *= u;
          }
          if (l.easeOutDuration > 0) {
            const u = Math.min((l.end - e) / l.easeOutDuration, 1);
            d *= u;
          }
          c.setVolume(d * this.director.weight);
        } else
          l._didTriggerPlay = !1, this.director.isPlaying && c.isPlaying && c.stop();
    }
    this.lastTime = e;
  }
  /** Call to load audio buffer for a specific time in the track. Can be used to preload the timeline audio */
  loadAudio(e, i = 0, n = 0) {
    let o = null;
    const a = e - n, l = e + i;
    for (const c of this.models)
      if (this.isInTimeRange(c, a, l)) {
        const h = this.audio[this.models.indexOf(c)], d = this.handleAudioLoading(c, h);
        d !== null && (o === null && (o = []), o.push(d));
      }
    return o !== null ? Promise.all(o) : null;
  }
  isInTimeRange(e, i, n) {
    return i <= e.start && n >= e.end || i >= e.start && i <= e.end || n >= e.start && n <= e.end;
  }
  static dispose() {
    va._audioBuffers.clear();
  }
  handleAudioLoading(e, i) {
    this._audioLoader || (this._audioLoader = new Zp());
    const n = this.getAudioFilePath(e.asset.clip);
    if (va._audioBuffers.get(n)) {
      const a = va._audioBuffers.get(n);
      return a.then((l) => {
        l && i.setBuffer(l);
      }), a;
    }
    Nn && console.warn("LOAD audio track", n, this.director.sourceId);
    const o = new Promise((a, l) => {
      this._audioLoader.load(
        n,
        (c) => {
          i.setBuffer(c), a(c);
        },
        void 0,
        (c) => {
          console.error("Error loading audio", c), a(null);
        }
      );
    });
    return va._audioBuffers.set(n, o), o;
  }
};
let Ta = va;
r(Ta, "_audioBuffers", /* @__PURE__ */ new Map());
class ru extends _f {
  constructor() {
    super(...arguments);
    r(this, "models", []);
    r(this, "didTrigger", []);
    r(this, "receivers", []);
  }
  // TODO: test when timeline signals are being reset in Unity
  // onEnable() {
  //     for (let i = 0; i < this.didTrigger?.length; i++) {
  //         this.didTrigger[i] = false;
  //     }
  // }
  // private _lastTime: number = -1;
  evaluate(e) {
    var n;
    if (this.track.muted)
      return;
    const i = this.director.context.time.deltaTime * 1.5;
    for (let o = 0; o < this.models.length; o++) {
      const a = this.models[o], l = this.didTrigger[o], c = a.time - e;
      let h = !1;
      if (a.retroActive)
        h = c <= 1e-6;
      else {
        const d = Math.abs(c);
        (d === 0 || d >= 1e-5 && d < i) && (h = !0);
      }
      if (h) {
        if (!l)
          if (Nn && console.log("Trigger signal", e, a.time, a), this.didTrigger[o] = !0, ((n = this.receivers) == null ? void 0 : n.length) <= 0)
            Ch.invoke(a.asset);
          else
            for (const d of this.receivers)
              d && d.invoke(a.asset);
      } else
        a.emitOnce || (this.didTrigger[o] = !1);
    }
  }
}
class y_ extends _f {
  constructor() {
    super(...arguments);
    r(this, "models", []);
    r(this, "timelines", []);
    r(this, "_previousActiveModel", null);
  }
  resolveSourceObjects(e) {
    for (let i = this.models.length - 1; i >= 0; i--) {
      const o = this.models[i].asset;
      if (!o.sourceObject || typeof o.sourceObject != "object") {
        console.log("no source object, removing model", i, o), this.models.splice(i, 1);
        continue;
      } else {
        const a = S.getComponent(o.sourceObject, Rr);
        this.timelines.push(a), a && o.updateDirector && (a.playOnAwake = !1);
      }
    }
  }
  evaluate(e) {
    var i;
    this._previousActiveModel = null;
    for (let n = 0; n < this.models.length; n++) {
      const o = this.models[n], a = o.asset;
      if (e >= o.start && e <= o.end) {
        this._previousActiveModel = o;
        const l = this.getClipTime(e, o);
        if (a.controlActivation) {
          const c = a.sourceObject;
          c.visible = !0;
        }
        if (a.updateDirector) {
          const c = this.timelines[n];
          c && (c.isPlaying && c.pause(), c.time = l, c.evaluate());
        }
      } else {
        const l = (i = this._previousActiveModel) == null ? void 0 : i.asset;
        if (a.controlActivation) {
          const c = a.sourceObject;
          (l == null ? void 0 : l.sourceObject) !== c && (c.visible = !1);
        }
      }
    }
  }
}
var CE = Object.defineProperty, PE = Object.getOwnPropertyDescriptor, rx = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? PE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && CE(t, e, n), n;
};
const as = x("debugtimeline");
var qp;
const Km = (qp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "playableAsset");
    r(this, "playOnAwake");
    r(this, "extrapolationMode", 1);
    /** When enabled the timeline will wait for audio tracks to load at the current time before starting to play */
    r(this, "waitForAudio", !0);
    r(this, "_visibilityChangeEvt");
    r(this, "_clonedPlayableAsset", !1);
    r(this, "_speed", 1);
    r(this, "_guidsMap");
    // INTERNALS
    r(this, "_isPlaying", !1);
    r(this, "_internalUpdateRoutine");
    r(this, "_isPaused", !1);
    /** internal, true during the time stop() is being processed */
    r(this, "_isStopping", !1);
    r(this, "_time", 0);
    r(this, "_duration", 0);
    r(this, "_weight", 1);
    r(this, "_animationTracks", []);
    r(this, "_audioTracks", []);
    r(this, "_signalTracks", []);
    r(this, "_controlTracks", []);
    r(this, "_customTracks", []);
    r(this, "_allTracks", [
      this._animationTracks,
      this._audioTracks,
      this._signalTracks,
      this._controlTracks,
      this._customTracks
    ]);
    /** Experimental support for overriding timeline animation data (position or rotation) */
    r(this, "animationCallbackReceivers", []);
  }
  static registerCreateTrack(t, e) {
    this.createTrackFunctions[t] = e;
  }
  /** @returns true if the timeline is currently playing */
  get isPlaying() {
    return this._isPlaying;
  }
  /** @returns true if the timeline is currently paused */
  get isPaused() {
    return this._isPaused;
  }
  /** the current time of the timeline */
  get time() {
    return this._time;
  }
  set time(t) {
    typeof t == "number" && !Number.isNaN(t) ? this._time = t : (as || ui()) && console.error("INVALID TIMELINE.TIME VALUE", t, this.name);
  }
  /** the duration of the timeline */
  get duration() {
    return this._duration;
  }
  set duration(t) {
    this._duration = t;
  }
  /** the weight of the timeline. Set to a value below 1 to blend with other timelines */
  get weight() {
    return this._weight;
  }
  set weight(t) {
    this._weight = t;
  }
  /** the playback speed of the timeline */
  get speed() {
    return this._speed;
  }
  set speed(t) {
    this._speed = t;
  }
  /** @internal */
  awake() {
    var t, e, i, n, o;
    as && console.log(this, (t = this.playableAsset) == null ? void 0 : t.tracks), this.rebuildGraph(), !this.isValid() && (as || z()) && (as ? console.warn("PlayableDirector is not valid", "Asset?", this.playableAsset, "Tracks:", (e = this.playableAsset) == null ? void 0 : e.tracks, "IsArray?", Array.isArray((i = this.playableAsset) == null ? void 0 : i.tracks), this) : (o = (n = this.playableAsset) == null ? void 0 : n.tracks) != null && o.length ? console.warn("PlayableDirector is not valid") : console.warn("PlayableDirector has no tracks"));
  }
  /** @internal */
  onEnable() {
    var t, e, i;
    for (const n of this._audioTracks)
      (t = n.onEnable) == null || t.call(n);
    for (const n of this._customTracks)
      (e = n.onEnable) == null || e.call(n);
    for (const n of this._animationTracks)
      (i = n.onEnable) == null || i.call(n);
    this.playOnAwake && this.play(), this._visibilityChangeEvt || (this._visibilityChangeEvt = () => {
      switch (document.visibilityState) {
        case "hidden":
          this.setAudioTracksAllowPlaying(!1);
          break;
        case "visible":
          this.setAudioTracksAllowPlaying(!0);
          break;
      }
    }), window.addEventListener("visibilitychange", this._visibilityChangeEvt);
  }
  /** @internal */
  onDisable() {
    var t, e, i;
    this.stop();
    for (const n of this._audioTracks)
      (t = n.onDisable) == null || t.call(n);
    for (const n of this._customTracks)
      (e = n.onDisable) == null || e.call(n);
    for (const n of this._animationTracks)
      (i = n.onDisable) == null || i.call(n);
    this._visibilityChangeEvt && window.removeEventListener("visibilitychange", this._visibilityChangeEvt);
  }
  /** @internal */
  onDestroy() {
    var t;
    for (const e of this._allTracks)
      for (const i of e)
        (t = i.onDestroy) == null || t.call(i);
  }
  /** @internal */
  rebuildGraph() {
    this.isValid() && (this.resolveBindings(), this.updateTimelineDuration(), this.setupAndCreateTrackHandlers());
  }
  /**
   * Play the timeline from the current time.  
   * If the timeline is already playing this method does nothing.
   */
  async play() {
    if (!this.isValid())
      return;
    const t = this._isPaused == !0;
    if (this._isPaused = !1, !this._isPlaying) {
      if (this._isPlaying = !0, t && this.invokePauseChangedMethodsOnTracks(), this.waitForAudio) {
        const e = [];
        for (const i of this._audioTracks) {
          const n = i.loadAudio(this._time, 1, 0);
          n && e.push(n);
        }
        if (e.length > 0 && (await Promise.all(e), !this._isPlaying))
          return;
        for (; this._audioTracks.length > 0 && this._isPlaying && !qe.userInteractionRegistered && this.waitForAudio; )
          await Gn(200);
      }
      this.invokeStateChangedMethodsOnTracks(), this._internalUpdateRoutine = this.startCoroutine(this.internalUpdate(), Re.LateUpdate);
    }
  }
  /**
   * Pause the timeline.
   */
  pause() {
    this.isValid() && (this._isPlaying = !1, !this._isPaused && (this._isPaused = !0, this.internalEvaluate(), this.invokePauseChangedMethodsOnTracks(), this.invokeStateChangedMethodsOnTracks()));
  }
  /**
   * Stop the timeline.
   */
  stop() {
    this._isStopping = !0;
    for (const i of this._audioTracks)
      i.stop();
    const t = this._isPaused == !0, e = this._isPlaying;
    this._isPlaying && (this._time = 0, this._isPlaying = !1, this._isPaused = !1, this.internalEvaluate(), t && this.invokePauseChangedMethodsOnTracks()), this._isPlaying = !1, this._isPaused = !1, t && !e && this.invokePauseChangedMethodsOnTracks(), e && this.invokeStateChangedMethodsOnTracks(), this._internalUpdateRoutine && this.stopCoroutine(this._internalUpdateRoutine), this._internalUpdateRoutine = null, this._isStopping = !1;
  }
  /**
   * Evaluate the timeline at the current time. This is useful when you want to manually update the timeline e.g. when the timeline is paused and you set `time` to a new value.
   */
  evaluate() {
    this.internalEvaluate(!0);
  }
  /**
   * @returns true if the timeline is valid and has tracks
   */
  isValid() {
    return this.playableAsset && this.playableAsset.tracks && Array.isArray(this.playableAsset.tracks);
  }
  /** Iterates over all tracks of the timeline
   * @returns all tracks of the timeline
   */
  *forEachTrack() {
    for (const t of this._allTracks)
      for (const e of t)
        yield e;
  }
  /**
   * @returns all animation tracks of the timeline
   */
  get animationTracks() {
    return this._animationTracks;
  }
  /**
   * @returns all audio tracks of the timeline
   */
  get audioTracks() {
    return this._audioTracks;
  }
  /** @internal */
  resolveGuids(t) {
    this._guidsMap = t;
  }
  /** should be called after evaluate if the director was playing */
  invokePauseChangedMethodsOnTracks() {
    var t;
    for (const e of this.forEachTrack())
      (t = e.onPauseChanged) == null || t.call(e);
  }
  invokeStateChangedMethodsOnTracks() {
    var t;
    for (const e of this.forEachTrack())
      (t = e.onStateChanged) == null || t.call(e, this._isPlaying);
  }
  *internalUpdate() {
    for (; this._isPlaying && this.activeAndEnabled; )
      !this._isPaused && this._isPlaying && (this._time += this.context.time.deltaTime * this.speed, this.internalEvaluate()), yield;
  }
  /**
   * PlayableDirector lifecycle should always call this instead of "evaluate"
   * @param called_by_user If true the evaluation is called by the user (e.g. via evaluate())
   */
  internalEvaluate(t = !1) {
    if (!this.isValid())
      return;
    let e = this._time;
    switch (this.extrapolationMode) {
      case 0:
        this._speed > 0 ? e = Math.min(e, this._duration) : this._speed < 0 && (e = Math.max(e, 0)), this._time = e;
        break;
      case 1:
        e %= this._duration, this._time = e;
        break;
      case 2:
        if (e > this._duration) {
          this.stop();
          return;
        }
        break;
    }
    const i = this._time;
    for (const n of this.playableAsset.tracks)
      if (!n.muted)
        switch (n.type) {
          case Vi.Activation:
            if (!t && !this._isPlaying)
              continue;
            for (let o = 0; o < n.outputs.length; o++) {
              const a = n.outputs[o];
              if (typeof a == "object") {
                let l = !1;
                if (n.clips)
                  for (const h of n.clips)
                    h.start <= i && i <= h.end && (l = !0);
                const c = a;
                c.visible !== void 0 && c.visible !== l && (c.visible = l, as && console.warn(this.name, "set ActivationTrack-" + o, c.name, l, i));
              }
            }
            break;
        }
    if (!this._isStopping)
      for (const n of this._animationTracks)
        n.evaluate(i);
    for (const n of this._audioTracks)
      n.evaluate(i);
    for (const n of this._signalTracks)
      n.evaluate(i);
    for (const n of this._controlTracks)
      n.evaluate(i);
    for (const n of this._customTracks)
      n.evaluate(i);
  }
  resolveBindings() {
    if (this._clonedPlayableAsset || (this._clonedPlayableAsset = !0, this.playableAsset = Ru(this.playableAsset)), !this.playableAsset || !this.playableAsset.tracks)
      return;
    const t = this.findRoot(this.gameObject);
    for (const e of this.playableAsset.tracks) {
      for (let i = e.outputs.length - 1; i >= 0; i--) {
        let n = e.outputs[i];
        if (typeof n == "string") {
          this._guidsMap && this._guidsMap[n] && (n = this._guidsMap[n]);
          const o = S.findByGuid(n, t);
          o === null || typeof o != "object" ? (e.outputs.splice(i, 1), console.warn("Failed to resolve binding", n, e.name, e.type)) : (as && console.log("Resolved binding", n, "to", o), e.outputs[i] = o);
        } else if (n === null) {
          if (e.outputs.splice(i, 1), Km.createTrackFunctions[e.type])
            continue;
          e.type !== Vi.Audio && e.type !== Vi.Control && e.type !== Vi.Marker && e.type !== Vi.Signal && console.warn("Missing binding", n, e.name, e.type, this.name, this.playableAsset.name);
        }
      }
      if (e.type === Vi.Control && e.clips)
        for (let i = 0; i < e.clips.length; i++) {
          const n = e.clips[i];
          let o = n.asset.sourceObject;
          if (typeof o == "string") {
            this._guidsMap && this._guidsMap[o] && (o = this._guidsMap[o]);
            const a = S.findByGuid(o, t);
            a === null || typeof a != "object" ? console.warn("Failed to resolve sourceObject binding", o, e.name, n) : (as && console.log("Resolved binding", o, "to", a), n.asset.sourceObject = a);
          }
        }
    }
  }
  findRoot(t) {
    return t.parent ? this.findRoot(t.parent) : t;
  }
  updateTimelineDuration() {
    if (this._duration = 0, !(!this.playableAsset || !this.playableAsset.tracks)) {
      for (const t of this.playableAsset.tracks)
        if (t.muted !== !0) {
          if (t.clips)
            for (const e of t.clips)
              e.end > this._duration && (this._duration = e.end);
          if (t.markers)
            for (const e of t.markers)
              e.time > this._duration && (this._duration = e.time + 1e-3);
        }
    }
  }
  setupAndCreateTrackHandlers() {
    var e, i, n;
    if (this._animationTracks.length = 0, this._audioTracks.length = 0, this._signalTracks.length = 0, !this.playableAsset)
      return;
    let t = S.findObjectOfType(lo, this.context);
    for (const o of this.playableAsset.tracks) {
      const a = o.type, l = Km.createTrackFunctions[a];
      if (l != null) {
        const c = l(this, o);
        if (typeof c.evaluate == "function") {
          c.director = this, c.track = o, this._customTracks.push(c);
          continue;
        }
      }
      if (o.type === Vi.Animation) {
        if (!o.clips || o.clips.length <= 0) {
          as && console.warn("Animation track has no clips", o);
          continue;
        }
        for (let c = o.outputs.length - 1; c >= 0; c--) {
          let h = o.outputs[c];
          if (h instanceof L) {
            const u = S.getOrAddComponent(h, zt);
            u && (h = u);
          }
          const d = (e = h == null ? void 0 : h.gameObject) == null ? void 0 : e.animations;
          if (d) {
            const u = new __();
            u.trackOffset = o.trackOffset, u.director = this, u.track = o;
            for (let p = 0; p < o.clips.length; p++) {
              const m = o.clips[p], g = m.asset;
              if (!g) {
                console.error(`Timeline ${this.name}: clip #${p} on track "${o.name}" has no animation data`);
                continue;
              }
              const _ = g.clip;
              let y = _;
              if ((typeof y == "string" || typeof y == "number") && (y = d.find((w) => w.name === _)), as && console.log(g, _, "→", y), !y) {
                console.warn("Could not find animationClip for model", m, o.name, this.name, (i = this.playableAsset) == null ? void 0 : i.name, d, h);
                continue;
              }
              h instanceof zt && h.runtimeAnimatorController && (h.__internalDidAwakeAndStart || h.initializeRuntimeAnimatorController(), h.runtimeAnimatorController.mixer || h.runtimeAnimatorController.bind(h), u.mixer = h.runtimeAnimatorController.mixer), u.mixer || (u.mixer = new og(h.gameObject), this.context.animations.registerAnimationMixer(u.mixer)), u.clips.push(y), u.mixer.uncacheAction(y), u.createHooks(m.asset, y);
              const b = u.mixer.clipAction(y);
              u.actions.push(b), u.models.push(m);
            }
            this._animationTracks.push(u);
          }
        }
      } else if (o.type === Vi.Audio) {
        if (!o.clips || o.clips.length <= 0)
          continue;
        const c = new Ta();
        c.director = this, c.track = o, c.audioSource = o.outputs.find((h) => h instanceof qe), this._audioTracks.push(c), t || (t = (n = this.context.mainCameraComponent) == null ? void 0 : n.gameObject.addComponent(lo)), c.listener = t.listener;
        for (let h = 0; h < o.clips.length; h++) {
          const d = o.clips[h];
          c.addModel(d);
        }
      } else if (o.type === Vi.Marker) {
        const c = new ru();
        if (c.director = this, c.track = o, o.markers)
          for (const h of o.markers)
            switch (h.type) {
              case ox.Signal:
                c.models.push(h), c.didTrigger.push(!1);
                break;
            }
        if (c !== null && c.models.length > 0) {
          const h = S.getComponent(this.gameObject, Ch);
          h && (c.receivers.push(h), this._signalTracks.push(c));
        }
      } else if (o.type === Vi.Signal) {
        const c = new ru();
        if (c.director = this, c.track = o, o.markers)
          for (const h of o.markers)
            c.models.push(h), c.didTrigger.push(!1);
        for (const h of o.outputs)
          c.receivers.push(h);
        this._signalTracks.push(c);
      } else if (o.type === Vi.Control) {
        const c = new y_();
        if (c.director = this, c.track = o, o.clips)
          for (const h of o.clips)
            c.models.push(h);
        c.resolveSourceObjects(this.context), this._controlTracks.push(c);
      }
    }
  }
  setAudioTracksAllowPlaying(t) {
    for (const e of this._audioTracks)
      e.onAllowAudioChanged(t);
  }
  /** Experimental: Receive callbacks for timeline animation. Allows modification of final value */
  registerAnimationCallback(t) {
    this.animationCallbackReceivers.push(t);
  }
  /** Experimental: Unregister callbacks for timeline animation. Allows modification of final value */
  unregisterAnimationCallback(t) {
    const e = this.animationCallbackReceivers.indexOf(t);
    e !== -1 && this.animationCallbackReceivers.splice(e, 1);
  }
}, r(qp, "createTrackFunctions", {}), qp);
let Rr = Km;
rx([
  f()
], Rr.prototype, "playOnAwake", 2);
rx([
  f()
], Rr.prototype, "extrapolationMode", 2);
var OE = Object.defineProperty, ME = Object.getOwnPropertyDescriptor, yf = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? ME(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && OE(t, e, n), n;
};
class yl extends I {
  constructor() {
    super(...arguments);
    r(this, "isGizmo", !1);
    r(this, "translationSnap", 1);
    r(this, "rotationSnapAngle", 15);
    r(this, "scaleSnap", 0.25);
    r(this, "_control");
    r(this, "orbit");
    /**
     * Event handler for when dragging state changes.
     * Disables orbit controls during dragging and requests ownership of the transform if it's synchronized.
     * @param event The drag change event
     */
    r(this, "onControlChangedEvent", (e) => {
      const i = this.orbit;
      if (i && (i.enabled = !e.value), e.value) {
        const n = S.getComponentInParent(this.gameObject, As);
        n && n.requestOwnership();
      }
    });
    /**
     * Handles keyboard shortcuts for transform operations:
     * - Q: Toggle local/world space
     * - W: Translation mode
     * - E: Rotation mode
     * - R: Scale mode
     * - Shift: Enable snapping (while held)
     * - +/-: Adjust gizmo size
     * - X/Y/Z: Toggle visibility of respective axis
     * - Spacebar: Toggle controls enabled state
     * @param event The keyboard event
     */
    r(this, "windowKeyDownListener", (e) => {
      if (this.enabled && this._control)
        switch (e.keyCode) {
          case 81:
            this._control.setSpace(this._control.space === "local" ? "world" : "local");
            break;
          case 16:
            this.enableSnapping();
            break;
          case 87:
            this._control.setMode("translate");
            break;
          case 69:
            this._control.setMode("rotate");
            break;
          case 82:
            this._control.setMode("scale");
            break;
          case 187:
          case 107:
            this._control.setSize(this._control.size + 0.1);
            break;
          case 189:
          case 109:
            this._control.setSize(Math.max(this._control.size - 0.1, 0.1));
            break;
          case 88:
            this._control.showX = !this._control.showX;
            break;
          case 89:
            this._control.showY = !this._control.showY;
            break;
          case 90:
            this._control.showZ = !this._control.showZ;
            break;
          case 32:
            this._control.enabled = !this._control.enabled;
            break;
        }
    });
    /**
     * Handles keyboard key release events.
     * Currently only handles releasing Shift key to disable snapping.
     * @param event The keyboard event
     */
    r(this, "windowKeyUpListener", (e) => {
      if (this.enabled)
        switch (e.keyCode) {
          case 16:
            this.disableSnapping();
            break;
        }
    });
  }
  /**
   * Gets the underlying three.js {@link TransformControls} instance.
   * @returns The TransformControls instance or undefined if not initialized.
   */
  get control() {
    return this._control;
  }
  /** @internal */
  onEnable() {
    var e;
    if (!(this.isGizmo && !Xc) && this.context.mainCamera && (this._control || (this._control = new hS(this.context.mainCamera, this.context.renderer.domElement), this._control.enabled = !0, this._control.getRaycaster().layers.set(2), this._control.size = 1, ("_root" in this._control ? this._control._root : this._control).traverse((n) => {
      const o = n;
      if (o.layers.set(2), o) {
        const a = o.material;
        a && (a.opacity = 0.3);
      }
    }), this.orbit = S.getComponentInParent(this.context.mainCamera, be) ?? void 0), this._control)) {
      const i = this._control.getHelper();
      this.context.scene.add(i), this._control.attach(this.gameObject), (e = this._control) == null || e.addEventListener("dragging-changed", this.onControlChangedEvent), window.addEventListener("keydown", this.windowKeyDownListener), window.addEventListener("keyup", this.windowKeyUpListener);
    }
  }
  /** @internal */
  onDisable() {
    var e, i, n;
    (i = (e = this._control) == null ? void 0 : e.getHelper()) == null || i.removeFromParent(), (n = this._control) == null || n.removeEventListener("dragging-changed", this.onControlChangedEvent), window.removeEventListener("keydown", this.windowKeyDownListener), window.removeEventListener("keyup", this.windowKeyUpListener);
  }
  /**
   * Enables grid snapping for transform operations according to set snap values.
   * This applies the translationSnap, rotationSnapAngle, and scaleSnap properties to the controls.
   */
  enableSnapping() {
    this._control && (this._control.setTranslationSnap(this.translationSnap), this._control.setRotationSnap(Cs.degToRad(this.rotationSnapAngle)), this._control.setScaleSnap(this.scaleSnap));
  }
  /**
   * Disables grid snapping for transform operations.
   * Removes all snapping constraints from the transform controls.
   */
  disableSnapping() {
    this._control && (this._control.setTranslationSnap(null), this._control.setRotationSnap(null), this._control.setScaleSnap(null));
  }
}
yf([
  f()
], yl.prototype, "isGizmo", 2);
yf([
  f()
], yl.prototype, "translationSnap", 2);
yf([
  f()
], yl.prototype, "rotationSnapAngle", 2);
yf([
  f()
], yl.prototype, "scaleSnap", 2);
var RE = Object.defineProperty, kE = Object.getOwnPropertyDescriptor, bf = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? kE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && RE(t, e, n), n;
};
class b_ {
  constructor() {
    r(this, "texture", null);
    r(this, "rect");
  }
}
bf([
  f(Fe)
], b_.prototype, "texture", 2);
let Ph = class extends nf {
  constructor() {
    super(...arguments);
    r(this, "_sprite");
    r(this, "pixelsPerUnitMultiplier", 1);
  }
  set image(e) {
    this.sprite || (this.sprite = new b_()), this.sprite.texture = e, this.onAfterCreated();
  }
  get image() {
    return this.sprite ? this.sprite.texture : null;
  }
  get sprite() {
    return this._sprite;
  }
  set sprite(e) {
    this._sprite !== e && (this._sprite = e, this.onAfterCreated());
  }
  isBuiltinSprite() {
    var i, n, o, a, l, c, h;
    const e = this.sprite;
    switch ((i = e == null ? void 0 : e.texture) == null ? void 0 : i.name) {
      case "InputFieldBackground":
      case "UISprite":
      case "Background":
      case "Knob":
        return !0;
    }
    return !((o = (n = e == null ? void 0 : e.texture) == null ? void 0 : n.name) != null && o.length) && ((l = (a = e == null ? void 0 : e.texture) == null ? void 0 : a.image) == null ? void 0 : l.width) === 32 && ((h = (c = e == null ? void 0 : e.texture) == null ? void 0 : c.image) == null ? void 0 : h.height) === 32;
  }
  onBeforeCreate(e) {
    var i, n;
    super.onBeforeCreate(e), this.isBuiltinSprite() && (e.borderRadius = 5 / this.pixelsPerUnitMultiplier, ((n = (i = this.sprite) == null ? void 0 : i.texture) == null ? void 0 : n.name) === "Knob" && (e.borderRadius = 999));
  }
  onAfterCreated() {
    var e;
    this.__didAwake && (super.onAfterCreated(), !this.isBuiltinSprite() && this.setTexture((e = this.sprite) == null ? void 0 : e.texture));
  }
};
bf([
  f(b_)
], Ph.prototype, "sprite", 1);
bf([
  f()
], Ph.prototype, "pixelsPerUnitMultiplier", 2);
class v_ extends nf {
  constructor() {
    super(...arguments);
    r(this, "_mainTexture");
  }
  get mainTexture() {
    return this._mainTexture;
  }
  set mainTexture(e) {
    this._mainTexture !== e && (this._mainTexture = e, this.onAfterCreated());
  }
  onAfterCreated() {
    this.__didAwake && (super.onAfterCreated(), this.setTexture(this.mainTexture));
  }
}
bf([
  f(Fe)
], v_.prototype, "mainTexture", 1);
var TE = Object.defineProperty, AE = Object.getOwnPropertyDescriptor, Fi = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? AE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && TE(t, e, n), n;
};
const Vo = x("debugbutton");
class Lo {
  constructor() {
    r(this, "colorMultiplier");
    r(this, "disabledColor");
    r(this, "fadeDuration");
    r(this, "highlightedColor");
    r(this, "normalColor");
    r(this, "pressedColor");
    r(this, "selectedColor");
  }
}
Fi([
  f()
], Lo.prototype, "colorMultiplier", 2);
Fi([
  f(we)
], Lo.prototype, "disabledColor", 2);
Fi([
  f()
], Lo.prototype, "fadeDuration", 2);
Fi([
  f(we)
], Lo.prototype, "highlightedColor", 2);
Fi([
  f(we)
], Lo.prototype, "normalColor", 2);
Fi([
  f(we)
], Lo.prototype, "pressedColor", 2);
Fi([
  f(we)
], Lo.prototype, "selectedColor", 2);
class EE {
  constructor() {
    r(this, "disabledTrigger");
    r(this, "highlightedTrigger");
    r(this, "normalTrigger");
    r(this, "pressedTrigger");
    r(this, "selectedTrigger");
  }
}
class jo extends I {
  constructor() {
    super(...arguments);
    r(this, "onClick", new xe());
    r(this, "_isHovered", 0);
    r(this, "colors");
    r(this, "transition");
    r(this, "animationTriggers");
    r(this, "animator");
    r(this, "_interactable", !0);
    r(this, "_requestedAnimatorTrigger");
    r(this, "_isInit", !1);
    r(this, "_image");
  }
  /**
   * Invokes the onClick event
   */
  click() {
    var e;
    (e = this.onClick) == null || e.invoke();
  }
  onPointerEnter(e) {
    var n, o;
    const i = e.event.pointerType === "mouse" && e.button === 0;
    i && (this._isHovered += 1), Vo && console.warn("Button Enter", i, this._isHovered, (n = this.animationTriggers) == null ? void 0 : n.highlightedTrigger, this.animator), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.highlightedTrigger) : this.transition === 1 && this.colors && ((o = this._image) == null || o.setState("hovered")), i && this.context.input.setCursor("pointer"));
  }
  onPointerExit() {
    var e, i;
    this._isHovered -= 1, this._isHovered < 0 && (this._isHovered = 0), Vo && console.log("Button Exit", this._isHovered, (e = this.animationTriggers) == null ? void 0 : e.highlightedTrigger, this.animator), this.interactable && (this._isHovered > 0 || (this._isHovered = 0, this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.normalTrigger) : this.transition === 1 && this.colors && ((i = this._image) == null || i.setState("normal")), this.context.input.unsetCursor("pointer")));
  }
  onPointerDown(e) {
    var i, n;
    Vo && console.log("Button Down", (i = this.animationTriggers) == null ? void 0 : i.highlightedTrigger, this.animator), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.pressedTrigger) : this.transition === 1 && this.colors && ((n = this._image) == null || n.setState("pressed")));
  }
  onPointerUp(e) {
    var i, n;
    Vo && console.warn("Button Up", (i = this.animationTriggers) == null ? void 0 : i.highlightedTrigger, this.animator, this._isHovered), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this._isHovered ? this.animationTriggers.highlightedTrigger : this.animationTriggers.normalTrigger) : this.transition === 1 && this.colors && ((n = this._image) == null || n.setState(this._isHovered ? "hovered" : "normal")));
  }
  onPointerClick(e) {
    if (this.interactable && !(e.button !== 0 && e.event.pointerType === vg.Mouse) && (Vo && (console.warn("Button Click", this.onClick), We("CLICKED button " + this.name + " at " + this.context.time.frameCount)), this.onClick && this.onClick.listenerCount > 0 && (this.onClick.invoke(), e.use(), Vo))) {
      const i = this.gameObject.worldPosition;
      i.add(this.gameObject.worldUp.multiplyScalar(1 + Math.random() * 0.5)), V.DrawLabel(i, "CLICK:" + Date.now(), 0.1, 1 + Math.random() * 0.5);
    }
  }
  set interactable(e) {
    this._interactable = e, this._image && (this._image.setInteractable(e), e ? this._image.setState("normal") : this._image.setState("disabled"));
  }
  get interactable() {
    return this._interactable;
  }
  set_interactable(e) {
    this.interactable = e;
  }
  awake() {
    super.awake(), Vo && console.log(this), this._isInit = !1, this.init();
  }
  start() {
    var e;
    (e = this._image) == null || e.setInteractable(this.interactable), this.gameObject.getComponentInParent(qa) || this.gameObject.addComponent(jg);
  }
  onEnable() {
    super.onEnable();
  }
  onDestroy() {
    this._isHovered && this.context.input.unsetCursor("pointer");
  }
  *setAnimatorTriggerAtEndOfFrame(e) {
    var i;
    this._requestedAnimatorTrigger = e, yield, yield, this._requestedAnimatorTrigger == e && ((i = this.animator) == null || i.setTrigger(e));
  }
  init() {
    this._isInit || (this._isInit = !0, this._image = S.getComponent(this.gameObject, Ph), this._image && (this.stateSetup(this._image), this.interactable ? this._image.setState("normal") : this._image.setState("disabled")));
  }
  stateSetup(e) {
    var m, g, _, y, b;
    e.setInteractable(this.interactable);
    const i = this.getFinalColor(e.color, (m = this.colors) == null ? void 0 : m.normalColor), n = {
      state: "normal",
      attributes: {
        backgroundColor: i,
        backgroundOpacity: i.alpha
      }
    };
    e.setupState(n);
    const o = this.getFinalColor(e.color, (g = this.colors) == null ? void 0 : g.highlightedColor), a = {
      state: "hovered",
      attributes: {
        backgroundColor: o,
        backgroundOpacity: o.alpha
      }
    };
    e.setupState(a);
    const l = this.getFinalColor(e.color, (_ = this.colors) == null ? void 0 : _.pressedColor), c = {
      state: "pressed",
      attributes: {
        backgroundColor: l,
        backgroundOpacity: l.alpha
      }
    };
    e.setupState(c);
    const h = this.getFinalColor(e.color, (y = this.colors) == null ? void 0 : y.selectedColor), d = {
      state: "selected",
      attributes: {
        backgroundColor: h,
        backgroundOpacity: h.alpha
      }
    };
    e.setupState(d);
    const u = this.getFinalColor(e.color, (b = this.colors) == null ? void 0 : b.disabledColor), p = {
      state: "disabled",
      attributes: {
        backgroundColor: u,
        // @marwie, this disabled alpha property doesn't seem to have the opacity requested in unity
        backgroundOpacity: u.alpha
      }
    };
    e.setupState(p);
  }
  getFinalColor(e, i) {
    return i ? e.clone().multiply(i).convertLinearToSRGB() : e.clone().convertLinearToSRGB();
  }
}
Fi([
  f(xe)
], jo.prototype, "onClick", 2);
Fi([
  f(Lo)
], jo.prototype, "colors", 2);
Fi([
  f()
], jo.prototype, "transition", 2);
Fi([
  f(EE)
], jo.prototype, "animationTriggers", 2);
Fi([
  f(zt)
], jo.prototype, "animator", 2);
Fi([
  f()
], jo.prototype, "interactable", 1);
var IE = Object.defineProperty, DE = Object.getOwnPropertyDescriptor, vf = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? DE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && IE(t, e, n), n;
};
const Qs = x("debuginputfield");
var ia;
const K = (ia = class extends I {
  constructor() {
    super(...arguments);
    r(this, "textComponent");
    r(this, "placeholder");
    r(this, "onValueChanged");
    r(this, "onEndEdit");
    r(this, "inputEventFn");
    r(this, "_iosEventFn");
  }
  get text() {
    var t;
    return ((t = this.textComponent) == null ? void 0 : t.text) ?? "";
  }
  set text(t) {
    this.textComponent && (this.textComponent.text = t, this.placeholder && (t.length > 0 ? this.placeholder.gameObject.visible = !1 : this.placeholder.gameObject.visible = !0));
  }
  get isFocused() {
    return K.active === this;
  }
  start() {
    Qs && console.log(this.name, this);
  }
  onEnable() {
    var t;
    K.htmlField || (K.htmlField = document.createElement("input"), K.htmlField.style.width = "0px", K.htmlField.style.height = "0px", K.htmlField.style.padding = "0px", K.htmlField.style.border = "none", K.htmlField.style.overflow = "hidden", K.htmlField.style.caretColor = "transparent", K.htmlField.style.outline = "none", K.htmlField.classList.add("ar"), K.htmlField.onfocus = () => K.htmlFieldFocused = !0, K.htmlField.onblur = () => K.htmlFieldFocused = !1, document.body.append(K.htmlField)), this.inputEventFn || (this.inputEventFn = this.onInput.bind(this)), K.htmlField.addEventListener("keyup", this.inputEventFn), this.placeholder && ((t = this.textComponent) != null && t.text.length) && S.setActive(this.placeholder.gameObject, !1), X.isiOS() && (this._iosEventFn = this.processInputOniOS.bind(this), window.addEventListener("click", this._iosEventFn));
  }
  onDisable() {
    var t;
    (t = K.htmlField) == null || t.removeEventListener("keyup", this.inputEventFn), this.onDeselected(), this._iosEventFn && window.removeEventListener("click", this._iosEventFn);
  }
  /** Clear the input field if it's currently active */
  clear() {
    K.active === this && K.htmlField ? (K.htmlField.value = "", this.setTextFromInputField()) : (this.textComponent && (this.textComponent.text = ""), this.placeholder && S.setActive(this.placeholder.gameObject, !0));
  }
  /** Select the input field, set it active to receive keyboard input */
  select() {
    this.onSelected();
  }
  /** Deselect the input field, stop receiving keyboard input */
  deselect() {
    this.onDeselected();
  }
  onPointerEnter(t) {
    t.event.pointerType === "mouse" && t.button === 0 && this.context.input.setCursor("text");
  }
  onPointerExit(t) {
    this.context.input.unsetCursor("text");
  }
  onPointerClick(t) {
    Qs && console.log("CLICK", t, K.active), K.activeTime = this.context.time.time, K.active !== this && this.startCoroutine(this.activeLoop(), Re.LateUpdate), this.selectInputField();
  }
  *activeLoop() {
    for (this.onSelected(); K.active === this && !(this.context.input.getPointerClicked(0) && this.context.time.time - K.activeTime > 0.2); )
      this.setTextFromInputField(), yield;
    this.onDeselected();
  }
  onSelected() {
    var t, e, i, n;
    if (K.active !== this && (Qs && console.log("Select", this.name, this, K.htmlField, this.context.isInXR, this.context.arOverlayElement, (t = this.textComponent) == null ? void 0 : t.text, (e = K.htmlField) == null ? void 0 : e.value), (i = K.active) == null || i.onDeselected(), K.active = this, this.placeholder && S.setActive(this.placeholder.gameObject, !1), K.htmlField)) {
      if (K.htmlField.value = ((n = this.textComponent) == null ? void 0 : n.text) || "", Qs && console.log("set input field value", K.htmlField.value), this.context.isInXR) {
        const o = this.context.arOverlayElement;
        o && o.append(K.htmlField);
      }
      this.selectInputField();
    }
  }
  onDeselected() {
    var t;
    K.active === this && (K.active = null, Qs && console.log("Deselect", this.name, this), K.htmlField && (K.htmlField.blur(), document.body.append(K.htmlField)), this.placeholder && (!this.textComponent || this.textComponent.text.length <= 0) && S.setActive(this.placeholder.gameObject, !0), K.htmlField && ((t = this.onEndEdit) == null || t.invoke(K.htmlField.value)));
  }
  // @Marwie, I can provide this fix. But the issue seems to comes from Raycaster+EventSystem
  // As we rollout InputField, and no others elements is behind raycast,
  // ThreeMeshUI.update is not called.
  update() {
    var t;
    K.active === this && ((t = this.textComponent) == null || t.markDirty());
  }
  onInput(t) {
    var e, i;
    if (K.active === this) {
      if (Qs && console.log(t.code, t, (e = K.htmlField) == null ? void 0 : e.value, (i = this.textComponent) == null ? void 0 : i.text), t.code === "Escape" || t.code === "Enter") {
        this.onDeselected();
        return;
      }
      K.htmlField && (this.textComponent && (this.setTextFromInputField(), this.placeholder && S.setActive(this.placeholder.gameObject, this.textComponent.text.length <= 0)), this.selectInputField());
    }
  }
  setTextFromInputField() {
    var t;
    if (this.textComponent && K.htmlField) {
      const e = this.textComponent.text, i = K.htmlField.value, n = this.textComponent.text !== K.htmlField.value;
      this.textComponent.text = K.htmlField.value, n && (Qs && console.log("[InputField] value changed:", i, e), (t = this.onValueChanged) == null || t.invoke(i, e));
    }
  }
  selectInputField() {
    K.htmlField && (Qs && console.log("Focus Inputfield", K.htmlFieldFocused), K.htmlField.setSelectionRange(K.htmlField.value.length, K.htmlField.value.length), X.isiOS() ? K.htmlField.focus({ preventScroll: !0 }) : setTimeout(() => {
      var t;
      return (t = K.htmlField) == null ? void 0 : t.focus();
    }, 1));
  }
  processInputOniOS() {
    const t = this.context.physics.raycast();
    if (!t.length)
      return;
    const i = t[0].object, n = Bg(i);
    ((n == null ? void 0 : n.gameObject) === this.gameObject || (n == null ? void 0 : n.gameObject.parent) === this.gameObject) && this.selectInputField();
  }
  // private static _lastDeletionTime: number = 0;
  // private static _lastKeyInputTime: number = 0;
  // TODO: support modifiers, refactor to not use backspace as string etc
  // private handleKey(key: string | null) {
  //     if (!this.textComponent) return;
  //     if (!key) return;
  //     InputField._lastKey = key || "";
  //     const text = this.textComponent.text;
  //     if (debug)
  //         console.log(key, text);
  //     switch (key) {
  //         case "Backspace":
  //             this.deleteLetter();
  //             break;
  //         default:
  //             this.appendLetter(key);
  //             break;
  //     }
  // }
  // private appendLetter(key: string | null) {
  //     if (this.textComponent && key) {
  //         const timeSinceLastInput = this.context.time.time - InputField._lastKeyInputTime;
  //         if (key.length === 1 && (this.context.input.getKeyDown() === key || timeSinceLastInput > .1)) {
  //             this.textComponent.text += key;
  //             InputField._lastKeyInputTime = this.context.time.time;
  //         }
  //     }
  // }
  // private deleteLetter() {
  //     if (this.textComponent) {
  //         const text = this.textComponent.text;
  //         if (text.length > 0 && this.context.time.time - InputField._lastDeletionTime > 0.05) {
  //             this.textComponent.text = text.slice(0, -1);
  //             InputField._lastDeletionTime = this.context.time.time;
  //         }
  //     }
  // }
}, r(ia, "active", null), r(ia, "activeTime", -1), r(ia, "htmlField", null), r(ia, "htmlFieldFocused", !1), ia);
let bl = K;
vf([
  f(si)
], bl.prototype, "textComponent", 2);
vf([
  f(si)
], bl.prototype, "placeholder", 2);
vf([
  f(xe)
], bl.prototype, "onValueChanged", 2);
vf([
  f(xe)
], bl.prototype, "onEndEdit", 2);
var LE = Object.defineProperty, jE = Object.getOwnPropertyDescriptor, ax = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? jE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && LE(t, e, n), n;
};
class wf extends I {
  constructor() {
    super(...arguments);
    r(this, "id", null);
    r(this, "keepAspect", !1);
    r(this, "_object", null);
  }
  onEnable() {
    if (this._object) {
      this.gameObject.add(this._object);
      return;
    }
    if (!this.id || !this.context.mainCamera)
      return;
    const e = document.getElementById(this.id);
    if (!e) {
      console.warn('Could not find element with id "' + this.id + '"');
      return;
    }
    e.style.display = "block", e.style.visibility = "hidden";
    const i = new dS();
    i.listenToPointerEvents(this.context.renderer, this.context.mainCamera), this.gameObject.add(i);
    const n = new uS(e);
    i.add(n), n.visible = !1;
    const o = n.material;
    o.transparent = !0, setTimeout(() => {
      n.visible = !0;
      const a = Au(this.gameObject).clone();
      Eu(this.gameObject, 0, 0, 0), this.gameObject.updateMatrixWorld();
      const l = new Pi();
      l.setFromObject(i), this.setWorldRotation(a.x, a.y, a.z);
      const c = l.max.x - l.min.x, h = l.max.y - l.min.y;
      if (this.keepAspect) {
        const u = c / h;
        c > h ? n.scale.set(1 / c, 1 / h / u, 1) : n.scale.set(1 / c * u, 1 / h, 1);
      } else
        n.scale.set(1 / c, 1 / h, 1);
      const d = this.gameObject.scale;
      n.scale.multiply(d);
    }, 1);
  }
  onDisable() {
    var e;
    (e = this._object) == null || e.removeFromParent();
  }
}
ax([
  f()
], wf.prototype, "id", 2);
ax([
  f()
], wf.prototype, "keepAspect", 2);
var BE = Object.defineProperty, FE = Object.getOwnPropertyDescriptor, xf = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? FE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && BE(t, e, n), n;
}, Xp;
const lx = (Xp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "target");
    r(this, "invertForward", !1);
    r(this, "keepUpDirection", !0);
    r(this, "copyTargetRotation", !1);
  }
  /** @internal */
  onBeforeRender() {
    let t = this.target;
    if (t || (t = this.context.mainCamera), !t)
      return;
    let e = this.copyTargetRotation;
    (this.context.isInVR || this.context.isInPassThrough) && (e = !1), Tu(this.gameObject, t, this.keepUpDirection, e), this.invertForward && this.gameObject.quaternion.multiply(lx.flipYQuat);
  }
  /** @internal */
  createBehaviours(t, e, i) {
    if (e.uuid === this.gameObject.uuid) {
      let n = e;
      if (this.keepUpDirection) {
        const a = Lt.createEmptyParent(e);
        n = a;
        const l = this.invertForward ? -1 : 1;
        a.setMatrix(a.getMatrix().multiply(new se().makeRotationZ(Math.PI / 2 * l))), e.setMatrix(e.getMatrix().multiply(new se().makeRotationZ(-Math.PI / 2 * l)));
      }
      const o = new kt(
        "lookat " + this.name,
        Ft.sceneStartTrigger(),
        ge.lookAtCameraAction(
          n,
          void 0,
          this.invertForward ? Ki.back : Ki.forward,
          this.keepUpDirection ? Ki.up : Ki.zero
        )
      );
      t.addBehavior(o);
    }
  }
}, r(Xp, "flipYQuat", new W().setFromAxisAngle(new v(0, 1, 0), Math.PI)), Xp);
let vl = lx;
xf([
  f(L)
], vl.prototype, "target", 2);
xf([
  f()
], vl.prototype, "invertForward", 2);
xf([
  f()
], vl.prototype, "keepUpDirection", 2);
xf([
  f()
], vl.prototype, "copyTargetRotation", 2);
var zE = Object.defineProperty, UE = Object.getOwnPropertyDescriptor, w_ = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? UE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && zE(t, e, n), n;
};
class Oh extends I {
  constructor() {
    super(...arguments);
    r(this, "url");
    r(this, "mode", 0);
    r(this, "clickable", !0);
  }
  /**
   * Opens the URL in a new tab or window.
   */
  async open() {
    if (!this.url) {
      console.warn("OpenURL: URL is not set, can't open.", this);
      return;
    }
    this._validateUrl();
    let e = this.url;
    switch (!e.startsWith("mailto:") && e.includes("@") && (e = "mailto:" + e), z() && We("Open URL: " + e), this.mode) {
      case 0:
        X.isSafari(), globalThis.open(e, "_blank");
        break;
      case 1:
        X.isSafari() && X.isiOS() ? globalThis.open(e, "_top") : globalThis.open(e, "_self");
        break;
      case 2:
        X.isSafari() ? globalThis.open(e, "_top") : globalThis.open(e, "_new");
        break;
    }
  }
  /** @internal */
  start() {
    this.gameObject.getComponentInParent(sn) || this.gameObject.addComponent(sn);
  }
  /** @internal */
  onPointerEnter(e) {
    !e.used && this.clickable && this.context.input.setCursor("pointer");
  }
  /** @internal */
  onPointerExit() {
    this.clickable && this.context.input.unsetCursor("pointer");
  }
  /** @internal */
  onPointerClick(e) {
    var i;
    this.clickable && !e.used && ((i = this.url) != null && i.length) && this.open();
  }
  _validateUrl() {
    this.url && this.url.startsWith("www.") && (z() && console.warn("URL is not valid, adding https:// to the start of the URL", this.url), this.url = "https://" + this.url);
  }
}
w_([
  f()
], Oh.prototype, "url", 2);
w_([
  f()
], Oh.prototype, "mode", 2);
w_([
  f()
], Oh.prototype, "clickable", 2);
var NE = Object.defineProperty, $E = Object.getOwnPropertyDescriptor, wl = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? $E(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && NE(t, e, n), n;
};
class Bo extends I {
  constructor() {
    super(...arguments);
    r(this, "side", "none");
    r(this, "controller", !0);
    r(this, "hands", !1);
    r(this, "controlVisibility", !0);
    r(this, "useGripSpace", !1);
    r(this, "resetTransformAfterXRSession", !0);
    r(this, "_startPosition", new v());
    r(this, "_startRotation", new W());
    r(this, "_startScale", new v());
  }
  // override active and enabled here so that we always receive xr update events
  get activeAndEnabled() {
    return !0;
  }
  /** @internal */
  onEnterXR(e) {
    this._startPosition.copy(this.gameObject.position), this._startRotation.copy(this.gameObject.quaternion), this._startScale.copy(this.gameObject.scale);
  }
  /** @internal */
  onUpdateXR(e) {
    if (!this.enabled)
      return;
    const i = e.xr.getController(this.side);
    if (i) {
      if (i.hand && !this.hands) {
        this.controlVisibility && (this.gameObject.visible = !1);
        return;
      } else if (!this.controller) {
        this.controlVisibility && (this.gameObject.visible = !1);
        return;
      }
      this.controlVisibility && (this.gameObject.visible = !0), this.useGripSpace || i.targetRayMode === "transient-pointer" ? (this.gameObject.worldPosition = i.gripWorldPosition, this.gameObject.worldQuaternion = i.gripWorldQuaternion, this.gameObject.worldScale = G(i.xr.rigScale, i.xr.rigScale, i.xr.rigScale).multiply(this._startScale)) : (this.gameObject.worldPosition = i.rayWorldPosition, this.gameObject.worldQuaternion = i.rayWorldQuaternion, this.gameObject.worldScale = G(i.xr.rigScale, i.xr.rigScale, i.xr.rigScale).multiply(this._startScale));
    }
  }
  /** @internal */
  onLeaveXR(e) {
    this.resetTransformAfterXRSession && (this.gameObject.position.copy(this._startPosition), this.gameObject.quaternion.copy(this._startRotation), this.gameObject.scale.copy(this._startScale));
  }
}
wl([
  f()
], Bo.prototype, "side", 2);
wl([
  f()
], Bo.prototype, "controller", 2);
wl([
  f()
], Bo.prototype, "hands", 2);
wl([
  f()
], Bo.prototype, "controlVisibility", 2);
wl([
  f()
], Bo.prototype, "useGripSpace", 2);
wl([
  f()
], Bo.prototype, "resetTransformAfterXRSession", 2);
function cx(s, t) {
  const e = s.xr.getFrame();
  if (!e)
    return console.warn("No XRFrame available"), !1;
  const i = e.session.enabledFeatures;
  if (i && !i.some((o) => o === "camera-access"))
    return console.error(`No camera feed available - please request the 'camera-access' feature before starting WebXR or add the ARCameraBackground component to your scene.

Example to request camera-access in global scope:
NeedleXRSession.onSessionRequestStart(evt => {
    evt.init.optionalFeatures = evt.init.optionalFeatures || [];
    evt.init.optionalFeatures.push('camera-access');
});
`), z() && Iu("No camera feed available - please request the 'camera-access' feature before starting WebXR or add the ARCameraBackground component to your scene"), !1;
  const n = e.getViewerPose(s.xr.getReferenceSpace());
  if (n)
    for (const o of n.views)
      if ("camera" in o && o.camera) {
        let a = s.xr.getBinding();
        if (a || (a = new XRWebGLBinding(e.session, s.getContext())), a) {
          let l = null;
          if ("getCameraImage" in a) {
            WE(s, t);
            const c = s.properties.get(t);
            if (c)
              return l = a.getCameraImage(o.camera), c.__webglTexture = l, !0;
            console.warn("No texture properties found for target texture");
          }
        } else
          console.error(o.camera, s.xr);
      } else
        console.error("NO CAMERA IN VIEW");
  else
    console.error(s.xr.getReferenceSpace(), e);
  return !1;
}
const Ub = /* @__PURE__ */ new WeakMap();
function WE(s, t) {
  const e = Ub.get(t) || /* @__PURE__ */ new WeakSet();
  if (e.has(s))
    return;
  e.add(s), Ub.set(t, e), console.debug("Initialize texture for camera feed");
  const i = new Me(), n = new Xn(), o = new Mi();
  o.add(new q(n, i));
  const a = new ye();
  i.map = t, s.render(o, a);
}
function nL(s, t, e, i = "image/webp", n) {
  return hx({ context: s, width: t, height: e, mimeType: i, camera: n });
}
function hx(s) {
  var O, M;
  s || (s = {});
  const { transparent: t = !1 } = s;
  let { mimeType: e, context: i, width: n, height: o, camera: a } = s;
  if (!i && (i = fe.Current, !i))
    return console.error("Can not save screenshot: No needle-engine context found or provided."), null;
  if (!a && (a = i.mainCamera, !a))
    return console.error("No camera found"), null;
  const l = i.renderer, c = l.xr.enabled;
  if (c && i.currentFrameEvent != Re.EarlyUpdate)
    return console.warn("Screenshot: defer to access XR frame"), new Promise((B) => {
      Ds((A) => {
        const F = hx(s);
        B(F);
      }, Re.EarlyUpdate, { once: !0 });
    });
  const h = l.domElement, d = h.width, u = h.height;
  n || (n = d), o || (o = u);
  const p = n, m = o, g = window.devicePixelRatio || 1;
  n /= g, o /= g, l.xr.isPresenting && l.xr.getFrame();
  const _ = l.xr.enabled;
  l.xr.enabled = !1, l.xr.isPresenting = !1, h.style.width = `${n}px`, h.style.height = `${o}px`;
  const y = l.getRenderTarget(), b = l.getClearColor(new ae()), w = l.getClearAlpha(), P = i.scene.background, k = "aspect" in a ? a.aspect : null;
  try {
    const E = s.render_events !== !1, B = new Array();
    E && (Qc(i.scene, Je, B), B.forEach((T) => {
      var j;
      if (T == null || T.onBeforeRender(), T.isInstancingActive && T.instances)
        for (let H = 0; H < ((j = T.instances) == null ? void 0 : j.length); H++) {
          const Y = T.instances[H];
          bs(Y.object, !0);
        }
    })), t && (i.scene.background = null, l.setClearColor(0, 0)), s.background && (i.scene.background = null, l.setClearColor(s.background), s.background instanceof we && l.setClearAlpha(s.background.a)), t && l.setClearAlpha(0), l.setSize(n, o, !1), "cam" in a && (a = a.threeCamera), a instanceof ye && (a.aspect = n / o, a.updateProjectionMatrix());
    const A = "type" in s && s.type === "texture";
    let F = null;
    A && (F = new ks(n, o, {
      wrapS: B_,
      wrapT: B_,
      format: 1023
    }), l.setRenderTarget(F));
    let U = h;
    if (c ? (F && console.error('Taking XR screenshots with { type: "texture" } is currently not supported.'), U = au.compositeWithCameraImage({
      width: p,
      height: m,
      scene: i.scene,
      camera: a,
      renderer: l
    })) : i.renderNow(a || null), a instanceof ye && k != null && (a.aspect = k, a.updateProjectionMatrix()), E && B.forEach((T) => T.onAfterRender()), !e && "download_filename" in s && s.download_filename)
      switch ((O = s.download_filename.split(".").pop()) == null ? void 0 : O.toLowerCase()) {
        case "png":
          e = "image/png";
          break;
        case "jpg":
        case "jpeg":
          e = "image/jpeg";
          break;
        case "webp":
          e = "image/webp";
          break;
      }
    if (t && s.trim === !0) {
      const T = VE(U);
      T && (U = T);
    }
    if ("type" in s) {
      if (s.type === "texture")
        return F ? (s.target && (s.target.image = F == null ? void 0 : F.texture.image, s.target.needsUpdate = !0), F.texture.offset.set(0, -1), F.texture.needsUpdate = !0, F.texture) : (console.error("No target texture found"), null);
      if (s.type === "blob")
        return new Promise((j, H) => {
          U.toBlob((Y) => {
            j(Y);
          }, e);
        });
      if (s.type === "share")
        return new Promise((j, H) => {
          U.toBlob((Y) => {
            if (Y && "share" in navigator) {
              let te = "file_type" in s && s.file_type || e;
              e || (te = "image/png");
              const le = (te == null ? void 0 : te.split("/")[1]) || "png", de = new File([Y], "filename" in s ? s.filename || `screenshot.${le}` : `screenshot.${le}`, { type: te });
              return navigator.share({
                title: "title" in s ? s.title : void 0,
                text: "text" in s ? s.text : void 0,
                url: "url" in s ? s.url : void 0,
                files: [de]
              }).catch((De) => {
                console.warn("User cancelled share", De.message);
              }).finally(() => {
                j({ blob: Y, shared: !0 });
              });
            }
            return {
              blob: Y,
              shared: !1
            };
          }, e);
        });
    }
    const Z = U.toDataURL(e);
    if ("download_filename" in s && s.download_filename) {
      let T = s.download_filename;
      if (X.isMobileDevice() && typeof window < "u") {
        const j = T + "_screenshots", H = T.split("."), Y = (M = H.pop()) == null ? void 0 : M.toLowerCase();
        let te = 0;
        localStorage.getItem(j) && (te = parseInt(sessionStorage.getItem(j) || "0")), te > 0 && (T = `${H.join()}-${te}.${Y}`), te += 1, sessionStorage.setItem(j, te.toString());
      }
      HE(Z, T);
    }
    return Z;
  } finally {
    l.setRenderTarget(y), i.scene.background = P, l.setSize(d, u, !1), l.setClearColor(b, w), k != null && a instanceof ye && (a.aspect = k, a.updateProjectionMatrix()), l.xr.enabled = _, l.xr.isPresenting = c, c || i.updateSize(!0);
  }
  return null;
}
function VE(s) {
  if (!("document" in globalThis))
    return null;
  const t = document.createElement("canvas");
  t.width = s.width, t.height = s.height;
  const e = t.getContext("2d");
  if (!e)
    return null;
  e.drawImage(s, 0, 0);
  const i = t.width, n = t.height, a = e.getImageData(0, 0, i, n).data;
  let l = n, c = i, h = 0, d = 0;
  for (let _ = 0; _ < n; _++)
    for (let y = 0; y < i; y++) {
      const b = (_ * i + y) * 4;
      a[b + 3] !== 0 && (y < c && (c = y), y > d && (d = y), _ < l && (l = _), _ > h && (h = _));
    }
  const u = d - c + 1, p = h - l + 1, m = document.createElement("canvas"), g = m.getContext("2d");
  return g ? (m.width = u, m.height = p, g.drawImage(t, c, l, u, p, 0, 0, u, p), m) : null;
}
let Bl = null;
function HE(s, t) {
  if (s) {
    if (!s.startsWith("data:image")) {
      console.error("Can not save image: Data url is not an image", s);
      return;
    }
    Bl || (Bl = document.createElement("a")), Bl.href = s, Bl.download = t, Bl.click();
  }
}
var au;
((s) => {
  let t = null, e = null, i = null, n = null, o = null;
  function a(h) {
    const { renderer: d, width: u, height: p } = h, m = d.xr.enabled, g = d.getRenderTarget(), _ = d.autoClear, y = u, b = p, w = u / p;
    (!i || i.width !== y || i.height !== b) && (i ?? (i = new ks(y, b, { colorSpace: vn })), i.width = y, i.height = b, i.samples = 4, i.texture.repeat.y = -1, i.texture.offset.y = 1), (!o || o.width !== y || o.height !== b) && (o = document.createElement("canvas"), o.width = y, o.height = b, o.style.position = "fixed", o.style.top = "0px", o.style.right = "0px", o.style.width = "300px", o.style.height = `${300 / w}px`, o.style.zIndex = "1000", o.style.pointerEvents = "none", o.style.opacity = "1.0", o.style.willChange = "contents"), t || (t = c({
      defines: {
        DECODE_VIDEO_TEXTURE: !0
      }
    })), e || (e = c()), n || (n = new Fe()), d.xr.updateCamera(h.camera), d.xr.enabled = !1, d.autoClear = !1, d.clear(), d.setSize(y, b), d.setRenderTarget(i), cx(h.renderer, n) || console.error("Could not update texture from XR frame");
    const k = S.findObjectOfType(Sf);
    return k ? k.setTexture(n) : (t.setTexture(n), d.render(t, h.camera)), d.clearDepth(), d.setSize(y, b), d.render(h.scene, h.camera), d.setRenderTarget(null), e.setTexture(i.texture), d.render(e, h.camera), o.getContext("2d", { alpha: !1 }).drawImage(d.domElement, 0, 0, o.width, o.height), d.setRenderTarget(g), d.xr.enabled = m, d.autoClear = _, o;
  }
  s.compositeWithCameraImage = a;
  const l = (
    /* glsl */
    `
uniform sampler2D t2D;
varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );

    #ifdef DECODE_VIDEO_TEXTURE

        // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
        texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    #endif

    gl_FragColor = texColor;
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`
  );
  function c(h) {
    const d = (h == null ? void 0 : h.material) || new bn({
      name: "BackgroundMaterial",
      uniforms: r0.clone(Dd.background.uniforms),
      vertexShader: Dd.background.vertexShader,
      fragmentShader: l,
      defines: h == null ? void 0 : h.defines,
      side: xo,
      depthTest: !1,
      depthWrite: !1,
      fog: !1
    });
    Object.defineProperty(d, "map", {
      get: function() {
        return this.threeTexture;
      }
    });
    const u = new q(new Xn(2, 2), d);
    return om(u, !1), u.geometry.deleteAttribute("normal"), u.renderOrder = -1e6, u.setTexture = function(p) {
      d.uniforms.t2D.value = p;
    }, u;
  }
  s.makeFullscreenPlane = c;
})(au || (au = {}));
var GE = Object.defineProperty, qE = Object.getOwnPropertyDescriptor, XE = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? qE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && GE(t, e, n), n;
};
const Nb = x("debugarcamera");
class Sf extends I {
  constructor() {
    super(...arguments);
    r(this, "backgroundTint", new we(1, 1, 1, 1));
    r(this, "backgroundPlane");
    r(this, "threeTexture");
    r(this, "forceTextureInitialization", function() {
      const e = new Me(), i = new Xn(), n = new Mi();
      n.add(new q(i, e));
      const o = new ye();
      return function(l, c) {
        e.map = c, l.render(n, o), Nb && console.warn("Force texture initialization");
      };
    }());
    /** @internal */
    r(this, "preRender", () => {
      if (!this || !this.gameObject)
        return;
      if (this.context.renderer.xr.getFrame()) {
        if (!this.threeTexture && this.context.renderer && (this.threeTexture = new Fe(), this.forceTextureInitialization(this.context.renderer, this.threeTexture)), this.backgroundPlane === void 0) {
          const n = this.backgroundTint;
          this.backgroundPlane = au.makeFullscreenPlane({
            material: new bn({
              name: "BackgroundMaterial",
              uniforms: {
                ...r0.clone(Dd.background.uniforms),
                tint: { value: new me(n.r, n.g, n.b, n.a) }
              },
              vertexShader: Dd.background.vertexShader,
              fragmentShader: QE,
              side: Ri,
              depthTest: !1,
              depthWrite: !1,
              fog: !1
            })
          });
        }
        this.backgroundPlane.parent !== this.scene && this.scene.add(this.backgroundPlane), this.backgroundPlane.material instanceof bn && this.backgroundPlane.material.uniforms.tint.value.set(this.backgroundTint.r, this.backgroundTint.g, this.backgroundTint.b, this.backgroundTint.a), this.updateFromFrame();
      }
    });
  }
  /** @internal */
  onBeforeXR(e, i) {
    e === "immersive-ar" && (i.optionalFeatures = i.optionalFeatures || [], i.optionalFeatures.push("camera-access"), Nb && console.warn("Requesting camera-access"));
  }
  /** @internal */
  onEnterXR(e) {
    e.xr.mode === "immersive-ar" && (this.backgroundPlane && (this.context.scene.add(this.backgroundPlane), this.backgroundPlane.visible = !1), this.backgroundPlane && this.context.scene.add(this.backgroundPlane), this.context.pre_render_callbacks.push(this.preRender));
  }
  /** @internal */
  onLeaveXR(e) {
    this.backgroundPlane && this.backgroundPlane.removeFromParent();
    const i = this.context.pre_render_callbacks.indexOf(this.preRender);
    i >= 0 && this.context.pre_render_callbacks.splice(i, 1);
  }
  get background() {
    return this.backgroundPlane;
  }
  /** @internal */
  onBeforeRender(e) {
    this.updateFromFrame();
  }
  updateFromFrame() {
    var e;
    this.threeTexture && ((e = this.context.xr) == null ? void 0 : e.mode) === "immersive-ar" && (cx(this.context.renderer, this.threeTexture), this.setTexture(this.threeTexture));
  }
  setTexture(e) {
    this.backgroundPlane && (this.threeTexture = e, this.backgroundPlane.setTexture(this.threeTexture), this.backgroundPlane.visible = !0);
  }
}
XE([
  f(we)
], Sf.prototype, "backgroundTint", 2);
const QE = (
  /* glsl */
  `
uniform sampler2D t2D;
uniform vec4 tint;

varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );
    texColor.w = 1.0;

    // inline sRGB decode
    texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    gl_FragColor = texColor * tint;

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`
);
var YE = Object.defineProperty, KE = Object.getOwnPropertyDescriptor, Fo = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? KE(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && YE(t, e, n), n;
};
const $b = x("debugimagetracking"), _u = class {
  constructor(t, e, i, n, o, a) {
    r(this, "measuredSize");
    r(this, "state");
    r(this, "_position");
    r(this, "_rotation");
    r(this, "_trackingComponent");
    r(this, "_trackedImage");
    r(this, "_bitmap");
    r(this, "_pose");
    this._trackingComponent = t, this._trackedImage = e, this._bitmap = i, this.measuredSize = n, this.state = o, this._pose = a;
  }
  get url() {
    return this._trackedImage.image ?? "";
  }
  get widthInMeters() {
    return this._trackedImage.widthInMeters ?? void 0;
  }
  get bitmap() {
    return this._bitmap;
  }
  get model() {
    return this._trackedImage;
  }
  /** Copy the image position to a vector */
  getPosition(t) {
    return this.ensureTransformData(), t.copy(this._position), t;
  }
  /** Copy the image rotation to a quaternion */
  getQuaternion(t) {
    return this.ensureTransformData(), t.copy(this._rotation), t;
  }
  applyToObject(t, e = void 0) {
    this.ensureTransformData();
    const i = t.position.distanceToSquared(this._position) / 0.05 + t.quaternion.angleTo(this._rotation) / 0.05;
    e && (e *= Math.max(1, i)), e === void 0 || e >= 1 ? (t.position.copy(this._position), t.quaternion.copy(this._rotation)) : (e = Math.max(0, Math.min(1, e)), t.position.lerp(this._position, e), t.quaternion.slerp(this._rotation, e));
  }
  ensureTransformData() {
    if (!this._position) {
      this._position = _u._positionBuffer.get(), this._rotation = _u._rotationBuffer.get();
      const t = this._pose.transform, e = J.active.convertSpace(t);
      this._position.copy(e == null ? void 0 : e.position), this._rotation.copy(e == null ? void 0 : e.quaternion);
    }
  }
};
let ga = _u;
r(ga, "_positionBuffer", new tn(() => new v(), 20)), r(ga, "_rotationBuffer", new tn(() => new W(), 20));
class zo {
  constructor() {
    r(this, "image");
    r(this, "widthInMeters", 0.25);
    r(this, "object");
    r(this, "createObjectInstance", !1);
    r(this, "imageDoesNotMove", !1);
    r(this, "hideWhenTrackingIsLost", !0);
  }
}
Fo([
  f(URL)
], zo.prototype, "image", 2);
Fo([
  f()
], zo.prototype, "widthInMeters", 2);
Fo([
  f(re)
], zo.prototype, "object", 2);
Fo([
  f()
], zo.prototype, "createObjectInstance", 2);
Fo([
  f()
], zo.prototype, "imageDoesNotMove", 2);
Fo([
  f()
], zo.prototype, "hideWhenTrackingIsLost", 2);
class ZE {
  constructor(t, e, i) {
    r(this, "filename");
    r(this, "widthInMeters");
    r(this, "imageData");
    this.filename = t, this.imageData = e, this.widthInMeters = i;
  }
  get extensionName() {
    return "image-tracking";
  }
  onAfterHierarchy(t, e) {
    const i = X.getiOSVersion(), a = (i ? parseInt(i.split(".")[0]) : 18) >= 18 ? 1 : 100;
    e.beginBlock('def Preliminary_ReferenceImage "AnchoringReferenceImage"'), e.appendLine("uniform asset image = @image_tracking/" + this.filename + "@"), e.appendLine("uniform double physicalWidth = " + (this.widthInMeters * a).toFixed(8)), e.closeBlock();
  }
  onBeforeBuildDocument(t) {
    const e = S.findObjectOfType(Qa);
    !e || !e.trackedImages || e.trackedImages.length > 1 && (z() && ve("USDZ: Only one tracked image is supported."), console.warn("USDZ: Only one tracked image is supported."));
  }
  onAfterSerialize(t) {
    t.files["image_tracking/" + this.filename] = this.imageData;
  }
  onExportObject(t, e, i) {
    var o;
    const n = S.findObjectOfType(Qa);
    if (!(!n || !n.trackedImages)) {
      for (const a of n.trackedImages)
        if (((o = a.object) == null ? void 0 : o.asset) === t) {
          const l = S.findObjectOfType(Ge);
          if (!l)
            continue;
          const { scale: c, target: h } = l.getARScaleAndTarget();
          let d = t;
          const u = new se();
          if (t !== h)
            for (; d.parent && d.parent !== h; )
              d = d.parent, u.premultiply(d.matrix);
          const p = u.clone().invert();
          e.setMatrix(p.scale(new v(c, c, c)));
          break;
        }
    }
  }
}
var Qp;
const oc = (Qp = class extends I {
  constructor() {
    super(...arguments);
    r(this, "trackedImages");
    r(this, "smooth", !0);
    r(this, "trackedImageIndexMap", /* @__PURE__ */ new Map());
    r(this, "_supported", !0);
    r(this, "imageToObjectMap", /* @__PURE__ */ new Map());
    r(this, "currentImages", []);
    r(this, "webXRIncubationsWarning", `Image tracking is currently not supported on this device. On Chrome for Android, you can enable the <a target="_blank" href="#" onclick="() => console.log('I')">chrome://flags/#webxr-incubations</a> flag.`);
    r(this, "onImageTrackingUpdate", (t) => {
      const e = J.active;
      if (e)
        for (const i of t) {
          const n = i.model, o = i.state === "tracked";
          if (!n.object)
            continue;
          let a = this.imageToObjectMap.get(n);
          if (a === void 0)
            a = { object: null, frames: 0, lastTrackingTime: Date.now() }, this.imageToObjectMap.set(n, a), n.object.loadAssetAsync().then((l) => {
              if (n.createObjectInstance && l && (l = S.instantiate(l)), l) {
                a.object = l;
                for (const c of l.getComponentsInChildren(Je))
                  c.setInstancingEnabled(!1);
                e.rig ? (e.rig.gameObject.add(l), i.applyToObject(l), l.activeSelf || S.setActive(l, !0)) : console.warn("XRImageTracking: missing XRRig");
              }
            });
          else {
            if (a.frames++, o && (a.lastTrackingTime = Date.now()), n.imageDoesNotMove && a.frames > 10 || !a.object)
              continue;
            e.rig && (e.rig.gameObject.add(a.object), i.applyToObject(a.object, this.smooth ? this.context.time.deltaTimeUnscaled * 3 : void 0), a.object.activeSelf || S.setActive(a.object, !0));
          }
        }
    });
  }
  /** @returns true if image tracking is supported on this device. This may return false at runtime if the user's browser did not enable webxr incubations */
  get supported() {
    return this._supported;
  }
  awake() {
    if ($b && console.log(this), !!this.trackedImages) {
      for (const t of this.trackedImages)
        if (t.image && !oc._imageElements.has(t.image)) {
          const e = t.image;
          oc._imageElements.set(e, null);
          const i = document.createElement("img");
          i.src = e, i.addEventListener("load", async () => {
            const n = await createImageBitmap(i);
            oc._imageElements.set(e, n);
            const o = await Bk(n);
            if (o) {
              const l = await (await o.convertToBlob({ type: "image/png" })).arrayBuffer(), c = S.findObjectOfType(Ge);
              c && this.trackedImages && (c.extensions.push(
                new ZE("marker.png", new Uint8Array(l), this.trackedImages[0].widthInMeters)
              ), c.anchoringType = "image");
            }
          });
        }
    }
  }
  onBeforeXR(t, e) {
    var i;
    if (this.trackedImages) {
      e.optionalFeatures = e.optionalFeatures || [], e.optionalFeatures.includes("image-tracking") || e.optionalFeatures.push("image-tracking"), e.trackedImages = [];
      for (const n of this.trackedImages)
        if ((i = n.image) != null && i.length && n.widthInMeters > 0) {
          const o = oc._imageElements.get(n.image);
          o && (this.trackedImageIndexMap.set(e.trackedImages.length, n), e.trackedImages.push({
            image: o,
            widthInMeters: n.widthInMeters
          }));
        }
    }
  }
  onEnterXR(t) {
    var e;
    if (this.trackedImages) {
      for (const i of this.trackedImages)
        if ((e = i.object) != null && e.asset) {
          const n = i.object.asset;
          n.userData || (n.userData = {});
          const o = {
            visible: n.visible,
            parent: n.parent,
            matrix: n.matrix.clone()
          };
          n.userData["image-tracking"] = o;
        }
    }
    for (const i of this.imageToObjectMap.values())
      i.frames = 0;
  }
  onLeaveXR(t) {
    var e, i;
    if (!this.supported && X.isAndroidDevice() && ve(this.webXRIncubationsWarning), this.trackedImages) {
      for (const n of this.trackedImages)
        if ((e = n.object) != null && e.asset) {
          const o = n.object.asset;
          if (o.userData) {
            const a = o.userData["image-tracking"];
            a && (o.visible = a.visible, (i = a.parent) == null || i.add(o), o.matrix.copy(a.matrix), o.matrix.decompose(o.position, o.quaternion, o.scale)), delete o.userData["image-tracking"];
          }
        }
    }
  }
  onUpdateXR(t) {
    var n;
    this.currentImages.length = 0;
    const e = t.xr.frame;
    if (!e)
      return;
    if ("getImageTrackingResults" in e) {
      if (((n = t.xr.session.enabledFeatures) == null ? void 0 : n.includes("image-tracking")) === !1)
        return;
      if (e.session && typeof e.getImageTrackingResults == "function") {
        const o = e.getImageTrackingResults();
        if (o.length > 0) {
          const a = this.context.renderer.xr.getReferenceSpace();
          if (a) {
            for (const l of o) {
              const c = l.trackingState, h = l.index, d = this.trackedImageIndexMap.get(h);
              if (d) {
                const u = e.getPose(l.imageSpace, a), p = new ga(this, d, l.image, l.measuredSize, c, u);
                this.currentImages.push(p);
              } else
                $b && console.warn("No tracked image for index", h);
            }
            if (this.currentImages.length > 0)
              try {
                this.dispatchEvent(new CustomEvent("image-tracking", { detail: this.currentImages })), this.onImageTrackingUpdate(this.currentImages);
              } catch (l) {
                console.error(l);
              }
          }
        }
      }
    } else {
      this.didPrintWarning || (this.didPrintWarning = !0, console.log(this.webXRIncubationsWarning)), this._supported = !1, ve(this.webXRIncubationsWarning);
      return;
    }
    const i = 1e3;
    for (const [o, a] of this.imageToObjectMap) {
      if (!a.object || !o || o.hideWhenTrackingIsLost === !1)
        continue;
      let l = !1;
      for (const c of this.currentImages)
        if (c.model === o) {
          const h = Date.now() - a.lastTrackingTime;
          if (o.imageDoesNotMove || c.state === "tracked" || h <= i) {
            l = !0;
            break;
          }
        }
      l || S.setActive(a.object, !1);
    }
  }
}, r(Qp, "_imageElements", /* @__PURE__ */ new Map()), Qp);
let Qa = oc;
Fo([
  f(zo)
], Qa.prototype, "trackedImages", 2);
Fo([
  f()
], Qa.prototype, "smooth", 2);
var JE = Object.defineProperty, eI = Object.getOwnPropertyDescriptor, xl = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? eI(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && JE(t, e, n), n;
};
const Ho = x("debugplanetracking");
class Uo extends I {
  constructor() {
    super(...arguments);
    r(this, "dataTemplate");
    r(this, "occluder", !0);
    r(this, "initiateRoomCaptureIfNoData", !0);
    r(this, "usePlaneData", !0);
    r(this, "useMeshData", !0);
    r(this, "runInVR", !0);
    r(this, "bounds", new Pi());
    r(this, "center", new v());
    r(this, "labelOffset", new v());
    r(this, "_dataId", 1);
    r(this, "_allPlanes", /* @__PURE__ */ new Map());
    r(this, "_allMeshes", /* @__PURE__ */ new Map());
    r(this, "firstTimeNoPlanesDetected", -100);
    r(this, "makeOccluder", (e, i, n = !1) => {
      if (i) {
        if (i instanceof Array) {
          for (const o of i)
            this.makeOccluder(e, o, n);
          return;
        }
        !n && !i.name.toLowerCase().includes("occlu") || (i.colorWrite = !1, i.depthTest = !0, i.depthWrite = !0, i.transparent = !1, i.polygonOffset = !0, i.polygonOffsetFactor = 1, i.polygonOffsetUnits = 0.1, e.renderOrder = -1e3);
      }
    });
    r(this, "_flipForwardMatrix", new se().makeRotationY(Math.PI));
    // we cache vertices-to-geometry, because it looks like when we get an update sometimes the geometry stays the same.
    // so we don't want to re-create the geometry every time.
    r(this, "_verticesCache", /* @__PURE__ */ new Map());
  }
  /**
   * Returns all tracked planes
   */
  get trackedPlanes() {
    return this._allPlanes.values();
  }
  get trackedMeshes() {
    return this._allMeshes.values();
  }
  /** @internal */
  onBeforeXR(e, i) {
    e === "immersive-vr" && !this.runInVR || (i.optionalFeatures = i.optionalFeatures || [], this.usePlaneData && !i.optionalFeatures.includes("plane-detection") && i.optionalFeatures.push("plane-detection"), this.useMeshData && !i.optionalFeatures.includes("mesh-detection") && i.optionalFeatures.push("mesh-detection"));
  }
  /** @internal */
  onEnterXR(e) {
    for (const i of this._allPlanes.keys())
      this.removeData(i, this._allPlanes);
    for (const i of this._allMeshes.keys())
      this.removeData(i, this._allMeshes);
  }
  onLeaveXR(e) {
    for (const i of this._allPlanes.keys())
      this.removeData(i, this._allPlanes);
    for (const i of this._allMeshes.keys())
      this.removeData(i, this._allMeshes);
  }
  /** @internal */
  onUpdateXR(e) {
    if (!this.runInVR && e.xr.isVR)
      return;
    const i = e.xr.rig;
    if (!i) {
      console.warn("No XR rig found, cannot parent tracked planes to it");
      return;
    }
    const n = e.xr.frame;
    if (!this.context.renderer.xr.getReferenceSpace())
      return;
    const l = n.detectedPlanes, c = n.detectedMeshes, h = l !== void 0 && l.size > 0, d = c !== void 0 && c.size > 0;
    if (this.initiateRoomCaptureIfNoData && (!h && !d && this.firstTimeNoPlanesDetected < -10 && (this.firstTimeNoPlanesDetected = Date.now()), (h || d) && (this.firstTimeNoPlanesDetected = -1), this.firstTimeNoPlanesDetected > 0 && Date.now() - this.firstTimeNoPlanesDetected > 2500 && "initiateRoomCapture" in n.session && (n.session.initiateRoomCapture(), this.firstTimeNoPlanesDetected = -1)), l !== void 0 && this.processFrameData(e.xr, i.gameObject, n, l, this._allPlanes), c !== void 0 && this.processFrameData(e.xr, i.gameObject, n, c, this._allMeshes), Ho) {
      const u = this.context.mainCameraComponent.gameObject.worldPosition;
      for (const p of this._allPlanes.values())
        !p.mesh || !p.mesh.visible || (this.bounds.makeEmpty(), p.mesh.traverse((m) => {
          m instanceof q && this.bounds.expandByObject(m);
        }), this.bounds.getCenter(this.center), this.labelOffset.copy(u).sub(this.center).normalize().multiplyScalar(0.1), V.DrawLabel(
          this.center.add(this.labelOffset),
          (p.xrData.semanticLabel || "plane").toUpperCase() + `
` + p.xrData.lastChangedTime.toFixed(2),
          0.02
        ));
    }
  }
  removeData(e, i) {
    const n = i.get(e);
    if (!n)
      return;
    i.delete(e), Ho && console.log("Plane no longer tracked, id=" + n.id), n.mesh && (n.mesh.removeFromParent(), n.mesh.traverse((a) => {
      const l = a.userData.normalsHelper;
      l ? (l.dispose(), l.removeFromParent()) : Ho && console.warn("No normals helper found for mesh", n.mesh);
    }), nn(n.mesh, !0, !0));
    const o = new CustomEvent("plane-tracking", {
      detail: {
        type: "plane-removed",
        context: n
      }
    });
    this.dispatchEvent(o);
  }
  processFrameData(e, i, n, o, a) {
    const c = this.context.renderer.xr.getReferenceSpace();
    if (c) {
      for (const h of a.keys())
        o.has(h) || this.removeData(h, a);
      for (const h of o) {
        const d = "planeSpace" in h ? h.planeSpace : "meshSpace" in h ? h.meshSpace : void 0;
        if (!d)
          continue;
        const u = n.getPose(d, c);
        let p;
        if (a.has(h)) {
          const m = a.get(h);
          if (p = m.mesh, m.timestamp < h.lastChangedTime) {
            if (m.timestamp = h.lastChangedTime, m.mesh) {
              const _ = this.createGeometry(h);
              if (m.mesh instanceof q)
                m.mesh.geometry.dispose(), m.mesh.geometry = _, this.makeOccluder(m.mesh, m.mesh.material);
              else if (m.mesh instanceof ho)
                for (const y of m.mesh.children)
                  y instanceof q && (y.geometry.dispose(), y.geometry = _, this.makeOccluder(y, y.material));
              if (m.collider) {
                const y = m.mesh;
                m.collider.sharedMesh = y, m.collider.convex = this.checkIfContextShouldBeConvex(y, m.xrData), m.collider.onDisable(), m.collider.onEnable();
              }
              Ho && (console.log("Plane updated, id=" + m.id, m), m.mesh.traverse((y) => {
                if (!(y instanceof q))
                  return;
                const b = y.userData.normalsHelper;
                b && b.update();
              }));
            }
            const g = new CustomEvent("plane-tracking", {
              detail: {
                type: "plane-updated",
                context: m
              }
            });
            this.dispatchEvent(g);
          }
        } else {
          if (!this.dataTemplate) {
            const m = new q();
            Ho ? m.material = new $1() : this.occluder ? (m.material = new Me(), this.makeOccluder(m, m.material, !0)) : m.material = new Me({ wireframe: !0, opacity: 0.5, transparent: !0, color: 3355443 }), this.dataTemplate = new re("", "", m);
          }
          if (!this.dataTemplate.asset)
            this.dataTemplate.loadAssetAsync();
          else {
            const m = S.instantiate(this.dataTemplate.asset);
            if (m.name = "xr-tracked-plane", p = m, E0(m, !1), m instanceof q)
              Ae(m.geometry), m.geometry = this.createGeometry(h), this.makeOccluder(m, m.material, this.occluder && !this.dataTemplate);
            else if (m instanceof ho)
              for (const y of m.children)
                y instanceof q && (Ae(y.geometry), y.geometry = this.createGeometry(h), this.makeOccluder(y, y.material, this.occluder && !this.dataTemplate));
            const g = m.getComponent(jr);
            if (g) {
              const y = m;
              g.sharedMesh = y, g.convex = this.checkIfContextShouldBeConvex(y, h), g.onDisable(), g.onEnable();
            }
            m.matrixAutoUpdate = !1, m.matrixWorldNeedsUpdate = !0, i.add(m);
            const _ = {
              id: this._dataId++,
              xrData: h,
              timestamp: h.lastChangedTime,
              mesh: m,
              collider: g
            };
            a.set(h, _), Ho && console.log("New plane detected, id=" + _.id, _, { hasCollider: !!g, isGroup: m instanceof ho });
            try {
              const y = new CustomEvent("plane-tracking", {
                detail: {
                  type: "plane-added",
                  context: _
                }
              });
              this.dispatchEvent(y);
            } catch (y) {
              console.error(y);
            }
          }
        }
        p && (u ? (p.visible = !0, p.matrix.fromArray(u.transform.matrix), p.matrix.premultiply(this._flipForwardMatrix)) : p.visible = !1, Ho && p.traverse((m) => {
          if (m instanceof q)
            if (m.userData.normalsHelper)
              m.userData.normalsHelper.update();
            else {
              const g = new fS(m, 0.05, 255);
              g.layers.disableAll(), g.layers.set(2), this.context.scene.add(g), m.userData.normalsHelper = g;
            }
        }));
      }
    }
  }
  // heuristic to determine if a collider should be convex or not - 
  // the "global mesh" should be non-convex, other meshes should be
  checkIfContextShouldBeConvex(e, i) {
    if (!e)
      return !0;
    if (e) {
      const n = new Pi();
      n.expandByObject(e);
      const o = new v();
      n.getSize(o);
      let a = !0;
      return o.x > 2 && o.y > 2 && o.z > 1.5 && (a = !1), a && "semanticLabel" in i && i.semanticLabel === "wall" && (a = !0), a;
    }
    return !0;
  }
  createGeometry(e) {
    return "polygon" in e ? this.createPlaneGeometry(e.polygon) : "vertices" in e && "indices" in e ? this.createMeshGeometry(e.vertices, e.indices) : new Ps();
  }
  createMeshGeometry(e, i) {
    const n = e.toString() + "_" + i.toString();
    if (this._verticesCache.has(n))
      return this._verticesCache.get(n);
    const o = new Ps();
    o.setIndex(new mt(i, 1)), o.setAttribute("position", new mt(e, 3));
    const a = Array();
    for (let l = 0; l < e.length; l += 3)
      a.push(e[l], e[l + 2]);
    return o.setAttribute("uv", new mt(e, 3)), o.computeVertexNormals(), this._verticesCache.set(n, o), o;
  }
  createPlaneGeometry(e) {
    const i = new Ps(), n = [], o = [];
    e.forEach((m) => {
      n.push(m.x, m.y, m.z), o.push(m.x, m.z);
    });
    const a = new v(n[0], n[1], n[2]), l = new v(n[3], n[4], n[5]), c = new v(n[6], n[7], n[8]), h = new v(), d = new v();
    h.subVectors(l, a), d.subVectors(c, a), h.cross(d), h.normalize();
    const u = [];
    for (let m = 0; m < n.length / 3; m++)
      u.push(h.x, h.y, h.z);
    const p = [];
    for (let m = 2; m < e.length; ++m)
      p.push(0, m - 1, m);
    return i.setAttribute("position", new mt(new Float32Array(n), 3)), i.setAttribute("uv", new mt(new Float32Array(o), 2)), i.setAttribute("normal", new mt(new Float32Array(u), 3)), i.setIndex(p), i.computeBoundingBox(), i.computeBoundingSphere(), i;
  }
}
xl([
  f(re)
], Uo.prototype, "dataTemplate", 2);
xl([
  f()
], Uo.prototype, "occluder", 2);
xl([
  f()
], Uo.prototype, "initiateRoomCaptureIfNoData", 2);
xl([
  f()
], Uo.prototype, "usePlaneData", 2);
xl([
  f()
], Uo.prototype, "useMeshData", 2);
xl([
  f()
], Uo.prototype, "runInVR", 2);
var tI = Object.defineProperty, iI = Object.getOwnPropertyDescriptor, nI = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? iI(t, e) : t, o = s.length - 1, a; o >= 0; o--)
    (a = s[o]) && (n = (i ? a(t, e, n) : a(n)) || n);
  return i && n && tI(t, e, n), n;
};
const Wb = x("debugwebxr");
class x_ extends I {
  constructor() {
    super(...arguments);
    r(this, "priority", 0);
    r(this, "_startScale");
  }
  get isActive() {
    return this.activeAndEnabled && this.gameObject.visible;
  }
  /** 
   * Sets this rig to be the active XR rig (needs to be called during an active XR session) 
   * Note that this might modify the priority of this rig to be the highest.
  */
  setAsActiveXRRig() {
    var e;
    (e = J.active) == null || e.setRigActive(this);
  }
  /** 
   * Sets the priority of the rig.
   */
  setPriority(e) {
    this.priority = e;
  }
  /** @internal */
  awake() {
    if (Wb) {
      const e = new L();
      e.position.y += 0.5, this.gameObject.add(e);
      const i = e.addNewComponent(hl);
      i && (i.isGizmo = !1);
      const n = new Oi(0.5);
      this.gameObject.add(n);
    }
  }
  isXRRig() {
    return !0;
  }
  supportsXR(e) {
    return !0;
  }
  /** @internal */
  onEnterXR(e) {
    this._startScale = this.gameObject.scale.clone(), e.xr.addRig(this), Wb && console.log("WebXR: add Rig", this.name, this.priority);
  }
  /** @internal */
  onLeaveXR(e) {
    e.xr.removeRig(this), this._startScale && this.gameObject && this.gameObject.scale.copy(this._startScale);
  }
}
nI([
  f()
], x_.prototype, "priority", 2);
class sI extends I {
  constructor() {
    super(...arguments);
    r(this, "toggleKey", "KeyP");
  }
  update() {
    this.context.input.isKeyDown(this.toggleKey) && this.context.domElement.classList.toggle("presentation-mode");
  }
}
R.add("AlignmentConstraint", $u);
R.add("Animation", ti);
R.add("Animator", zt);
R.add("AudioListener", lo);
R.add("AudioSource", qe);
R.add("Avatar_Brain_LookAt", Jd);
R.add("Avatar_MouthShapes", qu);
R.add("Avatar_MustacheShake", Uv);
R.add("AvatarBlink_Simple", Ja);
R.add("AvatarEyeLook_Rotation", Jc);
R.add("AxesHelper", eh);
R.add("BasicIKConstraint", Wv);
R.add("BoxHelperComponent", wi);
R.add("Camera", Pe);
R.add("CharacterController", el);
R.add("CharacterControllerInput", Oo);
R.add("Collider", Ai);
R.add("SphereCollider", th);
R.add("BoxCollider", ih);
R.add("MeshCollider", jr);
R.add("CapsuleCollider", So);
R.add("ContactShadows", Yn);
R.add("LogStats", Hv);
R.add("DeleteBox", Ra);
R.add("Deletable", qv);
R.add("DeviceFlag", $g);
R.add("DragControls", Si);
R.add("DropListener", Mo);
R.add("Duplicatable", nh);
R.add("EventListEvent", Lg);
R.add("EventTrigger", Gg);
R.add("GltfExportBox", lw);
R.add("GltfExport", Ku);
R.add("VariantAction", bw);
R.add("ChangeTransformOnClick", sl);
R.add("ChangeMaterialOnClick", rh);
R.add("SetActiveOnClick", ol);
R.add("HideOnStart", or);
R.add("EmphasizeOnClick", ah);
R.add("PlayAudioOnClick", Cr);
R.add("PlayAnimationOnClick", Xa);
R.add("PreliminaryAction", lh);
R.add("PreliminaryTrigger", Zu);
R.add("VisibilityAction", Ju);
R.add("TapGestureTrigger", vw);
R.add("USDZExporter", Ge);
R.add("Fog", uh);
R.add("BoxGizmo", hl);
R.add("GridHelper", fh);
R.add("GroundProjectedEnv", Ls);
R.add("UsageMarker", Qu);
R.add("Interactable", Gv);
R.add("FixedJoint", Bw);
R.add("HingeJoint", sf);
R.add("Light", Di);
R.add("LODGroup", of);
R.add("LookAtConstraint", Za);
R.add("NeedleMenu", Fs);
R.add("NestedGltf", r_);
R.add("Networking", gh);
R.add("OffsetConstraint", dl);
R.add("CameraTargetReachedEvent", Zd);
R.add("OrbitControls", be);
R.add("ParticleSystemRenderer", Pn);
R.add("ParticleSystem", ut);
R.add("PlayerColor", Wc);
R.add("Antialiasing", af);
R.add("BloomEffect", ml);
R.add("ChromaticAberration", lf);
R.add("ColorAdjustments", zr);
R.add("DepthOfField", es);
R.add("EffectWrapper", nu);
R.add("PixelationEffect", hf);
R.add("ScreenSpaceAmbientOcclusion", Io);
R.add("ScreenSpaceAmbientOcclusionN8", ts);
R.add("SharpeningEffect", df);
R.add("TiltShiftEffect", Us);
R.add("ToneMappingEffect", Mr);
R.add("Vignette", _l);
R.add("Volume", vh);
R.add("ReflectionProbe", sh);
R.add("Renderer", Je);
R.add("MeshRenderer", Yu);
R.add("SkinnedMeshRenderer", rw);
R.add("Rigidbody", _e);
R.add("SceneSwitcher", rt);
R.add("ScreenCapture", $r);
R.add("ShadowCatcher", uf);
R.add("RemoteSkybox", Is);
R.add("SmoothFollow", Wr);
R.add("SpatialTriggerReceiver", Rs);
R.add("SpatialTrigger", pf);
R.add("SpectatorCamera", p_);
R.add("SpriteRenderer", Ei);
R.add("SyncedCamera", m_);
R.add("SyncedRoom", is);
R.add("SyncedTransform", As);
R.add("TestRunner", ix);
R.add("TestSimulateUserData", nx);
R.add("PlayableDirector", Rr);
R.add("SignalReceiver", Ch);
R.add("AnimationTrackHandler", __);
R.add("AudioTrackHandler", Ta);
R.add("SignalTrackHandler", ru);
R.add("ControlTrackHandler", y_);
R.add("TransformGizmo", yl);
R.add("BaseUIComponent", xn);
R.add("UIRootComponent", Vu);
R.add("Button", jo);
R.add("Canvas", Ut);
R.add("CanvasGroup", Or);
R.add("EventSystem", di);
R.add("Graphic", al);
R.add("MaskableGraphic", nf);
R.add("Image", Ph);
R.add("RawImage", v_);
R.add("InputField", bl);
R.add("VerticalLayoutGroup", Aw);
R.add("HorizontalLayoutGroup", Ew);
R.add("GridLayoutGroup", Iw);
R.add("Outline", dh);
R.add("ObjectRaycaster", sn);
R.add("GraphicRaycaster", jg);
R.add("SpatialGrabRaycaster", gr);
R.add("RectTransform", ii);
R.add("SpatialHtml", wf);
R.add("Text", si);
R.add("LookAt", vl);
R.add("OpenURL", Oh);
R.add("VideoPlayer", bt);
R.add("Voip", Lr);
R.add("Avatar", Pr);
R.add("XRControllerFollow", Bo);
R.add("XRControllerModel", Es);
R.add("XRControllerMovement", on);
R.add("TeleportTarget", Zg);
R.add("WebARCameraBackground", Sf);
R.add("WebARSessionRoot", gn);
R.add("WebXR", et);
R.add("AvatarMarker", _t);
R.add("WebXRImageTracking", Qa);
R.add("WebXRPlaneTracking", Uo);
R.add("XRRig", x_);
R.add("XRFlag", Xi);
R.add("PlayerSync", ch);
R.add("PlayerState", Ji);
R.add("PresentationMode", sI);
const wc = gt, oI = x("debugtypestore");
oI && console.log(R);
function rI(s, t) {
  const i = YP(s, t);
  return i !== void 0 ? i : null;
}
const aI = new QP(), Ep = Symbol("deserialize-queue");
async function lI(s, t, e, i = null, n) {
  if (!e) {
    console.debug("Can not create component instances: gltf is null");
    return;
  }
  let o = i;
  typeof o == "number" && (o = new Bt(i));
  const a = t.indexOf("?");
  t = a === -1 ? t : t.substring(0, a);
  const l = new uv(e.scene);
  l.gltfId = t, l.context = s, l.gltf = e, l.nodeToObject = n == null ? void 0 : n.nodeToObjectMap, l.implementationInformation = aI;
  let c = s[Ep];
  if (c || (c = s[Ep] = []), e.scenes)
    for (const h of e.scenes)
      await eg(l, h, c);
  if (e.children)
    for (const h of e.children)
      await eg(l, h, c);
  s.new_scripts_pre_setup_callbacks.push(() => {
    const h = s[Ep];
    if (h) {
      for (const d of h)
        cI(d, l);
      h.length = 0;
    }
    if (o) {
      const d = {}, u = [];
      Jm(e, o, d, u);
      for (const p of e.scenes)
        Jm(p, o, d, u);
      for (const p of u)
        p.resolveGuids(d);
    }
  });
}
const Zm = Symbol("original-component-name"), Jr = /* @__PURE__ */ new Map();
function Jm(s, t, e, i) {
  if (t === null || !s)
    return;
  const n = s.guid, o = s.guid;
  o != null && o.length && (Jr.has(o) || (wc && console.log('Creating InstanceIdProvider with key "' + o + '" for object ' + s.name), Jr.set(o, new Bt(o))));
  const a = o && Jr.get(o) || t;
  if (s.guid = a.generateUUID(), n && n !== "invalid" && (e[n] = s.guid), s && s.userData && s.userData.components)
    for (const l of s.userData.components) {
      if (l === null)
        continue;
      const c = l.guid;
      c ? Jr.has(c) || (wc && console.log('Creating InstanceIdProvider with key "' + c + '" for component ' + l[Zm]), Jr.set(c, new Bt(c))) : wc && console.warn("Can not create IdProvider: component " + l[Zm] + " has no guid", l.guid);
      const h = Jr.get(c) || t, d = l.guid;
      l.guid = h.generateUUID(), d && d !== "invalid" && (e[d] = l.guid), l.resolveGuids && i.push(l);
    }
  if (s.children)
    for (const l of s.children)
      Jm(l, t, e, i);
}
const Fl = [];
async function eg(s, t, e, i) {
  var o, a, l, c, h;
  if (!t)
    return;
  const n = t.userData;
  if (n) {
    const d = n.builtin_components;
    if (d && d.length > 0)
      for (const u of d)
        try {
          if (u === null)
            continue;
          const p = R.get(u.name);
          if (p != null) {
            const m = new p();
            m.sourceId = s.gltfId, $a(m, u, s.implementationInformation), m.context = s.context, "guid" in u && (m[fd] = u.guid), m[Zm] = u.name, Oa(t, m, !1), e.push({ instance: m, compData: u, obj: t }), m.isCamera && s.context && s.context.mainCamera === null && m.tag === "MainCamera" && s.context.setCurrentCamera(m), ((l = (a = (o = s.context) == null ? void 0 : o.physics) == null ? void 0 : a.engine) == null ? void 0 : l.isInitialized) === !1 && (m.isCollider || m.isRigidbody) && ((h = (c = s.context) == null ? void 0 : c.physics.engine) == null || h.initialize());
          } else
            wc && console.debug("unknown component: " + u.name), Fl.includes(u.name) || Fl.push(u.name);
        } catch (p) {
          console.error(u.name + " - " + p.message, p);
        }
    if (Fl.length > 0) {
      const u = Fl.join(", ");
      console.warn("unknown components: " + u), Fl.length = 0, ui() && We(`<strong>Unknown components in scene</strong>:

${u}

This could mean you forgot to add a npmdef to your ExportInfo
<a href="https://engine.needle.tools/docs/project_structure.html#creating-and-installing-a-npmdef" target="_blank">documentation</a>`, Zi.Warn);
    }
  }
  if (t.children)
    for (const d of t.children)
      await eg(s, d, e);
}
function cI(s, t) {
  const { instance: e, compData: i, obj: n } = s;
  t.object = n, t.target = e, ym(e, i, t), wc && console.debug("add " + i.name, i, e);
}
const lu = x("debugfileformat");
async function hI(s, t = !0) {
  var i;
  if (t) {
    const n = s, o = new URL(n, globalThis.location.origin);
    let a = null;
    const l = o.searchParams.get("filetype");
    switch (l && (a = l.toUpperCase()), a != null && a.length || (a = (i = o.pathname.split(".").pop()) == null ? void 0 : i.toUpperCase()), lu && console.debug("Use file extension to determine type: " + a), a) {
      case "GLTF":
        return "gltf";
      case "VRM":
        return "vrm";
      case "GLB":
        return "glb";
      case "FBX":
        return "fbx";
      case "USD":
        return "usd";
      case "USDA":
        return "usda";
      case "USDZ":
        return "usdz";
      case "OBJ":
        return "obj";
    }
  }
  if (!s.startsWith("blob:")) {
    const n = new URL(s);
    n.searchParams.append("range", "true"), s = n.toString();
  }
  const e = await fetch(s, {
    method: "GET",
    headers: {
      range: "bytes=0-32"
    }
  }).catch((n) => null);
  if (e != null && e.ok) {
    const n = await e.arrayBuffer(), o = dI(n, e);
    return lu && console.log("Determined file type from header: " + o), o;
  }
  return "unknown";
}
function dI(s, t) {
  if (s.byteLength < 4)
    return "unknown";
  const e = new Uint8Array(s);
  if (lu && console.warn(`Trying to determine file type from binary data
`, '"' + new TextDecoder().decode(s) + `"
`, e), e[0] == 103 && e[1] == 108 && e[2] == 84 && e[3] == 70)
    return console.debug("GLTF detected"), "glb";
  if (e[0] == 80 && e[1] == 75 && e[2] == 3 && e[3] == 4)
    return console.debug("USDZ detected"), "usdz";
  if (e[0] == 80 && e[1] == 88 && e[2] == 82 && e[3] == 45 && e[4] == 85 && e[5] == 83 && e[6] == 68 && e[7] == 67)
    return console.debug("Binary USD detected"), "usd";
  if (e[0] == 35 && e[1] == 117 && e[2] == 115 && e[3] == 100 && e[4] == 97)
    return console.debug("ASCII USD detected"), "usda";
  if (e[0] == 75 && e[1] == 97 && e[2] == 121 && e[3] == 100 && e[4] == 97 && e[5] == 114 && e[6] == 97 && e[7] == 32)
    return console.debug("Binary FBX detected"), "fbx";
  if (e[0] == 59 && e[1] == 32 && e[2] == 70 && e[3] == 66 && e[4] == 88 && e[5] == 32)
    return console.debug("ASCII FBX detected"), "fbx";
  if (e[0] == 35 && e[1] == 32 && e[2] == 66 && e[3] == 108 && e[4] == 101 && e[5] == 110 && e[6] == 100 && e[7] == 101 && e[8] == 114 && e[9] == 32)
    return console.debug("OBJ detected"), "obj";
  if (e[0] == 35 && e[1] == 32 && e[2] == 65 && e[3] == 108 && e[4] == 105 && e[5] == 97 && e[6] == 115 && e[7] == 32 && e[8] == 79 && e[9] == 66 && e[10] == 74)
    return console.debug("OBJ detected"), "obj";
  if (t.headers.has("content-type")) {
    const i = t.headers.get("content-type");
    switch (console.debug("Content-Type: " + i), i) {
      case "model/gltf+json":
        return "gltf";
      case "model/gltf-binary":
        return "glb";
      case "model/vrm":
        return "vrm";
      case "model/vnd.usdz+zip":
        return "usdz";
      case "model/vnd.usd+zip":
        return "usd";
      case "model/vnd.usda+zip":
        return "usda";
      case "model/fbx":
      case "model/vnd.autodesk.fbx":
        return "fbx";
      case "model/obj":
        return "obj";
    }
  }
  if (e[0] == 118 && e[1] == 32 || e[0] == 102 && e[1] == 32)
    return console.debug("OBJ detected (the file has no header and starts with vertex or face)"), "obj";
  if (e[0] == 35 && e[1] == 32 && e[2] == 70 && e[3] == 105 && e[4] == 108 && e[5] == 101 && e[6] == 32 && e[7] == 101 && e[8] == 120 && e[9] == 112 && e[10] == 111 && e[11] == 114 && e[12] == 116 && e[13] == 101 && e[14] == 100 && e[15] == 32 && e[16] == 98 && e[17] == 121 && e[18] == 32 && e[19] == 90 && e[20] == 66 && e[21] == 114 && e[22] == 117 && e[23] == 115 && e[24] == 104)
    return console.debug("OBJ detected (exported by ZBrush)"), "obj";
  if (e[0] == 109 && e[1] == 116 && e[2] == 108 && e[3] == 108 && e[4] == 105 && e[5] == 98)
    return console.debug("OBJ detected (mtllib)"), "obj";
  if (z() || lu) {
    const i = new TextDecoder().decode(s.slice(0, 16));
    console.debug('Could not determine file type from binary data: "' + i + '..."', e);
  } else
    console.debug("Could not determine file type from binary data", e);
  return "unknown";
}
class dx {
  createBuiltinComponents(t, e, i, n, o) {
    return lI(t, e, i, n, o);
  }
  writeBuiltinComponentData(t, e) {
    return rI(t, e);
  }
  parseSync(t, e, i, n) {
    return pI(t, e, i, n);
  }
  loadSync(t, e, i, n, o) {
    return mI(t, e, i, n, o);
  }
}
_0(dx);
const ux = x("printGltf") || x("printgltf"), fx = x("downloadgltf"), uI = x("debugfileformat");
var fI = /* @__PURE__ */ ((s) => (s[s.BeforeLoad = 0] = "BeforeLoad", s[s.AfterLoaded = 1] = "AfterLoaded", s[s.FinishedSetup = 10] = "FinishedSetup", s))(fI || {});
class Aa {
  constructor(t, e, i, n) {
    r(this, "context");
    r(this, "loader");
    r(this, "path");
    r(this, "gltf");
    this.context = t, this.path = e, this.loader = i, this.gltf = n;
  }
}
const bo = {};
function sL(s, t) {
  bo[s] = bo[s] || [], bo[s].push(t);
}
function oL(s, t) {
  if (bo[s]) {
    const e = bo[s].indexOf(t);
    e >= 0 && bo[s].splice(e, 1);
  }
}
function Ea(s, t) {
  if (bo[s])
    for (const e of bo[s])
      e(t);
}
async function px(s, t, e, i, n) {
  ux && console.warn("glTF", t, e), t.includes("?") && (t = t.split("?")[0]), await Hn().createBuiltinComponents(s, t, e, i, n);
}
async function mx(s, t) {
  const e = await hI(s) || "unknown";
  switch (uI && console.debug("Determined file type: " + e + " for url", s), e) {
    case "unknown": {
      console.warn("Unknown file type. Assuming glTF:", s);
      const i = new xr();
      return await Im(i, t, s), i;
    }
    case "fbx":
      return new u0();
    case "obj":
      return new dg();
    case "usd":
    case "usda":
    case "usdz":
      return console.warn(e.toUpperCase() + " files are not supported."), null;
    default:
      console.warn("Unknown file type:", e);
    case "gltf":
    case "glb":
    case "vrm": {
      const i = new xr();
      return await Im(i, t, s), i;
    }
  }
}
async function pI(s, t, e, i) {
  typeof e != "string" && (console.warn("Parse gltf binary without path, this might lead to errors in resolving extensions. Please provide the source path of the gltf/glb file", e, typeof e), e = ""), ux && console.log("Parse glTF", e);
  const n = await mx(e, s);
  if (!n)
    return;
  if (n instanceof dg) {
    typeof t != "string" && (t = new TextDecoder().decode(t));
    const l = n.parse(t);
    return {
      animations: l.animations,
      scene: l,
      scenes: [l]
    };
  }
  if (!(n instanceof xr)) {
    const l = n.parse(t, e);
    return yx(n, l), {
      animations: l.animations,
      scene: l,
      scenes: [l]
    };
  }
  const a = qg(n);
  return new Promise((l, c) => {
    try {
      let h = e.split("?")[0].trimEnd();
      {
        const u = h.split("/");
        u.length > 0 && u[u.length - 1] !== "" && u.pop(), h = u.join("/"), h.endsWith("/") || (h += "/");
      }
      n.resourcePath = h, Nu(n, s), Ea(0, new Aa(s, e, n));
      const d = s.mainCamera;
      n.parse(t, "", async (u) => {
        iw(e, u, s), Ea(1, new Aa(s, e, n, u)), await px(s, e, u, i, a), await gx(u.scene, s, d), Ea(10, new Aa(s, e, n, u)), l(u), fx && _x(t);
      }, (u) => {
        console.error('Loading asset at "' + e + `" failed
`, u), l(void 0);
      });
    } catch (h) {
      console.error(h), c(h);
    }
  });
}
async function mI(s, t, e, i, n) {
  gI(t);
  const o = await mx(t, s);
  if (!o)
    return;
  if (!(o instanceof xr)) {
    const l = await o.loadAsync(t, n);
    return yx(o, l), {
      animations: l.animations,
      scene: l,
      scenes: [l]
    };
  }
  const a = qg(o);
  return new Promise((l, c) => {
    try {
      Nu(o, s), Ea(0, new Aa(s, t, o));
      const h = s.mainCamera;
      o.load(t, async (d) => {
        iw(t, d, s), Ea(1, new Aa(s, t, o, d)), await px(s, e, d, i, a), await gx(d.scene, s, h), Ea(10, new Aa(s, t, o, d)), l(d), fx && _x(t);
      }, (d) => {
        n == null || n.call(o, d);
      }, (d) => {
        console.error('Loading asset at "' + t + `" failed
`, d), l(void 0);
      });
    } catch (h) {
      console.error(h), c(h);
    }
  });
}
async function gx(s, t, e) {
  e || (e = t.mainCamera);
  try {
    e ? await t.renderer.compileAsync(s, e, t.scene).catch((i) => {
      console.warn(i.message);
    }) : kP(s, t);
  } catch (i) {
    console.warn((i == null ? void 0 : i.message) || i);
  }
}
function gI(s) {
  if (new URL(s, window.location.href).href.startsWith("file://")) {
    const e = `Hi - it looks like you are trying to load a local file which will not work. You need to use a webserver to serve your files.
Please refer to the documentation on <a href="https://fwd.needle.tools/needle-engine/docs/local-server">https://docs.needle.tools</a> or ask for help in our <a href="https://discord.needle.tools">discord community</a>`;
    We(e), console.warn(e);
  }
}
function _x(s) {
  if (typeof s == "string") {
    const t = document.createElement("a");
    t.href = s, t.download = s.split("/").pop(), t.click();
  } else {
    const t = new Blob([s], { type: "application/octet-stream" }), e = window.URL.createObjectURL(t), i = document.createElement("a");
    i.href = e, i.download = "download.glb", i.click();
  }
}
function yx(s, t) {
  if (t != null && t.isObject3D) {
    const e = t;
    (s instanceof u0 || s instanceof dg) && e.traverse((i) => {
      const n = i;
      n != null && n.isMesh && I0(n, n.material);
    });
  }
}
_0(dx);
const Le = x("debugwebcomponent"), Vb = "needle-engine", bx = "vr", vx = "desktop", _I = [Tv, bx, vx], zl = "ar-session-active", Ul = "desktop-session-active", yI = [
  "public-key",
  "version",
  "hash",
  "src",
  "camera-controls",
  "loadstart",
  "progress",
  "loadfinished",
  "dracoDecoderPath",
  "dracoDecoderType",
  "ktx2DecoderPath",
  "tone-mapping",
  "tone-mapping-exposure",
  "background-blurriness",
  "background-color"
];
class wx extends HTMLElement {
  constructor() {
    super();
    r(this, "_context");
    r(this, "_overlay_ar");
    r(this, "_loadingProgress01", 0);
    r(this, "_loadingView");
    r(this, "_previousSrc", null);
    /** set to true after <needle-engine> did load completely at least once. Set to false when <needle-engine> is removed from the document */
    r(this, "_didFullyLoad", !1);
    r(this, "_loadId", 0);
    r(this, "_abortController", null);
    r(this, "_lastSourceFiles", null);
    r(this, "_createContextPromise", null);
    r(this, "onXRSessionStarted", () => {
      var i;
      const e = this.context.xrSessionMode;
      e === "immersive-ar" ? this.onEnterAR(this.context.xrSession) : e === "immersive-vr" && this.onEnterVR(this.context.xrSession), (i = this.context.xrSession) == null || i.addEventListener("end", () => {
        this.dispatchEvent(new CustomEvent("xr-session-ended", { detail: { session: this.context.xrSession, context: this._context, sessionMode: e } })), e === "immersive-ar" ? this.onExitAR(this.context.xrSession) : e === "immersive-vr" && this.onExitVR(this.context.xrSession);
      });
    });
    /** called by the context when the first frame has been rendered */
    r(this, "onReady", () => {
      var e;
      return (e = this._loadingView) == null ? void 0 : e.onLoadingFinished();
    });
    r(this, "onError", () => {
      var e;
      return (e = this._loadingView) == null ? void 0 : e.setMessage("Loading failed!");
    });
    r(this, "_previouslyRegisteredMap", /* @__PURE__ */ new Map());
    this._overlay_ar = new nM(), this.addEventListener("ready", this.onReady), Pv(), this.attachShadow({ mode: "open" });
    const e = document.createElement("template");
    e.innerHTML = `<style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');

    :host {
        position: absolute;
        display: block;
        width: max(600px, 100%);
        height: max(300px, 100%);
        touch-action: none;

        -webkit-tap-highlight-color: transparent;
    }

    @media (max-width: 600px) {
        :host {
            width: 100%;
        }
    }
    @media (max-height: 300px) {
        :host {
            height: 100%;
        }
    }

    :host > div.canvas-wrapper {
        width: 100%;
        height: 100%;
    }

    :host canvas {   
        position: absolute;
        user-select: none;
        -webkit-user-select: none;

        /** allow touch panning but no pinch zoom **/
        /** but this doesnt work yet: 
         * touch-action: pan-x, pan-y;
         **/
        
        -webkit-touch-callout: none;
        -webkit-user-drag: none;
        -webkit-user-modify: none;
    }
    :host .content {
        position: absolute;
        top: 0;
        width: 100%;
        height: 100%;
        visibility: visible;
        z-index: 500; /* < must be less than the webxr buttons element */
        pointer-events: none;
    }
    :host .overlay-content {
        position: absolute;
        user-select: auto;
        pointer-events: all;
    }
    :host slot[name="quit-ar"]:hover {
        cursor: pointer;
    }
    :host .quit-ar-button {
        position: absolute;
        // top: env(titlebar-area-y); /** this doesnt work **/
        top: 60px; /** camera access needs a bit more space **/
        right: 20px;
        z-index: 9999;
    }
</style>
<div class="canvas-wrapper"> <!-- this wrapper is necessary for WebXR https://github.com/meta-quest/immersive-web-emulator/issues/55 -->
    <canvas></canvas>
</div>
<div class="content">
    <slot class="overlay-content"></slot>
</div>
`, this.shadowRoot && this.shadowRoot.appendChild(e.content.cloneNode(!0)), this._context = new ee({ domElement: this }), this.addEventListener("error", this.onError);
  }
  static get observedAttributes() {
    return yI;
  }
  get loadingProgress01() {
    return this._loadingProgress01;
  }
  get loadingFinished() {
    return this.loadingProgress01 > 0.999;
  }
  /**
   * If set to false the camera controls are disabled. Default is true.  
   * @type {boolean | null}
   * @memberof NeedleEngineAttributes
   * @example
   * <needle-engine camera-controls="false"></needle-engine>
   * @example
   * <needle-engine camera-controls="true"></needle-engine>
   * @example
   * <needle-engine camera-controls></needle-engine>
   * @example
   * <needle-engine></needle-engine>
   * @returns {boolean | null} if the attribute is not set it returns null
   */
  get cameraControls() {
    const e = this.getAttribute("camera-controls");
    return e == null ? null : !(e === null || e === "False" || e === "false" || e === "0" || e === "none");
  }
  /**
   * Get the current context for this web component instance. The context is created when the src attribute is set and the loading has finished.  
   * The context is disposed when the needle engine is removed from the document (you can prevent this by setting the keep-alive attribute to true).  
   * @returns {Promise<Context>} a promise that resolves to the context when the loading has finished
   */
  getContext() {
    return new Promise((e, i) => {
      if (this._context && this.loadingFinished)
        e(this._context);
      else {
        const n = () => {
          this.removeEventListener("loadfinished", n), this._context && this.loadingFinished && e(this._context);
        };
        this.addEventListener("loadfinished", n);
      }
    });
  }
  /**
   * Get the context that is created when the src attribute is set and the loading has finished.
   */
  get context() {
    return this._context;
  }
  /**
   * @internal
   */
  async connectedCallback() {
    if (Le && console.log("<needle-engine> connected"), this.setPublicKey(), this.setVersion(), this.addEventListener("xr-session-started", this.onXRSessionStarted), this.onSetupDesktop(), !this.getAttribute("src")) {
      const i = globalThis["needle:codegen_files"];
      Le && console.log('src is null, trying to load from globalThis["needle:codegen_files"]', i), i && (Le && console.log('globalThis["needle:codegen_files"]', i), this.setAttribute("src", i));
    }
    Le && console.log("src", this.getAttribute("src"));
    const e = this._loadId;
    setTimeout(() => {
      this.isConnected !== !1 && e === this._loadId && this.onLoad();
    }, 1);
  }
  /**
   * @internal
   */
  disconnectedCallback() {
    var n;
    this.removeEventListener("xr-session-started", this.onXRSessionStarted), this._didFullyLoad = !1;
    const e = this.getAttribute("keep-alive"), i = e == null || (e == null ? void 0 : e.length) > 0 && e !== "true" && e !== "1";
    Le && console.warn('<needle-engine> disconnected, keep-alive: "' + e + '"', typeof e, "Dispose=", i), i ? (Le && console.warn("<needle-engine> dispose"), (n = this._context) == null || n.dispose(), this._context = null, this._lastSourceFiles = null, this._loadId += 1) : Le && console.warn("<needle-engine> is not disposed because keep-alive is set");
  }
  /**
   * @internal
   */
  attributeChangedCallback(e, i, n) {
    switch (Le && console.log("attributeChangedCallback", e, i, n), e) {
      case "src":
        Le && console.warn(`<needle-engine src>
changed from "`, i, '" to "', n, '"'), this.onLoad();
        break;
      case "hash":
        this._context && (this._context.hash = n);
        break;
      case "loadstart":
      case "progress":
      case "loadfinished":
        typeof n == "string" && n.length > 0 && (Le && console.log(e + " attribute changed", n), this.registerEventFromAttribute(e, n));
        break;
      case "dracoDecoderPath":
        Le && console.log("dracoDecoderPath", n), Qy(n);
        break;
      case "dracoDecoderType":
        n === "wasm" || n === "js" ? (Le && console.log("dracoDecoderType", n), Yy(n)) : console.error("Invalid dracoDecoderType", n, "expected js or wasm");
        break;
      case "ktx2DecoderPath":
        Le && console.log("ktx2DecoderPath", n), Ky(n);
        break;
      case "tone-mapping": {
        this.applyAttributes();
        break;
      }
      case "tone-mapping-exposure": {
        this.applyAttributes();
        break;
      }
      case "background-blurriness": {
        const o = parseFloat(n);
        o != null && this._context && (this._context.scene.backgroundBlurriness = o);
        break;
      }
      case "background-color": {
        this.applyAttributes();
        break;
      }
      case "public-key": {
        n != ud && this.setPublicKey();
        break;
      }
      case "version": {
        n != $n && this.setVersion();
        break;
      }
    }
  }
  async onLoad() {
    var _, y;
    if (!this.isConnected)
      return;
    if (this._context || (Le && console.warn("Create new context"), this._context = new ee({ domElement: this })), !this._context) {
      console.error("Needle Engine: Context not initialized");
      return;
    }
    const e = this.getSourceFiles();
    if (!this.checkIfSourceHasChanged(e, this._lastSourceFiles))
      return;
    this._abortController && (Le && console.warn("Abort previous loading process"), this._abortController.abort(), this._abortController = null), this._lastSourceFiles = e;
    const i = ++this._loadId;
    if ((e == null || e.length <= 0) && (Le && console.warn("Clear scene", e), this._context.clear(), i !== this._loadId))
      return;
    const n = this.getAttribute("alias");
    this.classList.add("loading");
    const o = Vn();
    this.ensureLoadStartIsRegistered();
    let a = this.dispatchEvent(new CustomEvent("loadstart", {
      detail: {
        context: this._context,
        alias: n
      },
      cancelable: !0
    }));
    if (o) {
      const b = this.getAttribute("hide-loading-overlay");
      b != null && b !== "0" && (a = !1);
    }
    a === !1 && !o && (z() || (a = !0), console.warn("Needle Engine: You need a commercial license to override the default loading view. Visit https://needle.tools/pricing"), z() && ve('You need a <a target="_blank" href="https://needle.tools/pricing">commercial license</a> to override the default loading view. This will not work in production.')), !this._loadingView && a && (this._loadingView = new xd(this)), a && (this._didFullyLoad !== !0 ? (_ = this._loadingView) == null || _.onLoadingBegin("begin load") : setTimeout(() => {
      this._loadingView && this._loadingProgress01 < 0.3 && this._loadId === i && this._loadingView.onLoadingBegin("begin load");
    }, 300)), Le && console.warn(`--------------
Needle Engine: Begin loading ` + i + `
`, e), this.onBeforeBeginLoading();
    const l = [], c = {
      context: this._context,
      name: "",
      progress: {},
      index: 0,
      count: e.length,
      totalProgress01: this._loadingProgress01
    }, h = new CustomEvent("progress", { detail: c }), d = new Array(), u = new AbortController();
    this._abortController = u;
    const p = {
      files: e,
      abortSignal: u.signal,
      onLoadingProgress: (b) => {
        var P;
        if (Le && console.debug("Loading progress: ", b), u.signal.aborted)
          return;
        const w = b.index;
        !d[w] && b.name && (d[w] = bI(b.name)), b.name = d[w], a && ((P = this._loadingView) == null || P.onLoadingUpdate(b)), c.name = b.name, c.progress = b.progress, this._loadingProgress01 = kv(b), c.totalProgress01 = this._loadingProgress01, this.dispatchEvent(h);
      },
      onLoadingFinished: (b, w, P) => {
        Le && console.debug(`Finished loading "${w}" (aborted? ${u.signal.aborted})`), !u.signal.aborted && P && l.push({
          src: w,
          file: P
        });
      }
    }, m = this.getAttribute("hash");
    m != null && (this._context.hash = m), this._context.alias = n, this._createContextPromise = this._context.create(p);
    const g = await this._createContextPromise;
    if (this.applyAttributes(), Le && console.warn(`--------------
Needle Engine: finished loading ` + i + `
`, e, `Aborted? ${u.signal.aborted}`), u.signal.aborted) {
      console.log("Loading finished but aborted...");
      return;
    }
    if (this._loadId !== i) {
      console.log("Load id changed during loading process");
      return;
    }
    this._loadingProgress01 = 1, a && g && ((y = this._loadingView) == null || y.onLoadingUpdate(1, "creating scene")), this._didFullyLoad = !0, this.classList.remove("loading"), this.classList.add("loading-finished"), this.dispatchEvent(new CustomEvent("loadfinished", {
      detail: {
        context: this._context,
        src: n,
        loadedFiles: l
      }
    }));
  }
  applyAttributes() {
    if (this._context.renderer) {
      const n = this.getAttribute("tonemapping") || this.getAttribute("tone-mapping");
      switch (n == null ? void 0 : n.toLowerCase()) {
        case "none":
          this._context.renderer.toneMapping = ja;
          break;
        case "linear":
          this._context.renderer.toneMapping = Ou;
          break;
        case "neutral":
          this._context.renderer.toneMapping = Ec;
          break;
        case "agx":
          this._context.renderer.toneMapping = Pu;
          break;
        default:
          n != null && console.warn("Invalid tone-mapping attribute: " + n);
      }
      const o = this.getAttribute("tone-mapping-exposure");
      if (o != null) {
        const a = parseFloat(o);
        isNaN(a) || (this._context.renderer.toneMappingExposure = a);
      }
    }
    const e = this.getAttribute("background-blurriness");
    if (e != null) {
      const n = parseFloat(e);
      n !== void 0 && this._context && (this._context.scene.backgroundBlurriness = n);
    }
    const i = this.getAttribute("background-color");
    if (this._context && typeof i == "string" && i.length > 0) {
      const n = this._context.scene.background;
      n instanceof ae ? n.set(i) : this._context.scene.background = new ae(i);
    }
  }
  internalSetLoadingMessage(e) {
    var i;
    (i = this._loadingView) == null || i.setMessage(e);
  }
  getSourceFiles() {
    const e = this.getAttribute("src");
    if (!e)
      return [];
    let i;
    Array.isArray(e) ? i = e : e.startsWith("[") && e.endsWith("]") ? i = JSON.parse(e) : e.includes(",") ? i = e.split(",") : i = [e];
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      (o === "null" || o === "undefined" || (o == null ? void 0 : o.length) <= 0) && i.splice(n, 1);
    }
    return i;
  }
  checkIfSourceHasChanged(e, i) {
    if ((e == null ? void 0 : e.length) !== (i == null ? void 0 : i.length) || e == null && i !== null || e !== null && i == null)
      return !0;
    if (e !== null && i !== null) {
      for (let n = 0; n < (e == null ? void 0 : e.length); n++)
        if (e[n] !== i[n])
          return !0;
    }
    return !1;
  }
  ensureLoadStartIsRegistered() {
    const e = this.getAttribute("loadstart");
    e && this.registerEventFromAttribute("loadstart", e);
  }
  registerEventFromAttribute(e, i) {
    const n = this._previouslyRegisteredMap.get(e);
    if (n && (this._previouslyRegisteredMap.delete(e), this.removeEventListener(e, n)), typeof i == "string" && i.length > 0)
      try {
        const o = (0, eval)(i);
        typeof o == "function" && (this._previouslyRegisteredMap.set(e, o), this.addEventListener(e, (a) => o == null ? void 0 : o.call(globalThis, this._context, a)));
      } catch (o) {
        console.error("Error registering event " + e + '="' + i + `" failed with the following error:
`, o);
      }
  }
  setPublicKey() {
    ud.length > 0 && this.setAttribute("public-key", ud);
  }
  setVersion() {
    $n.length > 0 && this.setAttribute("version", $n);
  }
  /**
   * @internal
   */
  getAROverlayContainer() {
    return this._overlay_ar.createOverlayContainer(this);
  }
  /**
   * @internal
   */
  getVROverlayContainer() {
    for (let e = 0; e < this.children.length; e++) {
      const i = this.children[e];
      if (i.classList.contains("vr"))
        return i;
    }
    return null;
  }
  /**
   * @internal
   */
  onEnterAR(e) {
    var n;
    this.onSetupAR();
    const i = this.getAROverlayContainer();
    this._overlay_ar.onBegin(this._context, i, e), this.dispatchEvent(new CustomEvent("enter-ar", { detail: { session: e, context: this._context, htmlContainer: (n = this._overlay_ar) == null ? void 0 : n.ARContainer } }));
  }
  /**
   * @internal
   */
  onExitAR(e) {
    var i;
    this._overlay_ar.onEnd(this._context), this.onSetupDesktop(), this.dispatchEvent(new CustomEvent("exit-ar", { detail: { session: e, context: this._context, htmlContainer: (i = this._overlay_ar) == null ? void 0 : i.ARContainer } }));
  }
  /**
   * @internal
   */
  onEnterVR(e) {
    this.onSetupVR(), this.dispatchEvent(new CustomEvent("enter-vr", { detail: { session: e, context: this._context } }));
  }
  /**
   * @internal
   */
  onExitVR(e) {
    this.onSetupDesktop(), this.dispatchEvent(new CustomEvent("exit-vr", { detail: { session: e, context: this._context } }));
  }
  onSetupAR() {
    this.classList.add(zl), this.classList.remove(Ul);
    const e = this.getAROverlayContainer();
    Le && console.warn("onSetupAR:", e), e && (e.classList.add(zl), e.classList.remove(Ul)), this.foreachHtmlElement((i) => this.setupElementsForMode(i, Tv));
  }
  onSetupVR() {
    this.classList.remove(zl), this.classList.remove(Ul), this.foreachHtmlElement((e) => this.setupElementsForMode(e, bx));
  }
  onSetupDesktop() {
    this.classList.remove(zl), this.classList.add(Ul);
    const e = this.getAROverlayContainer();
    e && (e.classList.remove(zl), e.classList.add(Ul)), this.foreachHtmlElement((i) => this.setupElementsForMode(i, vx));
  }
  setupElementsForMode(e, i, n = null) {
    var a, l;
    if (e === ((l = (a = this._context) == null ? void 0 : a.renderer) == null ? void 0 : l.domElement) || e.id === "VRButton" || e.id === "ARButton")
      return;
    if (e.classList.contains(i))
      e.style.visibility = "visible", e.style.display === "none" && (e.style.display = "block");
    else
      for (const c of _I)
        e.classList.contains(c) && (e.style.visibility = "hidden", e.style.display = "none");
  }
  foreachHtmlElement(e) {
    for (let i = 0; i < this.children.length; i++) {
      const n = this.children[i];
      n.style && e(n);
    }
  }
  onBeforeBeginLoading() {
    const e = this.getAttribute("dracoDecoderPath");
    e && (Le && console.log("using custom draco decoder path", e), Qy(e));
    const i = this.getAttribute("dracoDecoderType");
    i && (Le && console.log("using custom draco decoder type", i), Yy(i));
    const n = this.getAttribute("ktx2DecoderPath");
    n && (Le && console.log("using custom ktx2 decoder path", n), Ky(n));
  }
}
typeof window < "u" && !window.customElements.get(Vb) && window.customElements.define(Vb, wx);
function bI(s) {
  if (s.startsWith("blob:"))
    return "blob";
  const t = s.split("/");
  let e = t[t.length - 1];
  const i = e.indexOf("?");
  i > 0 && (e = e.substring(0, i));
  const n = e.indexOf("=");
  n > 0 && (e = e.substring(n));
  const o = e.split(".").pop(), l = o ? ["glb", "gltf", "usdz", "usd", "fbx", "obj", "mtl"].indexOf(o.toLowerCase()) : -1;
  if (o && l >= 0 && (e = e.substring(0, e.length - o.length - 1)), e = decodeURIComponent(e), e.length > 3) {
    let c = "", h = !1;
    const d = ["(", ")", "[", "]", "{", "}", ":", ";", ",", ".", "!", "?"];
    for (let u = 0; u < e.length; u++) {
      let p = e[u];
      (p === "_" || p === "-") && (p = " "), !(p === " " && c.length <= 0 || d.includes(p) || (c.length === 0 && (p = p.toUpperCase()), h && p === " ")) && (h && (p = p.toUpperCase()), h = !1, c += p, p === " " && (h = !0));
    }
    return z() && e !== c && console.debug('Generated display name: "' + e + '" → "' + c + '"'), c.trim();
  }
  return z() && console.debug("Loading: use default name", e), e;
}
const vI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NeedleEngineHTMLElement: wx
}, Symbol.toStringTag, { value: "Module" }));
function wI() {
  Wn.registerWaitForInteraction(() => {
    const s = W1.getContext();
    s.addEventListener("statechange", () => {
      setTimeout(() => {
        const t = s.state;
        (t === "suspended" || t === "interrupted") && s.resume().then(() => {
          console.log("AudioContext resumed successfully");
        }).catch((e) => {
          console.log("Failed to resume AudioContext: " + e);
        });
      }, 500);
    });
  });
}
setTimeout(wI, 1e3);
const Ed = x("debughotreload");
let Vc = !1;
const xc = /* @__PURE__ */ new Map();
function rL() {
  return Vc;
}
function aL(s) {
  var i;
  if (Vc)
    return;
  const e = s.constructor.name;
  xc.has(e) ? (i = xc.get(e)) == null || i.push(s) : xc.set(e, [s]);
}
function lL(s) {
  if (Vc)
    return;
  const e = s.constructor.name, i = xc.get(e);
  if (!i)
    return;
  const n = i.indexOf(s);
  n !== -1 && i.splice(n, 1);
}
let Hb = !1;
function xI() {
  if (Ed || Hb)
    return;
  Hb = !0;
  const s = console.error;
  console.error = (...t) => {
    if (t.length) {
      const e = t[0];
      if (typeof e == "string" && e.includes("[hmr] Failed to reload ")) {
        console.log("[Needle Engine] Hot reloading failed"), window.location.reload();
        return;
      }
    }
    s.apply(console, t);
  };
}
function cL(s) {
  Ed && console.log("[HMR] Apply changes", s, Object.keys(s)), xI();
  for (const t of Object.keys(s))
    try {
      Vc = !0;
      const e = R.get(t);
      if (!e) {
        Ed && console.log("[HMR] Type not found: " + t);
        continue;
      }
      const i = s[t], n = xc.get(i.name);
      let o = "[Needle Engine] Updating type: " + t;
      const a = (n == null ? void 0 : n.length) ?? -1;
      a > 0 ? o += " x" + a : o += " - no instances", console.log(o);
      const l = Object.getOwnPropertyNames(e.prototype), c = Object.getOwnPropertyDescriptors(i.prototype);
      for (const h in c)
        c[h].writable && (e.prototype[h] = s[t].prototype[h]);
      for (const h of l)
        c[h] || delete e.prototype[h];
      if (n) {
        const h = new i(), d = Object.getOwnPropertyDescriptors(h);
        for (const u of n) {
          const p = u, m = p.isComponent === !0, g = m ? p.activeAndEnabled : !0, _ = m ? p.context : void 0;
          try {
            if (m && _ && ys(p, _), m && g && (p.enabled = !1), u.onBeforeHotReloadFields && u.onBeforeHotReloadFields() === !1)
              continue;
            for (const y in d)
              if (d[y].writable) {
                if (u[y] === void 0)
                  u[y] = h[y];
                else if (typeof u[y] == "function" && !u[y].prototype) {
                  const w = u[y], P = w.name, k = "bound ";
                  if (P === k)
                    continue;
                  const O = w.name.substring(k.length), M = i.prototype[O];
                  M && (u[y] = M.bind(u));
                }
              }
            u.onAfterHotReloadFields && u.onAfterHotReloadFields();
          } finally {
            m && _ && Cg(p, _), m && g && (p.enabled = !0);
          }
        }
      }
    } catch (e) {
      if (Ed)
        console.error(e);
      else
        return !1;
    } finally {
      Vc = !1, Bn(Zi.Log, "Script changes applied (HMR)");
    }
  return !0;
}
const Qe = x("debugphysics"), Ip = x("debugcolliderplacement"), Dp = x("debugcollisions"), SI = x("showcolliders"), Lp = x("debugraycasts"), hi = Symbol("needle component"), Gt = Symbol("physics body"), Gb = Symbol("rigidbody");
globalThis.true = globalThis.true !== void 0 ? globalThis.true : !0;
Qe && console.log("Use Rapier", !0, globalThis.true);
fe.registerCallback(pe.ContextCreationStart, (s) => {
  Qe && console.log("Register rapier physics backend"), s.context.physics.engine = new qo(s.context);
});
const Tc = class {
  constructor(t) {
    r(this, "debugRenderColliders", !1);
    r(this, "debugRenderRaycasts", !1);
    r(this, "context");
    r(this, "_initializePromise");
    r(this, "_isInitialized", !1);
    r(this, "rapierRay");
    r(this, "raycastVectorsBuffer", new tn(() => new v(), 10));
    r(this, "rapierSphere", null);
    r(this, "rapierColliderArray", []);
    r(this, "rapierIdentityRotation", { x: 0, y: 0, z: 0, w: 1 });
    r(this, "rapierForwardVector", { x: 0, y: 0, z: 1 });
    // physics simulation
    r(this, "enabled", !1);
    r(this, "_tempPosition", new v());
    r(this, "_tempQuaternion", new W());
    r(this, "_tempScale", new v());
    r(this, "_tempMatrix", new se());
    r(this, "_isUpdatingPhysicsWorld", !1);
    r(this, "_world");
    r(this, "_hasCreatedWorld", !1);
    r(this, "eventQueue");
    r(this, "collisionHandler");
    r(this, "objects", []);
    r(this, "bodies", []);
    r(this, "_meshCache", /* @__PURE__ */ new Map());
    r(this, "_gravity", { x: 0, y: -9.81, z: 0 });
    // private _lastStepTime: number | undefined = 0;
    r(this, "lines");
    r(this, "_tempCenterPos", new v());
    r(this, "_tempCenterVec", new v());
    r(this, "_tempCenterQuaternion", new W());
    this.context = t;
  }
  removeBody(t) {
    var i, n, o;
    if (!t)
      return;
    this.validate();
    const e = t[Gt];
    if (t[Gt] = null, e && this.world) {
      const a = this.objects.findIndex((l) => l === t);
      if (a >= 0) {
        const l = this.bodies[a];
        if (this.bodies.splice(a, 1), this.objects.splice(a, 1), l instanceof D.RAPIER_PHYSICS.MODULE.Collider) {
          const c = l;
          (i = this.world) == null || i.removeCollider(c, !0);
          const h = c.parent();
          h && h.numColliders() <= 0 && (h[hi] || (n = this.world) == null || n.removeRigidBody(h));
        } else
          l instanceof D.RAPIER_PHYSICS.MODULE.RigidBody && (l.numColliders() <= 0 ? (o = this.world) == null || o.removeRigidBody(l) : z() && (l.did_log_removing || setTimeout(() => {
            l.numColliders() > 0 && (l.did_log_removing = !0, console.warn("RapierPhysics: removing rigidbody with colliders from the physics world is not possible right now, please remove the colliders first"));
          }, 1)));
      }
    }
  }
  updateBody(t, e, i) {
    if (this.validate(), !!this.enabled && !(t.destroyed || !t.gameObject) && !(!e && !i))
      if (t.isCollider === !0)
        console.warn("TODO: implement updating collider position");
      else {
        const n = t, o = n[Gt];
        o && this.syncPhysicsBody(n.gameObject, o, e, i);
      }
  }
  updateProperties(t) {
    if (this.validate(), t.isCollider) {
      const e = t, i = e[Gt];
      i && (this.internalUpdateColliderProperties(e, i), e.sharedMaterial && this.updatePhysicsMaterial(e));
    } else {
      const e = t, i = this.internal_getRigidbody(e);
      i && this.internalUpdateRigidbodyProperties(e, i);
    }
  }
  addForce(t, e, i) {
    this.validate();
    const n = this.internal_getRigidbody(t);
    n ? n.addForce(e, i) : console.warn("Rigidbody doesn't exist: can not apply force (does your object with the Rigidbody have a collider?)");
  }
  addImpulse(t, e, i) {
    this.validate();
    const n = this.internal_getRigidbody(t);
    n ? n.applyImpulse(e, i) : console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  getLinearVelocity(t) {
    this.validate();
    const e = this.internal_getRigidbody(t);
    return e ? e.linvel() : null;
  }
  getAngularVelocity(t) {
    this.validate();
    const e = this.internal_getRigidbody(t);
    return e ? e.angvel() : null;
  }
  resetForces(t, e) {
    this.validate();
    const i = this.internal_getRigidbody(t);
    i == null || i.resetForces(e);
  }
  resetTorques(t, e) {
    this.validate();
    const i = this.internal_getRigidbody(t);
    i == null || i.resetTorques(e);
  }
  applyImpulse(t, e, i) {
    this.validate();
    const n = this.internal_getRigidbody(t);
    n ? n.applyImpulse(e, i) : console.warn("Rigidbody doesn't exist: can not apply impulse (does your object with the Rigidbody have a collider?)");
  }
  wakeup(t) {
    this.validate();
    const e = this.internal_getRigidbody(t);
    e ? e.wakeUp() : console.warn("Rigidbody doesn't exist: can not wake up (does your object with the Rigidbody have a collider?)");
  }
  isSleeping(t) {
    this.validate();
    const e = this.internal_getRigidbody(t);
    return e == null ? void 0 : e.isSleeping();
  }
  setAngularVelocity(t, e, i) {
    this.validate();
    const n = this.internal_getRigidbody(t);
    n ? n.setAngvel(e, i) : console.warn("Rigidbody doesn't exist: can not set angular velocity (does your object with the Rigidbody have a collider?)");
  }
  setLinearVelocity(t, e, i) {
    this.validate();
    const n = this.internal_getRigidbody(t);
    n ? n.setLinvel(e, i) : console.warn("Rigidbody doesn't exist: can not set linear velocity (does your object with the Rigidbody have a collider?)");
  }
  get isInitialized() {
    return this._isInitialized;
  }
  async initialize() {
    return this._initializePromise || (this._initializePromise = this.internalInitialization()), this._initializePromise;
  }
  async internalInitialization() {
    return x("__nophysics") ? (console.warn("Physics are disabled"), !1) : (Qe && console.log("Initialize rapier physics engine"), "env" in import.meta && {}.VITE_NEEDLE_USE_RAPIER === "false" ? (Qe && console.log("Rapier disabled"), !1) : this._hasCreatedWorld ? (console.error("Invalid call to create physics world: world is already created"), !0) : (this._hasCreatedWorld = !0, D.RAPIER_PHYSICS.MAYBEMODULE == null && (Qe && console.trace("Loading rapier physics engine"), await (await D.RAPIER_PHYSICS.load()).init()), Qe && console.log("Physics engine initialized, creating world..."), this._world = new D.RAPIER_PHYSICS.MODULE.World(this._gravity), this.rapierRay = new D.RAPIER_PHYSICS.MODULE.Ray({ x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 }), this.enabled = !0, this._isInitialized = !0, Qe && console.log("Physics world created"), !0));
  }
  /** Check is the physics engine has been initialized and the call can be made */
  validate() {
    this._isInitialized || Qe && (this._lastWarnTime = this._lastWarnTime ?? 0, Date.now() - this._lastWarnTime > 1e3 && (this._lastWarnTime = Date.now(), console.warn("Physics engine is not initialized")));
  }
  raycast(t, e, i) {
    var c;
    if (!this._isInitialized)
      return console.log("Physics engine is not initialized"), null;
    let n = i == null ? void 0 : i.maxDistance, o = i == null ? void 0 : i.solid;
    n === void 0 && (n = 1 / 0), o === void 0 && (o = !0);
    const a = this.getPhysicsRay(this.rapierRay, t, e);
    if (!a)
      return null;
    (this.debugRenderRaycasts || Lp) && V.DrawRay(a.origin, a.dir, 255, 1);
    const l = (c = this.world) == null ? void 0 : c.castRay(a, n, o, i == null ? void 0 : i.queryFilterFlags, i == null ? void 0 : i.filterGroups, void 0, void 0, (h) => {
      const d = h[hi];
      return i != null && i.filterPredicate ? i.filterPredicate(d) : (i == null ? void 0 : i.useIgnoreRaycastLayer) !== !1 ? !(d != null && d.gameObject.layers.isEnabled(2)) : !0;
    });
    if (l) {
      const h = a.pointAt(l.timeOfImpact), d = this.raycastVectorsBuffer.get();
      return d.set(h.x, h.y, h.z), { point: d, collider: l.collider[hi] };
    }
    return null;
  }
  raycastAndGetNormal(t, e, i) {
    var c;
    if (!this._isInitialized)
      return null;
    let n = i == null ? void 0 : i.maxDistance, o = i == null ? void 0 : i.solid;
    n === void 0 && (n = 1 / 0), o === void 0 && (o = !0);
    const a = this.getPhysicsRay(this.rapierRay, t, e);
    if (!a)
      return null;
    (this.debugRenderRaycasts || Lp) && V.DrawRay(a.origin, a.dir, 255, 1);
    const l = (c = this.world) == null ? void 0 : c.castRayAndGetNormal(a, n, o, i == null ? void 0 : i.queryFilterFlags, i == null ? void 0 : i.filterGroups, void 0, void 0, (h) => {
      const d = h[hi];
      return i != null && i.filterPredicate ? i.filterPredicate(d) : (i == null ? void 0 : i.useIgnoreRaycastLayer) !== !1 ? !(d != null && d.gameObject.layers.isEnabled(2)) : !0;
    });
    if (l) {
      const h = a.pointAt(l.timeOfImpact), d = l.normal, u = this.raycastVectorsBuffer.get(), p = this.raycastVectorsBuffer.get();
      return u.set(h.x, h.y, h.z), p.set(d.x, d.y, d.z), { point: u, normal: p, collider: l.collider[hi] };
    }
    return null;
  }
  getPhysicsRay(t, e, i) {
    var l, c, h;
    const n = (l = this.context) == null ? void 0 : l.mainCamera;
    if (e === void 0) {
      const d = (c = this.context) == null ? void 0 : c.input.getPointerPosition(0);
      if (d)
        e = d;
      else
        return null;
    }
    if (e.z === void 0) {
      if (!n)
        return console.error("Can not perform raycast from 2d point - no main camera found"), null;
      const d = this.raycastVectorsBuffer.get();
      d.x = e.x, d.y = e.y, d.z = 0, (d.x > 1 || d.y > 1 || d.y < -1 || d.x < -1) && (Qe && console.warn("Converting screenspace to raycast space", d), (h = this.context) == null || h.input.convertScreenspaceToRaycastSpace(d)), d.unproject(n), e = d;
    }
    const o = e;
    t.origin.x = o.x, t.origin.y = o.y, t.origin.z = o.z;
    const a = this.raycastVectorsBuffer.get();
    if (i)
      a.set(i.x, i.y, i.z);
    else {
      if (!n)
        return console.error("Can not perform raycast - no camera found"), null;
      a.set(t.origin.x, t.origin.y, t.origin.z);
      const d = ie(n);
      a.sub(d);
    }
    return a.normalize(), t.dir.x = a.x, t.dir.y = a.y, t.dir.z = a.z, t;
  }
  /** Precice sphere overlap detection using rapier against colliders
   * @param point center of the sphere in worldspace
   * @param radius radius of the sphere
   * @returns array of colliders that overlap with the sphere. Note: they currently only contain the collider and the gameobject
   */
  sphereOverlap(t, e) {
    return this.rapierColliderArray.length = 0, this._isInitialized ? this.world ? (this.rapierSphere ?? (this.rapierSphere = new D.RAPIER_PHYSICS.MODULE.Ball(e)), this.rapierSphere.radius = e, (this.debugRenderRaycasts || Lp) && V.DrawWireSphere(t, e, 3359999, 1), this.world.intersectionsWithShape(
      t,
      this.rapierIdentityRotation,
      this.rapierSphere,
      (i) => {
        const n = i[hi], o = new oR(n.gameObject, n);
        return this.rapierColliderArray.push(o), !0;
      },
      // TODO: it seems as QueryFilterFlags.EXCLUDE_SENSORS also excludes DYNAMIC Rigidbodies (only if they're set to kinematic)
      void 0,
      // QueryFilterFlags.EXCLUDE_SENSORS, 
      void 0,
      void 0,
      void 0,
      (i) => i.isSensor() ? !1 : i[hi].gameObject.layers.isEnabled(2) == !1
    ), this.rapierColliderArray) : this.rapierColliderArray : this.rapierColliderArray;
  }
  /** Get access to the rapier world */
  get world() {
    return this._world;
  }
  get isUpdating() {
    return this._isUpdatingPhysicsWorld;
  }
  get gravity() {
    var t;
    return ((t = this.world) == null ? void 0 : t.gravity) ?? this._gravity;
  }
  set gravity(t) {
    this.world ? this.world.gravity = t : this._gravity = t;
  }
  clearCaches() {
    var t, e, i, n;
    this._meshCache.clear(), (t = this.eventQueue) != null && t.raw && ((e = this.eventQueue) == null || e.free()), (i = this.world) != null && i.bodies && ((n = this.world) == null || n.free());
  }
  async addBoxCollider(t, e) {
    if (this._isInitialized || await this.initialize(), !t.activeAndEnabled)
      return;
    if (!this.enabled) {
      Qe && console.warn("Physics are disabled");
      return;
    }
    const i = t.gameObject, n = Ke(i, this._tempPosition).multiply(e);
    n.multiplyScalar(0.5), n.x < 0 && (n.x = Math.abs(n.x)), n.y < 0 && (n.y = Math.abs(n.y)), n.z < 0 && (n.z = Math.abs(n.z)), n.x == 0 && (n.x = 1e-7), n.y == 0 && (n.y = 1e-7), n.z == 0 && (n.z = 1e-7);
    const o = D.RAPIER_PHYSICS.MODULE.ColliderDesc.cuboid(n.x, n.y, n.z);
    this.createCollider(t, o);
  }
  async addSphereCollider(t) {
    if (this._isInitialized || await this.initialize(), !t.activeAndEnabled)
      return;
    if (!this.enabled) {
      Qe && console.warn("Physics are disabled");
      return;
    }
    const e = D.RAPIER_PHYSICS.MODULE.ColliderDesc.ball(0.5);
    this.createCollider(t, e), this.updateProperties(t);
  }
  async addCapsuleCollider(t, e, i) {
    if (this._isInitialized || await this.initialize(), !t.activeAndEnabled)
      return;
    if (!this.enabled) {
      Qe && console.warn("Physics are disabled");
      return;
    }
    const n = t.gameObject, o = Ke(n, this._tempPosition);
    o.x = Math.abs(o.x), o.y = Math.abs(o.y);
    const a = i * o.x;
    e = Math.max(e, a * 2);
    const l = $.clamp(e * 0.5 * o.y - i * o.x, 0, Number.MAX_SAFE_INTEGER), c = D.RAPIER_PHYSICS.MODULE.ColliderDesc.capsule(l, a);
    this.createCollider(t, c);
  }
  async addMeshCollider(t, e, i, n) {
    var u, p, m;
    let o = e.geometry;
    if (!o) {
      Qe && console.warn("Missing mesh geometry", e.name);
      return;
    }
    (p = (u = o.index) == null ? void 0 : u.array) != null && p.length || (console.warn(`Your MeshCollider is missing vertices or indices in the assined mesh "${e.name}". Consider providing an indexed geometry.`), o = pS(o));
    let a = null;
    const l = o.getAttribute("position");
    if (l instanceof i0) {
      const g = l.count;
      a = new Float32Array(g * 3);
      for (let _ = 0; _ < g; _++) {
        const y = l.getX(_), b = l.getY(_), w = l.getZ(_);
        a[_ * 3] = y, a[_ * 3 + 1] = b, a[_ * 3 + 2] = w;
      }
    } else
      a = l.array;
    if (await this.initialize(), !this.enabled) {
      Qe && console.warn("Physics are disabled");
      return;
    }
    if (!t.activeAndEnabled)
      return;
    const c = (m = o.index) == null ? void 0 : m.array, h = t.gameObject.worldScale.clone();
    if (n && h.multiply(n), Math.abs(h.x - 1) > 1e-4 || Math.abs(h.y - 1) > 1e-4 || Math.abs(h.z - 1) > 1e-4) {
      const g = `${o.uuid}_${h.x}_${h.y}_${h.z}_${i}`;
      if (this._meshCache.has(g))
        Qe && console.warn("Use cached mesh collider"), a = this._meshCache.get(g);
      else {
        (Qe || z()) && console.debug(`[Performance] Your MeshCollider "${t.name}" is scaled: consider applying the scale to the collider mesh instead (${h.x}, ${h.y}, ${h.z})`);
        const _ = new Float32Array(a.length);
        for (let y = 0; y < a.length; y += 3)
          _[y] = a[y] * h.x, _[y + 1] = a[y + 1] * h.y, _[y + 2] = a[y + 2] * h.z;
        a = _, this._meshCache.set(g, _);
      }
    }
    const d = i ? D.RAPIER_PHYSICS.MODULE.ColliderDesc.convexHull(a) : D.RAPIER_PHYSICS.MODULE.ColliderDesc.trimesh(a, c);
    d && this.createCollider(t, d);
  }
  updatePhysicsMaterial(t) {
    if (!t)
      return;
    const e = t.sharedMaterial, i = t[Gt];
    if (i && e) {
      if (e.bounciness !== void 0 && i.setRestitution(e.bounciness), e.bounceCombine !== void 0)
        switch (e.bounceCombine) {
          case Ot.Average:
            i.setRestitutionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case Ot.Maximum:
            i.setRestitutionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case Ot.Minimum:
            i.setRestitutionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case Ot.Multiply:
            i.setRestitutionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      if (e.dynamicFriction !== void 0 && i.setFriction(e.dynamicFriction), e.frictionCombine !== void 0)
        switch (e.frictionCombine) {
          case Ot.Average:
            i.setFrictionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case Ot.Maximum:
            i.setFrictionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case Ot.Minimum:
            i.setFrictionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case Ot.Multiply:
            i.setFrictionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
    }
  }
  /** Get the rapier body for a Needle component */
  getBody(t) {
    return t ? t[Gt] : null;
  }
  /** Get the Needle Engine component for a rapier object */
  getComponent(t) {
    return t ? t[hi] : null;
  }
  createCollider(t, e) {
    var a;
    if (!this.world)
      throw new Error("Physics world not initialized");
    const i = this._tempMatrix;
    let n;
    t.attachedRigidbody ? n = this.getRigidbody(t, this._tempMatrix) : (Qe && console.log("Create collider without rigidbody", t.name), i.makeRotationFromQuaternion(Ce(t.gameObject)), i.setPosition(ie(t.gameObject))), i.decompose(this._tempPosition, this._tempQuaternion, this._tempScale), this.tryApplyCenter(t, this._tempPosition), e.setTranslation(this._tempPosition.x, this._tempPosition.y, this._tempPosition.z), e.setRotation(this._tempQuaternion), e.setSensor(t.isTrigger);
    const o = t.sharedMaterial;
    if (o) {
      if (o.bounciness !== void 0 && e.setRestitution(o.bounciness), o.bounceCombine !== void 0)
        switch (o.bounceCombine) {
          case Ot.Average:
            e.setRestitutionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case Ot.Maximum:
            e.setRestitutionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case Ot.Minimum:
            e.setRestitutionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case Ot.Multiply:
            e.setRestitutionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
      if (o.dynamicFriction !== void 0 && e.setFriction(o.dynamicFriction), o.frictionCombine !== void 0)
        switch (o.frictionCombine) {
          case Ot.Average:
            e.setFrictionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Average);
            break;
          case Ot.Maximum:
            e.setFrictionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Max);
            break;
          case Ot.Minimum:
            e.setFrictionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Min);
            break;
          case Ot.Multiply:
            e.setFrictionCombineRule(D.RAPIER_PHYSICS.MODULE.CoefficientCombineRule.Multiply);
            break;
        }
    }
    ((a = t.attachedRigidbody) == null ? void 0 : a.autoMass) === !1 && (e.setDensity(1e-6), e.setMass(1e-6));
    try {
      const l = this.world.createCollider(e, n);
      return l[hi] = t, t[Gt] = l, l.setActiveEvents(D.RAPIER_PHYSICS.MODULE.ActiveEvents.COLLISION_EVENTS), l.setActiveCollisionTypes(D.RAPIER_PHYSICS.MODULE.ActiveCollisionTypes.ALL), this.objects.push(t), this.bodies.push(l), this.updateColliderCollisionGroups(t), l;
    } catch (l) {
      return console.error('Error creating collider "' + t.name + `"
Error:`, l), null;
    }
  }
  /**
   * Updates the collision groups of a collider.
   * 
   * @param collider - The collider to update.
   */
  updateColliderCollisionGroups(t) {
    const e = t[Gt], i = t.membership;
    let n = 0;
    if (i == null)
      n = 65535;
    else
      for (let l = 0; l < i.length; l++) {
        const c = i[l];
        c > 31 ? console.error(`Rapier only supports 32 layers, layer ${c} is not supported`) : n |= 1 << Math.floor(c);
      }
    const o = t.filter;
    let a = 0;
    if (o == null)
      a = 65535;
    else
      for (let l = 0; l < o.length; l++) {
        const c = o[l];
        c > 31 ? console.error(`Rapier only supports 32 layers, layer ${c} is not supported`) : a |= 1 << Math.floor(c);
      }
    e.setCollisionGroups(n << 16 | a);
  }
  getRigidbody(t, e) {
    if (!this.world)
      throw new Error("Physics world not initialized");
    let i = null;
    if (t.attachedRigidbody) {
      const n = t.attachedRigidbody;
      if (i = n[Gt], !i) {
        const o = n.isKinematic && !Ip;
        Qe && console.log("Create rigidbody", o);
        const a = o ? D.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased() : D.RAPIER_PHYSICS.MODULE.RigidBodyDesc.dynamic(), l = ie(t.attachedRigidbody.gameObject);
        a.setTranslation(l.x, l.y, l.z), a.setRotation(Ce(t.attachedRigidbody.gameObject)), a.centerOfMass = new D.RAPIER_PHYSICS.MODULE.Vector3(n.centerOfMass.x, n.centerOfMass.y, n.centerOfMass.z), i = this.world.createRigidBody(a), this.bodies.push(i), this.objects.push(n);
      }
      i[hi] = n, n[Gt] = i, this.internalUpdateRigidbodyProperties(n, i), this.getRigidbodyRelativeMatrix(t.gameObject, n.gameObject, e), t[Gb] = i;
    } else {
      const n = D.RAPIER_PHYSICS.MODULE.RigidBodyDesc.kinematicPositionBased(), o = ie(t.gameObject);
      n.setTranslation(o.x, o.y, o.z), n.setRotation(Ce(t.gameObject)), i = this.world.createRigidBody(n), e.identity(), i[hi] = null;
    }
    return i;
  }
  internal_getRigidbody(t) {
    return t.isCollider === !0 ? t[Gb] : t[Gt];
  }
  internalUpdateColliderProperties(t, e) {
    const i = e.shape;
    let n = !1;
    switch (i.type) {
      case D.RAPIER_PHYSICS.MODULE.ShapeType.Ball: {
        const p = i, m = t, g = t.gameObject, _ = Ke(g, this._tempPosition), y = Math.abs(m.radius * _.x);
        n = p.radius !== y, p.radius = y, n && e.setShape(p);
        break;
      }
      case D.RAPIER_PHYSICS.MODULE.ShapeType.Cuboid:
        const o = i, a = t, l = t.gameObject, c = Ke(l, this._tempPosition), h = a.size.x * 0.5 * c.x, d = a.size.y * 0.5 * c.y, u = a.size.z * 0.5 * c.z;
        n = o.halfExtents.x !== h || o.halfExtents.y !== d || o.halfExtents.z !== u, o.halfExtents.x = h, o.halfExtents.y = d, o.halfExtents.z = u, n && e.setShape(o);
        break;
    }
    if (n) {
      const o = t.attachedRigidbody;
      if (o != null && o.autoMass) {
        const a = this.getBody(o);
        a == null || a.recomputeMassPropertiesFromColliders();
      }
    }
    this.updateColliderCollisionGroups(t), t.isTrigger !== e.isSensor() && e.setSensor(t.isTrigger);
  }
  internalUpdateRigidbodyProperties(t, e) {
    if (e.enableCcd(t.collisionDetectionMode !== Dg.Discrete), e.setLinearDamping(t.drag), e.setAngularDamping(t.angularDrag), e.setGravityScale(t.useGravity ? t.gravityScale : 0, !0), t.dominanceGroup <= 127 && t.dominanceGroup >= -127 ? e.setDominanceGroup(Math.floor(t.dominanceGroup)) : e.setDominanceGroup(0), t.autoMass) {
      e.setAdditionalMass(0, !1);
      for (let i = 0; i < e.numColliders(); i++)
        e.collider(i).setDensity(1);
      e.recomputeMassPropertiesFromColliders();
    } else {
      e.setAdditionalMass(t.mass, !1);
      for (let i = 0; i < e.numColliders(); i++)
        e.collider(i).setDensity(1e-7);
      e.recomputeMassPropertiesFromColliders();
    }
    e.setEnabledRotations(!t.lockRotationX, !t.lockRotationY, !t.lockRotationZ, !1), e.setEnabledTranslations(!t.lockPositionX, !t.lockPositionY, !t.lockPositionZ, !1), t.isKinematic ? e.setBodyType(D.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased, !1) : e.setBodyType(D.RAPIER_PHYSICS.MODULE.RigidBodyType.Dynamic, !1);
  }
  step(t) {
    if (this.world && this.enabled) {
      if (this._isUpdatingPhysicsWorld = !0, this.eventQueue || (this.eventQueue = new D.RAPIER_PHYSICS.MODULE.EventQueue(!1)), t === void 0 || t <= 0) {
        this._isUpdatingPhysicsWorld = !1;
        return;
      } else
        t !== void 0 && (this.world.timestep = $.lerp(this.world.timestep, t, 0.8));
      try {
        this.world.step(this.eventQueue);
      } catch (e) {
        console.warn("Error running physics step", e);
      }
      this._isUpdatingPhysicsWorld = !1;
    }
  }
  postStep() {
    this.world && this.enabled && (this._isUpdatingPhysicsWorld = !0, this.syncObjects(), this._isUpdatingPhysicsWorld = !1, this.eventQueue && !this.collisionHandler && (this.collisionHandler = new CI(this.world, this.eventQueue)), this.collisionHandler && (this.collisionHandler.handleCollisionEvents(), this.collisionHandler.update()), this.updateDebugRendering(this.world));
  }
  updateDebugRendering(t) {
    var e, i, n, o;
    if (Qe || Ip || SI || this.debugRenderColliders === !0) {
      if (!this.lines) {
        const l = new t0({
          color: 7855479,
          fog: !1
          // vertexColors: VertexColors
        }), c = new Ps();
        this.lines = new e0(c, l), this.lines.layers.disableAll(), this.lines.layers.enable(2);
      }
      this.lines.parent !== ((e = this.context) == null ? void 0 : e.scene) && ((i = this.context) == null || i.scene.add(this.lines));
      const a = t.debugRender();
      this.lines.geometry.setAttribute("position", new mt(a.vertices, 3)), this.lines.geometry.setAttribute("color", new mt(a.colors, 4)), (this.context.time.frame % 30 === 0 || ((n = this.lines.geometry.boundingSphere) == null ? void 0 : n.radius) === 0) && this.lines.geometry.computeBoundingSphere();
    } else
      this.lines && ((o = this.context) == null || o.scene.remove(this.lines));
  }
  /** sync rendered objects with physics world (except for colliders without rigidbody) */
  syncObjects() {
    if (!Ip)
      for (let t = 0; t < this.bodies.length; t++) {
        const e = this.objects[t], i = this.bodies[t], n = e;
        if ((n == null ? void 0 : n.isCollider) === !0 && !n.attachedRigidbody) {
          const c = i.parent();
          c ? this.syncPhysicsBody(e.gameObject, c, !0, !0) : this.syncPhysicsBody(e.gameObject, i, !0, !0);
          continue;
        }
        const o = i.translation(), a = i.rotation();
        if (Number.isNaN(o.x) || Number.isNaN(a.x)) {
          !n.__COLLIDER_NAN && z() && (console.warn("Collider has NaN values", n.name, n.gameObject, i), n.__COLLIDER_NAN = !0);
          continue;
        }
        const l = e.center;
        if (l && l.isVector3) {
          this._tempQuaternion.set(a.x, a.y, a.z, a.w);
          const c = this._tempPosition.copy(l).applyQuaternion(this._tempQuaternion), h = Ke(e.gameObject);
          c.multiply(h), o.x -= c.x, o.y -= c.y, o.z -= c.z;
        }
        Fa(e.gameObject, o.x, o.y, o.z), R0(e.gameObject, a.x, a.y, a.z, a.w);
      }
  }
  syncPhysicsBody(t, e, i, n) {
    if (e instanceof D.RAPIER_PHYSICS.MODULE.RigidBody) {
      const o = ie(t, this._tempPosition), a = Ce(t, this._tempQuaternion);
      switch (e.bodyType()) {
        case D.RAPIER_PHYSICS.MODULE.RigidBodyType.Fixed:
        case D.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicPositionBased:
        case D.RAPIER_PHYSICS.MODULE.RigidBodyType.KinematicVelocityBased:
          i && e.setNextKinematicTranslation(o), n && e.setNextKinematicRotation(a);
          break;
        default:
          i && e.setTranslation(o, !1), n && e.setRotation(a, !1);
          break;
      }
    } else if (e instanceof D.RAPIER_PHYSICS.MODULE.Collider) {
      t.matrixWorldNeedsUpdate && t.updateWorldMatrix(!0, !1), t.matrixWorld.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
      const o = this._tempPosition, a = this._tempQuaternion, l = e[hi];
      if (this.tryApplyCenter(l, o), i) {
        const c = e.translation();
        (c.x !== o.x || c.y !== o.y || c.z !== o.z) && e.setTranslation(o);
      }
      if (n) {
        const c = e.rotation();
        (c.x !== a.x || c.y !== a.y || c.z !== a.z || c.w !== a.w) && e.setRotation(a);
      }
    }
  }
  tryApplyCenter(t, e) {
    const i = t.center;
    i && t.gameObject && (i.x !== 0 || i.y !== 0 || i.z !== 0) && (this._tempCenterPos.x = i.x, this._tempCenterPos.y = i.y, this._tempCenterPos.z = i.z, Ke(t.gameObject, this._tempCenterVec), this._tempCenterPos.multiply(this._tempCenterVec), t.attachedRigidbody ? this._tempCenterPos.applyQuaternion(t.gameObject.quaternion) : (Ce(t.gameObject, this._tempCenterQuaternion), this._tempCenterPos.applyQuaternion(this._tempCenterQuaternion)), e.x += this._tempCenterPos.x, e.y += this._tempCenterPos.y, e.z += this._tempCenterPos.z);
  }
  getRigidbodyRelativeMatrix(t, e, i, n) {
    if (n === void 0 && (n = Tc._matricesBuffer, n.length = 0), t === e) {
      const o = Ke(t, this._tempPosition);
      i.makeScale(o.x, o.y, o.z);
      for (let a = n.length - 1; a >= 0; a--)
        i.multiply(n[a]);
      return i;
    }
    return n.push(t.matrix), t.parent && this.getRigidbodyRelativeMatrix(t.parent, e, i, n), i;
  }
  addFixedJoint(t, e) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const i = t[Gt], n = e[Gt];
    this.calculateJointRelativeMatrices(t.gameObject, e.gameObject, this._tempMatrix), this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const o = D.RAPIER_PHYSICS.MODULE.JointData.fixed(
      Tc.centerConnectionPos,
      Tc.centerConnectionRot,
      this._tempPosition,
      this._tempQuaternion
    ), a = this.world.createImpulseJoint(o, i, n, !0);
    Qe && console.log("ADD FIXED JOINT", a);
  }
  /** The joint prevents any relative movement between two rigid-bodies, except for relative rotations along one axis. This is typically used to simulate wheels, fans, etc. They are characterized by one local anchor as well as one local axis on each rigid-body. */
  addHingeJoint(t, e, i, n) {
    if (!this.world) {
      console.error("Physics world not initialized");
      return;
    }
    const o = t[Gt], a = e[Gt];
    this.calculateJointRelativeMatrices(t.gameObject, e.gameObject, this._tempMatrix), this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale);
    const l = D.RAPIER_PHYSICS.MODULE.JointData.revolute(i, this._tempPosition, n), c = this.world.createImpulseJoint(l, o, a, !0);
    Qe && console.log("ADD HINGE JOINT", c);
  }
  calculateJointRelativeMatrices(t, e, i) {
    t.updateWorldMatrix(!0, !1), e.updateWorldMatrix(!0, !1);
    const n = t.matrixWorld, o = e.matrixWorld;
    n.elements[0] = 1, n.elements[5] = 1, n.elements[10] = 1, o.elements[0] = 1, o.elements[5] = 1, o.elements[10] = 1, i.copy(o).premultiply(n.invert()).invert();
  }
};
let qo = Tc;
r(qo, "_didLoadPhysicsEngine", !1), r(qo, "_matricesBuffer", []), r(qo, "centerConnectionPos", { x: 0, y: 0, z: 0 }), r(qo, "centerConnectionRot", { x: 0, y: 0, z: 0, w: 1 });
class CI {
  constructor(t, e) {
    r(this, "world");
    r(this, "eventQueue");
    r(this, "activeCollisions", []);
    r(this, "activeCollisionsStay", []);
    r(this, "activeTriggers", []);
    this.world = t, this.eventQueue = e;
  }
  handleCollisionEvents() {
    this.eventQueue && this.world && this.eventQueue.drainCollisionEvents((t, e, i) => {
      const n = this.world.getCollider(t), o = this.world.getCollider(e);
      if (!n || !o)
        return;
      const a = n[hi], l = o[hi];
      Dp && console.log("EVT", a.name, l.name, i, n, o), a && l && (i ? (this.onCollisionStarted(a, n, l, o), this.onCollisionStarted(l, o, a, n)) : (this.onCollisionEnded(a, l), this.onCollisionEnded(l, a)));
    });
  }
  update() {
    this.onHandleCollisionStay();
  }
  onCollisionStarted(t, e, i, n) {
    let o = null;
    if (t.isTrigger || i.isTrigger)
      Va(t.gameObject, (a) => {
        a.onTriggerEnter && !a.destroyed && a.onTriggerEnter(i), this.activeTriggers.push({ collider: t, component: a, otherCollider: i });
      });
    else {
      const a = t.gameObject;
      this.world.contactPair(e, n, (l, c) => {
        Va(a, (h) => {
          var u;
          if (h.destroyed)
            return;
          const d = h.onCollisionEnter || h.onCollisionStay || h.onCollisionExit;
          if (d || Dp) {
            if (!o) {
              const p = [], m = l.normal();
              i instanceof jr && i.convex && (m.x = -m.x, m.y = -m.y, m.z = -m.z);
              for (let g = 0; g < l.numSolverContacts(); g++) {
                const _ = l.solverContactPoint(g), y = l.contactImpulse(g);
                if (_) {
                  const b = l.contactDist(g), w = l.solverContactFriction(g), P = l.solverContactTangentVelocity(g), k = new nR(_, b, m, y, w, P);
                  p.push(k), Dp && V.DrawDirection(_, m, 16711680, 3, !0);
                }
              }
              o = new sR(a, i, p);
            }
            if (d) {
              const p = { collider: t, component: h, collision: o };
              this.activeCollisions.push(p), h.onCollisionStay && this.activeCollisionsStay.push(p), (u = h.onCollisionEnter) == null || u.call(h, o);
            }
          }
        });
      });
    }
  }
  onHandleCollisionStay() {
    for (const t of this.activeCollisionsStay) {
      const e = t.component;
      if (!e.destroyed && e.activeAndEnabled && e.onCollisionStay) {
        if (t.collision.collider.destroyed)
          continue;
        const i = t.collision;
        e.onCollisionStay(i);
      }
    }
    for (const t of this.activeTriggers) {
      const e = t.component;
      if (!e.destroyed && e.activeAndEnabled && e.onTriggerStay) {
        const i = t.otherCollider;
        if (i.destroyed)
          continue;
        e.onTriggerStay(i);
      }
    }
  }
  onCollisionEnded(t, e) {
    if (!(t.destroyed || e.destroyed)) {
      for (let i = 0; i < this.activeCollisions.length; i++) {
        const n = this.activeCollisions[i], o = n.collider;
        if (o.destroyed || n.collision.collider.destroyed) {
          this.activeCollisions.splice(i, 1), i--;
          continue;
        }
        if (o === t && n.collision.collider === e) {
          const a = n.component;
          if (this.activeCollisions.splice(i, 1), i--, a.activeAndEnabled && a.onCollisionExit) {
            const l = n.collision;
            a.onCollisionExit(l);
          }
        }
      }
      for (let i = 0; i < this.activeCollisionsStay.length; i++) {
        const n = this.activeCollisionsStay[i], o = n.collider;
        if (o.destroyed || n.collision.collider.destroyed) {
          this.activeCollisionsStay.splice(i, 1), i--;
          continue;
        }
        if (o === t && n.collision.collider === e) {
          const a = n.component;
          if (this.activeCollisionsStay.splice(i, 1), i--, a.activeAndEnabled && a.onCollisionExit) {
            const l = n.collision;
            a.onCollisionExit(l);
          }
        }
      }
      for (let i = 0; i < this.activeTriggers.length; i++) {
        const n = this.activeTriggers[i], o = n.collider;
        if (o.destroyed || n.otherCollider.destroyed) {
          this.activeTriggers.splice(i, 1), i--;
          continue;
        }
        if (o === t && n.otherCollider === e) {
          const a = n.component;
          if (this.activeTriggers.splice(i, 1), i--, a.activeAndEnabled && a.onTriggerExit) {
            const l = n.otherCollider;
            a.onTriggerExit(l);
          }
        }
      }
    }
  }
}
class hL {
  /**
   * Use this method to quickly setup a scene to compare multiple models.  
   * @example
   * ```ts
   * const files = [
   *    "https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb",
   *   "https://threejs.org/examples/models/gltf/Lantern/glTF-Binary/Lantern.glb",
   * ];
   * const { scene, camera } = await TestUtils.createComparisonScene({ files });
   * // this could now be assigned to the Needle Engine Context
   * context.scene = scene;
   * context.mainCamera = camera;
   * ```
   */
  static async createComparisonScene(t) {
    const { files: e } = t, n = await Promise.all(e.map((y) => new re(y).loadAssetAsync())), o = new Mi();
    let a = 0;
    for (const y of n)
      if (y instanceof L) {
        y.position.y = a, o.add(y);
        const b = ki([y]);
        a += b.getSize(new v()).y, a += 0.1;
      }
    const l = new ye(20);
    o.add(l);
    const c = t.environment || "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/studio_small_09_1k.exr";
    if (c) {
      let y = null;
      if (c.endsWith(".hdr")) {
        const b = (await import("./three-examples.js").then((w) => w.RGBELoader$1)).RGBELoader;
        y = new b();
      } else if (c.endsWith(".exr")) {
        const b = (await import("./three-examples.js").then((w) => w.EXRLoader$1)).EXRLoader;
        y = new b();
      }
      if (y) {
        const b = await y.loadAsync(c).catch((w) => (console.error(w), null));
        b && (b.mapping = Ms, b.needsUpdate = !0, o.background = b, o.environment = b, o.backgroundBlurriness = 0.75);
      } else
        console.warn("Unsupported environment map format", c);
    }
    const h = ki(o.children), d = h.getCenter(new v()), u = h.getSize(new v()), m = Math.max(u.x, u.y, u.z) / (2 * Math.tan(Math.PI * l.fov / 360));
    l.position.set(d.x, d.y, m), l.lookAt(d);
    const g = new c0(l, t.domElement || document.body);
    g.target = d, g.update();
    const _ = (t.domElement || document.body).getBoundingClientRect();
    return l.aspect = _.width / _.height, l.updateProjectionMatrix(), {
      scene: o,
      camera: l
    };
  }
}
let tg = 0;
function qb(s) {
  s ? tg++ : tg--;
}
function dL() {
  return tg > 0;
}
const PI = {
  binary: !0,
  animations: !0
};
async function uL(s) {
  if (!s.context)
    throw new Error("No context provided to exportAsGLTF");
  s.scene || (s.scene = s.context.scene);
  const t = {
    ...PI,
    ...s
  }, { context: e } = t, i = new h0();
  i.register((l) => new nw(l)), i.register((l) => new KR(l)), i.register((l) => new Kv(l)), tw(i, t.context);
  const n = {
    binary: t.binary,
    animations: MI(e, t.scene, [])
  }, o = new OI();
  console.debug("Exporting GLTF", n), o.onBeforeExport(t), qb(!0);
  const a = await i.parseAsync(t.scene, n).catch((l) => (console.error(l), null));
  if (qb(!1), o.onAfterExport(t), !a)
    throw new Error("Failed to export GLTF");
  if (t.downloadAs != null) {
    let l = null;
    if (a instanceof ArrayBuffer ? l = new Blob([a], { type: "application/octet-stream" }) : console.error("Can not download GLTF as a blob", a), l) {
      const c = URL.createObjectURL(l), h = document.createElement("a");
      h.href = c;
      let d = t.downloadAs;
      !d.endsWith(".glb") && !d.endsWith(".gltf") && (d += t.binary ? ".glb" : ".gltf"), h.download = d, h.click();
    }
  }
  return a;
}
const Xb = Symbol("needle:weight");
class OI {
  constructor() {
    r(this, "_undo", []);
  }
  onBeforeExport(t) {
    t.context.animations.mixers.forEach((e) => {
      const i = zc.tryGetActionsFromMixer(e);
      if (i)
        for (let n = 0; n < i.length; n++) {
          const o = i[n];
          o[Xb] = o.weight, o.weight = 0, this._undo.push(() => {
            o.weight = o[Xb];
          });
        }
      e.update(0);
    }), t.context.scene.traverse((e) => {
      if (!Am(e)) {
        const i = e.parent;
        i && (e.removeFromParent(), this._undo.push(() => i.add(e)));
      }
    });
  }
  onAfterExport(t) {
    this._undo.forEach((e) => e()), this._undo.length = 0;
  }
}
function MI(s, t, e) {
  s.animations.mixers.forEach((n) => {
    const o = zc.tryGetActionsFromMixer(n);
    if (o)
      for (let a = 0; a < o.length; a++) {
        const c = o[a].getClip();
        e.push(c);
      }
  }), Array.isArray(t) || (t = [t]);
  for (const n of t)
    zc.tryGetAnimationClipsFromObjectHierarchy(n, e);
  const i = new Set(e);
  return Array.from(i);
}
const Qb = "needle-button", jp = z();
var rr, ar, lr, Xt, _s, Ia, yu, Sx, bu, Cx, qc;
class xx extends HTMLElement {
  constructor() {
    super();
    zi(this, yu);
    zi(this, bu);
    zi(this, rr, void 0);
    zi(this, ar, void 0);
    /** These are the default styles that can be overridden by the user from the outside by styling <needle-button> */
    zi(this, lr, void 0);
    /** This is the button that was generated using one of the factories */
    zi(this, Xt, void 0);
    /** If AR or VR is requested we create and use the webxr button factory to create a button with default behaviour */
    zi(this, _s, void 0);
    zi(this, Ia, void 0);
    zi(this, qc, (e) => {
      jp && console.log("Needle Button clicked"), !e.defaultPrevented && ue(this, Xt) && ue(this, Xt).click();
    });
    this.removeEventListener("click", ue(this, qc)), this.addEventListener("click", ue(this, qc));
  }
  attributeChangedCallback(e, i, n) {
    Pl(this, yu, Sx).call(this);
  }
}
rr = new WeakMap(), ar = new WeakMap(), lr = new WeakMap(), Xt = new WeakMap(), _s = new WeakMap(), Ia = new WeakMap(), yu = new WeakSet(), Sx = function() {
  var i, n;
  if ((i = ue(this, Xt)) == null || i.remove(), this.getAttribute("ar") != null)
    ue(this, _s) ?? ln(this, _s, new yo()), ln(this, Xt, ue(this, _s).createARButton());
  else if (this.getAttribute("vr") != null)
    ue(this, _s) ?? ln(this, _s, new yo()), ln(this, Xt, ue(this, _s).createVRButton());
  else if (this.getAttribute("quicklook") != null)
    ue(this, _s) ?? ln(this, _s, new yo()), ln(this, Xt, ue(this, _s).createQuicklookButton());
  else {
    jp ? console.warn("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.") : console.debug("No button type specified for <needle-button>. Use either ar, vr or quicklook attribute.");
    return;
  }
  ue(this, rr) ?? ln(this, rr, this.attachShadow({ mode: "open" })), ue(this, ar) ?? ln(this, ar, document.createElement("slot")), ue(this, lr) ?? ln(this, lr, document.createElement("style")), ue(this, lr).innerHTML = `
            button {
                all: initial;
                cursor: inherit;
                color: inherit;
                font-family: inherit;
                gap: inherit;
                white-space: nowrap;
            }
        `, this.getAttribute("unstyled") != null || (ue(this, lr).innerHTML += `
            :host {
                display: inline-block;
                background: rgba(255, 255, 255, .8);
                backdrop-filter: blur(10px);
                width: fit-content;
                transition: background .2s;

                cursor: pointer;
                padding: 0.4rem .5rem;
                border-radius: 0.8rem;
                color: black;
                background: rgba(245, 245, 245, .8);
                outline: rgba(0,0,0,.05) 1px solid;
            }
            :host(:hover) {
                background: rgba(255, 255, 255, 1);
                transition: background .2s;
            }
            slot {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: .5rem;
            }
`), ue(this, ar).innerHTML = ue(this, Xt).innerHTML, ue(this, ar).style.cssText = "display: flex; align-items: center; justify-content: center;", ue(this, Xt).innerHTML = ue(this, ar).outerHTML, ue(this, rr).innerHTML = ue(this, Xt).outerHTML, ue(this, rr).prepend(ue(this, lr)), qd(Om, { element: ue(this, rr) }), (n = ue(this, Ia)) == null || n.disconnect(), ue(this, Ia) ?? ln(this, Ia, new MutationObserver(() => Pl(this, bu, Cx).call(this))), ue(this, Ia).observe(ue(this, Xt), { attributes: !0 }), jp && console.log("Needle Button updated");
}, bu = new WeakSet(), Cx = function() {
  ue(this, Xt) && (ue(this, Xt).style.display === "none" ? this.style.display = "none" : this.style.display === "none" && (this.style.display = ""));
}, qc = new WeakMap(), r(xx, "observedAttributes", ["ar", "vr", "quicklook"]);
typeof window < "u" && !window.customElements.get(Qb) && window.customElements.define(Qb, xx);
const Nl = x("debugavatar");
class Px {
  /**
   * Creates a new avatar model.
   * @param root The root object of the avatar
   * @param head The head object of the avatar
   * @param leftHand The left hand object of the avatar
   * @param rigthHand The right hand object of the avatar
   */
  constructor(t, e, i, n) {
    /** The root object of the avatar model */
    r(this, "root");
    /** The head object of the avatar model */
    r(this, "head");
    /** The left hand object of the avatar model, if available */
    r(this, "leftHand");
    /** The right hand object of the avatar model, if available */
    r(this, "rigthHand");
    var o;
    this.root = t, this.head = e, this.leftHand = i, this.rigthHand = n, (o = this.root) == null || o.traverse((a) => a.layers.set(2));
  }
  /**
   * Checks if the avatar model has a valid configuration.
   * An avatar is considered valid if it has a head.
   * @returns Whether the avatar has a valid setup
   */
  get isValid() {
    return this.head !== null && this.head !== void 0;
  }
}
class RI {
  constructor() {
    r(this, "avatarRegistryUrl", null);
  }
  // private loader: GLTFLoader | null;
  // private avatarModelCache: Map<string, AvatarModel | null> = new Map<string, AvatarModel | null>();
  /**
   * Retrieves or creates a new avatar instance from an ID or existing Object3D.
   * @param context The application context
   * @param avatarId Either a string ID to load an avatar or an existing Object3D to use as avatar
   * @returns Promise resolving to an AvatarModel if successful, or null if failed
   */
  async getOrCreateNewAvatarInstance(t, e) {
    if (!e)
      return console.error("Can not create avatar: failed to provide id or root object"), null;
    let i = null;
    if (typeof e == "string") {
      if (i = await this.loadAvatar(t, e), !i) {
        const o = new Qn();
        i = S.instantiate(Ic(e, t.scene), o);
      }
    } else
      i = e;
    if (!i)
      return null;
    const n = this.findAvatar(i);
    return n.isValid ? (Nl && console.log("[Custom Avatar] valid config", e, Nl ? n : ""), n) : (console.warn("[Custom Avatar] config isn't valid", e, Nl ? n : ""), null);
  }
  /**
   * Loads an avatar model from a file or registry using the provided ID.
   * @param context The engine context
   * @param avatarId The ID of the avatar to load
   * @returns Promise resolving to the loaded avatar's Object3D, or null if failed
   */
  async loadAvatar(t, e) {
    if (console.assert(e != null && typeof e == "string", "Avatar id must not be null"), e.length <= 0 || !e)
      return null;
    if (Nl && console.log("[Custom Avatar] " + e + ", loading..."), e.endsWith(".glb") || (e += ".glb"), this.avatarRegistryUrl === null) {
      const n = await fetch("./" + e);
      let o = null;
      if (n.ok) {
        const l = await n.blob();
        l && (o = await l.arrayBuffer());
      }
      if (!o)
        return null;
      const a = await Hn().parseSync(t, o, null, 0);
      return (a == null ? void 0 : a.scene) ?? null;
    }
    const i = new xr();
    return Nu(i, t), new Promise((n, o) => {
      const a = this.avatarRegistryUrl + "/" + e;
      i.load(
        a,
        async (l) => {
          await Hn().createBuiltinComponents(t, a, l, null, void 0), n(l.scene);
        },
        (l) => {
          Nl && console.log("[Custom Avatar] " + l.loaded / l.total * 100 + "% loaded of " + l.total / 1024 + "kB");
        },
        (l) => {
          console.error("[Custom Avatar] Error when loading: " + l), n(null);
        }
      );
    });
  }
  /**
   * Caches an avatar model for reuse.
   * @param _id The ID to associate with the model
   * @param _model The avatar model to cache
   */
  cacheModel(t, e) {
  }
  /**
   * Analyzes an Object3D to find avatar parts (head, hands) based on naming conventions.
   * @param obj The Object3D to search for avatar parts
   * @returns A structured AvatarModel with references to found parts
   */
  findAvatar(t) {
    const e = t;
    let i = e;
    i.children.length == 1 && (i = t.children[0]);
    let n = this.findAvatarPart(i, ["head"]);
    const o = this.findAvatarPart(i, ["left", "hand"]), a = this.findAvatarPart(i, ["right", "hand"]);
    if (!n) {
      n = e;
      const c = new v();
      new Pi().setFromObject(n).getSize(c);
      const h = Math.max(c.x, c.y, c.z);
      console.warn("[Custom Avatar] Normalizing head scale, it's too big: " + h + " meters! Should be < 0.3m"), h > 0.3 && n.scale.multiplyScalar(1 / h * 0.3);
    }
    return new Px(e, n, o, a);
  }
  /**
   * Recursively searches for an avatar part by name within an Object3D hierarchy.
   * @param obj The Object3D to search within
   * @param searchString Array of strings that should all be present in the object name
   * @returns The found Object3D part or null if not found
   */
  findAvatarPart(t, e) {
    const i = t.name.toLowerCase();
    let n = !0;
    for (const o of e) {
      if (!n)
        break;
      i.indexOf(o) === -1 && (n = !1);
    }
    if (n)
      return t;
    if (t.children)
      for (const o of t.children) {
        const a = this.findAvatarPart(o, e);
        if (a)
          return a;
      }
    return null;
  }
  /**
   * Handles HTTP response errors from avatar loading operations.
   * @param response The fetch API response to check
   * @returns The response if it was ok
   * @throws Error with status text if response was not ok
   */
  handleCustomAvatarErrors(t) {
    if (!t.ok)
      throw Error(t.statusText);
    return t;
  }
}
class kI {
  get extensionName() {
    return "DocumentExtension";
  }
  onAfterBuildDocument(t) {
  }
}
class TI {
}
const fL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionBuilder: ge,
  ActionCollection: Gk,
  ActionModel: bi,
  AlignmentConstraint: $u,
  Animation: ti,
  AnimationCurve: _h,
  AnimationExtension: Qg,
  AnimationTrackHandler: __,
  Animator: zt,
  AnimatorController: yn,
  Antialiasing: af,
  AudioExtension: nl,
  AudioListener: lo,
  AudioSource: qe,
  AudioTrackHandler: Ta,
  Avatar: Pr,
  AvatarBlink_Simple: Ja,
  AvatarEyeLook_Rotation: Jc,
  AvatarLoader: RI,
  AvatarMarker: _t,
  AvatarModel: Px,
  Avatar_Brain_LookAt: Jd,
  Avatar_MouthShapes: qu,
  Avatar_MustacheShake: Uv,
  Avatar_POI: go,
  AxesHelper: eh,
  BaseUIComponent: xn,
  BasicIKConstraint: Wv,
  BehaviorExtension: Cw,
  BehaviorModel: kt,
  BloomEffect: ml,
  BoxCollider: ih,
  BoxGizmo: hl,
  BoxHelperComponent: wi,
  Button: jo,
  CallInfo: io,
  Camera: Pe,
  CameraTargetReachedEvent: Zd,
  Canvas: Ut,
  CanvasGroup: Or,
  CapsuleCollider: So,
  ChangeMaterialOnClick: rh,
  ChangeTransformOnClick: sl,
  CharacterController: el,
  CharacterControllerInput: Oo,
  ChromaticAberration: lf,
  Collider: Ai,
  ColorAdjustments: zr,
  ColorBySpeedModule: yh,
  ColorOverLifetimeModule: l_,
  ContactShadows: Yn,
  ControlTrackHandler: y_,
  CustomBranding: cl,
  Deletable: qv,
  DeleteBox: Ra,
  DepthOfField: es,
  DeviceFlag: $g,
  DocumentExtension: kI,
  DragControls: Si,
  DropListener: Mo,
  Duplicatable: nh,
  EffectWrapper: nu,
  EmissionModule: Eo,
  EmphasizeOnClick: ah,
  EventList: xe,
  EventListEvent: Lg,
  EventSystem: di,
  EventTrigger: Gg,
  FieldWithDefault: vk,
  FixedJoint: Bw,
  Fog: uh,
  GltfExport: Ku,
  GltfExportBox: lw,
  Gradient: ul,
  Graphic: al,
  GraphicRaycaster: jg,
  GridHelper: fh,
  GridLayoutGroup: Iw,
  GroundProjectedEnv: Ls,
  GroupActionModel: nr,
  HideOnStart: or,
  HingeJoint: sf,
  HorizontalLayoutGroup: Ew,
  Image: Ph,
  InheritVelocityModule: pl,
  InputField: bl,
  InstanceHandle: yc,
  InstancingHandler: ir,
  Interactable: Gv,
  Keyframe: Ci,
  LODGroup: of,
  LODModel: mh,
  Light: Di,
  LimitVelocityOverLifetimeModule: xt,
  LogStats: Hv,
  LookAt: vl,
  LookAtConstraint: Za,
  MainModule: oi,
  MaskableGraphic: nf,
  MeshCollider: jr,
  MeshRenderer: Yu,
  MinMaxCurve: Q,
  MinMaxGradient: Li,
  NeedleMenu: Fs,
  NestedGltf: r_,
  Networking: gh,
  NoiseModule: Oe,
  ObjectRaycaster: sn,
  OffsetConstraint: dl,
  OpenURL: Oh,
  OrbitControls: be,
  Outline: dh,
  Padding: ll,
  ParticleBurst: Wm,
  ParticleSubEmitter: zw,
  ParticleSystem: ut,
  ParticleSystemRenderer: Pn,
  PhysicsExtension: Pw,
  PixelationEffect: hf,
  PlayAnimationOnClick: Xa,
  PlayAudioOnClick: Cr,
  PlayableDirector: Rr,
  PlayerColor: Wc,
  PointerEventData: Hu,
  PostProcessingHandler: qw,
  PreliminaryAction: lh,
  PreliminaryTrigger: Zu,
  RawImage: v_,
  Rect: P2,
  RectTransform: ii,
  ReflectionProbe: sh,
  RegisteredAnimationInfo: sr,
  RemoteSkybox: Is,
  Renderer: Je,
  RendererLightmap: Dm,
  Rigidbody: _e,
  RotationBySpeedModule: Cn,
  RotationOverLifetimeModule: Jn,
  SceneSwitcher: rt,
  ScreenCapture: $r,
  ScreenSpaceAmbientOcclusion: Io,
  ScreenSpaceAmbientOcclusionN8: ts,
  SetActiveOnClick: ol,
  ShadowCatcher: uf,
  ShapeModule: tt,
  SharpeningEffect: df,
  SignalAsset: g_,
  SignalReceiver: Ch,
  SignalReceiverEvent: gf,
  SignalTrackHandler: ru,
  Size: C2,
  SizeBySpeedModule: ji,
  SizeOverLifetimeModule: fl,
  SkinnedMeshRenderer: rw,
  SmoothFollow: Wr,
  SpatialGrabRaycaster: gr,
  SpatialHtml: wf,
  SpatialTrigger: pf,
  SpatialTriggerReceiver: Rs,
  SpectatorCamera: p_,
  SphereCollider: th,
  Sprite: Ro,
  SpriteData: br,
  SpriteRenderer: Ei,
  SpriteSheet: Nc,
  SubEmitterSystem: Gm,
  SyncedCamera: m_,
  SyncedRoom: is,
  SyncedTransform: As,
  TapGestureTrigger: vw,
  TeleportTarget: Zg,
  TestRunner: ix,
  TestSimulateUserData: nx,
  Text: si,
  TextBuilder: Tw,
  TextExtension: Jg,
  TextureSheetAnimationModule: ri,
  TiltShiftEffect: Us,
  ToneMappingEffect: Mr,
  TrailModule: Xe,
  TransformData: $e,
  TransformGizmo: yl,
  TriggerBuilder: Ft,
  TriggerModel: _o,
  UIRaycastUtils: Bv,
  UIRootComponent: Vu,
  USDZExporter: Ge,
  USDZText: pa,
  USDZUIExtension: jw,
  UsageMarker: Qu,
  VariantAction: bw,
  VelocityOverLifetimeModule: it,
  VerticalLayoutGroup: Aw,
  VideoPlayer: bt,
  Vignette: _l,
  VisibilityAction: Ju,
  Voip: Lr,
  Volume: vh,
  VolumeParameter: N,
  VolumeProfile: h_,
  WebARCameraBackground: Sf,
  WebARSessionRoot: gn,
  WebXR: et,
  WebXRImageTracking: Qa,
  WebXRImageTrackingModel: zo,
  WebXRPlaneTracking: Uo,
  WebXRTrackedImage: ga,
  XRControllerFollow: Bo,
  XRControllerModel: Es,
  XRControllerMovement: on,
  XRFlag: Xi,
  XRRig: x_,
  XRState: ei,
  __Ignore: TI
}, Symbol.toStringTag, { value: "Module" }));
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const AI = {
  topLight: {
    intensity: 500,
    position: [0.418, 16.199, 0.3]
  },
  room: {
    position: [-0.757, 13.219, 0.717],
    scale: [31.713, 28.305, 28.591]
  },
  boxes: [
    {
      position: [-10.906, 2.009, 1.846],
      rotation: -0.195,
      scale: [2.328, 7.905, 4.651]
    },
    {
      position: [-5.607, -0.754, -0.758],
      rotation: 0.994,
      scale: [1.97, 1.534, 3.955]
    },
    {
      position: [6.167, 0.857, 7.803],
      rotation: 0.561,
      scale: [3.927, 6.285, 3.687]
    },
    {
      position: [-2.017, 0.018, 6.124],
      rotation: 0.333,
      scale: [2.002, 4.566, 2.064]
    },
    {
      position: [2.291, -0.756, -2.621],
      rotation: -0.286,
      scale: [1.546, 1.552, 1.496]
    },
    {
      position: [-2.193, -0.369, -5.547],
      rotation: 0.516,
      scale: [3.875, 3.487, 2.986]
    }
  ],
  lights: [
    {
      intensity: 50,
      position: [-16.116, 14.37, 8.208],
      scale: [0.1, 2.428, 2.739]
    },
    {
      intensity: 50,
      position: [-16.109, 18.021, -8.207],
      scale: [0.1, 2.425, 2.751]
    },
    {
      intensity: 17,
      position: [14.904, 12.198, -1.832],
      scale: [0.15, 4.265, 6.331]
    },
    {
      intensity: 43,
      position: [-0.462, 8.89, 14.52],
      scale: [4.38, 5.441, 0.088]
    },
    {
      intensity: 20,
      position: [3.235, 11.486, -12.541],
      scale: [2.5, 2, 0.1]
    },
    {
      intensity: 100,
      position: [0, 20, 0],
      scale: [1, 0.1, 1]
    }
  ]
}, EI = {
  topLight: {
    intensity: 400,
    position: [0.5, 14, 0.5]
  },
  room: {
    position: [0, 13.2, 0],
    scale: [31.5, 28.5, 31.5]
  },
  boxes: [
    {
      position: [-10.906, -1, 1.846],
      rotation: -0.195,
      scale: [2.328, 7.905, 4.651]
    },
    {
      position: [-5.607, -0.754, -0.758],
      rotation: 0.994,
      scale: [1.97, 1.534, 3.955]
    },
    {
      position: [6.167, -0.16, 7.803],
      rotation: 0.561,
      scale: [3.927, 6.285, 3.687]
    },
    {
      position: [-2.017, 0.018, 6.124],
      rotation: 0.333,
      scale: [2.002, 4.566, 2.064]
    },
    {
      position: [2.291, -0.756, -2.621],
      rotation: -0.286,
      scale: [1.546, 1.552, 1.496]
    },
    {
      position: [-2.193, -0.369, -5.547],
      rotation: 0.516,
      scale: [3.875, 3.487, 2.986]
    }
  ],
  lights: [
    {
      intensity: 80,
      position: [-14, 10, 8],
      scale: [0.1, 2.5, 2.5]
    },
    {
      intensity: 80,
      position: [-14, 14, -4],
      scale: [0.1, 2.5, 2.5]
    },
    {
      intensity: 23,
      position: [14, 12, 0],
      scale: [0.1, 5, 5]
    },
    {
      intensity: 16,
      position: [0, 9, 14],
      scale: [5, 5, 0.1]
    },
    {
      intensity: 80,
      position: [7, 8, -14],
      scale: [2.5, 2.5, 0.1]
    },
    {
      intensity: 80,
      position: [-7, 16, -14],
      scale: [2.5, 2.5, 0.1]
    },
    {
      intensity: 1,
      position: [0, 20, 0],
      scale: [0.1, 0.1, 0.1]
    }
  ]
};
class II extends Mi {
  constructor(t) {
    super(), this.position.y = -3.5;
    const e = new Da();
    e.deleteAttribute("uv");
    const i = new It({ metalness: 0, side: Cu }), n = new It({ metalness: 0 }), o = t == "legacy" ? AI : EI, a = new ng(16777215, o.topLight.intensity, 28, 2);
    a.position.set(...o.topLight.position), this.add(a);
    const l = new q(e, i);
    l.position.set(...o.room.position), l.scale.set(...o.room.scale), this.add(l);
    for (const c of o.boxes) {
      const h = new q(e, n);
      h.position.set(...c.position), h.rotation.set(0, c.rotation, 0), h.scale.set(...c.scale), this.add(h);
    }
    for (const c of o.lights) {
      const h = new q(e, this.createAreaLightMaterial(c.intensity));
      h.position.set(...c.position), h.scale.set(...c.scale), this.add(h);
    }
  }
  createAreaLightMaterial(t) {
    const e = new Me();
    return e.color.setScalar(t), e;
  }
}
const cu = x("debugmissingcamera");
fe.registerCallback(pe.MissingCamera, (s) => {
  var l, c, h, d;
  cu && console.warn("Creating missing camera");
  const t = s.context.scene, e = new ye();
  e.name = "Default Fallback Camera", t.add(e);
  const i = new Pe();
  if (i.sourceId = ((c = (l = s.files) == null ? void 0 : l[0]) == null ? void 0 : c.src) ?? "unknown", i.fieldOfView = 35, s.context.domElement.getAttribute("transparent") != null)
    i.clearFlags = _r.Uninitialized;
  else if ((h = s.context.domElement.getAttribute("skybox-image")) != null && h.length || (d = s.context.domElement.getAttribute("background-image")) != null && d.length || s.context.lightmaps.tryGetSkybox(i.sourceId))
    i.clearFlags = _r.Skybox, i.backgroundBlurriness = 0.2;
  else {
    i.clearFlags = _r.SolidColor;
    let u = "#efefef";
    if (typeof window !== void 0 && window.matchMedia("(prefers-color-scheme: dark)").matches && (u = "#1f1f1f"), t.background = new ae(u), !t.environment) {
      const p = new V1(s.context.renderer), m = new II("neutral");
      t.environment = p.fromScene(m, 0.025).texture;
    }
  }
  const o = Oa(e, i, !0);
  e.position.x = 0, e.position.y = 1, e.position.z = 2;
  const a = s.context.domElement;
  return (a == null ? void 0 : a.cameraControls) != !1 && Ox(s.context, o), o;
});
fe.registerCallback(pe.ContextCreated, (s) => {
  if (!s.context.mainCamera) {
    cu && console.log("Will not auto-fit because a default camera exists");
    return;
  }
  const t = s.context.domElement;
  if ((t == null ? void 0 : t.cameraControls) == !0) {
    const e = ZS(s.context.mainCamera);
    if ((e == null ? void 0 : e.isCameraController) == !0) {
      cu && console.log("Will not auto-fit because a camera controller exists");
      return;
    }
    Ox(s.context);
  }
});
function Ox(s, t) {
  t = t ?? s.mainCameraComponent;
  const e = t == null ? void 0 : t.gameObject;
  if (cu && console.log("Creating default camera controls", t == null ? void 0 : t.name), e) {
    const i = Bu(e, be);
    i.sourceId = (t == null ? void 0 : t.sourceId) ?? "unknown";
    const n = s.domElement.getAttribute("auto-rotate");
    if (i.autoRotate = n != null && n != "0" && (n == null ? void 0 : n.toLowerCase()) != "false", i.autoRotateSpeed = 0.5, i.autoFit = !0, i.autoRotate && n) {
      const o = parseFloat(n);
      isNaN(o) || (i.autoRotateSpeed = o);
    }
  } else
    console.warn("Missing camera object, can not add orbit controls");
}
fe.registerCallback(pe.ContextCreated, (s) => {
  const t = s.context.domElement.getAttribute("autoplay");
  if (t !== void 0 && (t === "" || t === "true" || t === "1") && s.files)
    for (const e of s.files)
      S.foreachComponent(e.file.scene, (n) => {
        if (n.enabled !== !1) {
          if (n instanceof ti && n.playAutomatically || n instanceof zt || n instanceof Rr && n.playOnAwake === !0)
            return !0;
          if (n instanceof ti)
            return n.playAutomatically = !0, !0;
          if (n instanceof Rr)
            return n.playOnAwake = !0, !0;
        }
      }, !0) !== !0 && zc.assignAnimationsFromFile(e.file, {
        createAnimationComponent: (n, o) => en(n, ti)
      });
});
class DI extends CS {
  constructor() {
    super(new PS()), this.name = "GenerateMeshBVHWorker";
  }
  runTask(t, e, i = {}) {
    return new Promise((n, o) => {
      if (e.getAttribute("position").isInterleavedBufferAttribute || e.index && e.index.isInterleavedBufferAttribute)
        throw new Error("GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.");
      t.onerror = (h) => {
        o(new Error(`GenerateMeshBVHWorker: ${h.message}`));
      }, t.onmessage = (h) => {
        const { data: d } = h;
        if (d.error)
          o(new Error(d.error)), t.onmessage = null;
        else if (d.serialized) {
          const { serialized: u, position: p } = d, m = OS.deserialize(u, e, { setIndex: !1 }), g = Object.assign({
            setBoundingBox: !0
          }, i);
          if (e.attributes.position.array = p, u.index)
            if (e.index)
              e.index.array = u.index;
            else {
              const _ = new mt(u.index, 1, !1);
              e.setIndex(_);
            }
          g.setBoundingBox && (e.boundingBox = m.getBoundingBox(new Pi())), i.onProgress && i.onProgress(d.progress), n(m), t.onmessage = null;
        } else
          i.onProgress && i.onProgress(d.progress);
      };
      const a = e.index ? e.index.array : null, l = e.attributes.position.array, c = [l];
      a && c.push(a), t.postMessage({
        index: a,
        position: l,
        options: {
          ...i,
          onProgress: null,
          includedProgressCallback: !!i.onProgress,
          groups: [...e.groups]
        }
      }, c.map((h) => h.buffer).filter((h) => typeof SharedArrayBuffer > "u" || !(h instanceof SharedArrayBuffer)));
    });
  }
}
const LI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GenerateMeshBVHWorker: DI
}, Symbol.toStringTag, { value: "Module" }));
export {
  QD as $physicsKey,
  ge as ActionBuilder,
  Gk as ActionCollection,
  bi as ActionModel,
  _O as Addressables,
  $u as AlignmentConstraint,
  pc as AmbientMode,
  ti as Animation,
  _h as AnimationCurve,
  Qg as AnimationExtension,
  __ as AnimationTrackHandler,
  zc as AnimationUtils,
  zt as Animator,
  Go as AnimatorConditionMode,
  yn as AnimatorController,
  Dv as AnimatorControllerParameterType,
  Fh as AnimatorStateInfo,
  af as Antialiasing,
  Wn as Application,
  Sm as ApplicationEvents,
  vP as AssetDatabase,
  re as AssetReference,
  nl as AudioExtension,
  lo as AudioListener,
  qe as AudioSource,
  Ta as AudioTrackHandler,
  Pr as Avatar,
  Ja as AvatarBlink_Simple,
  Jc as AvatarEyeLook_Rotation,
  RI as AvatarLoader,
  _t as AvatarMarker,
  Px as AvatarModel,
  Jd as Avatar_Brain_LookAt,
  qu as Avatar_MouthShapes,
  Uv as Avatar_MustacheShake,
  go as Avatar_POI,
  Ql as Axes,
  eh as AxesHelper,
  U0 as BUILD_TIME,
  xn as BaseUIComponent,
  Wv as BasicIKConstraint,
  Cw as BehaviorExtension,
  kt as BehaviorModel,
  Ga as BlobStorage,
  ml as BloomEffect,
  ih as BoxCollider,
  hl as BoxGizmo,
  wi as BoxHelperComponent,
  jo as Button,
  zn as ButtonsFactory,
  lR as CallDirection,
  io as CallInfo,
  Pe as Camera,
  Zd as CameraTargetReachedEvent,
  Ut as Canvas,
  Or as CanvasGroup,
  So as CapsuleCollider,
  rh as ChangeMaterialOnClick,
  sl as ChangeTransformOnClick,
  el as CharacterController,
  Oo as CharacterControllerInput,
  lf as ChromaticAberration,
  tn as CircularBuffer,
  _r as ClearFlags,
  us as ClipExtrapolation,
  Ai as Collider,
  sR as Collision,
  Dg as CollisionDetectionMode,
  zr as ColorAdjustments,
  yh as ColorBySpeedModule,
  l_ as ColorOverLifetimeModule,
  BD as Component,
  I as Component$1,
  Lu as ComponentLifecycleEvents,
  fL as Components,
  iP as ConnectionEvents,
  nR as ContactPoint,
  Yn as ContactShadows,
  ee as Context,
  LD as ContextArgs,
  pe as ContextEvent,
  fe as ContextRegistry,
  y_ as ControlTrackHandler,
  cl as CustomBranding,
  Wi as CustomShader,
  Cm as DefaultReflectionMode,
  qv as Deletable,
  Ra as DeleteBox,
  es as DepthOfField,
  $g as DeviceFlag,
  X as DeviceUtilities,
  kI as DocumentExtension,
  Si as DragControls,
  Xv as DragMode,
  Mo as DropListener,
  nh as Duplicatable,
  nu as EffectWrapper,
  Eo as EmissionModule,
  ah as EmphasizeOnClick,
  xd as EngineLoadingView,
  xe as EventList,
  Lg as EventListEvent,
  di as EventSystem,
  Gg as EventTrigger,
  vk as FieldWithDefault,
  fc as FileReference,
  wO as FileReferenceSerializer,
  YD as FileSpawnModel,
  NR as File_Event,
  Bw as FixedJoint,
  uh as Fog,
  Re as FrameEvent,
  gg as GENERATOR,
  S as GameObject,
  V as Gizmos,
  Ku as GltfExport,
  lw as GltfExportBox,
  Aa as GltfLoadEvent,
  fI as GltfLoadEventType,
  ul as Gradient,
  al as Graphic,
  jg as GraphicRaycaster,
  pn as Graphics,
  fh as GridHelper,
  Iw as GridLayoutGroup,
  Ls as GroundProjectedEnv,
  nr as GroupActionModel,
  Fg as HideFlags,
  or as HideOnStart,
  sf as HingeJoint,
  Ew as HorizontalLayoutGroup,
  TD as HostData,
  Ph as Image,
  uc as ImageReference,
  vO as ImageReferenceSerializer,
  pl as InheritVelocityModule,
  WC as Input,
  vi as InputEventQueue,
  Ne as InputEvents,
  bl as InputField,
  yc as InstanceHandle,
  ir as InstancingHandler,
  _n as InstancingUtil,
  AP as InstantiateEvent,
  Bt as InstantiateIdProvider,
  Qn as InstantiateOptions,
  Gv as Interactable,
  au as InternalScreenshotUtils,
  CD as JoinedRoomResponse,
  wD as KeyEventArgs,
  Ci as Keyframe,
  of as LODGroup,
  mh as LODModel,
  PD as LeftRoomResponse,
  Di as Light,
  BO as LightData,
  xt as LimitVelocityOverLifetimeModule,
  jD as LoadingElementOptions,
  Hv as LogStats,
  Zi as LogType,
  vl as LookAt,
  Za as LookAtConstraint,
  D as MODULES,
  oi as MainModule,
  ox as MarkerType,
  nf as MaskableGraphic,
  $ as Mathf,
  jr as MeshCollider,
  Yu as MeshRenderer,
  Q as MinMaxCurve,
  Li as MinMaxGradient,
  kh as NEKeyboardEvent,
  Ys as NEPointerEvent,
  xx as NeedleButtonElement,
  wx as NeedleEngineHTMLElement,
  dx as NeedleLoader,
  Fs as NeedleMenu,
  Df as NeedlePatchesKey,
  V0 as NeedleXRController,
  J as NeedleXRSession,
  oP as NeedleXRSync,
  pP as NeedleXRUtils,
  r_ as NestedGltf,
  sP as NetworkConnection,
  xs as NetworkedStreamEvents,
  Gu as NetworkedStreams,
  gh as Networking,
  DP as NewInstanceModel,
  Oe as NoiseModule,
  sn as ObjectRaycaster,
  Ar as ObjectUtils,
  dl as OffsetConstraint,
  Tf as OneEuroFilter,
  O0 as OneEuroFilterXYZ,
  Oh as OpenURL,
  be as OrbitControls,
  dh as Outline,
  nP as OwnershipEvent,
  X0 as OwnershipModel,
  ud as PUBLIC_KEY,
  ll as Padding,
  Wm as ParticleBurst,
  zw as ParticleSubEmitter,
  ut as ParticleSystem,
  Fr as ParticleSystemBaseBehaviour,
  Pn as ParticleSystemRenderer,
  Nm as ParticleSystemShapeType,
  Ma as PeerHandle,
  JC as PeerNetworking,
  cc as Physics,
  Pw as PhysicsExtension,
  Ot as PhysicsMaterialCombine,
  hf as PixelationEffect,
  Xa as PlayAnimationOnClick,
  Cr as PlayAudioOnClick,
  Rr as PlayableDirector,
  Wc as PlayerColor,
  Ji as PlayerState,
  c2 as PlayerStateEvent,
  ch as PlayerSync,
  RO as PlayerView,
  kO as PlayerViewManager,
  Hu as PointerEventData,
  vg as PointerType,
  dt as PostProcessingEffect,
  qw as PostProcessingHandler,
  lh as PreliminaryAction,
  Zu as PreliminaryTrigger,
  Ko as PreviewHelper,
  Na as PrimitiveType,
  he as Progress,
  v0 as PromiseAllWithErrors,
  Q_ as PromiseErrorResult,
  we as RGBAColor,
  qo as RapierPhysics,
  v_ as RawImage,
  Ts as RaycastOptions,
  P2 as Rect,
  ii as RectTransform,
  sh as ReflectionProbe,
  sr as RegisteredAnimationInfo,
  Is as RemoteSkybox,
  pr as RenderTexture,
  FM as RenderTextureSerializer,
  Je as Renderer,
  jO as RendererData,
  Dm as RendererLightmap,
  _e as Rigidbody,
  nt as RigidbodyConstraints,
  ne as RoomEvents,
  Cn as RotationBySpeedModule,
  Jn as RotationOverLifetimeModule,
  Em as SceneLightSettings,
  rt as SceneSwitcher,
  $r as ScreenCapture,
  Io as ScreenSpaceAmbientOcclusion,
  ts as ScreenSpaceAmbientOcclusionN8,
  In as SendQueue,
  uv as SerializationContext,
  ol as SetActiveOnClick,
  uf as ShadowCatcher,
  tt as ShapeModule,
  df as SharpeningEffect,
  g_ as SignalAsset,
  Ch as SignalReceiver,
  gf as SignalReceiverEvent,
  ru as SignalTrackHandler,
  C2 as Size,
  ji as SizeBySpeedModule,
  fl as SizeOverLifetimeModule,
  rw as SkinnedMeshRenderer,
  Wr as SmoothFollow,
  gr as SpatialGrabRaycaster,
  wf as SpatialHtml,
  pf as SpatialTrigger,
  Rs as SpatialTriggerReceiver,
  p_ as SpectatorCamera,
  th as SphereCollider,
  Y0 as SphereIntersection,
  oR as SphereOverlapResult,
  Ro as Sprite,
  br as SpriteData,
  Ei as SpriteRenderer,
  Nc as SpriteSheet,
  zD as StateMachineBehaviour,
  Fv as StreamEndedEvent,
  rR as StreamReceivedEvent,
  Gm as SubEmitterSystem,
  m_ as SyncedCamera,
  is as SyncedRoom,
  As as SyncedTransform,
  vw as TapGestureTrigger,
  Zg as TeleportTarget,
  ix as TestRunner,
  hL as TestSceneUtils,
  nx as TestSimulateUserData,
  si as Text,
  Tw as TextBuilder,
  Jg as TextExtension,
  ri as TextureSheetAnimationModule,
  Us as TiltShiftEffect,
  FO as Time,
  Mr as ToneMappingEffect,
  _f as TrackHandler,
  Vi as TrackType,
  Xe as TrailModule,
  $e as TransformData,
  yl as TransformGizmo,
  Ft as TriggerBuilder,
  _o as TriggerModel,
  R as TypeStore,
  Bv as UIRaycastUtils,
  Vu as UIRootComponent,
  uw as USDDocument,
  Lt as USDObject,
  Tk as USDWriter,
  Ge as USDZExporter,
  Ek as USDZExporter$1,
  pa as USDZText,
  jw as USDZUIExtension,
  zM as UriSerializer,
  Qu as UsageMarker,
  OD as UserJoinedOrLeftRoomModel,
  $n as VERSION,
  bw as VariantAction,
  it as VelocityOverLifetimeModule,
  Aw as VerticalLayoutGroup,
  bt as VideoPlayer,
  dr as ViewDevice,
  _l as Vignette,
  Ju as VisibilityAction,
  Lr as Voip,
  vh as Volume,
  N as VolumeParameter,
  h_ as VolumeProfile,
  ED as WaitForFrames,
  SO as WaitForPromise,
  Sv as WaitForSeconds,
  fo as Watch,
  Sf as WebARCameraBackground,
  gn as WebARSessionRoot,
  et as WebXR,
  yo as WebXRButtonFactory,
  Qa as WebXRImageTracking,
  zo as WebXRImageTrackingModel,
  Uo as WebXRPlaneTracking,
  ga as WebXRTrackedImage,
  Bo as XRControllerFollow,
  Es as XRControllerModel,
  on as XRControllerMovement,
  Xi as XRFlag,
  x_ as XRRig,
  ei as XRState,
  ws as XRStateFlag,
  TI as __Ignore,
  xP as __internalNotifyObjectDestroyed,
  po as activeInHierarchyFieldName,
  BS as addAttributeChangeCallback,
  en as addComponent,
  KD as addCustomExtensionPlugin,
  sL as addGltfLoadEventListener,
  Oa as addNewComponent,
  _g as addPatch,
  Rg as apply,
  cL as applyHMRChanges,
  sO as applyPrototypeExtensions,
  IP as beginListenDestroy,
  jP as beginListenInstantiate,
  G0 as binaryIdentifierCasts,
  DD as build_scene_functions,
  sa as builtinComponentKeyName,
  kv as calculateProgress01,
  hD as clearMessages,
  GD as colorSerializer,
  VP as compareAssociation,
  Kf as componentSerializer,
  dC as copyTexture,
  mx as createLoader,
  dM as createMotion,
  gi as debugNet,
  Eh as debugOwner,
  Dk as decompressGpuTexture,
  Ru as deepClone,
  Gn as delay,
  ku as delayForFrames,
  ym as deserializeObject,
  nn as destroy,
  hO as destroyComponentInstance,
  Ae as disposeObjectResources,
  Ss as disposeStream,
  fd as editorGuidKeyName,
  xa as enableSpatialConsole,
  qD as euler,
  XD as eventListSerializer,
  uL as exportAsGLTF,
  bv as findByGuid,
  Uu as findObjectOfType,
  dO as findObjectsOfType,
  tv as findResourceUsers,
  mC as fitObjectIntoVolume,
  Va as foreachComponent,
  Tg as foreachComponentEnumerator,
  pD as forward,
  US as generateQRCode,
  LP as generateSeed,
  ki as getBoundingBox,
  ZS as getCameraController,
  Ya as getComponent,
  zu as getComponentInChildren,
  Vd as getComponentInParent,
  Fu as getComponents,
  Qc as getComponentsInChildren,
  Mg as getComponentsInParent,
  Pk as getFormattedDate,
  Dt as getIconElement,
  Wy as getIconTexture,
  aD as getIp,
  lD as getIpAndLocation,
  rD as getIpCloudflare,
  Hn as getLoader,
  Bu as getOrAddComponent,
  x as getParam,
  mD as getParentHierarchyPath,
  XI as getPath,
  xD as getPeerOptions,
  ZC as getPeerjsInstance,
  kD as getResourceUserCount,
  iC as getTempColor,
  En as getTempQuaternion,
  G as getTempVector,
  Mu as getUrlParams,
  pC as getVisibleInCustomShadowRendering,
  lC as getWorldDirection,
  k0 as getWorldEuler,
  ie as getWorldPosition,
  Ce as getWorldQuaternion,
  Au as getWorldRotation,
  Ke as getWorldScale,
  Vn as hasCommercialLicense,
  Rv as hasIndieLicense,
  km as hasPointerEventComponent,
  fr as hasProLicense,
  xC as hideDebugConsole,
  Bk as imageToCanvas,
  Ha as instantiate,
  iw as invokeAfterImportPluginHooks,
  $C as invokeXRSessionEnd,
  NC as invokeXRSessionStart,
  uO as isActiveInHierarchy,
  Yc as isActiveSelf,
  JI as isAndroidDevice,
  hC as isAnimationAction,
  iR as isComponent,
  VI as isDebugMode,
  QI as isDesktop,
  Wa as isDestroyed,
  z as isDevEnvironment,
  RD as isDisposed,
  dL as isExporting,
  kS as isHostedOnGlitch,
  rL as isHotReloading,
  KI as isIPad,
  NO as isIconElement,
  ui as isLocalNetwork,
  tD as isMacOS,
  YI as isMobileDevice,
  eD as isMozillaXR,
  sD as isQuest,
  wP as isResourceTrackingEnabled,
  nD as isSafari,
  kg as isUsingInstancing,
  iD as isiOS,
  ZI as isiPad,
  mI as loadSync,
  rm as logHierarchy,
  uD as lookAtInverse,
  Tu as lookAtObject,
  fD as lookAtScreenPoint,
  GI as makeId,
  ES as makeIdFromRandomWords,
  qn as makeNameSafe,
  fO as markAsInstancedRendered,
  oD as microphonePermissionsGranted,
  WI as nameof,
  TS as nameofFactory,
  DM as objectSerializer,
  vD as offXRSessionEnd,
  bD as offXRSessionStart,
  WD as onAfterRender,
  $D as onBeforeRender,
  UD as onClear,
  ND as onDestroy,
  xM as onInitialized,
  SM as onStart,
  CM as onUpdate,
  W0 as onXRSessionEnd,
  bg as onXRSessionStart,
  pI as parseSync,
  gC as placeOnSurface,
  I0 as postprocessFBXMaterials,
  HD as prefix,
  AS as pushState,
  qI as randomNumber,
  q0 as registerBinaryType,
  Eg as registerComponent,
  qg as registerComponentExtension,
  On as registerCustomEffectType,
  tw as registerExportExtensions,
  Im as registerExtensions,
  aL as registerHotReloadType,
  _0 as registerLoader,
  FP as registerPrefabProvider,
  oO as registerPrototypeExtensions,
  AD as registerType,
  DS as relativePathPrefix,
  FS as removeAttributeChangeCallback,
  gv as removeComponent,
  ZD as removeCustomImportExtensionType,
  oL as removeGltfLoadEventListener,
  yD as removePatch,
  Tr as resolveUrl,
  IS as sanitizeString,
  HE as saveImage,
  nL as screenshot,
  hx as screenshot2,
  av as sendDestroyed,
  f as serializable,
  YP as serializeObject,
  Ka as serializeable,
  bd as setActive,
  WS as setAllowBalloonMessages,
  cD as setAllowOverlayMessages,
  om as setAutoFitEnabled,
  Z_ as setCameraController,
  pO as setDestroyed,
  _D as setDevEnvironment,
  J0 as setDisposable,
  Rl as setDontDestroy,
  G_ as setOrAddParamsToUrl,
  HI as setParam,
  jd as setParamWithoutReload,
  SD as setPeerOptions,
  MD as setResourceTrackingEnabled,
  y0 as setState,
  E0 as setVisibleInCustomShadowRendering,
  T0 as setWorldEuler,
  yt as setWorldPosition,
  Fa as setWorldPositionXYZ,
  wn as setWorldQuaternion,
  R0 as setWorldQuaternionXYZW,
  A0 as setWorldRotation,
  Eu as setWorldRotationXYZ,
  Lc as setWorldScale,
  Iu as showBalloonError,
  We as showBalloonMessage,
  ve as showBalloonWarning,
  j0 as showDebugConsole,
  dD as slerp,
  ju as syncDestroy,
  xw as syncField,
  lv as syncInstantiate,
  gD as textureToCanvas,
  YC as tryCastBinary,
  dI as tryDetermineFileTypeFromBinary,
  hI as tryDetermineFileTypeFromURL,
  Ic as tryFindObject,
  KC as tryGetGuid,
  lL as unregisterHotReloadType,
  b0 as unwatchWrite,
  JS as useForAutoFit,
  Nt as validate,
  fg as watchWrite
};
