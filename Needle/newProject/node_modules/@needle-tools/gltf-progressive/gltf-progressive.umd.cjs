"use strict";var Xe=Object.defineProperty;var Ke=(n,e,t)=>e in n?Xe(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var f=(n,e,t)=>(Ke(n,typeof e!="symbol"?e+"":e,t),t),Pe=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)};var m=(n,e,t)=>(Pe(n,e,"read from private field"),t?t.call(n):e.get(n)),j=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},z=(n,e,t,r)=>(Pe(n,e,"write to private field"),r?r.call(n,t):e.set(n,t),t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const y=require("three"),_e=require("three/examples/jsm/loaders/GLTFLoader.js"),Ye=require("three/examples/jsm/libs/meshopt_decoder.module.js"),He=require("three/examples/jsm/loaders/DRACOLoader.js"),je=require("three/examples/jsm/loaders/KTX2Loader.js"),ke="";globalThis.GLTF_PROGRESSIVE_VERSION=ke;console.debug("[gltf-progressive] version -");let q="https://www.gstatic.com/draco/versioned/decoders/1.5.7/",Z="https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";const Je=q,Qe=Z,Ge=new URL(q+"draco_decoder.js");Ge.searchParams.append("range","true");fetch(Ge,{method:"GET",headers:{Range:"bytes=0-1"}}).catch(n=>{console.debug(`Failed to fetch remote Draco decoder from ${q} (offline: ${typeof navigator<"u"?navigator.onLine:"unknown"})`),q===Je&&Ie("./include/draco/"),Z===Qe&&$e("./include/ktx2/")}).finally(()=>{Fe()});function Ie(n){q=n,k&&k[De]!=q?(console.debug("Updating Draco decoder path to "+n),k[De]=q,k.setDecoderPath(q),k.preload()):console.debug("Setting Draco decoder path to "+n)}function $e(n){Z=n,V&&V.transcoderPath!=Z?(console.debug("Updating KTX2 transcoder path to "+n),V.setTranscoderPath(Z),V.init()):console.debug("Setting KTX2 transcoder path to "+n)}const De=Symbol("dracoDecoderPath");let k,fe,V;function Fe(){k||(k=new He.DRACOLoader,k[De]=q,k.setDecoderPath(q),k.setDecoderConfig({type:"js"}),k.preload()),V||(V=new je.KTX2Loader,V.setTranscoderPath(Z),V.init()),fe||(fe=Ye.MeshoptDecoder)}function be(n){return Fe(),n?V.detectSupport(n):n!==null&&console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail"),{dracoLoader:k,ktx2Loader:V,meshoptDecoder:fe}}function Se(n){n.dracoLoader||n.setDRACOLoader(k),n.ktx2Loader||n.setKTX2Loader(V),n.meshoptDecoder||n.setMeshoptDecoder(fe)}const we=new WeakMap;function Te(n,e){let t=we.get(n);t?t=Object.assign(t,e):t=e,we.set(n,t)}const Le=_e.GLTFLoader.prototype.load;function Ze(...n){const e=we.get(this);let t=n[0];const r=new URL(t,window.location.href);if(r.hostname.endsWith("needle.tools")){const s=(e==null?void 0:e.progressive)!==void 0?e.progressive:!0,o=e!=null&&e.usecase?e.usecase:"default";s?this.requestHeader.Accept=`*/*;progressive=allowed;usecase=${o}`:this.requestHeader.Accept=`*/*;usecase=${o}`,t=r.toString()}return n[0]=t,Le==null?void 0:Le.call(this,...n)}_e.GLTFLoader.prototype.load=Ze;ae("debugprogressive");function ae(n){if(typeof window>"u")return!1;const t=new URL(window.location.href).searchParams.get(n);return t==null||t==="0"||t==="false"?!1:t===""?!0:t}function et(n,e){if(e===void 0||e.startsWith("./")||e.startsWith("http")||n===void 0)return e;const t=n.lastIndexOf("/");if(t>=0){const r=n.substring(0,t+1);for(;r.endsWith("/")&&e.startsWith("/");)e=e.substring(1);return r+e}return e}let se;function tt(){return se!==void 0||(se=/iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent),ae("debugprogressive")&&console.log("[glTF Progressive]: isMobileDevice",se)),se}const rt=typeof window>"u"&&typeof document>"u",ve=Symbol("needle:raycast-mesh");function re(n){return(n==null?void 0:n[ve])instanceof y.BufferGeometry?n[ve]:null}function Ve(n,e){if((n.type==="Mesh"||n.type==="SkinnedMesh")&&!re(n)){const r=st(e);r.userData={isRaycastMesh:!0},n[ve]=r}}function Ne(n=!0){if(n){if(oe)return;const e=oe=y.Mesh.prototype.raycast;y.Mesh.prototype.raycast=function(t,r){const i=this,s=re(i);let o;s&&i.isMesh&&(o=i.geometry,i.geometry=s),e.call(this,t,r),o&&(i.geometry=o)}}else{if(!oe)return;y.Mesh.prototype.raycast=oe,oe=null}}let oe=null;function st(n){const e=new y.BufferGeometry;for(const t in n.attributes)e.setAttribute(t,n.getAttribute(t));return e.setIndex(n.getIndex()),e}const Q=new Array,W="NEEDLE_progressive",x=ae("debugprogressive"),me=Symbol("needle-progressive-texture"),ne=new Map,Oe=new Set;if(x){let n=function(){e+=1,console.log("Toggle LOD level",e,ne),ne.forEach((i,s)=>{for(const o of i.keys){const a=s[o];if(a!=null)if(a.isBufferGeometry===!0){const l=S.getMeshLODInformation(a),u=l?Math.min(e,l.lods.length):0;s["DEBUG:LOD"]=u,l&&(t=Math.max(t,l.lods.length-1))}else s.isMaterial===!0&&(s["DEBUG:LOD"]=e)}}),e>=t&&(e=-1)},e=-1,t=2,r=!1;window.addEventListener("keyup",i=>{i.key==="p"&&n(),i.key==="w"&&(r=!r,Oe&&Oe.forEach(s=>{s.name!="BackgroundCubeMaterial"&&s.glyphMap==null&&"wireframe"in s&&(s.wireframe=r)}))})}function Ee(n,e,t){var i;if(!x)return;ne.has(n)||ne.set(n,{keys:[],sourceId:t});const r=ne.get(n);((i=r==null?void 0:r.keys)==null?void 0:i.includes(e))==!1&&r.keys.push(e)}const O=class{constructor(e,t){f(this,"parser");f(this,"url");f(this,"_isLoadingMesh");f(this,"loadMesh",e=>{var r,i;if(this._isLoadingMesh)return null;const t=(i=(r=this.parser.json.meshes[e])==null?void 0:r.extensions)==null?void 0:i[W];return t?(this._isLoadingMesh=!0,this.parser.getDependency("mesh",e).then(s=>{var o;return this._isLoadingMesh=!1,s&&O.registerMesh(this.url,t.guid,s,(o=t.lods)==null?void 0:o.length,void 0,t),s})):null});x&&console.log("Progressive extension registered for",t),this.parser=e,this.url=t}get name(){return W}static getMeshLODInformation(e){const t=this.getAssignedLODInformation(e);return t!=null&&t.key?this.lodInfos.get(t.key):null}static getMaterialMinMaxLODsCount(e,t){const r=this,i="LODS:minmax",s=e[i];if(s!=null)return s;if(t||(t={min_count:1/0,max_count:0,lods:[]}),Array.isArray(e)){for(const a of e)this.getMaterialMinMaxLODsCount(a,t);return e[i]=t,t}if(x==="verbose"&&console.log("getMaterialMinMaxLODsCount",e),e.type==="ShaderMaterial"||e.type==="RawShaderMaterial"){const a=e;for(const l of Object.keys(a.uniforms)){const u=a.uniforms[l].value;(u==null?void 0:u.isTexture)===!0&&o(u,t)}}else if(e.isMaterial)for(const a of Object.keys(e)){const l=e[a];(l==null?void 0:l.isTexture)===!0&&o(l,t)}return e[i]=t,t;function o(a,l){const u=r.getAssignedLODInformation(a);if(u){const c=r.lodInfos.get(u.key);if(c&&c.lods){l.min_count=Math.min(l.min_count,c.lods.length),l.max_count=Math.max(l.max_count,c.lods.length);for(let g=0;g<c.lods.length;g++){const p=c.lods[g];p.width&&(l.lods[g]=l.lods[g]||{min_height:1/0,max_height:0},l.lods[g].min_height=Math.min(l.lods[g].min_height,p.height),l.lods[g].max_height=Math.max(l.lods[g].max_height,p.height))}}}}}static hasLODLevelAvailable(e,t){var s;if(Array.isArray(e)){for(const o of e)if(this.hasLODLevelAvailable(o,t))return!0;return!1}if(e.isMaterial===!0){for(const o of Object.keys(e)){const a=e[o];if(a&&a.isTexture&&this.hasLODLevelAvailable(a,t))return!0}return!1}else if(e.isGroup===!0){for(const o of e.children)if(o.isMesh===!0&&this.hasLODLevelAvailable(o,t))return!0}let r,i;if(e.isMesh?r=e.geometry:(e.isBufferGeometry||e.isTexture)&&(r=e),r&&(s=r==null?void 0:r.userData)!=null&&s.LODS){const o=r.userData.LODS;if(i=this.lodInfos.get(o.key),t===void 0)return i!=null;if(i)return Array.isArray(i.lods)?t<i.lods.length:t===0}return!1}static assignMeshLOD(e,t){var r;if(!e)return Promise.resolve(null);if(e instanceof y.Mesh||e.isMesh===!0){const i=e.geometry,s=this.getAssignedLODInformation(i);if(!s)return Promise.resolve(null);for(const o of Q)(r=o.onBeforeGetLODMesh)==null||r.call(o,e,t);return e["LOD:requested level"]=t,O.getOrLoadLOD(i,t).then(o=>{if(Array.isArray(o)){const a=s.index||0;o=o[a]}return e["LOD:requested level"]===t&&(delete e["LOD:requested level"],o&&i!=o&&((o==null?void 0:o.isBufferGeometry)?(e.geometry=o,x&&Ee(e,"geometry",s.url)):x&&console.error("Invalid LOD geometry",o))),o}).catch(o=>(console.error("Error loading mesh LOD",e,o),null))}else x&&console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh",e);return Promise.resolve(null)}static assignTextureLOD(e,t=0){if(!e)return Promise.resolve(null);if(e.isMesh===!0){const r=e;if(Array.isArray(r.material)){const i=new Array;for(const s of r.material){const o=this.assignTextureLOD(s,t);i.push(o)}return Promise.all(i).then(s=>{const o=new Array;for(const a of s)Array.isArray(a)&&o.push(...a);return o})}else return this.assignTextureLOD(r.material,t)}if(e.isMaterial===!0){const r=e,i=[],s=new Array;if(x&&Oe.add(r),r.uniforms&&(r.isRawShaderMaterial||r.isShaderMaterial===!0)){const o=r;for(const a of Object.keys(o.uniforms)){const l=o.uniforms[a].value;if((l==null?void 0:l.isTexture)===!0){const u=this.assignTextureLODForSlot(l,t,r,a).then(c=>(c&&o.uniforms[a].value!=c&&(o.uniforms[a].value=c,o.uniformsNeedUpdate=!0),c));i.push(u),s.push(a)}}}else for(const o of Object.keys(r)){const a=r[o];if((a==null?void 0:a.isTexture)===!0){const l=this.assignTextureLODForSlot(a,t,r,o);i.push(l),s.push(o)}}return Promise.all(i).then(o=>{const a=new Array;for(let l=0;l<o.length;l++){const u=o[l],c=s[l];u&&u.isTexture===!0?a.push({material:r,slot:c,texture:u,level:t}):a.push({material:r,slot:c,texture:null,level:t})}return a})}if(e instanceof y.Texture||e.isTexture===!0){const r=e;return this.assignTextureLODForSlot(r,t,null,null)}return Promise.resolve(null)}static assignTextureLODForSlot(e,t,r,i){return(e==null?void 0:e.isTexture)!==!0?Promise.resolve(null):i==="glyphMap"?Promise.resolve(e):O.getOrLoadLOD(e,t).then(s=>{if(Array.isArray(s))return null;if((s==null?void 0:s.isTexture)===!0){if(s!=e){if(r&&i){const o=r[i];if(o&&!x){const a=this.getAssignedLODInformation(o);if(a&&(a==null?void 0:a.level)<t)return x==="verbose"&&console.warn("Assigned texture level is already higher: ",a.level,t,r,o,s),null}r[i]=s}if(x&&i&&r){const o=this.getAssignedLODInformation(e);o?Ee(r,i,o.url):console.warn("No LOD info for texture",e)}}return s}else x=="verbose"&&console.warn("No LOD found for",e,t);return null}).catch(s=>(console.error("Error loading LOD",e,s),null))}afterRoot(e){var t,r;return x&&console.log("AFTER",this.url,e),(t=this.parser.json.textures)==null||t.forEach((i,s)=>{var o;if(i!=null&&i.extensions){const a=i==null?void 0:i.extensions[W];if(a){if(!a.lods){x&&console.warn("Texture has no LODs",a);return}let l=!1;for(const u of this.parser.associations.keys())if(u.isTexture===!0){const c=this.parser.associations.get(u);(c==null?void 0:c.textures)===s&&(l=!0,O.registerTexture(this.url,u,(o=a.lods)==null?void 0:o.length,s,a))}l||this.parser.getDependency("texture",s).then(u=>{var c;u&&O.registerTexture(this.url,u,(c=a.lods)==null?void 0:c.length,s,a)})}}}),(r=this.parser.json.meshes)==null||r.forEach((i,s)=>{if(i!=null&&i.extensions){const o=i==null?void 0:i.extensions[W];if(o&&o.lods){for(const a of this.parser.associations.keys())if(a.isMesh){const l=this.parser.associations.get(a);(l==null?void 0:l.meshes)===s&&O.registerMesh(this.url,o.guid,a,o.lods.length,l.primitives,o)}}}}),null}static async getOrLoadLOD(e,t){var a,l,u,c;const r=x=="verbose",i=e.userData.LODS;if(!i)return null;const s=i==null?void 0:i.key;let o;if(e.isTexture===!0){const g=e;g.source&&g.source[me]&&(o=g.source[me])}if(o||(o=O.lodInfos.get(s)),o){if(t>0){let w=!1;const v=Array.isArray(o.lods);if(v&&t>=o.lods.length?w=!0:v||(w=!0),w)return this.lowresCache.get(s)}const g=Array.isArray(o.lods)?(a=o.lods[t])==null?void 0:a.path:o.lods;if(!g)return x&&!o["missing:uri"]&&(o["missing:uri"]=!0,console.warn("Missing uri for progressive asset for LOD "+t,o)),null;const p=et(i.url,g);if(p.endsWith(".glb")||p.endsWith(".gltf")){if(!o.guid)return console.warn("missing pointer for glb/gltf texture",o),null;const w=p+"_"+o.guid,v=this.previouslyLoaded.get(w);if(v!==void 0){r&&console.log(`LOD ${t} was already loading/loaded: ${w}`);let h=await v.catch(U=>(console.error(`Error loading LOD ${t} from ${p}
`,U),null)),G=!1;if(h==null||(h instanceof y.Texture&&e instanceof y.Texture?(l=h.image)!=null&&l.data||(u=h.source)!=null&&u.data?h=this.copySettings(e,h):(G=!0,this.previouslyLoaded.delete(w)):h instanceof y.BufferGeometry&&e instanceof y.BufferGeometry&&((c=h.attributes.position)!=null&&c.array||(G=!0,this.previouslyLoaded.delete(w)))),!G)return h}const M=o,N=new Promise(async(h,G)=>{const U=new _e.GLTFLoader;Se(U),x&&(await new Promise(T=>setTimeout(T,1e3)),r&&console.warn("Start loading (delayed) "+p,M.guid));let I=p;if(M&&Array.isArray(M.lods)){const T=M.lods[t];T.hash&&(I+="?v="+T.hash)}const P=await U.loadAsync(I).catch(T=>(console.error(`Error loading LOD ${t} from ${p}
`,T),null));if(!P)return null;const X=P.parser;r&&console.log("Loading finished "+p,M.guid);let b=0;if(P.parser.json.textures){let T=!1;for(const d of P.parser.json.textures){if(d!=null&&d.extensions){const L=d==null?void 0:d.extensions[W];if(L!=null&&L.guid&&L.guid===M.guid){T=!0;break}}b++}if(T){let d=await X.getDependency("texture",b);return d&&O.assignLODInformation(i.url,d,s,t,void 0,void 0),r&&console.log('change "'+e.name+'" → "'+d.name+'"',p,b,d,w),e instanceof y.Texture&&(d=this.copySettings(e,d)),d&&(d.guid=M.guid),h(d)}else x&&console.warn("Could not find texture with guid",M.guid,P.parser.json)}if(b=0,P.parser.json.meshes){let T=!1;for(const d of P.parser.json.meshes){if(d!=null&&d.extensions){const L=d==null?void 0:d.extensions[W];if(L!=null&&L.guid&&L.guid===M.guid){T=!0;break}}b++}if(T){const d=await X.getDependency("mesh",b),L=M;if(r&&console.log(`Loaded Mesh "${d.name}"`,p,b,d,w),d.isMesh===!0){const _=d.geometry;return O.assignLODInformation(i.url,_,s,t,void 0,L.density),h(_)}else{const _=new Array;for(let A=0;A<d.children.length;A++){const E=d.children[A];if(E.isMesh===!0){const H=E.geometry;O.assignLODInformation(i.url,H,s,t,A,L.density),_.push(H)}}return h(_)}}else x&&console.warn("Could not find mesh with guid",M.guid,P.parser.json)}return h(null)});return this.previouslyLoaded.set(w,N),await N}else if(e instanceof y.Texture){r&&console.log("Load texture from uri: "+p);const v=await new y.TextureLoader().loadAsync(p);return v?(v.guid=o.guid,v.flipY=!1,v.needsUpdate=!0,v.colorSpace=e.colorSpace,r&&console.log(o,v)):x&&console.warn("failed loading",p),v}}else x&&console.warn(`Can not load LOD ${t}: no LOD info found for "${s}" ${e.name}`,e.type);return null}static assignLODInformation(e,t,r,i,s,o){if(!t)return;t.userData||(t.userData={});const a=new ot(e,r,i,s,o);t.userData.LODS=a}static getAssignedLODInformation(e){var t;return((t=e==null?void 0:e.userData)==null?void 0:t.LODS)||null}static copySettings(e,t){return t?(x&&console.warn(`Copy texture settings
`,e.uuid,`
`,t.uuid),t=t.clone(),t.offset=e.offset,t.repeat=e.repeat,t.colorSpace=e.colorSpace,t.magFilter=e.magFilter,t.minFilter=e.minFilter,t.wrapS=e.wrapS,t.wrapT=e.wrapT,t.flipY=e.flipY,t.anisotropy=e.anisotropy,t.mipmaps||(t.generateMipmaps=e.generateMipmaps),t):e}};let S=O;f(S,"registerTexture",(e,t,r,i,s)=>{if(x&&console.log("> Progressive: register texture",i,t.name,t.uuid,t,s),!t){x&&console.error("gltf-progressive: Register texture without texture");return}t.source&&(t.source[me]=s);const o=s.guid;O.assignLODInformation(e,t,o,r,i,void 0),O.lodInfos.set(o,s),O.lowresCache.set(o,t)}),f(S,"registerMesh",(e,t,r,i,s,o)=>{var u;x&&console.log("> Progressive: register mesh",s,r.name,o,r.uuid,r);const a=r.geometry;if(!a){x&&console.warn("gltf-progressive: Register mesh without geometry");return}a.userData||(a.userData={}),O.assignLODInformation(e,a,t,i,s,o.density),O.lodInfos.set(t,o);let l=O.lowresCache.get(t);l?l.push(r.geometry):l=[r.geometry],O.lowresCache.set(t,l),i>0&&!re(r)&&Ve(r,a);for(const c of Q)(u=c.onRegisteredNewMesh)==null||u.call(c,r,o)}),f(S,"lodInfos",new Map),f(S,"previouslyLoaded",new Map),f(S,"lowresCache",new Map);class ot{constructor(e,t,r,i,s){f(this,"url");f(this,"key");f(this,"level");f(this,"index");f(this,"density");this.url=e,this.key=t,this.level=r,i!=null&&(this.index=i),s!=null&&(this.density=s)}}const $=ae("debugprogressive"),it=ae("noprogressive"),xe=Symbol("Needle:LODSManager"),Me=Symbol("Needle:LODState"),J=Symbol("Needle:CurrentLOD"),F={mesh_lod:-1,texture_lod:-1};var B,K,he,ee,te,ge,Y;const C=class{constructor(e,t){f(this,"context");f(this,"renderer");f(this,"projectionScreenMatrix",new y.Matrix4);f(this,"targetTriangleDensity",2e5);f(this,"updateInterval","auto");j(this,B,1);f(this,"pause",!1);f(this,"manual",!1);f(this,"_lodchangedlisteners",[]);j(this,K,void 0);j(this,he,new y.Clock);j(this,ee,0);j(this,te,0);j(this,ge,0);j(this,Y,0);f(this,"_fpsBuffer",[60,60,60,60,60]);f(this,"_sphere",new y.Sphere);f(this,"_tempBox",new y.Box3);f(this,"_tempBox2",new y.Box3);f(this,"tempMatrix",new y.Matrix4);f(this,"_tempWorldPosition",new y.Vector3);f(this,"_tempBoxSize",new y.Vector3);f(this,"_tempBox2Size",new y.Vector3);this.renderer=e,this.context={...t}}static getObjectLODState(e){return e[Me]}static addPlugin(e){Q.push(e)}static removePlugin(e){const t=Q.indexOf(e);t>=0&&Q.splice(t,1)}static get(e,t){if(e[xe])return console.debug("[gltf-progressive] LODsManager already exists for this renderer"),e[xe];const r=new C(e,{engine:"unknown",...t});return e[xe]=r,r}get plugins(){return Q}addEventListener(e,t){e==="changed"&&this._lodchangedlisteners.push(t)}removeEventListener(e,t){if(e==="changed"){const r=this._lodchangedlisteners.indexOf(t);r>=0&&this._lodchangedlisteners.splice(r,1)}}enable(){if(m(this,K))return;console.debug("[gltf-progressive] Enabling LODsManager for renderer");let e=0;z(this,K,this.renderer.render);const t=this;be(this.renderer),this.renderer.render=function(r,i){const s=t.renderer.getRenderTarget();(s==null||"isXRRenderTarget"in s&&s.isXRRenderTarget)&&(e=0,z(t,ee,m(t,ee)+1),z(t,te,m(t,he).getDelta()),z(t,ge,m(t,ge)+m(t,te)),t._fpsBuffer.shift(),t._fpsBuffer.push(1/m(t,te)),z(t,Y,t._fpsBuffer.reduce((a,l)=>a+l)/t._fpsBuffer.length),$&&m(t,ee)%200===0&&console.log("FPS",Math.round(m(t,Y)),"Interval:",m(t,B)));const o=e++;m(t,K).call(this,r,i),t.onAfterRender(r,i,o)}}disable(){m(this,K)&&(console.debug("[gltf-progressive] Disabling LODsManager for renderer"),this.renderer.render=m(this,K),z(this,K,void 0))}update(e,t){this.internalUpdate(e,t)}onAfterRender(e,t,r){if(this.pause)return;const s=this.renderer.renderLists.get(e,0).opaque;let o=!0;if(s.length===1){const a=s[0].material;(a.name==="EffectMaterial"||a.name==="CopyShader")&&(o=!1)}if((t.parent&&t.parent.type==="CubeCamera"||r>=1&&t.type==="OrthographicCamera")&&(o=!1),o){if(it||(this.updateInterval==="auto"?m(this,Y)<40&&m(this,B)<10?(z(this,B,m(this,B)+1),$&&console.warn("↓ Reducing LOD updates",m(this,B),m(this,Y).toFixed(0))):m(this,Y)>=60&&m(this,B)>1&&(z(this,B,m(this,B)-1),$&&console.warn("↑ Increasing LOD updates",m(this,B),m(this,Y).toFixed(0))):z(this,B,this.updateInterval),m(this,B)>0&&m(this,ee)%m(this,B)!=0))return;this.internalUpdate(e,t)}}internalUpdate(e,t){var l,u;const r=this.renderer.renderLists.get(e,0),i=r.opaque;this.projectionScreenMatrix.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse);const s=this.targetTriangleDensity;for(const c of i){if(c.material&&(((l=c.geometry)==null?void 0:l.type)==="BoxGeometry"||((u=c.geometry)==null?void 0:u.type)==="BufferGeometry")&&(c.material.name==="SphericalGaussianBlur"||c.material.name=="BackgroundCubeMaterial"||c.material.name==="CubemapFromEquirect"||c.material.name==="EquirectangularToCubeUV")){$&&(c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]||(c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]=!0,console.warn("Ignoring skybox or BLIT object",c,c.material.name,c.material.type)));continue}switch(c.material.type){case"LineBasicMaterial":case"LineDashedMaterial":case"PointsMaterial":case"ShadowMaterial":case"MeshDistanceMaterial":case"MeshDepthMaterial":continue}if($==="color"&&c.material&&!c.object.progressive_debug_color){c.object.progressive_debug_color=!0;const p=Math.random()*16777215,w=new y.MeshStandardMaterial({color:p});c.object.material=w}const g=c.object;(g instanceof y.Mesh||g.isMesh)&&this.updateLODs(e,t,g,s)}const o=r.transparent;for(const c of o){const g=c.object;(g instanceof y.Mesh||g.isMesh)&&this.updateLODs(e,t,g,s)}const a=r.transmissive;for(const c of a){const g=c.object;(g instanceof y.Mesh||g.isMesh)&&this.updateLODs(e,t,g,s)}}updateLODs(e,t,r,i){var a,l;r.userData||(r.userData={});let s=r[Me];if(s||(s=new nt,r[Me]=s),s.frames++<2)return;for(const u of Q)(a=u.onBeforeUpdateLOD)==null||a.call(u,this.renderer,e,t,r);this.calculateLodLevel(t,r,s,i,F),F.mesh_lod=Math.round(F.mesh_lod),F.texture_lod=Math.round(F.texture_lod),F.mesh_lod>=0&&this.loadProgressiveMeshes(r,F.mesh_lod);let o=F.texture_lod;r.material&&o>=0&&this.loadProgressiveTextures(r.material,o);for(const u of Q)(l=u.onAfterUpdatedLOD)==null||l.call(u,this.renderer,e,t,r,F);s.lastLodLevel_Mesh=F.mesh_lod,s.lastLodLevel_Texture=F.texture_lod}loadProgressiveTextures(e,t){if(!e)return;if(Array.isArray(e)){for(const s of e)this.loadProgressiveTextures(s,t);return}let r=!1;(e[J]===void 0||t<e[J])&&(r=!0);const i=e["DEBUG:LOD"];i!=null&&(r=e[J]!=i,t=i),r&&(e[J]=t,S.assignTextureLOD(e,t).then(s=>{this._lodchangedlisteners.forEach(o=>o({type:"texture",level:t,object:e}))}))}loadProgressiveMeshes(e,t){if(!e)return Promise.resolve(null);let r=e[J]!==t;const i=e["DEBUG:LOD"];if(i!=null&&(r=e[J]!=i,t=i),r){e[J]=t;const s=e.geometry;return S.assignMeshLOD(e,t).then(o=>(o&&e[J]==t&&s!=e.geometry&&this._lodchangedlisteners.forEach(a=>a({type:"mesh",level:t,object:e})),o))}return Promise.resolve(null)}static isInside(e,t){const r=e.min,i=e.max,s=(r.x+i.x)*.5,o=(r.y+i.y)*.5;return this._tempPtInside.set(s,o,r.z).applyMatrix4(t).z<0}calculateLodLevel(e,t,r,i,s){var N;if(!t){s.mesh_lod=-1,s.texture_lod=-1;return}if(!e){s.mesh_lod=-1,s.texture_lod=-1;return}let a=10+1,l=!1;if($&&t["DEBUG:LOD"]!=null)return t["DEBUG:LOD"];const u=S.getMeshLODInformation(t.geometry),c=u==null?void 0:u.lods,g=c&&c.length>0,p=S.getMaterialMinMaxLODsCount(t.material),w=(p==null?void 0:p.min_count)!=1/0&&p.min_count>0&&p.max_count>0;if(!g&&!w){s.mesh_lod=0,s.texture_lod=0;return}g||(l=!0,a=0);const v=this.renderer.domElement.clientHeight||this.renderer.domElement.height;let M=t.geometry.boundingBox;if(t.type==="SkinnedMesh"){const D=t;if(!D.boundingBox)D.computeBoundingBox();else if(r.frames%30===0){const h=re(D),G=D.geometry;h&&(D.geometry=h),D.computeBoundingBox(),D.geometry=G}M=D.boundingBox}if(M){const D=e;if(t.geometry.attributes.color&&t.geometry.attributes.color.count<100&&t.geometry.boundingSphere){this._sphere.copy(t.geometry.boundingSphere),this._sphere.applyMatrix4(t.matrixWorld);const d=e.getWorldPosition(this._tempWorldPosition);if(this._sphere.containsPoint(d)){s.mesh_lod=0,s.texture_lod=0;return}}if(this._tempBox.copy(M),this._tempBox.applyMatrix4(t.matrixWorld),D.isPerspectiveCamera&&C.isInside(this._tempBox,this.projectionScreenMatrix)){s.mesh_lod=0,s.texture_lod=0;return}if(this._tempBox.applyMatrix4(this.projectionScreenMatrix),this.renderer.xr.enabled&&D.isPerspectiveCamera&&D.fov>70){const d=this._tempBox.min,L=this._tempBox.max;let _=d.x,A=d.y,E=L.x,H=L.y;const le=2,pe=1.5,ce=(d.x+L.x)*.5,ue=(d.y+L.y)*.5;_=(_-ce)*le+ce,A=(A-ue)*le+ue,E=(E-ce)*le+ce,H=(H-ue)*le+ue;const We=_<0&&E>0?0:Math.min(Math.abs(d.x),Math.abs(L.x)),qe=A<0&&H>0?0:Math.min(Math.abs(d.y),Math.abs(L.y)),ye=Math.max(We,qe);r.lastCentrality=(pe-ye)*(pe-ye)*(pe-ye)}else r.lastCentrality=1;const h=this._tempBox.getSize(this._tempBoxSize);h.multiplyScalar(.5),screen.availHeight>0&&v>0&&h.multiplyScalar(v/screen.availHeight),e.isPerspectiveCamera?h.x*=e.aspect:e.isOrthographicCamera;const G=e.matrixWorldInverse,U=this._tempBox2;U.copy(M),U.applyMatrix4(t.matrixWorld),U.applyMatrix4(G);const I=U.getSize(this._tempBox2Size),P=Math.max(I.x,I.y);if(Math.max(h.x,h.y)!=0&&P!=0&&(h.z=I.z/Math.max(I.x,I.y)*Math.max(h.x,h.y)),r.lastScreenCoverage=Math.max(h.x,h.y,h.z),r.lastScreenspaceVolume.copy(h),r.lastScreenCoverage*=r.lastCentrality,$&&C.debugDrawLine){const d=this.tempMatrix.copy(this.projectionScreenMatrix);d.invert();const L=C.corner0,_=C.corner1,A=C.corner2,E=C.corner3;L.copy(this._tempBox.min),_.copy(this._tempBox.max),_.x=L.x,A.copy(this._tempBox.max),A.y=L.y,E.copy(this._tempBox.max);const H=(L.z+E.z)*.5;L.z=_.z=A.z=E.z=H,L.applyMatrix4(d),_.applyMatrix4(d),A.applyMatrix4(d),E.applyMatrix4(d),C.debugDrawLine(L,_,255),C.debugDrawLine(L,A,255),C.debugDrawLine(_,E,255),C.debugDrawLine(A,E,255)}let b=999;if(c&&r.lastScreenCoverage>0){for(let d=0;d<c.length;d++)if(c[d].density/r.lastScreenCoverage<i){b=d;break}}b<a&&(a=b,l=!0)}if(l?s.mesh_lod=a:s.mesh_lod=r.lastLodLevel_Mesh,$&&s.mesh_lod!=r.lastLodLevel_Mesh){const h=c==null?void 0:c[s.mesh_lod];h&&console.log(`Mesh LOD changed: ${r.lastLodLevel_Mesh} → ${s.mesh_lod} (${h.density.toFixed(0)}) - ${t.name}`)}if(w){const D="saveData"in globalThis.navigator&&globalThis.navigator.saveData===!0;if(r.lastLodLevel_Texture<0){if(s.texture_lod=p.max_count-1,$){const h=p.lods[p.max_count-1];$&&console.log(`First Texture LOD ${s.texture_lod} (${h.max_height}px) - ${t.name}`)}}else{const h=r.lastScreenspaceVolume.x+r.lastScreenspaceVolume.y+r.lastScreenspaceVolume.z;let G=r.lastScreenCoverage*4;((N=this.context)==null?void 0:N.engine)==="model-viewer"&&(G*=1.5);const I=v/window.devicePixelRatio*G;let P=!1;for(let X=p.lods.length-1;X>=0;X--){let b=p.lods[X];if(!(D&&b.max_height>=2048)&&!(tt()&&b.max_height>4096)&&(b.max_height>I||!P&&X===0)){if(P=!0,s.texture_lod=X,s.texture_lod<r.lastLodLevel_Texture){const T=b.max_height;$&&console.log(`Texture LOD changed: ${r.lastLodLevel_Texture} → ${s.texture_lod} = ${T}px 
Screensize: ${I.toFixed(0)}px, Coverage: ${(100*r.lastScreenCoverage).toFixed(2)}%, Volume ${h.toFixed(1)} 
${t.name}`)}break}}}}else s.texture_lod=0}};let R=C;B=new WeakMap,K=new WeakMap,he=new WeakMap,ee=new WeakMap,te=new WeakMap,ge=new WeakMap,Y=new WeakMap,f(R,"debugDrawLine"),f(R,"corner0",new y.Vector3),f(R,"corner1",new y.Vector3),f(R,"corner2",new y.Vector3),f(R,"corner3",new y.Vector3),f(R,"_tempPtInside",new y.Vector3);class nt{constructor(){f(this,"frames",0);f(this,"lastLodLevel_Mesh",-1);f(this,"lastLodLevel_Texture",-1);f(this,"lastScreenCoverage",0);f(this,"lastScreenspaceVolume",new y.Vector3);f(this,"lastCentrality",0)}}const Ce=Symbol("NEEDLE_mesh_lod"),de=Symbol("NEEDLE_texture_lod");let ie=null;function Ae(){const n=at();n&&(n.mapURLs(function(e){return Be(),e}),Be(),ie==null||ie.disconnect(),ie=new MutationObserver(e=>{e.forEach(t=>{t.addedNodes.forEach(r=>{r instanceof HTMLElement&&r.tagName.toLowerCase()==="model-viewer"&&Ue(r)})})}),ie.observe(document,{childList:!0,subtree:!0}))}function at(){if(typeof customElements>"u")return null;const n=customElements.get("model-viewer");return n||(customElements.whenDefined("model-viewer").then(()=>{console.debug("[gltf-progressive] model-viewer defined"),Ae()}),null)}function Be(){if(typeof document>"u")return;document.querySelectorAll("model-viewer").forEach(e=>{Ue(e)})}const Re=new WeakSet;let lt=0;function Ue(n){if(!n||Re.has(n))return null;Re.add(n),console.debug("[gltf-progressive] found new model-viewer..."+ ++lt+`
`,n.getAttribute("src"));let e=null,t=null,r=null;for(let i=n;i!=null;i=Object.getPrototypeOf(i)){const s=Object.getOwnPropertySymbols(i),o=s.find(u=>u.toString()=="Symbol(renderer)"),a=s.find(u=>u.toString()=="Symbol(scene)"),l=s.find(u=>u.toString()=="Symbol(needsRender)");!e&&o!=null&&(e=n[o].threeRenderer),!t&&a!=null&&(t=n[a]),!r&&l!=null&&(r=n[l])}if(e&&t){let i=function(){if(r){let o=0,a=setInterval(()=>{if(o++>5){clearInterval(a);return}r==null||r.call(n)},300)}};console.debug("[gltf-progressive] setup model-viewer");const s=R.get(e,{engine:"model-viewer"});return R.addPlugin(new ct),s.enable(),s.addEventListener("changed",()=>{r==null||r.call(n)}),n.addEventListener("model-visibility",o=>{o.detail.visible&&(r==null||r.call(n))}),n.addEventListener("load",()=>{i()}),()=>{s.disable()}}return null}class ct{constructor(){f(this,"_didWarnAboutMissingUrl",!1)}onBeforeUpdateLOD(e,t,r,i){this.tryParseMeshLOD(t,i),this.tryParseTextureLOD(t,i)}getUrl(e){if(!e)return null;let t=e.getAttribute("src");return t||(t=e.src),t||(this._didWarnAboutMissingUrl||console.warn("No url found in modelviewer",e),this._didWarnAboutMissingUrl=!0),t}tryGetCurrentGLTF(e){return e._currentGLTF}tryGetCurrentModelViewer(e){return e.element}tryParseTextureLOD(e,t){if(t[de]==!0)return;t[de]=!0;const r=this.tryGetCurrentGLTF(e),i=this.tryGetCurrentModelViewer(e),s=this.getUrl(i);if(s&&r&&t.material){let o=function(l){var c,g,p;if(l[de]==!0)return;l[de]=!0,l.userData&&(l.userData.LOD=-1);const u=Object.keys(l);for(let w=0;w<u.length;w++){const v=u[w],M=l[v];if((M==null?void 0:M.isTexture)===!0){const N=(g=(c=M.userData)==null?void 0:c.associations)==null?void 0:g.textures;if(N==null)continue;const D=r.parser.json.textures[N];if(!D){console.warn("Texture data not found for texture index "+N);continue}if((p=D==null?void 0:D.extensions)!=null&&p[W]){const h=D.extensions[W];h&&s&&S.registerTexture(s,M,h.lods.length,N,h)}}}};const a=t.material;if(Array.isArray(a))for(const l of a)o(l);else o(a)}}tryParseMeshLOD(e,t){var o,a;if(t[Ce]==!0)return;t[Ce]=!0;const r=this.tryGetCurrentModelViewer(e),i=this.getUrl(r);if(!i)return;const s=(a=(o=t.userData)==null?void 0:o.gltfExtensions)==null?void 0:a[W];if(s&&i){const l=t.uuid;S.registerMesh(i,l,t,0,s.lods.length,s)}}}function ze(n,e,t,r){be(e),Se(t),Te(t,{progressive:!0,...r==null?void 0:r.hints}),t.register(s=>new S(s,n));const i=R.get(e);return(r==null?void 0:r.enableLODsManager)!==!1&&i.enable(),i}Ae();if(!rt){const n={gltfProgressive:{useNeedleProgressive:ze,LODsManager:R,configureLoader:Te,getRaycastMesh:re,useRaycastMeshes:Ne}};if(!globalThis.Needle)globalThis.Needle=n;else for(const e in n)globalThis.Needle[e]=n[e]}exports.EXTENSION_NAME=W;exports.LODsManager=R;exports.NEEDLE_progressive=S;exports.VERSION=ke;exports.addDracoAndKTX2Loaders=Se;exports.configureLoader=Te;exports.createLoaders=be;exports.getRaycastMesh=re;exports.patchModelViewer=Ae;exports.registerRaycastMesh=Ve;exports.setDracoDecoderLocation=Ie;exports.setKTX2TranscoderLocation=$e;exports.useNeedleProgressive=ze;exports.useRaycastMeshes=Ne;
